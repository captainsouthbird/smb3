; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-19 22:50:51.409583184 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

	; CAUTION!! ObjectGroup00 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $00 (i.e. objects starting at ID $00) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup00_InitJumpTable:
	.word ObjInit_DoNothing	; Object $00
	.word ObjInit_Obj01	; Object $01
	.word ObjInit_Obj02	; Object $02
	.word ObjInit_DoNothing	; Object $03
	.word ObjInit_Obj04	; Object $04
	.word ObjInit_Obj05	; Object $05
	.word ObjInit_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjInit_WarpHide	; Object $07 - OBJ_WARPHIDE
	.word ObjInit_PDoor	; Object $08 - OBJ_PSWITCHDOOR
	.word ObjInit_Anchor	; Object $09 - OBJ_AIRSHIPANCHOR
	.word ObjInit_Obj0A	; Object $0A
	.word ObjInit_PUpMush	; Object $0B - OBJ_POWERUP_1UP
	.word ObjInit_StarOrSuit; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjInit_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjInit_Koopaling	; Object $0E - OBJ_BOSS_KOOPALING
	.word ObjInit_DoNothing	; Object $0F
	.word ObjInit_DoNothing	; Object $10
	.word ObjInit_DoNothing	; Object $11
	.word ObjInit_DoNothing	; Object $12
	.word ObjInit_DoNothing	; Object $13
	.word ObjInit_DoNothing	; Object $14
	.word ObjInit_DoNothing	; Object $15
	.word ObjInit_DoNothing	; Object $16
	.word ObjInit_SpinyCheep; Object $17 - OBJ_SPINYCHEEP
	.word ObjInit_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjInit_FireFlower; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjInit_DoNothing	; Object $1A
	.word ObjInit_BounceLR	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjInit_Obj1C	; Object $1C
	.word ObjInit_DoNothing	; Object $1D
	.word ObjInit_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjInit_Vine	; Object $1F - OBJ_GROWINGVINE
	.word ObjInit_DoNothing	; Object $20
	.word ObjInit_DoNothing	; Object $21 - OBJ_POWERUP_MUSHCARD
	.word ObjInit_DoNothing	; Object $22 - OBJ_POWERUP_FIRECARD
	.word ObjInit_DoNothing	; Object $23 - OBJ_POWERUP_STARCARD


	; Object group $00 (i.e. objects starting at ID $00) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup00_NormalJumpTable:
	.word ObjNorm_DoNothing	; Object $00
	.word ObjNorm_Obj01	; Object $01
	.word ObjNorm_Obj02	; Object $02
	.word ObjNorm_DoNothing	; Object $03
	.word ObjNorm_Obj04	; Object $04
	.word ObjNorm_Obj05	; Object $05
	.word ObjNorm_BounceDU	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjNorm_WarpHide	; Object $07 - OBJ_WARPHIDE
	.word ObjNorm_PDoor	; Object $08 - OBJ_PSWITCHDOOR
	.word ObjNorm_Anchor	; Object $09 - OBJ_AIRSHIPANCHOR
	.word ObjNorm_Obj0A	; Object $0A
	.word ObjNorm_PUp1UpMush; Object $0B - OBJ_POWERUP_1UP
	.word ObjNorm_StarOrSuit; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjNorm_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjNorm_Koopaling	; Object $0E - OBJ_BOSS_KOOPALING
	.word ObjNorm_DoNothing	; Object $0F
	.word ObjNorm_DoNothing	; Object $10
	.word ObjNorm_DoNothing	; Object $11
	.word ObjNorm_DoNothing	; Object $12
	.word ObjNorm_DoNothing	; Object $13
	.word ObjNorm_DoNothing	; Object $14
	.word ObjNorm_DoNothing	; Object $15
	.word ObjNorm_DoNothing	; Object $16
	.word ObjNorm_SpinyCheep; Object $17 - OBJ_SPINYCHEEP
	.word ObjNorm_Bowser	; Object $18 - OBJ_BOSS_BOWSER
	.word ObjNorm_FireFlower; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjNorm_Obj1A	; Object $1A
	.word ObjNorm_BounceLR	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjNorm_Obj1C	; Object $1C
	.word ObjNorm_DoNothing	; Object $1D
	.word ObjNorm_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjNorm_Vine	; Object $1F - OBJ_GROWINGVINE
	.word ObjNorm_DoNothing	; Object $20
	.word ObjNorm_Card	; Object $21 - OBJ_POWERUP_MUSHCARD
	.word ObjNorm_Card	; Object $22 - OBJ_POWERUP_FIRECARD
	.word ObjNorm_Card	; Object $23 - OBJ_POWERUP_STARCARD


	; Object group $00 (i.e. objects starting at ID $00) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup00_CollideJumpTable:
	.word ObjHit_DoNothing	; Object $00
	.word ObjHit_Obj01	; Object $01
	.word ObjHit_DoNothing	; Object $02
	.word ObjHit_DoNothing	; Object $03
	.word ObjHit_Obj04	; Object $04
	.word ObjHit_Obj05	; Object $05
	.word ObjHit_DoNothing	; Object $06 - OBJ_BOUNCEDOWNUP
	.word ObjHit_DoNothing	; Object $07 - OBJ_WARPHIDE
	.word ObjHit_DoNothing	; Object $08 - OBJ_PSWITCHDOOR
	.word ObjHit_DoNothing	; Object $09 - OBJ_AIRSHIPANCHOR
	.word ObjHit_Obj0A	; Object $0A
	.word ObjHit_PUp1UpMush	; Object $0B - OBJ_POWERUP_1UP
	.word ObjHit_StarOrSuit	; Object $0C - OBJ_POWERUP_STARMAN
	.word ObjHit_PUpMush	; Object $0D - OBJ_POWERUP_MUSHROOM
	.word ObjHit_Koopaling	; Object $0E - OBJ_BOSS_KOOPALING
	.word ObjHit_DoNothing	; Object $0F
	.word ObjHit_DoNothing	; Object $10
	.word ObjHit_DoNothing	; Object $11
	.word ObjHit_DoNothing	; Object $12
	.word ObjHit_DoNothing	; Object $13
	.word ObjHit_DoNothing	; Object $14
	.word ObjHit_DoNothing	; Object $15
	.word ObjHit_DoNothing	; Object $16
	.word ObjHit_DoNothing	; Object $17 - OBJ_SPINYCHEEP
	.word OCSPECIAL_HIGHSCORE; Object $18 - OBJ_BOSS_BOWSER
	.word ObjHit_FireFlower	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.word ObjHit_Obj1A	; Object $1A
	.word ObjHit_BoundLR	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.word ObjHit_DoNothing	; Object $1C
	.word ObjHit_DoNothing	; Object $1D
	.word ObjHit_SuperLeaf	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.word ObjHit_DoNothing	; Object $1F - OBJ_GROWINGVINE
	.word ObjHit_DoNothing	; Object $20
	.word ObjHit_Card	; Object $21 - OBJ_POWERUP_MUSHCARD
	.word ObjHit_Card	; Object $22 - OBJ_POWERUP_FIRECARD
	.word ObjHit_Card	; Object $23 - OBJ_POWERUP_STARCARD

	
	; Object group $00 (i.e. objects starting at ID $00) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup00_Attributes:
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $00
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $01
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $02
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $03
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $04
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $05
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $07 - OBJ_WARPHIDE
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $08 - OBJ_PSWITCHDOOR
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $09 - OBJ_AIRSHIPANCHOR
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0A
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0B - OBJ_POWERUP_1UP
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $0E - OBJ_BOSS_KOOPALING
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $0F
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $10
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $11
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $12
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $13
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $14
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $15
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $16
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $17 - OBJ_SPINYCHEEP
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH32	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1A
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1C
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $1D
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $1F - OBJ_GROWINGVINE
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $20
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $21 - OBJ_POWERUP_MUSHCARD
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $22 - OBJ_POWERUP_FIRECARD
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $23 - OBJ_POWERUP_STARCARD


	; Object group $00 (i.e. objects starting at ID $00) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup00_Attributes2:
	.byte OA2_TDOGRP0	; Object $00
	.byte OA2_TDOGRP1	; Object $01
	.byte OA2_TDOGRP1	; Object $02
	.byte OA2_TDOGRP5	; Object $03
	.byte OA2_TDOGRP2	; Object $04
	.byte OA2_TDOGRP1	; Object $05
	.byte OA2_TDOGRP1	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA2_TDOGRP0	; Object $07 - OBJ_WARPHIDE
	.byte OA2_TDOGRP0	; Object $08 - OBJ_PSWITCHDOOR
	.byte OA2_TDOGRP1	; Object $09 - OBJ_AIRSHIPANCHOR
	.byte OA2_TDOGRP1	; Object $0A
	.byte OA2_TDOGRP1	; Object $0B - OBJ_POWERUP_1UP
	.byte OA2_TDOGRP1	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA2_TDOGRP1	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA2_TDOGRP6	; Object $0E - OBJ_BOSS_KOOPALING
	.byte OA2_TDOGRP0	; Object $0F
	.byte OA2_TDOGRP0	; Object $10
	.byte OA2_TDOGRP0	; Object $11
	.byte OA2_TDOGRP0	; Object $12
	.byte OA2_TDOGRP0	; Object $13
	.byte OA2_TDOGRP0	; Object $14
	.byte OA2_TDOGRP0	; Object $15
	.byte OA2_TDOGRP5	; Object $16
	.byte OA2_TDOGRP1	; Object $17 - OBJ_SPINYCHEEP
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP12	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA2_TDOGRP1	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA2_TDOGRP1	; Object $1A
	.byte OA2_TDOGRP1	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA2_TDOGRP1	; Object $1C
	.byte OA2_TDOGRP2	; Object $1D
	.byte OA2_TDOGRP1	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA2_TDOGRP1	; Object $1F - OBJ_GROWINGVINE
	.byte OA2_TDOGRP0	; Object $20
	.byte OA2_TDOGRP1	; Object $21 - OBJ_POWERUP_MUSHCARD
	.byte OA2_TDOGRP1	; Object $22 - OBJ_POWERUP_FIRECARD
	.byte OA2_TDOGRP1	; Object $23 - OBJ_POWERUP_STARCARD


	; Object group $00 (i.e. objects starting at ID $00) third set attribute bits

	; Attribute bits for objects:
	;	Bits 0-3: Determines what to do when gameplay halted (see Object_DoHaltedAction, most common is 5 / 0101)
	;	Bit 4: If set, enemy goes to "squashed" (state 7) after being stomped, otherwise it goes to "shelled" (state 3); in the case of being stomped by Kuribo's shoe or the Tanooki statue, squashed enemies still get sqashed, and otherwise they get "killed" (6)
	;	Bit 5: Object is NOT stompable (e.g. a spikey enemy, HURTS PLAYER, not same as attr 2 bit 2 which is just indifferent)
	;	Bit 6: The CollideJumpTable entry MAY contain the "special" entry; see CollideJumpTable; also "dies" into "shell" (state 3) (i.e. object "bumps" into shell when hit from beneath)
	;	Bit 7: If set, object cannot be tail attacked

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup00_Attributes3:
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $00
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $01
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $02
	.byte OA3_HALT_JUSTDRAWWIDE 	; Object $03
	.byte OA3_HALT_JUSTDRAWTALL 	; Object $04
	.byte OA3_HALT_JUSTDRAW 	; Object $05
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $07 - OBJ_WARPHIDE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $08 - OBJ_PSWITCHDOOR
	.byte OA3_HALT_JUSTDRAW 	; Object $09 - OBJ_AIRSHIPANCHOR
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $0A
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0B - OBJ_POWERUP_1UP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $0E - OBJ_BOSS_KOOPALING
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $0F
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $10
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $11
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $12
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $13
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $14
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $15
	.byte OA3_HALT_DONOTHING4 	; Object $16
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $17 - OBJ_SPINYCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $18 - OBJ_BOSS_BOWSER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OA3_HALT_JUSTDRAW 	; Object $1A
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $1C
	.byte OA3_HALT_DONOTHING 	; Object $1D
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $1F - OBJ_GROWINGVINE
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $20
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $21 - OBJ_POWERUP_MUSHCARD
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $22 - OBJ_POWERUP_FIRECARD
	.byte OA3_HALT_JUSTDRAWMIRROR | OA3_TAILATKIMMUNE	; Object $23 - OBJ_POWERUP_STARCARD


	; Object group $00 (i.e. objects starting at ID $00) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup00_PatTableSel:
	.byte OPTS_NOCHANGE	; Object $00
	.byte OPTS_SETPT5 | $48	; Object $01
	.byte OPTS_SETPT5 | $4C	; Object $02
	.byte OPTS_SETPT5 | $48	; Object $03
	.byte OPTS_SETPT5 | $48	; Object $04
	.byte OPTS_SETPT5 | $48	; Object $05
	.byte OPTS_NOCHANGE	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte OPTS_NOCHANGE	; Object $07 - OBJ_WARPHIDE
	.byte OPTS_SETPT6 | $13	; Object $08 - OBJ_PSWITCHDOOR
	.byte OPTS_SETPT6 | $37	; Object $09 - OBJ_AIRSHIPANCHOR
	.byte OPTS_SETPT5 | $48	; Object $0A
	.byte OPTS_NOCHANGE	; Object $0B - OBJ_POWERUP_1UP
	.byte OPTS_NOCHANGE	; Object $0C - OBJ_POWERUP_STARMAN
	.byte OPTS_NOCHANGE	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte OPTS_NOCHANGE	; Object $0E - OBJ_BOSS_KOOPALING
	.byte OPTS_NOCHANGE	; Object $0F
	.byte OPTS_NOCHANGE	; Object $10
	.byte OPTS_NOCHANGE	; Object $11
	.byte OPTS_NOCHANGE	; Object $12
	.byte OPTS_NOCHANGE	; Object $13
	.byte OPTS_NOCHANGE	; Object $14
	.byte OPTS_NOCHANGE	; Object $15
	.byte OPTS_SETPT5 | $48	; Object $16
	.byte OPTS_SETPT5 | $1A	; Object $17 - OBJ_SPINYCHEEP
	.byte OPTS_SETPT5 | $3A	; Object $18 - OBJ_BOSS_BOWSER
	.byte OPTS_NOCHANGE	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte OPTS_NOCHANGE	; Object $1A
	.byte OPTS_NOCHANGE	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte OPTS_NOCHANGE	; Object $1C
	.byte OPTS_SETPT5 | $48	; Object $1D
	.byte OPTS_NOCHANGE	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte OPTS_NOCHANGE	; Object $1F - OBJ_GROWINGVINE
	.byte OPTS_SETPT5 | $0A	; Object $20
	.byte OPTS_NOCHANGE	; Object $21 - OBJ_POWERUP_MUSHCARD
	.byte OPTS_NOCHANGE	; Object $22 - OBJ_POWERUP_FIRECARD
	.byte OPTS_NOCHANGE	; Object $23 - OBJ_POWERUP_STARCARD


	; Object group $00 (i.e. objects starting at ID $00) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup00_KillAction:
	.byte KILLACT_STANDARD	; Object $00
	.byte KILLACT_STANDARD	; Object $01
	.byte KILLACT_STANDARD	; Object $02
	.byte KILLACT_STANDARD	; Object $03
	.byte KILLACT_STANDARD	; Object $04
	.byte KILLACT_STANDARD	; Object $05
	.byte KILLACT_STANDARD	; Object $06 - OBJ_BOUNCEDOWNUP
	.byte KILLACT_STANDARD	; Object $07 - OBJ_WARPHIDE
	.byte KILLACT_STANDARD	; Object $08 - OBJ_PSWITCHDOOR
	.byte KILLACT_STANDARD	; Object $09 - OBJ_AIRSHIPANCHOR
	.byte KILLACT_STANDARD	; Object $0A
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0B - OBJ_POWERUP_1UP
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0C - OBJ_POWERUP_STARMAN
	.byte KILLACT_JUSTDRAWMIRROR	; Object $0D - OBJ_POWERUP_MUSHROOM
	.byte KILLACT_NORMALANDKILLED	; Object $0E - OBJ_BOSS_KOOPALING
	.byte KILLACT_STANDARD	; Object $0F
	.byte KILLACT_STANDARD	; Object $10
	.byte KILLACT_STANDARD	; Object $11
	.byte KILLACT_STANDARD	; Object $12
	.byte KILLACT_STANDARD	; Object $13
	.byte KILLACT_STANDARD	; Object $14
	.byte KILLACT_STANDARD	; Object $15
	.byte KILLACT_STANDARD	; Object $16
	.byte KILLACT_JUSTDRAW16X16	; Object $17 - OBJ_SPINYCHEEP
	.byte KILLACT_NORMALSTATE	; Object $18 - OBJ_BOSS_BOWSER
	.byte KILLACT_JUSTDRAWMIRROR	; Object $19 - OBJ_POWERUP_FIREFLOWER
	.byte KILLACT_STANDARD	; Object $1A
	.byte KILLACT_STANDARD	; Object $1B - OBJ_BOUNCELEFTRIGHT
	.byte KILLACT_STANDARD	; Object $1C
	.byte KILLACT_STANDARD	; Object $1D
	.byte KILLACT_STANDARD	; Object $1E - OBJ_POWERUP_SUPERLEAF
	.byte KILLACT_STANDARD	; Object $1F - OBJ_GROWINGVINE
	.byte KILLACT_STANDARD	; Object $20
	.byte KILLACT_STANDARD	; Object $21 - OBJ_POWERUP_MUSHCARD
	.byte KILLACT_STANDARD	; Object $22 - OBJ_POWERUP_FIRECARD
	.byte KILLACT_STANDARD	; Object $23 - OBJ_POWERUP_STARCARD


	; Object group $00 (i.e. objects starting at ID $00) pattern index starts
	; These are used for all states except "normal"

OG0_POff .func (\1 - ObjectGroup00_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup00_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG0_POff(ObjP00), OG0_POff(ObjP01), OG0_POff(ObjP02), OG0_POff(ObjP03)
	.byte OG0_POff(ObjP04), OG0_POff(ObjP05), OG0_POff(ObjP06), OG0_POff(ObjP07)
	.byte OG0_POff(ObjP08), OG0_POff(ObjP09), OG0_POff(ObjP0A), OG0_POff(ObjP0B)
	.byte OG0_POff(ObjP0C), OG0_POff(ObjP0D), OG0_POff(ObjP0E), OG0_POff(ObjP0F)
	.byte OG0_POff(ObjP10), OG0_POff(ObjP11), OG0_POff(ObjP12), OG0_POff(ObjP13)
	.byte OG0_POff(ObjP14), OG0_POff(ObjP15), OG0_POff(ObjP16), OG0_POff(ObjP17)
	.byte OG0_POff(ObjP18), OG0_POff(ObjP19), OG0_POff(ObjP1A), OG0_POff(ObjP1B)
	.byte OG0_POff(ObjP1C), OG0_POff(ObjP1D), OG0_POff(ObjP1E), OG0_POff(ObjP1F)
	.byte OG0_POff(ObjP20), OG0_POff(ObjP21), OG0_POff(ObjP22), OG0_POff(ObjP23)

	; Object group $00 (i.e. objects starting at ID $00) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup00_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup00_PatternSets:
	; (End restricted alignment space)
ObjP00:
ObjP03:
ObjP07:
ObjP0E:
ObjP0F:
ObjP10:
ObjP11:
ObjP12:
ObjP13:
ObjP14:
ObjP15:
ObjP16:
ObjP17:
ObjP18:	
ObjP1D:
ObjP20:	.byte $AD, $AF, $B9, $BB, $B9, $BB
ObjP01:	.byte $81, $81
ObjP02:	.byte $8F, $8F, $99, $9B, $9D, $9F
ObjP04:	.byte $B1, $B3, $B5, $B7, $B9, $BB, $BD, $BF
ObjP05:	.byte $A5, $A7, $A1, $A3, $A1, $A3
ObjP06:	
ObjP1B:	.byte $79, $7B, $79, $7B, $77, $77, $75, $75	; SB: Not actually used, see BounceBlock_Tile
ObjP09:	.byte $E1, $E5, $E1
ObjP0A:	.byte $81, $83, $85, $87
ObjP0C:	.byte $55, $55, $93, $93, $91, $91, $95, $95
ObjP0B:	
ObjP0D:	.byte $51, $51
ObjP19:	.byte $53, $53
ObjP1A:	.byte $59, $5B
ObjP1C:	.byte $75, $77
ObjP1E:	.byte $5D, $5F
ObjP1F:	.byte $7D, $7D
ObjP21:	.byte $51, $51
ObjP22:	.byte $53, $53
ObjP23:	.byte $55, $55
ObjP08:	.byte $FB, $FB, $FB, $FB, $BB, $B9, $B9, $BB, $BF, $BD

SpinyCheep_XVel:
	.byte 8, -8

ObjInit_SpinyCheep:
	INC Objects_InWater,X	 ; Set object as in-water

	; Pick the correct X Velocity to chase Player
	JSR Level_ObjCalcXDiffs
	LDA SpinyCheep_XVel,Y
	STA <Objects_XVel,X

	; Var10 = Object's X
	LDA <Objects_X,X
	SUB #$30
	STA Objects_Var10,X

	; Var11 = Object's X + 96
	ADD #96
	STA Objects_Var11,X

	RTS		 ; Return

	; Y velocity acceleration and limits based on direction
SpinyCheep_YVelAccel:	.byte $01, -$01
SpinyCheep_YVelMax:	.byte $08, -$08

ObjNorm_SpinyCheep:
	LDA <Player_HaltGame
	BNE PRG001_A277	 ; If gameplay is halted, jump to PRG001_A277

	INC <Objects_Var5,X	 ; Not sure what this is used for?

	LDA <Counter_1	
	AND #$07	
	BNE PRG001_A23F	 ; Only proceed every 8 ticks, otherwise, jump to PRG001_A23F

	LDA <Objects_Var4,X	 ; Get Var 4 (selects direction)
	AND #$01
	TAY		 ; Y = 0 or 1

	; Spike Cheep's Y velocity
	LDA <Objects_YVel,X
	ADD SpinyCheep_YVelAccel,Y
	STA <Objects_YVel,X

	CMP SpinyCheep_YVelMax,Y
	BNE PRG001_A23F	 	; If Spiny cheep hasn't hit velocity limit, jump to PRG001_A23F

	INC <Objects_Var4,X	 ; Effectively, change direction

PRG001_A23F:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_X,X
	CMP Objects_Var10,X
	BEQ PRG001_A25A	 	; If Spiny Cheep is back at his origin, jump to PRG001_A25A

	CMP Objects_Var11,X
	BEQ PRG001_A25A	 	; If Spiny Cheep is at his origin + 96, jump to PRG001_A25A

	JSR Object_WorldDetect4	 

	LDA <Objects_DetStat,X	
	AND #$03	 
	BEQ PRG001_A263	 ; If spiny cheep hasn't hit a wall on either side, jump to PRG001_A263

PRG001_A25A:
	; Flip Spiny cheep around!
	JSR Object_AboutFace
	JSR Object_ApplyXVel
	JSR Object_ApplyXVel

PRG001_A263:
	JSR Player_HitEnemy	 ; Player hits enemy
	JSR Object_DeleteOffScreen_N4	 ; Delete object if it falls off-screen

	; Swim frame based on counter and index (just to keep it interesting)
	TXA
	ASL A
	ASL A
	ADC Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

PRG001_A277:
	JMP Object_ShakeAndDraw	 ; Draw object and don't return


	RTS		 ; Return

ObjInit_Obj01:
	LDA #$00	 
	STA Objects_FlipBits,X	 ; Clear flip bits
	STA Objects_Var1,X	 ; Clear var 1
	RTS		 ; Return


ObjNorm_Obj01:
	LDA Objects_Var1,X
	BNE PRG001_A28F	 ; If var 1 <> 0, jump to PRG001_A28F 

	JSR Object_HitTestRespond ; If Player has collided with this object, do Collide routine!
	JMP PRG001_A292	 ; Jump to PRG001_A292

PRG001_A28F:
	JSR ObjHit_Obj01	 ; Do "Hit" routine

PRG001_A292:
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world

	LDA #$00
	STA <Objects_XVel,X	 ; Halt X velocity
	STA Objects_Frame,X	 ; Clear Objects_Frame

	LDA <Obj01_Flag
	BEQ PRG001_A2B0	 ; If Obj01_Flag = 0, jump to PRG001_A2B0

	LDA <Objects_X,X
	AND #$0f	
	BEQ PRG001_A2B0	 ; If object is right on left edge of tile, jump to PRG001_A2B0

	LDY #$0f	 ; Y = $F (X velocity)

	LDA <Player_XVel
	BPL PRG001_A2AE	 ; If object's X Velocity >= 0 (still or moving rightward), jump to PRG001_A2AE

	LDY #-$0f	 ; Y = -$F (X velocity)

PRG001_A2AE:
	STY <Objects_XVel,X ; Set X velocity appropriately 

PRG001_A2B0:
	JSR Object_ShakeAndDraw		; Draw object and "shake awake" 
	JMP Object_DeleteOffScreen	 ; Delete object if it falls off screen and don't come back


PRG001_A2B6:
	.byte $04, $01, $00, $00, $00, $00

ObjHit_Obj01:
	LDA <Player_InAir		 
	BEQ PRG001_A2CB	 ; If Player is NOT mid air, jump to PRG001_A2CB

	LDA <Player_YVel
	BMI PRG001_A2D5	 ; If Player's Y velocity < 0 (moving upward), jump to PRG001_A2D5

	LDA #$00
	STA <Player_YVel ; Otherwise, halt Player

	JMP PRG001_A2D5	 ; Jump to PRG001_A2D5

PRG001_A2CB:
	LDA <Obj01_Flag
	BNE PRG001_A320	 ; If Obj01_Flag <> 0, jump to PRG001_A320 (RTS)

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG001_A2EB	 ; If Player is pressing left or right, jump to PRG001_A2EB

PRG001_A2D5:
	LDA Objects_Var1,X
	CMP #$18	 
	BGS PRG001_A2DE	 ; If var 1 > $18, jump to PRG001_A2DE

	LDA #$0a	 ; Otherwise, A = 10

PRG001_A2DE:
	PHA		 ; Save var 1

	LDA <Player_SpriteX
	CMP <Objects_SpriteX,X

	PLA		 ; Restore var 1

	BGE PRG001_A2E9	 ; If Player's sprite X >= Object's sprite X, jump to PRG001_A2E9

	JSR Negate	 ; Negate Player's sprite X

PRG001_A2E9:
	STA <Obj01_Flag	 ; Store this into Obj01_Flag

PRG001_A2EB:
	LDA <Obj01_Flag	 
	BEQ PRG001_A2F7	 ; If Obj01_Flag = 0, jump to PRG001_A2F7

	LDA #$00	 
	STA Objects_Var1,X	 ; Var 1 = 0

	JMP PRG001_A320	 ; Jump to PRG001_A320 (RTS)

PRG001_A2F7:
	LDA Objects_Var1,X
	LSR A
	LSR A
	LSR A
	LSR A		; Shift var 1 to the right by 4 (upper 4 bits)
	TAY		 ; -> Y

	LDA PRG001_A2B6,Y ; Get value

	LDY <Player_XVel
	BPL PRG001_A309	  ; If Player's X velocity >= 0, jump to PRG001_A309

	JSR Negate	 ; Otherwise, negate the value

PRG001_A309:
	STA <Player_XVel 	; Store as Player's X Velocity
 	STA <Objects_XVel,X	; Set Object's X velocity to the same

	INC Objects_Var1,X	; var 1 ++

	LDA Objects_Var1,X
	CMP #$40
	BLS PRG001_A320	 ; If var 1 < $40, jump to PRG001_A320 (RTS)

	DEC Objects_Var1,X	; var 1 --

	LDA #$00	
	STA <Player_XVel	 ; Halt Player
	STA <Objects_XVel,X	 ; Object stops too

PRG001_A320:
	RTS		 ; Return

ObjInit_Obj02:
	LDA #$00	 
	STA Player_Bounce	 ; Kill Player bounce

	LDA Level_Tile_GndL
	EOR Level_Tile_GndR
	BEQ PRG001_A334	 	; If both tiles at Player's feet are the same, jump to PRG001_A334

	; Otherwise, this object's toast
	LDA #OBJSTATE_DEADEMPTY	 
	STA Objects_State,X	; Mark dead/empty

	RTS		 ; Return

PRG001_A334:

	; Set object vertical position to match Player's Y/Hi + 32, aligned to tile grid
	LDA <Player_YHi
	STA <Objects_YHi,X
	LDA <Player_Y
	ADD #32		
	AND #$f0	 ; Align to grid
	STA <Objects_Y,X

	BCC PRG001_A345	 ; If no carry, jump to PRG001_A345

	INC <Objects_YHi,X	 ; Otherwise, apply carry

PRG001_A345:

	; Match Player's X
	LDA <Player_X
	STA <Objects_X,X
	LDA <Player_XHi	
	STA <Objects_XHi,X

	LDA #11
	STA Objects_Timer,X	 ; Set Timer to 11
	STA <Player_InAir	 ; Mark Player as mid-air

	LDA #$00
	STA Objects_FlipBits,X	 ; Clear left/right flag
	STA <Player_YVel	 ; Halt Player vertical movement

	LDA #$b0
	STA Objects_Var1,X	 ; Set var1 to $b0

	RTS		 ; Return

PRG001_A361:
	.byte $00, $00, $01, $01, $02, $02, $02, $01, $01, $01, $00

ObjNorm_Obj02:

	; Set Player as mid-air
	LDA #$01
	STA <Player_InAir

	LDY Objects_Timer,X
	BNE PRG001_A383	 ; If timer is not expired, jump to PRG001_A383

	; Set object to dead/empty state
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	; Copy var 1 into Player's Y Velocity and micro goomba flag
	LDA Objects_Var1,X
	STA <Player_YVel
	STA Player_mGoomba

	RTS		 ; Return

PRG001_A383:
	LDY Objects_Timer,X
	
	; Set frame based on timer
	LDA PRG001_A361,Y
	STA Objects_Frame,X

	; Set Player Y Velocity by table by timer
	LDA Bouncer_PUpVel,Y
	STA <Player_YVel

	LDA Objects_Timer,X
	CMP #$07
	BGS PRG001_A3A3		; If timer > 7, jump to PRG001_A3A3

	LDA <Pad_Input
	AND #PAD_A
	BEQ PRG001_A3A3	 	; If Player is NOT pressing 'A', jump to PRG001_A3A3

	; Var 1 = $88
	LDA #$88	
	STA Objects_Var1,X

PRG001_A3A3:
	JMP Object_ShakeAndDraw	; Jump to Object_ShakeAndDraw


	; Same as ObjInit_Obj05 ??
ObjInit_Obj04:
	LDA #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Force left/right flag to SPR_HFLIP (Player is to right of object)

	LDY #$08	 ; Y = 8

	LDA <Scroll_LastDir
	BNE PRG001_A3B6	 ; If screen last moved left/down, jump to PRG001_A3B6

	STA Objects_FlipBits,X	 ; Force left/right flag to $00 (Player is to the left of object)
	LDY #-8	 	; Y = -8

PRG001_A3B6:
	STY <Objects_XVel,X	 ; Set object X velocity to 8 or -8 as appropriate
	RTS		 ; Return


ObjNorm_Obj04:
	JSR Object_HitTestRespond	; Handle object collision
	JSR Object_InteractWithWorld	; Move, detect, interact with blocks of world
	JSR Object_ToggleFrameBySpd	; Toggle frame 0 or 1 by object's speed

	INC Objects_Timer,X	 	; Timer++

	JSR Object_Draw16x32Sprite	; Draw sprite

	JMP Object_DeleteOffScreen	; Delete object if it falls off screen and don't come back


ObjHit_Obj04:

	; Set Object's Y velocity to Player's Y velocity
	LDA <Player_YVel	
	STA <Objects_YVel,X	

	; Set Object's X velocity to Player's X velocity
	LDA <Player_XVel
	STA <Objects_XVel,X

	LDA Player_FlipBits_OLD	
	CMP <Player_FlipBits	
	BEQ PRG001_A3DD	 	; If Player hasn't turned around, jump to PRG001_A3DD (RTS)

	INC Objects_Timer,X	; Otherwise, increment timer

PRG001_A3DD:
	RTS		 ; Return

	; Same as ObjInit_Obj04 ??
ObjInit_Obj05:
	LDA #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Force left/right flag to SPR_HFLIP (Player is to right of object)

	LDY #$08	 ; Y = 8

	LDA <Scroll_LastDir
	BNE PRG001_A3EE	 ; If screen last moved left/down, jump to PRG001_A3B6

	STA Objects_FlipBits,X	 ; Force left/right flag to $00 (Player is to the left of object)
	LDY #-8	 	; Y = -8

PRG001_A3EE:
	STY <Objects_XVel,X	 ; Set object X velocity to 8 or -8 as appropriate
	RTS		 ; Return


ObjNorm_Obj05:
	LDA Objects_Timer,X
	BNE PRG001_A412	 ; If timer not expired, jump to PRG001_A412

	LDA <Objects_DetStat,X	
	AND #$04	 
	BEQ PRG001_A455	 ; If object has not hit ground, jump to PRG001_A455

	LDA RandomN,X
	AND #$3f	
	BNE PRG001_A455	 ; Only 1:40 chance we don't jump to PRG001_A455

	LDA RandomN,X
	AND #$80	
	ASL A		
	ROL A		
	STA Objects_Var1,X	; Object Var 1 = random 0 or 1

	; Set timer to $90
	LDA #$90
	STA Objects_Timer,X

PRG001_A412:
	LDA Objects_Timer,X
	CMP #$01	 
	BNE PRG001_A446	 ; If timer <> 1, jump to 

	LDA Objects_Var1,X
	BEQ PRG001_A42E	 ; If Var 1 = 0, jump to PRG001_A42E

	JSR Object_CalcCoarseXDiff
	EOR Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG001_A455	 ; If Player face direction versus object face direction are opposite, jump to PRG001_A455

	JSR Object_AboutFace	 ; Turn around
	JMP PRG001_A455	 ; Jump to PRG001_A455

PRG001_A42E:
	LDA <Objects_YHi,X
	CMP <Player_YHi	
	BLS PRG001_A455	 ; If Objects's Y Hi is less than player's Y Hi, jump to PRG001_A455
	BNE PRG001_A43C	 ; If they're otherwise unequal, jump to PRG001_A43C

	; Player Y Hi and object's Y Hi are the ssame...

	LDA <Objects_Y,X
	CMP <Player_Y	
	BLT PRG001_A43F	 ; If Object's Y < Player_Y, jump to PRG001_A43F

PRG001_A43C:
	INC Objects_Timer,X	 ; Increment timer

PRG001_A43F:
	; Object "jumps"
	LDA #-$20
	STA <Objects_YVel,X

	JMP PRG001_A455	 ; Jump to PRG001_A455

PRG001_A446:
	LDA #$01	; A = 1

	LDY Objects_Var1,X

	BNE PRG001_A44F	 ; If object variable 1 <> 0, jump to PRG001_A44F

	LDA #$02	; A = 2

PRG001_A44F:
	STA Objects_Frame,X	; Set frame to 1 or 2
	JMP PRG001_A458	 ; Jump to PRG001_A458

PRG001_A455:
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world

PRG001_A458:
	JSR Object_ToggleFrameBySpd	; Toggles between frame 0 and 1 based on speed
	JSR Object_HitTestRespond	; Handle hit response
	JSR Object_ShakeAndDraw		; Draw object and "shake awake" 
	JMP Object_DeleteOffScreen	; Delete object if it falls off screen and don't come back

ObjHit_Obj05:
	LDA Objects_Timer2,X
	BNE PRG001_A48F	 ; If timer 2 has not expired, jump to PRG001_A48F

	LDA <Player_YHi
	STA <Temp_Var1		 ; Temp_Var1 = Player Y Hi

	LDA <Objects_Y,X	
	SUB <Player_Y		
	STA <Temp_Var2		 ; Temp_Var2 = difference between Object's Y and Player's Y

	BCS PRG001_A478	 	; If no carry, jump to PRG001_A478

	INC <Temp_Var1		 ; Otherwise, apply carry

PRG001_A478:
	LDA <Temp_Var1	
	CMP <Objects_YHi,X
	BNE PRG001_A49E	 ; If the "Y Hi" values are different, jump to PRG001_A49E

	LDA <Temp_Var2	
	SUB #$09	
	BMI PRG001_A49E	 ; If (Temp_Var2 - 9) < 0, jump to PRG001_A49E

	; Reset timer
	LDA #$00	 
	STA Objects_Timer,X

	; Set timer 2 to $80
	LDA #$80	
	STA Objects_Timer2,X

PRG001_A48F:
	LDA #-$40
	STA <Player_YVel ; Bounce Player

	; Bounce Player in direction he's facing
	LDY #$10
	LDA <Player_XVel
	BPL PRG001_A49B	

	LDY #-$10	

PRG001_A49B:
	STY <Player_XVel

	RTS		 ; Return

PRG001_A49E:
	JMP Player_GetHurt	 ; Hurt Player and never return

PRG001_A4A1:
	.byte $4C, $EF, $DB, $08, $20, $10, $20, $05, $20, $0C, $20, $03, $04
	

ObjInit_BounceDU: 
	LDA Player_BounceDir
	STA Objects_Var2,X	 ; Store Player's bounce into var 2
	BEQ PRG001_A4BF	 ; If bounce direction is down, jump to PRG001_A4BF

	LDA Player_BounceObj
	BNE PRG001_A4C6	 ; If this is actually an object that bounced, jump to PRG001_A4C6

	LDA #$20	 
	STA <Player_YVel ; PRG001_A4C6 = $20 (bounce down)

PRG001_A4BF:
	STX <Player_InAir ; Mark Player as mid-air

	LDA #$00
	STA Player_Flip	 ; Cancel invincibility somersault

PRG001_A4C6:
	LDA Player_Bounce
	STA Objects_Var1,X	; Store Player_Bounce -> var1

	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 ; Shift right 4
	STA Objects_Frame,X	 ; Store into Objects_Frame 
 
	LDA #$00
	STA Player_Bounce	 ; Clear Player_Bounce
	STA Player_BounceObj	 ; Clear Player_BounceObj
	STA Objects_FlipBits,X	 ; Force left/right flag to zero
	STA Objects_SprVVis,X	 ; Clear flags 2
	STA Objects_SprHVis,X	 ; Clear flags 1

	LDA #10
	STA Level_BlkBump_Pos-6,X ; Block bump position = 10

	JMP BounceBlock_Update	 ; Jump to BounceBlock_Update

	; Power-up which may emerge from different types of bounce blocks
Bouncer_PUp:	.byte $00, $00, OBJ_POWERUP_FIREFLOWER, OBJ_POWERUP_SUPERLEAF, OBJ_POWERUP_STARMAN
		.byte OBJ_POWERUP_MUSHROOM, OBJ_GROWINGVINE, OBJ_POWERUP_1UP

Bounce_TileReplacements:	
	.byte CHNGTILE_TOGNOTEBLOCK
	.byte CHNGTILE_COINHEAVEN
	.byte CHNGTILE_TOMETALPLATE
	.byte CHNGTILE_TOBRICK
	.byte CHNGTILE_TONOTEBLOCK
	.byte CHNGTILE_TOBOUNCEWOOD
	.byte CHNGTILE_TOBRICKCOIN
	.byte CHNGTILE_PIPEJCT

	; Power-up X or Y velocity upon emerging from the bounce block
Bouncer_PUpVel:	.byte $00, -$40, -$40, -$30, -$20, -$10, $00, $10, $20, $30, $40


ObjNorm_BounceDU:
	LDY Level_BlkBump_Pos-6,X
	BNE PRG001_A56F	 ; If the block bump position > 0, jump to PRG001_A56F

	; Block bump complete
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X	; Set state to dead/empty

	LDA Objects_Var1,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Var1 >> 4 -> 'Y'

	LDA Bounce_TileReplacements,Y
	CMP #$07	 
	BNE PRG001_A527	 ; If value <> 7, jump to PRG001_A527

	LDY Level_PSwitchCnt
	BEQ PRG001_A527	 ; If P-Switch not active, jump to PRG001_A527

	LDA #CHNGTILE_FROZENCOIN	 ; Otherwise, A = CHNGTILE_FROZENCOIN (same as "frozen coin" thawing, replace coin)

PRG001_A527:
	STA <Temp_Var12  ; -> Temp_Var12

	; Temp_Var15 = bumper X Hi
	LDA <Objects_XHi,X
	STA <Temp_Var15	 

	; Temp_Var16 = bumper X
	LDA <Objects_X,X
	STA <Temp_Var16	 

	; Temp_Var13 = bumper Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Temp_Var14 = bumper Y, grid aligned
	LDA <Objects_Y,X
	AND #$f0	
	STA <Temp_Var14	

	JSR BlockBump_Init

	LDA Objects_Var2,X
	BNE PRG001_A56E	 ; If Var 2 <> 0, jump to PRG001_A56E (RTS)

	LDA #-$38
	STA <Player_YVel	 ; Set Player bounce
	STA Player_mGoomba	 

	LDA Objects_Timer2,X
	BEQ PRG001_A56E	 ; If timer 2 expired, jump to PRG001_A56E (RTS)

	LDA #-$70
	STA <Player_YVel	; Larger Player bounce

	LDA Objects_Var1,X
	AND #$f0
	CMP #$10
	BNE PRG001_A56E	 ; If var 1 upper 4 bits <> $10, jump to PRG001_A56E (RTS)

	LDA Player_InWater
	BNE PRG001_A56E	 ; If Player is in water, jump to PRG001_A56E (RTS)

	; Flag to go to coin heaven
	LDA #$80
	STA Level_CoinHeav

	; Bounce into coin heaven sound
	LDA Sound_QLevel1
	ORA #SND_LEVELVINE
	STA Sound_QLevel1

PRG001_A56E:
	RTS		 ; Return


PRG001_A56F:
	LDA Level_BlkBump_Pos-6,X
	CMP #10
	BNE PRG001_A5D5	 ; If Block bump position <> 10, jump to PRG001_A5D5

	; Block bump position is 10...

	LDA Objects_Var1,X
	AND #$0f
	TAY		 ; Y = 0 to 15, based on var 1

	LDA Bouncer_PUp,Y
	BEQ PRG001_A5BB	 ; If value is zero (no power up), jump to PRG001_A5BB

	STA <Temp_Var1	 ; Store value -> Temp_Var1

	LDY #$05	 ; Y = 5 (power-up always in slot 5)

	; Set the ID
	LDA <Temp_Var1
	STA Level_ObjectID,Y

	; Set X
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; State 1 (Initialize)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

	; Set Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var1

	LDA #$08	 ; A = 8

	STY <Temp_Var2		 ; Backup 'Y' -> Temp_Var2

	LDY Objects_Var2,X
	BEQ PRG001_A5AA	 ; If var2 = 0, jump to PRG001_A5AA

	DEC <Temp_Var1	 ; Temp_Var1-- (Y Hi)
	LDA #-1		 ; A = -1

PRG001_A5AA:
	LDY <Temp_Var2	 ; Restore 'Y'

	ADD <Objects_Y,X ; Apply Y offset
	STA Objects_Y,Y	 ; -> Object's Y
 
	BCC PRG001_A5B6	 ; If no carry, jump to PRG001_A5B6

	INC <Temp_Var1	 ; Apply carry

PRG001_A5B6:
	; Set Y Hi
	LDA <Temp_Var1
	STA Objects_YHi,Y

PRG001_A5BB:
	; Backup Y Hi -> Temp_Var13 
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Backup Y -> Temp_Var14
	LDA <Objects_Y,X
	STA <Temp_Var14

	; Backup X Hi -> Temp_Var15
	LDA <Objects_XHi,X
	STA <Temp_Var15

	; Backup X -> Temp_Var16
	LDA <Objects_X,X
	STA <Temp_Var16

	LDA Objects_Var2,X
	BEQ PRG001_A5D5	 ; If Var2 = 0, jump to PRG001_A5D5

	; Erase the tile behind the bump
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

PRG001_A5D5:
	JSR Object_ApplyYVel	 ; Apply Y velocity
	JSR BounceBlock_Update

	LDY Level_BlkBump_Pos-6,X	; Y = block bump pos

	LDA Bouncer_PUpVel,Y

	LDY Objects_Var2,X	 ; Y = var2
	BEQ PRG001_A5EE	 ; If Var2 = 0, jump to PRG001_A5EE

	JSR Negate	 ; Negate retrieved Y Velocity

	STA <Objects_YVel,X	; Set Y Velocity 

	JMP PRG001_A5FD	 ; Jump to PRG001_A5FD

PRG001_A5EE:
	STA <Objects_YVel,X	 ; Set Y Velocity 
	STA <Player_YVel	 ; ... of Player too

	LDA <Pad_Input
	AND #PAD_A
	BEQ PRG001_A5FD	 ; If Player is not pressing A, jump to PRG001_A5FD

	; Otherwise, Timer 2 = 11
	LDA #$0b
	STA Objects_Timer2,X

PRG001_A5FD:
	DEC Level_BlkBump_Pos-6,X	; Block bump pos--
	RTS		 ; Return

	; The following block bounces are referenced by PRG008's LATR_BlockResult
	; Type 7 is for the UNUSED breakable pipeworks tile!

	; Palette select for a bounce block
BounceBlock_Pal:
	.byte SPR_PAL1	; 0 (possibly unused / Note Block)
	.byte SPR_PAL2	; 1 (coin heaven Note Block)
	.byte SPR_PAL3	; 2 ("Metal plate" post-? block hit)
	.byte SPR_PAL3	; 3 (used for empty brick)
	.byte SPR_PAL1	; 4 (typical Note Block)
	.byte SPR_PAL3	; 5 (wood)
	.byte SPR_PAL3	; 6 (used for brick with coins)
	.byte SPR_PAL1	; 7 (UNUSED, would be for desert's breakable pipeworks tile!)

	; Offset into Sprite_RAM based on which block bounce slot
BounceBlock_SprOff:
	.byte $08, $10

	; Tile for block bounce sprite (if same, mirrors)
BounceBlock_Tile:
	.byte $79, $7B	; 0 (possibly unused / Note Block)
	.byte $79, $7B	; 1 (coin heaven Note Block)
	.byte $77, $77	; 2 ("Metal plate" post-? block hit)
	.byte $75, $75	; 3 (used for empty brick)
	.byte $79, $7B	; 4 (typical Note Block)
	.byte $7F, $7F	; 5 (wood)
	.byte $75, $75	; 6 (used for brick with coins)
	.byte $7B, $7B	; 7 (UNUSED, would be for desert's breakable pipeworks tile!)

BounceBlock_Update:
	LDA Objects_Var1,X	; Player_Bounce
	LSR A
	LSR A
	LSR A
	LSR A		; Get kind of block that is getting bounced
	TAY		; -> Y

	; Temp_Var1 stores palette of object
	LDA BounceBlock_Pal,Y	
	STA <Temp_Var1

	; Y *= 2
	TYA
	ASL A
	TAY

	; Temp_Var2/3 store the tiles that make up the sprites of the bounce block
	LDA BounceBlock_Tile,Y
	STA <Temp_Var2		
	LDA BounceBlock_Tile+1,Y
	STA <Temp_Var3		

	LDA #$00	 ; A = 0 (do not flip second sprite)

	LDY <Temp_Var2
	CPY <Temp_Var3
	BNE PRG001_A63F	 ; If tiles are NOT the same, jump to PRG001_A63F

	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (flip second sprite)

PRG001_A63F:
	STA <Temp_Var4	 ; Store the selected sprite attribute

	; Select own range of sprite area
	LDA #$05
	ADD Counter_7to0
	TAY		 ; Y = 5 + (0 to 7)

	LDA SprRamOffsets,Y
	PHA		 ; Save this value

	; Block bouncers always appear in object slot 6 or 7, so this makes it relative to 0 or 1
	TXA		 
	SUB #$06	 
	TAY		 ; Y = 0 or 1
 
	PLA		 ; Restore the value

	ADD BounceBlock_SprOff,Y
	TAY		 ; Y is now offset into Sprite_RAM

	; Screen-relative X position for sprite position
	LDA <Objects_X,X
	SUB Horz_Scroll	
	STA <Objects_SpriteX,X

	; Store two pieces of bounce block sprite X
	STA Sprite_RAM+3,Y
	ADD #$08	 
	STA Sprite_RAM+7,Y

	; Screen-relative Y position for sprite position
	LDA <Objects_Y,X
	SUB Level_VertScroll
	SUB #$01
	STA <Objects_SpriteY,X

	; Store two pieces of bounce block sprite Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Build the other parts of sprites
	LDA <Temp_Var2
	STA Sprite_RAM+1,Y

	LDA <Temp_Var3
	STA Sprite_RAM+5,Y

	LDA <Temp_Var1
	STA Sprite_RAM+2,Y

	ORA <Temp_Var4
	STA Sprite_RAM+6,Y

	RTS		 ; Return

	; Force's some X bits
ObjInit_Anchor:
	LDA <Objects_X,X
	ORA #%00001100	
	STA <Objects_X,X
	RTS		 ; Return


ObjNorm_Anchor:
	LDA Level_AirshipCtl
	CMP #$03
	BNE PRG001_A6A3	 	; If Level_AirshipCtl <> 3 (enter airship), jump to PRG001_A6A3

	LDA #-$0C
	STA <Objects_YVel,X 	; Y velocity = -$0C

	JSR Object_ApplyYVel	; Apply Y velocity

PRG001_A6A3:
	LDA #$50
	STA Object_SprRAM,X	 ; Set anchor's Sprite_RAM offset @ $50

	JSR Object_DrawWide	 ; Draw the main anchor
 
	; Flips the edge of the anchor sprite
	LDA Sprite_RAM+10,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+10,Y

	LDA Objects_SprHVis,X
	BNE PRG001_A702		; Any off-screen flags, jump to PRG001_A702 (RTS)

	LDA <Objects_YHi,X
	BEQ PRG001_A702	 	; If anchor is "high", it's invisible for this sake, jump to PRG001_A702 (RTS)

	; Anchor top
	LDA <Objects_SpriteY,X
	STA <Temp_Var1		; Temp_Var1 = Sprite Y
	SUB #16	
	STA <Temp_Var1		; Temp_Var1 -= 16

	STA Sprite_RAM+12,Y	; Set Sprite Y

	LDA <Objects_SpriteX,X	
	ADD #$08	
	STA <Temp_Var2		; Temp_Var2 = Sprite X + 8
	STA Sprite_RAM+15,Y	; Set sprite X

	; Set pattern of anchor top
	LDA #$e3
	STA Sprite_RAM+13,Y

	; Set attribute of anchor top
	LDA Objects_SprAttr,X
	STA Sprite_RAM+14,Y

	LDY #$60	 ; Y = $60
PRG001_A6DF:
	LDA <Temp_Var1
	SUB #16
	STA <Temp_Var1	 ; Temp_Var1 -= 16 (next link up)
	BCC PRG001_A702	 ; If we're done with the chain, jump to PRG001_A702

	STA Sprite_RAM,Y ; Set sprite Y

	; Pattern of anchor chain link
	LDA #$e7	 
	STA Sprite_RAM+1,Y

	; Set attribute
	LDA Objects_SprAttr,X
	STA Sprite_RAM+2,Y

	; Set sprite X
	LDA <Temp_Var2	
	STA Sprite_RAM+3,Y

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)

	JMP PRG001_A6DF	 ; Jump to PRG001_A6DF

PRG001_A702:
	RTS		 ; Return

ObjInit_Obj0A:
	LDA #$00
	STA Objects_FlipBits,X	 ; Clear LR flag
	RTS		 ; Return


ObjNorm_Obj0A:
	JSR Object_HitTestRespond	 ; Handle collision routine
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world

	; Halt object horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	LDA <Counter_1
	AND #$08
	LSR A	
	LSR A	
	LSR A	
	STA Objects_Frame,X	 ; Alternate between frame 0 and 1 every 8 ticks

	JSR Object_ShakeAndDraw	; Draw object and "shake awake" 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
	RTS		 ; Return

ObjHit_Obj0A:
	LDA <Player_YVel
	BMI PRG001_A746	 ; If Player Y Velocity is negative (moving upward), jump to PRG001_A746

	LDA <Objects_SpriteY,X	
	SUB <Player_SpriteY	
	CMP #$16
	BLS PRG001_A746	 ; If Object is less than 16 pixels above Player, jump to PRG001_A746

	; Mark Player as not mid air
	LDA #$00
	STA <Player_InAir

	LDY <Objects_YHi,X	; Y = object's Y Hi

	; Subtract 25 from Object's Y
	LDA <Objects_Y,X 
	SUB #25	 
	BCS PRG001_A73F
	DEY		 ; Apply carry, if needed
PRG001_A73F:
	STA <Player_Y	 ; Player Y = Object's Y - 25
	STY <Player_YHi	 ; Set Player Y Hi appropriately
	JMP PRG001_A77C	 ; Jump to PRG001_A77C

PRG001_A746:
	LDA <Player_YVel
	BPL PRG001_A757	 ; If Player is not moving upward, jump to PRG001_A757

	LDA <Objects_SpriteY,X
	SUB <Player_SpriteY	
	CMP #-$6
	BGS PRG001_A757	 

	LDA #$01	 
	STA <Player_YVel	 ; Set Player's Y velocity to slow decent

PRG001_A757:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG001_A761	 ; If Player is pressing left or right, jump to PRG001_A761

	; Otherwise, halt Player movement
	LDA #$00
	STA <Player_XVel

PRG001_A761:
	LDA <Player_SpriteX
	CMP <Objects_SpriteX,X

	LDA <Player_XVel ; A = Player's X Velocity

	BGE PRG001_A76C	 ; If Player's sprite X >= object's sprite X, jump to PRG001_A76C
	JSR Negate	 ; Otherwise, invert the X Velocity
PRG001_A76C:
	BPL PRG001_A77C	 ; If the velocity is not negative, jump to PRG001_A77C

	LDY #-$03	 ; Y = -3

	; Set Object's X velocity to Player's X velocity
	LDA <Player_XVel
	STA <Objects_XVel,X

	BMI PRG001_A77A	 ; If velocity is negative, jump to PRG001_A77A
	BEQ PRG001_A77A	 ; If velocity is zero, jump to PRG001_A77A

	LDY #$03	 ; Y = 3

PRG001_A77A:
	STY <Player_XVel ; Set Player X Velocity appropriately

PRG001_A77C:
	RTS		 ; Return


	RTS		 ; Return

ObjNorm_PUp1UpMush:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_A78E	 	; If mushroom has not hit ground, jump to PRG001_A78E

	LDA <Objects_XVel,X
	BNE PRG001_A78E	 	; If mushroom is moving horizontally, jump to PRG001_A78E

	JSR PowerUp_BounceXVel	 ; Bounce off wall

PRG001_A78E:
	JSR Object_InteractWithWorld	 	; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen 		; Delete object if it falls off screen
	JMP PowerUp_DoHitTest	 		; Do hit test and don't come back!


ObjHit_PUp1UpMush:

	; "1-UP"
	LDA #$0d	
	JSR Score_PopUp	

	; Set to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	RTS		 ; Return

Star_Palettes:
	.byte SPR_PAL0, SPR_PAL1, SPR_PAL2, SPR_PAL3

ObjInit_StarOrSuit:
	JSR Mushroom_SetFall	 ; Figure the way that the star should fall

	LDA #$10	
	STA Objects_Timer2,X	 ; Object's timer 2 = 16

	; This will make mushroom drop downward if it was "knocked out" downward
	LDY #$10	
	LDA Player_BounceDir
	BEQ PRG001_A7BF	 
	LDY #-$38

	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X	 ; Set object's timer to $3d

PRG001_A7BF:
	STY <Objects_YVel,X	 ; Set object's Y velocity
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?

	JSR PowerUp_BounceXVel	 ; Bounce off wall

	LDA PUp_StarManFlash
	AND #$03	 
	STA Objects_Frame,X
	TAY

	; Set a start palette
	LDA Star_Palettes,Y
	STA Objects_SprAttr,X

	RTS		 ; Return


ObjNorm_StarOrSuit:
	LDA PUp_StarManFlash
	BPL PRG001_A7E0	 ; If flashing is not active, jump to PRG001_A7E0

	; Store counter into cycler
	LDA <Counter_1	
	STA Objects_ColorCycle,X

PRG001_A7E0:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world

	LDA <Objects_DetStat,X
	TAY		 ; Detection status -> 'Y'

	AND #$04
	BEQ PRG001_A7F1	 ; If star hasn't touched the ground, jump to PRG001_A7F1

	LDA #-$40
	STA <Objects_YVel,X	; Star bounce off ground!

PRG001_A7F1:
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!

	; Different "frames" of the "Starman" power up include the super
	; suits; Tanooki, Frog, and Hammer, in order
PUp_StarOrSuitFrames:	.byte $00, $05, $04, $06	; Star, Tanooki, Frog, Hammer

ObjHit_StarOrSuit:
	LDA Objects_Frame,X
	BNE PRG001_A818	 ; If frame <> 0, jump to PRG001_A818

	LDA Level_PSwitchCnt
	BNE PRG001_A810	 ; If P-Switch is active, jump to PRG001_A810

	; Otherwise, play invincibility theme!
	LDA Sound_QMusic2
	ORA #MUS2A_INVINCIBILITY
	STA Sound_QMusic2

PRG001_A810:

	; Player_StarInv = $E0
	LDA #$e0
	STA Player_StarInv

	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect

PRG001_A818:

	; This is one of the Super Suits (Tanooki, Frog, Hammer), not a Starman

	TAY		 ; Frame -> 'Y' (index)

	LDA PUp_StarOrSuitFrames,Y	 ; Get what kind of super suit this is
	CMP <Player_Suit
	BEQ PRG001_A834	 ; If this is already the suit that the Player is wearing, jump to PRG001_A834

	TAY		 ; Suit -> 'Y'
	INY		 ; Y++ (valid Player_QueueSuit value)
	STY Player_QueueSuit	 ; Queue changing to this suit!

PRG001_A825:
	; "Poof" into new suit
	LDA #$17	 
	STA Player_SuitLost

	; Play suit power-up sound
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

	BNE PRG001_A837	 ; Jump (technically always) to PRG001_A837

PRG001_A834:
	JSR PowerUp_PlaySound	 ; Play Power Up sound

PRG001_A837:
	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect


ObjInit_PUpMush:
	JSR Mushroom_SetFall	 ; Figure the way that the mushroom should fall

	LDA #$10	
	STA Objects_Timer2,X	 ; Object's timer 2 = 16

	; SB: This is probably used by the Big ? block which CAN spawn mushroom/flower/star for some reason
	LDA PUp_StarManFlash
	BEQ PRG001_A852	 ; If flashing is NOT active, jump to PRG001_A852

	JSR Mushroom_SetXVel	 ; Set's X velocity appropriately by Player's 

	LDY #-$38
	JSR Mushroom_SetUpVel	 ; Set vertical velocity and mid air flag
	JMP PRG001_A859		; Jump to PRG001_A859

PRG001_A852:

	; This will make mushroom drop downward if it was "knocked out" downward
	LDY #$10	
	LDA Player_BounceDir
	BEQ Mushroom_SetUpVel

PRG001_A859:
	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X

	RTS		 ; Return


Mushroom_SetUpVel:
	STY <Objects_YVel,X	 ; Set object's Y velocity
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?
	RTS		 ; Return


Mushroom_SetXVel:
	LDY #$10	 ; Y = $10

	LDA <Player_X
	AND #$10	 ; determine if Player is on even/odd tile
	BNE PRG001_A86E	 ; Jump to PRG001_A86E if odd
	LDY #-$10	 ; Otherwise, Y = -$10
PRG001_A86E:
	STY <Objects_XVel,X	 ; Set X velocity appropriately
	RTS		 ; Return


ObjNorm_PUpMush:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_A881	 ; If mushroom has NOT hit the ground, jump to PRG001_A881

	LDA <Objects_XVel,X
	BNE PRG001_A881	 ; If mushroom hasn't hit a wall, jump to PRG001_A881

	JSR PowerUp_BounceXVel	 ; Otherwise, bounce off wall!

PRG001_A881:
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

PowerUp_DoHitTest:
	; Cannot collect power up while it's "raising"
	LDA Objects_Timer2,X
	BNE PRG001_A892	 ; If the timer is still active, jump to PRG001_A892 (RTS)

	JSR Object_HitTestRespond	 ; Otherwise, perform hit testing

PRG001_A892:
	RTS		 ; Return

ObjHit_PUpMush:

	; Temp_Var = 1
	LDA #$01
	STA <Temp_Var1

PRG001_A897:
	JSR PowerUp_PlaySound	 ; Play Power Up sound

	LDA <Player_Suit
	BNE PUp_GeneralCollect	; If Player is not small, jump to PUp_GeneralCollect

	; Queue change to Super
	LDA #$02
	STA Player_QueueSuit

	LDA Player_Kuribo
	BEQ PRG001_A8AB	 ; If Player is NOT in a Kuribo's shoe, jump to PRG001_A8AB

	JMP PRG001_A825	 ; Jump to PRG001_A825

PRG001_A8AB:

	; Do "growing" animation
	LDA #$2f
	STA Player_Grow

PUp_GeneralCollect:
	; Get 1000 pts
	LDA #$09
	JSR Score_PopUp

	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X	 ; Set power-up to dead/empty

	RTS		 ; Return

PowerUp_PlaySound:
	; Play the standard "Power Up" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELPOWER
	STA Sound_QLevel1
	RTS		 ; Return

PowerUp_DoRaise:
	LDA Objects_Timer,X
	BEQ PRG001_A940	 ; If timer expired, jump to PRG001_A940 (will NOT return here if game is halted)

	CMP #$2d
	BNE PRG001_A8D5	 ; If object timer <> $2D, jump to PRG001_A8D5

	; Play powerup rising sound
	LDA Sound_QLevel1
	ORA #SND_LEVELRISE
	STA Sound_QLevel1

PRG001_A8D5:
	BGE PRG001_A93D	 ; If timer is >= $2D, jump to PRG001_A93D

	; ObjSplash_DisTimer = 8
	LDA #$08
	STA ObjSplash_DisTimer,X

	DEC Objects_Var1,X	 ; Objects_Var1--
	BPL PRG001_A8F7	 ; If Objects_Var1 >= 0, jump to PRG001_A8F7

	; When var 1 falls below 0, reset to 2
	LDA #$02
	STA Objects_Var1,X

	LDA <Player_HaltGame
	BNE PRG001_A8F7	 ; If game is halted, jump to PRG001_A8F7


	; Game not halted...

	; Move powerup up 1 pixel
	LDA <Objects_Y,X
	SUB #$01
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

PRG001_A8F7:
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite

	LDA PUp_StarManFlash
	ASL A
	ORA Level_PipeMove
	BNE PRG001_A937	 ; If starman flashing or Player in pipe, jump to PRG001_A937 (no masking sprite)

	LDY #$00	 ; Y = 0

	JSR Object_AnySprOffscreen
	BNE PRG001_A937	 ; If any sprite is off-screen, jump to PRG001_A937 (no masking sprite)

	; This puts on the masking sprite over the raising powerup

	LDA <Objects_Y,X
	AND #$f0	 	; Align object Y to tile
	ADD #$0f	 	; +15
	SUB Level_VertScroll	; Calc relative to vertical scroll

	; Set for both sprite halves Y
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y

	; Masking tile
	LDA #$77
	STA Sprite_RAM+1,Y
	STA Sprite_RAM+5,Y

	; Set sprite priority
	LDA #%00100000
	STA Sprite_RAM+2,Y
	STA Sprite_RAM+6,Y

	; Set sprite X's side by side
	LDA Objects_SpriteX,X
	STA Sprite_RAM+3,Y
	ADD #$08
	STA Sprite_RAM+7,Y

PRG001_A937:
	JSR PowerUp_DoHitTest	 ; Hit test power up when it has emerged from the box
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

PRG001_A93D:

	; Do NOT return to caller!
	PLA
	PLA

	RTS		 ; Return

PRG001_A940:
	LDA <Player_HaltGame
	BEQ PRG001_A949	 ; If game is NOT halted by Player, jump to PRG001_A949

	; Draw mushroom if game halted
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite

	; Do NOT return to caller!! (JSR could've been a JMP?)
	PLA
	PLA

PRG001_A949:
	RTS		 ; Return

	; Determines which way a mushroom should fall based on Player's position
Mushroom_SetFall:
	LDY #$00	 ; Y = 0 (mushroom falls to the left)

	LDA <Objects_X,X
	SUB <Horz_Scroll	; Make X relative to screen
	CMP <Player_SpriteX	
	BLT PRG001_A956	 	; If object X is less than Player's X, jump to PRG001_A956

	INY		 	; Otherwise, Y = 1 (mushroom falls to the right)

PRG001_A956:
	STY Player_MushFall	; Set direction of mushroom fall
	RTS		 ; Return

PowerUp_BounceXVel:
	LDY #$10	 ; Y = $10

	LDA Player_MushFall	
	BNE PRG001_A963	 ; If falling to right, jump to PRG001_A963
	LDY #-$10	 ; Otherwise, Y = -$10
PRG001_A963:
	STY <Objects_XVel,X	 ; Set X velocity appropriately


	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_InteractWithWorld
;
; Calls Object_Move and handles the object responding to hitting
; the floor/ceiling, or bump blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $A966
Object_InteractWithWorld:
	JSR Object_Move	; Move and collide with world

	LDA <Objects_DetStat,X

	TAY		 ; Object detection status -> 'Y'
	AND #$04	 
	BEQ PRG001_A973	 ; If object did NOT hit floor, jump to PRG001_A973

	JSR Object_HitGround ; Object hit ground, align

PRG001_A973:
	TYA		 ; Object detection status -> 'A'
	AND #$08
	BEQ PRG001_A97C	 ; If object did NOT hit ceiling, jump to PRG001_A97C

	LDA #$04
	STA <Objects_YVel,X ; Object hit ceiling, use rebound velocity

PRG001_A97C:
	LDA Object_TileFeet2
	CMP #TILEA_BLOCKBUMP_CLEAR
	BNE PRG001_A993	 ; If object did not hit the TILEA_BLOCKBUMP_CLEAR tile, jump to PRG001_A993

	; Hit the blockbump tile... (i.e. this kills an enemy who was unlucky enough to be on a bumped block)

	LDA #-$30
	STA <Objects_YVel,X	 ; Object Y velocity = -$30

	LDA <Objects_X,X
	ASL A	
	ASL A	
	ASL A	
	ASL A			; Shift X left 4 (sort of makes it a 4.4FP)
	EOR <Objects_XVel,X	; Flip against the "whole" part of the X velocity
	AND #$80	 	
	BNE PRG001_A9B1	 	; If object is on the left half of the tile with a right going velocity or vice versa, jump to PRG001_A9B1

PRG001_A993:

	; Object didn't hit the bump tile 

	TYA		 ; Object detection status -> 'A'
	AND #$03
	BEQ PRG001_A9B7	 ; If object did NOT hit a wall, jump to PRG001_A9B7 (RTS)

	CPX #$05
	BNE PRG001_A9B1	 ; If object slot is NOT 5, jump to PRG001_A9B1

	; Object slot 5 only...

	LSR A		 ; Shifts detection bits right 1
 
	LDA <Objects_X,X
	AND #$0f	 ; Tile-relative X

	LDY #$03	 ; Y = 3

	BCS PRG001_A9A7	 ; If object hit wall on the right, jump to PRG001_A9A7

	LDY #$03	 ; Otherwise, Y = 3 (oops?)

PRG001_A9A7:
	STY <Temp_Var1	 ; Temp_Var1 = 3 (because the above does nothing, heh)
	ADD <Temp_Var1	 ; Temp_Var1 = 6
	CMP #$08	 
	BGE PRG001_A9B1	 ; If Temp_Var1 >= 8 (never gonna happen), jump to PRG001_A9B1

	RTS		 ; Return

PRG001_A9B1:

	; Combined, this just reverses the X velocity
	JSR Object_AboutFace
	JSR Object_FlipFace

PRG001_A9B7:
	RTS		 ; Return

ObjInit_FireFlower:
	LDA #$10
	STA Objects_Timer2,X	 ; Fire flower's timer 2 = $10

	; SB: This is probably used by the Big ? block which CAN spawn mushroom/flower/star for some reason
	LDA PUp_StarManFlash
	BEQ PRG001_A9C8	 ; If flashing is NOT active, jump to PRG001_A852

	; Strangely, the Big ? flower will "move over"; probably a partially developed idea??
	; Or they just accidentally leftover stuff from mushroom
	JSR Mushroom_SetXVel
	JMP PRG001_A9CF	 ; Jump to PRG001_A9CF

PRG001_A9C8:

	; This will make flower drop downward if it was "knocked out" downward
	LDY #$10
	LDA Player_BounceDir
	BEQ PRG001_A9D5	

PRG001_A9CF:
	; Delay until rise
	LDA #$3d
	STA Objects_Timer,X
	RTS		 ; Return

PRG001_A9D5:
	; Knock flower downward
	STY <Objects_YVel,X	; Y Vel = $10
	STY <Objects_DetStat,X	 ; I think this is a mistake?  They probably meant to clear it?
	RTS		 ; Return

ObjNorm_FireFlower:
	LDA PUp_StarManFlash
	BPL PRG001_A9E4	 ; If there's no star man flash going on, jump to PRG001_A9E4

	; Otherwise, color cycle (?)
	LDA <Counter_1
	STA Objects_ColorCycle,X

PRG001_A9E4:
	JSR PowerUp_DoRaise	 ; Do power up raising out of box
	JSR Object_InteractWithWorld	 ; Move, detect, interact with blocks of world
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

	LDA <Objects_YVel,X
	BNE PRG001_A9F6	 ; If Y Velocity <> 0, jump to PRG001_A9F6

	STA <Objects_XVel,X	 ; Otherwise, halt horizontal movement too

PRG001_A9F6:
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!


ObjHit_FireFlower:
	LDA <Player_Suit
	BNE PRG001_AA05	 ; If Player is not small, jump to PRG001_AA05

	; Player is small...

	; NOTE: The "flashing" Fire Flower is never used (but can be found in the
	; "lost" Big Question Block test level, and it grants you fire power 
	; regardless of whether you're small or not!!)
	LDY PUp_StarManFlash
	BNE PRG001_AA05	 ; If fire flower came from Big (?) block, jump to PRG001_AA05

	JMP PRG001_A897	 ; Otherwise, jump to PRG001_A897

PRG001_AA05:
	CMP #$02
	BEQ PRG001_AA13	 ; If Player is already Fire, jump to PRG001_AA13

	; Uses the "invincibility wear-off" as the Power Up effect
	LDA #$1f
	STA Player_StarOff

	; And ultimately comes out fire!
	LDA #$03
	STA Player_QueueSuit

PRG001_AA13:
	JSR PowerUp_PlaySound	 ; Play Power Up sound

	; Set flower to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X
	STA Player_Statue	 ; Also kill statue mode if you're in it!

	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect


ObjNorm_Obj1A:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_AA2A	 ; If object hasn't hit ground, jump to PRG001_AA2A

	JSR Object_HitGround	 ; Align to floor

PRG001_AA2A:
	JSR Object_HitTestRespond	; Do hit testing
	JSR Object_ShakeAndDraw		; Draw object and "shake awake" 
	JMP Object_DeleteOffScreen	; Delete object if it falls off screen and don't come back

ObjHit_Obj1A:
	; Set object to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	; Halt Player's movement
	LDA #$00
	STA <Player_XVel
	STA <Player_YVel

	LDX <SlotIndexBackup	 ; Restore 'X' as Object slot index
	RTS		 ; Return

PRG001_AA41:
	.byte $1C, $0E, $1C, $14, $18, $0A, $18, $17

ObjInit_BounceLR:
	LDA Player_BounceDir
	STA Objects_Var2,X	 ; Store Player's bounce into var 2

	LDY #-$10	 ; Y = -$10 (bounce left)

	CMP #$02	 
	BEQ PRG001_AA57	 ; If bouncing to the left, jump to PRG001_AA57

	LDY #$10	 ; Otherwise, Y = $10 (bounce right)

PRG001_AA57:
	STY <Player_XVel 	; Store appropriate X velocity

	LDA Player_Bounce
	STA Objects_Var1,X	; Store Player_Bounce -> var1

	LDA #$00
	STA Objects_SprVVis,X	 ; Clear flags 2
	STA Objects_SprHVis,X	 ; Clear flags 1
	STA Player_Bounce	 ; Clear Player_Bounce
	STA Objects_FlipBits,X	 ; Force left/right flag to zero

	LDA #10
	STA Level_BlkBump_Pos-6,X ; Block bump position = 10

	JSR BounceBlock_Update	 ; Do block bounce update

	RTS		 ; Return


ObjNorm_BounceLR:
	LDY Level_BlkBump_Pos-6,X
	BNE PRG001_AAB1	 ; If block bump pos <> 0, jump to PRG001_AAB1

	; Block bump pos = 0...

	; Set to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	LDA Objects_Var1,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = var >> 4

	LDA Bounce_TileReplacements,Y
	STA <Temp_Var12

	; Temp_Var15 = Bouncer X Hi
	LDA <Objects_XHi,X
	STA <Temp_Var15

	; Temp_Var16 = Bouncer X
	LDA <Objects_X,X
	STA <Temp_Var16

	; Temp_Var13 = Bouncer Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var13

	; Temp_Var14 = Bouncer Y
	LDA <Objects_Y,X
	STA <Temp_Var14

	JSR BlockBump_Init

	LDY #10		 ; Y = 10

	LDA <Objects_XVel,X
	BPL PRG001_AAA8	 ; If bouncer is moving to the right, jump to PRG001_AAA8

	LDY #-10	 ; Y = -10

PRG001_AAA8:
	TYA		 ; A = 10 or -10

	; SpriteX += 10 or -10
	ADD <Objects_SpriteX,X
	STA <Objects_SpriteX,X

	JMP Object_HitTestRespond	 ; Do hit test and don't come back


PRG001_AAB1:

	; Block bump pos <> 0...

	LDA Level_BlkBump_Pos-6,X
	CMP #$05
	BNE PRG001_AAC5	 ; If block bump pos <> 5, jump to PRG001_AAC5

	; Block bump pos = 5...

	; LRBounce_X = Sprite X
	LDA <Objects_SpriteX,X
	STA LRBounce_X

	; LRBounce_Y = Sprite Y
	LDA <Objects_SpriteY,X
	STA LRBounce_Y

	JMP PRG001_AAFE	 ; Jump to PRG001_AAFE

PRG001_AAC5:
	CMP #$0a
	BNE PRG001_AAFE	 ; If block bump pos <> 10, jump to PRG001_AAFE

	; Block bump pos = 10...

	LDA Objects_Var1,X
	AND #$0f
	TAY		 ; Y = lower 4 bits of Var1

	LDA Bouncer_PUp,Y ; Get power-up for this block
	BEQ PRG001_AAFE	 ; If no Power Up for this block, jump to PRG001_AAFE

	STA <Temp_Var1	 ; Power Up type -> Temp_Var1

	LDY #$05	 ; Y = 5 (power-up always in slot 5)

	LDA Objects_State,Y	; ? Maybe they were going to check first?

	; Set the ID
	LDA <Temp_Var1
	STA Level_ObjectID,Y

	; Set X
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Set Y
	LDA <Objects_Y,X
	SUB #$01
	STA Objects_Y,Y

	; Set Y Hi
	LDA <Objects_YHi,X
	SBC #$00
	STA Objects_YHi,Y

	; State 1 (Initialize)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

PRG001_AAFE:
	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR BounceBlock_Update	 ; Do block bounce update

	LDY Level_BlkBump_Pos-6,X ; Y = block bump pos

	LDA Bouncer_PUpVel,Y	 ; Get velocity

	LDY Objects_Var2,X
	CPY #$02
	BEQ PRG001_AB14	 ; If var2 = 2, jump to PRG001_AB14

	JSR Negate	 ; Otherwise, negate the velocity

PRG001_AB14:
	STA <Objects_XVel,X	 ; Set appropriate X velocity

	DEC Level_BlkBump_Pos-6,X ; Block bump pos--

	RTS		 ; Return


ObjHit_BoundLR:
	LDY #$10	 ; Y = $10

	LDA <Player_X
	CMP <Objects_X,X
	BGS PRG001_AB24	 ; If Player_X > Objects_X, jump to PRG001_AB24

	LDY #-$10	 ; Y = -$10

PRG001_AB24:
	STY <Player_XVel ; Set Player's X velocity as appropriate

	LDY #15		 ; Y = 15 (Player will be aligned to right side of bouncer)

	LDA <Player_X
	PHA		 ; Save Player_X

	AND #$0f	 ; Lower 4 bits only
	CMP #$08
	BGS PRG001_AB33	 ; If Player is to the right of the bouncer, jump to PRG001_AB33

	LDY #$00	 ; Y = 0 (Player will be aligned to left side of bouncer)

PRG001_AB33:
	STY <Temp_Var1	 ; Temp_Var1 = $00 or $0F
	PLA		 ; Restore Player_X


	AND #$f0	 ; Keep only upper 4 bits of Player's position
	ORA <Temp_Var1	 ; Apply the alignment
	STA <Player_X	 ; -> Player_X

	RTS		 ; Return


ObjInit_Obj1C:
	LDA #$40	 ; A = $40

	LDY <Objects_X,X
	CPY <Player_X	
	BGS PRG001_AB48	 ; If Object's X > Player_X, jump to PRG001_AB48

	JSR Negate	 ; A = -$40

PRG001_AB48:
	STA <Objects_XVel,X	 ; Set X Velocity

	LDA #-$80
	STA <Objects_YVel,X	 ; Y Velocity = -$80

	LDA #$05
	STA Objects_Timer,X	 ; Object's timer = 5

	LDY #$05	 ; Y = 5

	LDA #OBJSTATE_INIT
	STA Objects_State,Y	 ; Set object state to 1 (re-init)

	LDA #OBJ_POWERUP_MUSHROOM
	STA Level_ObjectID,Y	 ; ... as object OBJ_POWERUP_MUSHROOM

	; Copy this object's X to slot 5
	LDA <Objects_X,X
	STA Objects_X,Y	

	; Copy this object's X Hi to slot 5
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Copy this object's Y Hi to slot 5
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	; Copy this object's Y minus 8 to slot 5
	LDA <Objects_Y,X
	SUB #$08
	STA Objects_Y,Y

	BCS PRG001_AB7A	 ; If that didn't cause a borrow, jump to PRG001_AB7A

	DEC <Objects_YHi,X	 ; Otherwise, apply it

PRG001_AB7A:
	RTS		 ; Return


ObjNorm_Obj1C:
	JSR Object_ShakeAndDraw	; Draw object and "shake awake" 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

	LDA Objects_Timer,X
	BNE PRG001_AB89	 ; If timer has not expired, jump to PRG001_AB89

	JMP Object_InteractWithWorld	 ; Interact with world and don't come back!

PRG001_AB89:
	JSR Object_ApplyYVel	 ; Apply Y velocity
	JMP Object_ApplyXVel	 ; Apply X velocity and don't come back!

	; Values used by the leaf based on bounce direction
Leaf_YVels:	.byte $04, $E0, $E0, $E0
Leaf_TimerVals:	.byte $08, $FF, $FF, $FF

ObjInit_SuperLeaf:
	LDA #$00
	STA <Objects_XVel,X	 ; Halt X velocity
	STA Objects_Var2,X	 ; Var2 = 0

	LDA #$0c	; A = $C (top spawn offset)

	LDY Player_BounceDir
	BEQ PRG001_ABA9	 ; If Player bounce down, jump to PRG001_ABA9

	LDA #-$0d	; A = -$D (bottom spawn offset)

	DEC <Objects_YHi,X	

PRG001_ABA9:
	ADD <Objects_Y,X
	STA <Objects_Y,X	 ; Set object Y

	BCC PRG001_ABB2	 	; If there's no carry, jump to PRG001_ABB2

	INC <Objects_YHi,X	 ; Otherwise, apply carry

PRG001_ABB2:
	; Set appropriate timer value (used to figure how far up the leaf needs to go)
	LDA Leaf_TimerVals,Y
	STA Objects_Timer,X

	; Set Y velocity
	LDA Leaf_YVels,Y
	STA <Objects_YVel,X

	; Timer2 = $10
	LDA #$10
	STA Objects_Timer2,X

	LDA PUp_StarManFlash
	BEQ PRG001_ABCC	; If leaf did not come from big ? block, jump to PRG001_ABCC

	; Otherwise, be green!!  (What IS this about anyway?)
	LDA #$02
	STA Objects_SprAttr,X

PRG001_ABCC:
	RTS		 ; Return

Leaf_XVelByOsc:	.byte $02, -$02
Leaf_XVelLimit:	.byte $20, -$20

PRG001_ABD1:
	.byte $0A, -$0A, $08

ObjNorm_SuperLeaf:
	LDA Objects_Timer,X
	BEQ PRG001_ABEC	 ; If timer expired, jump to PRG001_ABEC

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity
	INC <Objects_YVel,X	 ; YVel ++

	LDA <Objects_YVel,X
	CMP #$00
	BEQ PRG001_ABE7	 ; If Super Leaf Y Vel = 0, jump to PRG001_ABE7

	JMP PRG001_AC15	 ; Jump to PRG001_AC15

PRG001_ABE7:

	; Reset timer
	LDA #$00
	STA Objects_Timer,X

PRG001_ABEC:
	LDA Objects_Var2,X
	AND #$01
	TAY		 ; Y = 0 or 1 (which oscillation direction)

	; Add appropriate X velocity for oscillation direction
	LDA <Objects_XVel,X
	ADD Leaf_XVelByOsc,Y
	STA <Objects_XVel,X

	CMP Leaf_XVelLimit,Y
	BNE PRG001_AC02	 ; If leaf has not hit X Vel limit, jump to PRG001_AC02

	INC Objects_Var2,X	 ; Switch oscillation direction

PRG001_AC02:
	LDA <Objects_XVel,X
	BPL PRG001_AC07	 ; If leaf is moving to the right, jump to PRG001_AC07

	INY		 ; Otherwise, Y++ (makes Y = 2)

PRG001_AC07:
	LDA PRG001_ABD1,Y
	ADD #$06	 	; Value +6
	STA <Objects_YVel,X	; -> Y Velocity

	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

PRG001_AC15:
	LDA #SPR_HFLIP	 ; A = SPR_HFLIP (horizontal flip)

	LDY <Objects_XVel,X
	BEQ PRG001_AC22	 ; If leaf X Vel = 0, jump to PRG001_AC22 (don't change flip at midpoint)
	BPL PRG001_AC1F	 ; If leaf X Vel > 0, jump to PRG001_AC1F

	LDA #$00	 ; A = 0 (not horizontally flipped)

PRG001_AC1F:
	STA Objects_FlipBits,X	 ; Set flip

PRG001_AC22:
	JSR Object_ShakeAndDraw	; Draw object and "shake awake" 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
 	JMP PowerUp_DoHitTest	 ; Do hit test and don't come back!



ObjHit_SuperLeaf:
	LDA <Player_Suit
	BNE PRG001_AC37	 ; If Player is not small, jump to PRG001_AC37

	; NOTE: The "flashing" Super Leaf is never used (but can be found in the
	; "lost" Big Question Block test level, and it grants you Raccoon 
	; regardless of whether you're small or not!!)
	; BUG to jump to PRG001_AC37, the compare will be invalid!!
	LDA PUp_StarManFlash
	BNE PRG001_AC37	 ; If leaf did not come from big (?) block, jump to PRG001_AC37 

	JMP PRG001_A897	 ; Otherwise, jump to PRG001_A897

PRG001_AC37:
	CMP #$03
	BNE PRG001_AC40	 ; If Player is not already Raccoon, jump to PRG001_AC40

	JSR PowerUp_PlaySound	 ; Play Power Up sound
	BNE PRG001_AC52	 ; Jump (technically always) to PRG001_AC52

PRG001_AC40:

	; "Poof" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

	; "Poof" effect
	LDA #$17
	STA Player_SuitLost

	; Change to Raccoon
	LDA #$04
	STA Player_QueueSuit

PRG001_AC52:
	; Disable statue
	LDA #$00
	STA Player_Statue

	JMP PUp_GeneralCollect	 ; Jump to PUp_GeneralCollect

ObjInit_Vine:
	LDA #SPR_BEHINDBG
	STA Objects_FlipBits,X
	RTS		 ; Return

	; Stores the high byte of the VRAM address
Vine_NTHigh:	.byte $20, $28

ObjNorm_Vine:

	; Vine moves at Y Vel = -$10
	LDA #-$10
	STA <Objects_YVel,X

	JSR Object_ApplyYVel	; Apply Y Velocity

	LDA <Objects_YHi,X
	BMI PRG001_AC80	 ; If vine goes off absolute top, jump to PRG001_AC80

	JSR Object_WorldDetectN1 ; Detect against world

	LDA Object_TileFeet
	PHA		 ; Save tile detected by vine

	; Calculate tile "quadrant"
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		 ; -> 'Y'

	PLA		 ; Restore tile detected by vine

	CMP Tile_AttrTable,Y
	BLT PRG001_AC86	 ; If vine is not within the solid tiles, jump to PRG001_AC86

PRG001_AC80:

	; Set vine to dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	RTS		 ; Return

PRG001_AC86:
	LDA <Objects_Y,X
	AND #$0f
	BNE PRG001_AC92	 ; If vine has NOT covered a new tile, jump to PRG001_AC92
 
	STA Objects_FlipBits,X	; Clears flip bits
	JSR Vine_Set8x8s	; Instant graphics update while vine moves

PRG001_AC92:
	JMP Object_ShakeAndDrawMirrored	 ; Draw sprite and don't come back!

Vine_Set8x8s:
	LDA <Objects_XHi,X
	ASL A		 ; Convert X Hi into 2 byte index
	TAY		 ; -> 'Y'

	; Get address of screen Vine is on (NOTE: Non-vertical level only!)
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1
	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var2	

	LDA <Objects_YHi,X
	BEQ PRG001_ACA9	 ; If vine is not on lower area of screen, jump to PRG001_ACA9

	INC <Temp_Var2	 ; Select address of lower tiles

PRG001_ACA9:
	LDA <Objects_Y,X
	AND #$f0	 ; Get current "row" of vine object
	STA <Temp_Var3	 ; -> Temp_Var3

	LDA <Objects_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3	 ; Merge column into lower 4 bits

	TAY		 ; -> 'Y'

	; Change tile to vine tile
	LDA #TILE1_VINE
	STA [Temp_Var1],Y

	LDA Objects_SprHVis,X
	CMP #$03
	BGE PRG001_AD23	; If vine object is off-screen horizontally, jump to PRG001_AD23 (RTS)

	LDA <Objects_Y,X	 ; A = Objects_Y

	LDY <Objects_YHi,X
	BNE PRG001_ACCE	 ; If the vine is on the low part of the screen, jump to PRG001_ACCE

	CMP #240
	BLT PRG001_ACD1	 ; If Y < 240, jump to PRG001_ACD1

	INY		 ; Y = 1 (uses the next nametable address in Vine_NTHigh)

PRG001_ACCE:
	ADD #16	 	; Next row

PRG001_ACD1:
	ASL A	
	ADC #$00
	ASL A	
	ADC #$00

	PHA		 ; Save VRAM column offset

	AND #$03	; Keep address from going out of range
	ORA Vine_NTHigh,Y	 ; Set the high bits

	LDY Graphics_BufCnt	 ; Y = current graphics buffer count

	; Set two rounds of high byte 
	STA Graphics_Buffer,Y	 
	STA Graphics_Buffer+5,Y	

	PLA		 ; Restore VRAM column offset
 
	AND #$c0
	STA <Temp_Var1

	; Store left column update
	LDA <Objects_X,X
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var1
	STA Graphics_Buffer+1,Y

	; Store right column update
	ADD #$01
	STA Graphics_Buffer+6,Y

	LDA #$82
	STA Graphics_Buffer+2,Y
	STA Graphics_Buffer+7,Y

	; Vine left 8x8 tiles
	LDA #$c4
	STA Graphics_Buffer+3,Y
	LDA #$c4
	STA Graphics_Buffer+4,Y

	; Vine right 8x8 tiles
	LDA #$c6
	STA Graphics_Buffer+8,Y
	LDA #$c6
	STA Graphics_Buffer+9,Y

	LDA #$00
	STA Graphics_Buffer+10,Y

	; Update run count
	TYA
	ADD #$0a	 ; Count += 10
	STA Graphics_BufCnt

PRG001_AD23:
	RTS		 ; Return

	; Basically this bumps the object up by 1 pixel...
ObjInit_PDoor:
	LDA <Objects_Y,X
	BNE PRG001_AD2A	 	; If object's Y <> 0, jump to PRG001_AD2A
	DEC <Objects_YHi,X	 ; Otherwise, decrement Y Hi (carry for next op)
PRG001_AD2A:
	DEC <Objects_Y,X	 ; Decrement object's Y
 	RTS		 ; Return

ObjInit_WarpHide:
	LDA Map_Got13Warp
	BEQ PRG001_AD37	 ; If Player didn't already get the 1-3 warp whistle, jump to PRG001_AD37

	; Otherwise, kill it!
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

PRG001_AD37:
	RTS		 ; Return


ObjNorm_WarpHide:
	LDA <Player_HaltGame
	BNE PRG001_AD7E	 ; If gameplay is halted, jump to PRG001_AD7E (RTS)

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

	LDA Player_Behind
	BEQ PRG001_AD7E	 ; If Player is behind the scenes, jump to PRG001_AD7E (RTS)

	; Trigger when close enough X
	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15	
	ADD #$04	
	CMP #$08	
	BGE PRG001_AD7E	

	; Trigger when close enough Y
	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15	
	ADD #$08	
	CMP #$10	
	BCS PRG001_AD7E	

	; To be awarded with warp whistle
	LDA #$01
	STA THouse_Treasure

	; Stop Player
	LSR A	
	STA <Player_XVel
	STA <Player_YVel

	; Special Toad House object layout
	LDA #LOW(TOAD_SpecO)
	STA <Level_ObjPtr_AddrL
	LDA #HIGH(TOAD_SpecO)
	STA <Level_ObjPtr_AddrH

	; Special Toad House level layout
	LDA #LOW(TOAD_SpecL)
	STA <Level_LayPtr_AddrL
	LDA #HIGH(TOAD_SpecL)
	STA <Level_LayPtr_AddrH

	; Jump to special Toad House
	LDA #$05
	STA Level_JctCtl

	STA Map_Got13Warp	 ; Flag Player already got the 1-3 warp whistle

PRG001_AD7E:
	RTS		 ; Return


ObjNorm_PDoor:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen

	LDA Level_PSwitchCnt
	BEQ PRG001_AD7E	 ; If P-Switch is not active, jump to PRG001_AD7E (RTS)

	LDA <Player_HaltGame
	BNE PRG001_ADBB	 ; If gameplay is halted, jump to PRG001_ADBB

	LDA <Player_InAir
	BNE PRG001_ADBB	 ; If Player is mid air, jump to PRG001_ADBB

	LDA <Pad_Holding
	AND #PAD_UP
	BEQ PRG001_ADBB	 ; If Player is NOT pressing up, jump to PRG001_ADBB

	; If Player is NOT within range of the door X-wise, jump to PRG001_ADBB
	JSR Object_CalcCoarseXDiff	 
	LDA <Temp_Var15	
	ADD #$02	
	CMP #$04	
	BGE PRG001_ADBB

	; If Player is NOT within range of the door Y-wise, jump to PRG001_ADBB
	JSR Object_CalcCoarseYDiff
	INC <Temp_Var15		
	BNE PRG001_ADBB	 

	LDY #$01	 ; Y = 1

	LDA Level_PipeNotExit
	BEQ PRG001_ADB1	 ; If this level has pipes exit to map, jump to PRG001_ADB1

	LDY #$03	 ; Y = 3

PRG001_ADB1:
	STY Level_JctCtl ; Set appropriate junction type

	; Set map return status?
	LDA #$00
	STA Map_ReturnStatus

	STA <Player_XVel ; Halt Player horizontally

PRG001_ADBB:
	JMP Object_Draw16x32Sprite	 ; Draw the door and don't come back


ObjNorm_Card:
	JSR Object_MoveAndReboundOffWall ; Move and rebound off walls (i.e. march, but this doesn't.)

	LDA Level_NoStopCnt
	ORA #$04
	STA Objects_ColorCycle,X ; Cycle colors!!

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off screen
	JSR Object_ShakeAndDrawMirrored	 ; Draw mirrored sprite
	JMP Object_HitTestRespond	 ; Do hit test and respond


ObjHit_Card:
	; Card becomes dead/empty
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	; Calculate which card you get
	LDA Level_ObjectID,X
	SUB #(OBJ_POWERUP_MUSHCARD-1)

	; Update the Player's card collection
	JSR Player_GetCardAndUpdate

	LDX <SlotIndexBackup	; Restore 'X' as object slot index

PRG001_ADE2:
	RTS		 ; Return


	; This is a fairly general "march" function, but it is only 
	; applied to one object here, the unused collectable card...
Object_MoveAndReboundOffWall:
	JSR Object_Move	 ; Do general movement code

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG001_ADEE	 ; If object hit ceiling, jump to PRG001_ADEE

	STA <Objects_YVel,X	 ; Otherwise, update Y Velocity

PRG001_ADEE:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ Object_HitGroundAlign ; If object has not hit a wall, jump to Object_HitGroundAlign

	LDA <Objects_XVel,X
	BEQ Object_HitGroundAlign ; If object not moving, jump to Object_HitGroundAlign

	JSR Object_AboutFace	 ; Otherwise, turn around

	; Aligns object that impacts the ground onto the floor
Object_HitGroundAlign:
	LDA <Objects_DetStat,X 
	AND #$04
	BEQ PRG001_ADE2	 ; If object did not hit ground, jump to PRG001_ADE2 (RTS)
 
	JMP Object_HitGround	 ; Otherwise, jump to Object_HitGround

Koopaling_Palettes:
	.byte $0F, $26, $30, $19	; World 1
	.byte $0F, $17, $30, $10	; World 2
	.byte $0F, $26, $30, $16	; World 3
	.byte $0F, $27, $30, $11	; World 4
	.byte $0F, $17, $30, $15	; World 5
	.byte $0F, $27, $30, $1A	; World 6
	.byte $0F, $18, $30, $1C	; World 7

ObjInit_Koopaling:
	LDA World_Num
	ASL A		
	ASL A		 ; A = World_Num * 4
	PHA		 ; Save it
	TAY		 ; -> Y

	; X = current buffer counter
	LDX Graphics_BufCnt

	; Going to change the sprite palette
	LDA #$3f	 
	STA Graphics_Buffer,X
	LDA #$18	 
	STA Graphics_Buffer+1,X	

	; 4 bytes (full sprite palette)
	LDA #$04	 
	STA Graphics_Buffer+2,X	 

	; Copy Koopaling's palette into buffer
	STA <Temp_Var1		 ; Temp_Var1 = 4 (loop counter)
PRG001_AE3B:
	LDA Koopaling_Palettes,Y ; Get palette byte
	STA Graphics_Buffer+3,X	 ; Store into buffer
	INX		 ; X++
	INY		 ; Y++
	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG001_AE3B	 ; While Temp_Var1 > 0, loop!

	; Terminator
	LDA #$00	 
	STA Graphics_Buffer+3,X	

	INX
	INX
	INX	
	STX Graphics_BufCnt	; Graphics_BufCnt += 3

	PLA		 ; Restore World_Num * 4
	TAY		 ; -> Y

	LDX #$18	 ; X = $18

	; Copy Koopaling palette into Pal_Data and Palette_Buffer
PRG001_AE56:
	LDA Koopaling_Palettes,Y
	STA Pal_Data,X	 
	STA Palette_Buffer,X
	INY		 ; Y++
	INX		 ; X++
	CPX #$1c	 
	BLT PRG001_AE56	 ; If X < $1C (end of Pal_Data offset), loop!

	LDX <SlotIndexBackup	 ; X = current object slot index


	; 10 hits to take out a Koopaling
	LDA #$0a	
	STA Objects_HitCount,X

	; Set object variable 3 to $40
	LDA #$40	
	STA Objects_Var3,X

	RTS		 ; Return


	; Selects the pattern table index 4 for the respective world Koopaling
KoopalingPatSet4:
	.byte $48	; World 1
	.byte $49	; World 2
	.byte $4A	; World 3
	.byte $48	; World 4
	.byte $49	; World 5
	.byte $48	; World 6
	.byte $4A	; World 7

	; Selects the pattern table index 5 for the respective world Koopaling
KoopalingPatSet5:
	.byte $37	; World 1
	.byte $37	; World 2
	.byte $4A	; World 3
	.byte $37	; World 4
	.byte $37	; World 5
	.byte $48	; World 6
	.byte $37	; World 7


	; Speed Koopaling moves when in the air
Koopaling_XVelMidAir:	.byte $10, $F0

	; The world number is added to this value to produce an index into
	; the Koopaling_JumpChanceMask and Koopaling_JumpYVels tables
Koopaling_JumpYVelsBase:
	.byte $00, $07, $0E

PRG001_AE85:
	.byte $63, $63, $9F, $63, $63, $00, $3F, $63, $3F, $9F, $23, $63, $00
	.byte $33, $33, $33, $9F, $43, $63, $00, $23

	; Provides a bitmask placed against Counter_1 which if zero means
	; the Koopaling will jump; thus, less bits means greater chance
Koopaling_JumpChanceMask:
	.byte $BF, $BF, $41, $83, $FF, $00, $7F, $BF, $BF, $41, $83, $FF, $00, $7F, $DF, $DF
	.byte $41, $83, $7F, $00, $9F

	; Jump velocities
Koopaling_JumpYVels:
	.byte -$30, -$30, -$10, -$30, -$50,  $00, -$50, -$40, -$38, -$20, -$40, -$60,  $00, -$60, -$50, -$50
	.byte -$50, -$50, -$70,  $00, -$70


ObjNorm_Koopaling:
	LDY World_Num	 ; Y = current world number

	; Use the right graphics for the Koopaling	
	LDA KoopalingPatSet4,Y
	STA PatTable_BankSel+4

	LDA KoopalingPatSet5,Y
	STA PatTable_BankSel+5

	; Behavior based on Level_GetWandState...
	LDA Level_GetWandState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Koopaling_Normal		; Wand State 0: Normal operation
	.word Koopaling_FinalHit	; Wand State 1: when Koopa Kid gets last hit and flies off
	.word Koopaling_WandFall	; Wand State 2: Koopaling gone, wand drops down (do-nothing state)
	.word Koopaling_WandGrab	; Wand State 3: when wand grabbed (do flashy color effect)
	.word Koopaling_TimeBonus	; Wand State 4: run down time for bonus
	.word Koopaling_AirshipVanish	; Wand State 5: as airship vanishes
	.word Koopaling_DoPlayerFall	; Wand State 6: Player falling...
	.word Koopaling_FallOff		; Wand State 7: Player falls off-screen into king's room

Koopaling_FinalHit:
	JSR Koopaling_DrawAndAnimate

	LDA <Player_HaltGame		
	BNE PRG001_AF2A	 ; If gameplay is halted (Player dead, etc.), jump to PRG001_AF2A (RTS)

	LDA Objects_Timer2,X
	CMP #$08	 
	BLT PRG001_AF02	 ; If timer2 < 8, jump to PRG001_AF02
	BNE PRG001_AF2A	 ; If timer2 <> 8, jump to PRG001_AF2A (RTS)

	; Koopaling exit sound...
	LDA Sound_QLevel2
	ORA #SND_LEVELAIRSHIP	
	STA Sound_QLevel2

	RTS		 ; Return

PRG001_AF02:
	ORA #$04
	STA Objects_Timer2,X	 ; timer 2 |= 4

	; Unused comparison and jump!  (Goes nowhere)
	CMP #$08
	BNE PRG001_AF0B
 PRG001_AF0B:

	LDA Objects_SprVVis,X
	CMP #$03
	BNE PRG001_AF20

	LDA <Objects_X,X
	SBC #$78	 ; Koopaling flies off to the left!
	CMP #$10	
	BGE PRG001_AF20	 ; If Koopaling's X >= $10, jump to PRG001_AF20

	; After Koopaling has left...
	INC Level_GetWandState	 ; Level_GetWandState = 2
	JMP PRG001_B10B	 	; Jump to PRG001_B10B

PRG001_AF20:
	JSR Object_ApplyXVel	 ; Apply X velocity

	LDA #-$60
	STA <Objects_YVel,X	 ; Y Velocity = -$60 (fly up and out!)
	JSR Object_ApplyYVel	 ; Apply Y velocity

PRG001_AF2A:
	RTS		 ; Return

Koopaling_Normal:
	LDA World_Num
	CMP #$05
	BNE PRG001_AF35	 ; If World_Num <> 5 (World 6, Lemmy), jump to PRG001_AF35
	JMP PRG001_B671	 ; Jump to PRG001_B671

PRG001_AF35:

	; Variable 1 is used as a counter to indicate that the heavy Koopaling has jumped onto the floor

	LDA Objects_Var1,X
	BEQ PRG001_AF55	 	; If object variable 1 = 0 (no heavy jump shake occurring), jump to PRG001_AF55

	DEC Objects_Var1,X 	; Decrement variable 1

	LDA <Player_InAir
	BNE PRG001_AF55	 	; If Player is in the air, jump to PRG001_AF55

	INC <Player_InAir	; Set Player as in the air

	LDA #$20	 
	STA Player_VibeDisable	; "Vibrationally disable" Player!

	LDA #-$10
	STA <Player_YVel	; Player Y velocity = -$10 (bounce the Player a bit)

	; Player_Y/Hi -= 1
	DEC <Player_Y
	LDY <Player_Y
	INY		
	BNE PRG001_AF55	
	DEC <Player_YHi

PRG001_AF55:
	JSR Koopaling_DrawAndAnimate	; Draw and animate Koopaling!

	LDA <Player_HaltGame
	BNE PRG001_AF8F	 		; If gameplay is halted, jump to PRG001_AF8F (RTS)

	JSR Koopaling_DetectWorld	; Detect world and do floor vibration, if appropriate
	JSR Koopaling_DieByFire		; If hit by enough fireballs, battle ends
	JSR Object_HitTestRespond	; Respond to Player collision
	JSR Object_CalcCoarseXDiff	; Calculate "coarse" X difference value

	LDA Objects_Timer2,X	
	BEQ PRG001_AF90	 ; If timer 2 is zero, jump to PRG001_AF90

	CMP #$40
	BGE PRG001_AF8F	 ; If timer 2 >= $40, jump to PRG001_AF8F (RTS)

	LSR A	
	BNE PRG001_AF7D	 	; Every other tick, jump to PRG001_AF7D (Koopaling jump!)

	STA Objects_Frame,X	 ; Set object frame 0 - 31??

	LDA <Temp_Var16		 
	STA Objects_FlipBits,X	 ; Stores $00 or $40, depending on result of Object_CalcCoarseXDiff

	RTS		 ; Return


PRG001_AF7D:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_AF8F	 ; If Koopaling is not on the ground, jump to PRG001_AF8F (RTS)

	; Koopaling on ground; jump!

	JSR Level_ObjCalcXDiffs	  

	; Set appropriate X velocity based on direction
	LDA Koopaling_XVelMidAir,Y
	STA <Objects_XVel,X

	; Set Y velocity for jump
	LDA #-$48
	STA <Objects_YVel,X

PRG001_AF8F:
	RTS		 ; Return


PRG001_AF90:

	; Timer 2 expired...

	LDA Objects_Timer,X
	BEQ PRG001_AFAB	 ; If timer is zero, jump to PRG001_AFAB

	; This creates the wand firing repetition
	AND #$07
	BNE PRG001_AF8F	 ; Only proceed every 8 ticks

	LDA #$03
	STA Objects_Frame,X	; Koopaling frame 3 (wand fire!)

	LDA World_Num
	CMP #$02
	BNE PRG001_AFA8	 ; If World_Num <> 2 (World 3, Wendy), jump to PRG001_AFA8

	JMP PRG001_B7EC	 ; Jump to PRG001_B7EC

PRG001_AFA8:
	JMP PRG001_B02E	 ; Otherwise, jump to PRG001_B02E

PRG001_AFAB:

	; Timer expired

	LDA <Objects_DetStat,X
	AND #$04	
	BEQ PRG001_B01F	 ; If Koopaling is not on the ground, jump to PRG001_B01F

	LDA <Counter_1
	AND #$07
	BNE PRG001_AFC5	 ; Every 7:8 ticks, jump to PRG001_AFC5

	; Once every 8 ticks, turn in the direction of the Player

	LDA <Temp_Var16		; Holds last checked direction towards Player
	STA Objects_FlipBits,X	 ; Objects_FlipBits = Temp_Var16 (face towards Player)

	; Set appropriate X velocity by facing direction
	LDY #$10
	ASL A		; If $40, now $80, thus BMI
	BMI PRG001_AFC3
	LDY #-$10

PRG001_AFC3:
	STY <Objects_XVel,X	 ; Set proper X velocity towards Player!

PRG001_AFC5:
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	; Set current walking frame 0/1

	; this basically selects a jump velocity from the Koopaling_JumpYVels
	; table with certain values only being reached by later world Koopalings
	; and making the overall height a bit variable
	LDY <Objects_Var4,X	 ; Get Koopaling's current hit count
	LDA Koopaling_JumpYVelsBase,Y
	ADD World_Num
	TAY		; -> 'Y'

	; This determines the chance that they will actually jump
	LDA <Counter_1	
	AND Koopaling_JumpChanceMask,Y
	BNE PRG001_AFE6	; If not jumping, jump to PRG001_AFE6

	; Koopaling jumps!
	LDA Koopaling_JumpYVels,Y
	STA <Objects_YVel,X

	RTS		 ; Return


PRG001_AFE6:

	; If Koopaling is not jumping...

	LDA World_Num
	CMP #$02	
	BNE PRG001_AFF9	 ; If World_Num <> 2 (World 3, Wendy), jump to PRG001_AFF9

	; Wendy only...

	LDA <Objects_Var4,X
	CMP Objects_Var6,X	 
	BLT PRG001_B01F	 ; If Objects_Var4 < Objects_Var6, jump to PRG001_B01F (RTS)

	INC Objects_Var6,X	 ; Objects_Var6++ 
	BNE PRG001_B000	 ; If Objects_Var6 <> 0, jump to PRG001_B000

PRG001_AFF9:
	LDA <Counter_1
	AND PRG001_AE85,Y
	BNE PRG001_B01F

PRG001_B000:
	; Face the Player
	LDA <Temp_Var16	
	STA Objects_FlipBits,X

	; Wand out frame
	LDA #$02
	STA Objects_Frame,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	LDA #$10	 ; A = $10

	LDY World_Num
	CPY #$02	
	BEQ PRG001_B01C	 ; If World_Num = 2 (World 3, Wendy), jump to PRG001_B01C

	; Everybody but Wendy...

	JSR Object_CalcHomingVels

	LDA #$20	 ; A = $20
PRG001_B01C:
	STA Objects_Timer,X	; This timer kicks off the wand firing!

PRG001_B01F:
	RTS		 ; Return


Koopaling_DieByFire:
	LDA Objects_HitCount,X
	BNE PRG001_B01F	 ; If hits remain, jump to PRG001_B01F

	; Set hit count to 2 (will force the third and final hit after the jump!)
	LDA #$02	
	STA <Objects_Var4,X
	JMP PRG001_B17B	 ; Jump to PRG001_B17B (force third and final hit!)

PRG001_B02C:
	.byte -$0E, $1E

PRG001_B02E:

	; All Koopalings except Wendy and Lemmy...

	LDA Objects_FlipBits,X
	ASL A
	ROL A
	ROL A		 ; Effectively, shift bit 6 to bit 0 (i.e. if $40, now 1)
	AND #$01	 ; Capping value to be sure
	TAY		 ; Y = 0 or 1

	LDA PRG001_B02C,Y
	STA <Temp_Var1	 ; Temp_Var1 = -$0E or $1E

	; Find an empty special object slot -> 'Y' OR if none available, do not return here!
	JSR SpecialObj_FindEmptyAbort

	; Special object: Koopaling wand blast!
	LDA #SOBJ_WANDBLAST
	STA SpecialObj_ID,Y

	; Set wand blast X
	LDA <Objects_X,X
	ADD <Temp_Var1	
	STA SpecialObj_XLo,Y

	; Set wand blast Y
	LDA <Objects_Y,X
	ADD #$0a
	STA SpecialObj_YLo,Y

	; Set wand blast Y Hi
	LDA <Objects_YHi,X
	ADC #$00	
	STA SpecialObj_YHi,Y

	; Set wand Y velocity
	LDA Objects_TargetingYVal,X
	STA SpecialObj_YVel,Y

	; Set wand X velocity
	LDA Objects_TargetingXVal,X
	STA SpecialObj_XVel,Y

	; Timer = $FF
	LDA #$ff	 
	STA SpecialObj_Timer,Y


	; Play wand sound if it isn't playing already
	LDA SndCur_Level1
	AND #$80
	BNE PRG001_B07B

	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

PRG001_B07B:
	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_CalcHomingVels
;
; How an 8-bit CPU can calculate aiming projectiles
; towards the Player!  Returns values in respective
; Objects_TargetingXVal and Objects_TargetingYVal
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_CalcHomingVels:
	
	LDA #$14
	STA <Temp_Var2	 ; Temp_Var2 = $14
	
	; Backup 'X' and 'Y'
	TXA
	PHA
	TYA
	PHA

	; Backup Player_Y
	LDA <Player_Y
	PHA

	CMP #$50
	BGE PRG001_B08F	 ; If Player_Y >= $50, jump to PRG001_B08F

	; Otherwise, force Player_Y = $50
	LDA #$50
	STA <Player_Y

PRG001_B08F:
	JSR Level_ObjCalcYDiffs
	STY <Temp_Var3		 ; Store above/below flag -> Temp_Var3

	; Get absolute value of Temp_Var16 (Y difference between Player and Koopaling)
	LDA <Temp_Var16	
	BPL PRG001_B09B	 
	JSR Negate	 
PRG001_B09B:
	STA <Temp_Var13		 ; -> Temp_Var13

	JSR Level_ObjCalcXDiffs
	STY <Temp_Var4		 ; Store left/right of flag -> Temp_Var4

	; Get absolute value of Temp_Var16 (X difference between Player and Koopaling)
	LDA <Temp_Var16	
	BPL PRG001_B0A9	
	JSR Negate
PRG001_B0A9:
	STA <Temp_Var14		 ; -> Temp_Var14

	LDY #$00	 ; Y = 0

	LDA <Temp_Var14
	CMP <Temp_Var13
	BGE PRG001_B0BC	 ; If Temp_Var14 (Player vs Koopaling X diff) >= Temp_Var13 (Player vs Koopaling Y diff), jump to PRG001_B0BC

	INY		 ; Y = 1

	; Swap Temp_Var13 and Temp_Var14
	PHA
	LDA <Temp_Var13
	STA <Temp_Var14
	PLA
	STA <Temp_Var13

PRG001_B0BC:

	; At this point, Temp_Var13 >= Temp_Var14, guaranteed

	; What follows is some kind of algorithm that can "aim" a projectile
	; towards a Player (e.g., Koopaling wand shots) but I'm not going to
	; research the "why" at this time... it "just works"

	LDA #$00
	STA <Temp_Var12		; Temp_Var12 = 0
	STA <Temp_Var1		; Temp_Var1 = 0
	LDX <Temp_Var2		; X = Temp_Var2 (starts at $14)

PRG001_B0C4:
	LDA <Temp_Var12
	ADD <Temp_Var13
	CMP <Temp_Var14
	BLT PRG001_B0D1		; If (Temp_Var12 + Temp_Var13) < Temp_Var14, jump to PRG001_B0D1

	; Otherwise...
	SBC <Temp_Var14		; Subtract Temp_Var14 from Temp_Var12
	INC <Temp_Var1		; Temp_Var1++

PRG001_B0D1:
	STA <Temp_Var12 	; Update Temp_Var12
	DEX		 	; X--
	BNE PRG001_B0C4	 	; While X > 0, loop!

	TYA
	BEQ PRG001_B0E3	 ; If Y = 0, jump to PRG001_B0E3

	; Swap Temp_Var1 and Temp_Var2
	LDA <Temp_Var1
	PHA		
	LDA <Temp_Var2	
	STA <Temp_Var1	
	PLA		
	STA <Temp_Var2	

PRG001_B0E3:
	LDA <Temp_Var1	
	LDY <Temp_Var3	
	BEQ PRG001_B0EE	

	JSR Negate	
	STA <Temp_Var1	

PRG001_B0EE:
	LDA <Temp_Var2	
	LDY <Temp_Var4	
	BEQ PRG001_B0F9	

	JSR Negate	
	STA <Temp_Var2	

PRG001_B0F9:

	; Restore Player_Y
	PLA
	STA <Player_Y

	; Restore 'Y' and 'X'
	PLA
	TAY
	PLA
	TAX


	; Temp_Var1 contains the "homing in" Y velocity
	LDA <Temp_Var1
	STA Objects_TargetingYVal,X

	; Temp_Var2 contains the "homing in" X velocity
	LDA <Temp_Var2
	STA Objects_TargetingXVal,X

	RTS		 ; Return

PRG001_B10B:
	; Immediately after defeated Koopaling has exited stage left...

	LDY #$05	 ; Y = 5
PRG001_B10D:
	LDA SpecialObj_ID,Y
	BEQ PRG001_B116  ; If this object slot is dead/empty, jump to PRG001_B116
	DEY		 ; Y--
	BPL PRG001_B10D	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG001_B116:

	; Recovered Koopaling wand
	LDA #SOBJ_RECOVEREDWAND
	STA SpecialObj_ID,Y

	; Start X at center of screen
	LDA #$80
	STA SpecialObj_XLo,Y

	; Start Y at Koopaling's Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Halt velocities in this slo
	LDA #$00
	STA SpecialObj_YVel,Y
	STA SpecialObj_XVel,Y

	; Var 1 = $50
	LDA #$50	
	STA SpecialObj_Var1,Y

PRG001_B137:
	RTS		 ; Return

ObjHit_Koopaling:
	LDA Objects_Frame,X
	CMP #$04
	BLT PRG001_B158	 ; If Koopaling's current animation frame < 4 (not in a spinning shell mode), jump to PRG001_B158

	; Koopaling is spinning in his shell...

	JSR Object_CalcCoarseYDiff	 ; Calculate Y difference between Koopaling and Player

	LDY <Temp_Var15
	CPY #$04	
	BGS PRG001_B137	 ; If the Y difference value > +4, jump to PRG001_B137 (RTS)

	DEY		 ; Y--
	BMI PRG001_B158	 ; If the difference was 0 (because now it just turned negative), jump to PRG001_B158

	; This gives the Player a semi-random rebound X Velocity after hitting the Koopaling
	; that is in his spinning shell mode
	LDA <Counter_1
	LSR A		 ; Bit 0 of Counter_1 -> carry
	LDA #$30	 ; A = $30
	BCS PRG001_B154	 ; If carry set from Counter_1 (i.e. every other tick), jump to PRG001_B154

	LDA #-$30	 ; A = -$30 instead

PRG001_B154:
	STA <Player_XVel ; Set Player's rebound velocity
	BNE PRG001_B160	 ; Jump (technically always) to PRG001_B160

PRG001_B158:

	; From Object_HitTestRespond:
	; Temp_Var12 holds specific info:
	;	Bit 0 - Set if Player's bbox bottom is HIGHER than object's bbox bottom
	;	Bit 1 - Set if Player's bbox left edge is to the LEFT of object's bbox left edge

	LDA <Temp_Var12	
	LSR A		
	BCS PRG001_B160	 ; If Player is above the Koopaling, jump to PRG001_B160

	JMP Player_GetHurt ; Hurt Player! (and don't come back

PRG001_B160:

	; Bounce Player off Koopaling!
	LDA #-$30
	STA <Player_YVel

	LDA Objects_Timer2,X
	BNE PRG001_B1C9	 ; If timer 2 is not expired, jump to PRG001_B1C9 (RTS)

	; Squish sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM	
	STA Sound_QPlayer

	LDA World_Num
	CMP #$05
	BNE PRG001_B17B	 ; If World_Num = 5 (World 6, Lemmy), jump to PRG001_B17B

	; Lemmy pops out another ball if hit
	JSR Lemmy_SpawnBall

PRG001_B17B:

	; Stop Koopaling's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	LDY <Objects_YVel,X
	BPL PRG001_B185	 ; If Koopaling's Y velocity >= 0 (not moving upward), jump to PRG001_B185

	; If Koopaling was moving upward when stomped, stop him!
	STA <Objects_YVel,X

PRG001_B185:

	; Hit Koopaling!
	INC <Objects_Var4,X	; Increment the hit count
	LDA <Objects_Var4,X
	CMP #$03
	BGE PRG001_B193	 ; If Objects_Var4 >= 3 (Koopaling's last hit), jump to PRG001_B193

	LDA #$80
	STA Objects_Timer2,X	 ; Timer 2 set to $80

	RTS		 ; Return

PRG001_B193:

	; Koopaling defeated!

	; Set all objects besides the Koopaling to "Dying" state!
	LDY #$04	 ; Y = 4
PRG001_B195:
	CPY <SlotIndexBackup
	BEQ PRG001_B1A8	 ; If this is the Koopaling's object index, jump to PRG001_B1A8 (do nothing)

	LDA Objects_State,Y
	BEQ PRG001_B1A8	 ; If this object slot is already dead/empty, jmp to PRG001_B1A8

	; There's an object here; set state to Poof Death
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,Y

	; Set object's timer to $1F
	LDA #$1f	 
	STA Objects_Timer,Y

PRG001_B1A8:
	DEY		 ; Y--
	BPL PRG001_B195	 ; While Y >= 0, loop!

	INC Level_GetWandState	 ; Level_GetWandState = 1

	; Lock the clock
	LDA #$81
	STA Level_TimerEn

	; Shoot him all you want >:(
	LDA #$7f
	STA Objects_HitCount,X	 

	; Set a velocity that moves Koopaling somewhere towards center
	; Not really precise though!
	LDA #$80
	SUB <Objects_X,X
	STA <Objects_XVel,X
	ASL A
	ROR <Objects_XVel,X

	LDA #$a0
	STA Objects_Timer2,X	 ; Set timer 2 to $A0

	; Do not return to caller!!
	PLA
	PLA

PRG001_B1C9:
	RTS		 ; Return


	; End and start frames of animation loop for Koopaling
Koopaling_FrameLoopEnd:
	.byte $0A	; Wand State 0: Normal operation
	.byte $12	; Wand State 1: when Koopa Kid gets last hit

Koopaling_FrameLoopStart:
	.byte $04	; Wand State 0: Normal operation
	.byte $0A	; Wand State 1: when Koopa Kid gets last hit

	; Objects_FlipBits setting by Object_Frame
Koopaling_LRByFrame:
	.byte $00, SPR_HFLIP, $00, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, $00, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_HFLIP
	.byte $00, $00


Koopaling_PatLookup:

	; Koopaling patterns; for some reason the origin is behind the array by 17 bytes?
KPatTable = Koopaling_PatLookup - 17

	; There are 18 bytes per Koopaling for their 6 sprites arranged 3x2
KPATS .func ((\1 - KPatTable) / 6)

	.byte KPATS(KoopalingPats_Larry)	; World 1
	.byte KPATS(KoopalingPats_Morton)	; World 2
	.byte KPATS(KoopalingPats_Wendy)	; World 3
	.byte KPATS(KoopalingPats_Iggy)		; World 4
	.byte KPATS(KoopalingPats_Roy)		; World 5
	.byte KPATS(KoopalingPats_Lemmy)	; World 6
	.byte KPATS(KoopalingPats_Ludwig)	; World 7

	; Each Koopaling uses six 8x16 sprite chunks arranged 3x2

	; Koopaling neutral frames
	.byte $B9, $71, $B9, $A1, $A3, $A5	; 4: Spinning shell 1
	.byte $BB, $71, $BB, $AD, $AF, $B1	; 5: Spinning shell 2
	.byte $BD, $71, $BD, $A1, $A3, $A5	; 6: Spinning shell 3
	.byte $B9, $71, $B9, $A7, $A9, $AB	; 7: Spinning shell 4
	.byte $BB, $71, $BB, $B3, $B5, $B7	; 8: Spinning shell 5
	.byte $BD, $71, $BD, $A7, $A9, $AB	; 9: Spinning shell 6
	.byte $8D, $8F, $71, $91, $93, $71	; 10: Exiting shell 1
	.byte $85, $87, $71, $89, $8B, $71	; 11: Exiting shell 2
	.byte $81, $81, $71, $83, $83, $71	; 12: Exiting shell 3
	.byte $71, $85, $87, $71, $89, $8B	; 13: Exiting shell 4
	.byte $71, $8D, $8F, $71, $91, $93	; 14: Exiting shell 5
	.byte $71, $95, $97, $71, $99, $9B	; 15: Exiting shell 6
	.byte $9D, $9D, $71, $9F, $9F, $71	; 16: Exiting shell 7
	.byte $95, $97, $71, $99, $9B, $71	; 17: Exiting shell 8

	; Larry
KoopalingPats_Larry:
	.byte $81, $83, $85, $87, $89, $8B	; Walk 1
	.byte $81, $83, $85, $87, $8D, $8F	; Walk 2
	.byte $81, $91, $85, $93, $95, $8B	; Wand swing

	; Morton
KoopalingPats_Morton:
	.byte $81, $83, $85, $87, $89, $8B	; Walk 1
	.byte $81, $83, $85, $8D, $8F, $91	; Walk 2
	.byte $81, $93, $85, $95, $A7, $8B	; Wand swing

	; Wendy
KoopalingPats_Wendy:
	.byte $9F, $A1, $A3, $B5, $A5, $A7	; Walk 1
	.byte $9F, $A1, $A3, $B5, $A9, $AB	; Walk 2
	.byte $9F, $AD, $A3, $AF, $B1, $A7	; Wand swing

	; Iggy
KoopalingPats_Iggy:
	.byte $9D, $9F, $A1, $87, $89, $8B	; Walk 1
	.byte $9D, $9F, $A1, $87, $8D, $8F	; Walk 2
	.byte $9D, $A3, $A1, $93, $95, $8B	; Wand swing

	; Roy
KoopalingPats_Roy:
	.byte $9F, $A1, $85, $87, $89, $8B	; Walk 1
	.byte $9F, $A1, $85, $8D, $8F, $91	; Walk 2
	.byte $9F, $A3, $85, $95, $A7, $8B	; Wand swing

	; Lemmy
KoopalingPats_Lemmy:
	.byte $A7, $AD, $71, $AF, $B1, $AB	; Walk 1
	.byte $A7, $AD, $71, $AF, $B3, $B5	; Walk 2
	.byte $A7, $A5, $71, $71, $A9, $AB	; Wand swing

	; Ludwig
KoopalingPats_Ludwig:
	.byte $81, $83, $85, $87, $89, $8B	; Walk 1
	.byte $81, $83, $85, $8D, $8F, $91	; Walk 2
	.byte $81, $93, $85, $95, $B7, $8B	; Wand swing

Koopaling_WandFrame:
	.byte $49, $49, $4B, $4D

Koopaling_OffYLo:
	.byte $05, $05, $FB, $0A, $0A, $0A, $FF, $0F, $08, $08, $FB, $0D

Koopaling_OffXLo:
	.byte $F4, $F4, $0C, $F2, $FA, $FA, $0A, $F8, $F5, $F5, $0C, $F3

	.byte $14, $14, $FC, $16, $0E, $0E, $FE, $10, $13, $13, $FC, $15

Koopaling_OffXHi:
	.byte $FF, $FF, $00, $FF, $FF, $FF, $00, $FF, $FF, $FF, $00, $FF

Koopaling_OffYHi:
	.byte $00, $00, $FF, $00, $00, $00, $FF, $00, $00, $00, $FF, $00

	; Offset to Koopaling_OffYLo/Hi by World
Koopaling_OffYOff:
	.byte $04	; World 1
	.byte $00	; World 2
	.byte $04	; World 3
	.byte $04	; World 4
	.byte $00	; World 5
	.byte $04	; World 6
	.byte $08	; World 7

Koopaling_DrawAndAnimate:
	LDA <Player_HaltGame
	BNE PRG001_B336	 ; If game is halted, jump to PRG001_B336

	LDA Objects_Timer2,X
	BEQ PRG001_B336	 ; If object timer 2 is zero, jump to PRG001_B336

	AND #$03
	BNE PRG001_B328	 ; 3:4 ticks, jump to PRG001_B328

	LDY Level_GetWandState	 ; Y = Level_GetWandState

	INC Objects_Frame,X	 ; Increment object's frame

	LDA Objects_Frame,X	; Get frame
	CMP Koopaling_FrameLoopEnd,Y	
	BLT PRG001_B321	 	; If frame is not at the end of the loop, jump to PRG001_B321

	LDA Koopaling_FrameLoopStart,Y
	STA Objects_Frame,X	 ; Set back to first frame of animation loop

PRG001_B321:
	TAY		 ; Frame -> 'Y'

	; Set the Objects_FlipBits setting for this frame
	LDA Koopaling_LRByFrame,Y
	STA Objects_FlipBits,X

PRG001_B328:

	; Every 15 ticks, play the shell rotation "swish" sound
	LDA <Counter_1
	AND #$0f
	BNE PRG001_B336

	; Play the shell rotation "swish" sound
	LDA Sound_QLevel2
	ORA #SND_LEVELMARCH
	STA Sound_QLevel2

PRG001_B336:
	JSR Object_DeleteOffScreen	; Delete object if it falls off screen
	JSR Draw_KoopalingWand		; Draw the Koopaling's wand
	JSR Object_ShakeAndCalcSprite	; Calculate sprite info

	LDX <SlotIndexBackup		; X = object's slot index

	LDA Objects_Frame,X
	CMP #$04	 
	BLT PRG001_B35C	 	; If object's frame < 4, jump to PRG001_B35C

	; Koopaling spinning shell frames here... (frame 4 - 9)

	; Force pattern table bank 4 to $4B
	LDY #$4b
	STY PatTable_BankSel+4

	CMP #$0a
	BLT PRG001_B368	 	; If object's frame < 10, jump to PRG001_B368

	; Koopaling exiting shell frames here... (frame 10 - 17)

	TAY		 	; Backup the frame -> 'Y'

	; Temp_Var2 += 4 (Sprite_X from Object_ShakeAndCalcSprite)
	LDA <Temp_Var2
	ADD #$04
	STA <Temp_Var2

	TYA		 	; Restore Frame
	BNE PRG001_B368	 	; Jump (most likely always) to PRG001_B368

PRG001_B35C:
	CMP #$03	 
	BNE PRG001_B362	 	; If object's frame <> 3, jump to PRG001_B362

	LDA #$00	 	; Otherwise, A = 0

PRG001_B362:
	LDY World_Num	 	; Y = World number
	ADC Koopaling_PatLookup,Y	; Get index into the Koopaling pattern table (divided by 6)

PRG001_B368:

	; A = frame value with offset

	; Multiply by 6
	ASL A	
	STA <Temp_Var16
	ASL A	
	ADC <Temp_Var16
	TAX		 	; -> 'X' (offset into Koopaling_PatLookup)

	LDY <Temp_Var7		 ; Y = Sprite_RAM offset

	JSR Draw_KoopalingBody	 ; Draw upper half Koopaling

	; Second row sprites
	LDA <Temp_Var1
	ADD #$10
	STA <Temp_Var1

	; Sprite_RAM offset += 12 (next three sprites)
	TYA
	ADD #$0c
	TAY

	; X += 3 (next sprite pattern set)
	INX
	INX
	INX

	JSR Draw_KoopalingBody	 ; Draw lower half Koopaling

	LDX <SlotIndexBackup	 ; X = object slot index

	LDY <Temp_Var7		 ; Y = starting Sprite_RAM offset

	LDA Objects_Frame,X
	CMP #$0c	 
	BEQ PRG001_B395	 ; If sprite frame = $C, jump to PRG001_B395

	CMP #$10	 
	BNE PRG001_B3A1	 ; If sprite frame <> $10, jump to PRG001_B3A1

PRG001_B395:

	; Set horizontal flip on some shell flip frames
	LDA Sprite_RAM+6,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+6,Y

	STA Sprite_RAM+$12,Y
	RTS		 ; Return

PRG001_B3A1:
	CMP #$04
	BLT PRG001_B3D0	 ; If frame < 4 (not shell frame), jump to PRG001_B3D0 (RTS)

	CMP #$0a
	BGE PRG001_B3D0	 ; If frame >= 10 (exiting shell frame), jump to PRG001_B3D0 (RTS)

	; Spinning shell frames only...

	; Offset Y +6
	LDA Sprite_RAM,Y
	ADC #$06
	STA Sprite_RAM,Y
	STA Sprite_RAM+8,Y

	; Clear horizontal/vertical flip bit on first half
	LDA Sprite_RAM+2,Y
	AND #$3f
	STA Sprite_RAM+2,Y

	; Set horizontal flip on second half
	ORA #SPR_HFLIP
	STA Sprite_RAM+10,Y

	LDA Objects_Timer2,X
	CMP #$60
	BGE PRG001_B3D0	 ; If Timer 2 >= $60, jump to PRG001_B3D0 (RTS)

	; Otherwise, set pattern $71
	LDA #$71
	STA Sprite_RAM+1,Y
	STA Sprite_RAM+9,Y

PRG001_B3D0:
	RTS		 ; Return

Draw_KoopalingWand:
	LDA Objects_Frame,X
	CMP #$04
	BGE PRG001_B3D0	 ; If frame >= 4, jump to PRG001_B3D0 (RTS)

	LDY World_Num	 ; Y = World number

	LDA Objects_Frame,X	; Get current frame
	ADD Koopaling_OffYOff,Y	; Add respective base index
	TAY		 	; Result -> 'Y'

	; Add offset to object Y and store previous value
	LDA <Objects_Y,X
	PHA		
	ADD Koopaling_OffYLo,Y
	STA <Objects_Y,X

	LDA <Objects_YHi,X
	PHA
	ADC Koopaling_OffYHi,Y
	STA <Objects_YHi,X

	LDA Objects_FlipBits,X
	ASL A
	BPL PRG001_B3FF	 ; If Player is not right of object, jump to PRG001_B3FF

	; Add 12 to offset index
	TYA
	ADD #$0c
	TAY

PRG001_B3FF:

	; Add offset to object X and store previous value
	LDA <Objects_X,X
	PHA
	ADD Koopaling_OffXLo,Y
	STA <Objects_X,X

	LDA <Objects_XHi,X
	PHA	
	ADC Koopaling_OffXHi,Y
	STA <Objects_XHi,X

	JSR Object_DetermineHorzVis	; Set flags based on which sprites of this object are horizontally visible
	JSR Object_DetermineVertVis	; Set flags based on which sprites of this object are vertically visible
	JSR Object_ShakeAndCalcSprite	; Calculate sprite info

	LDX <SlotIndexBackup		; Restore 'X' as object index

	LDY #$02	 ; Y = 2

	LDA Objects_Timer,X
	BEQ PRG001_B425	 ; If first object timer = 0, jump to PRG001_B425
 
	AND #$03	; Cap 0 - 3
	TAY		; -> 'Y'

PRG001_B425:
	STY <Temp_Var4	; Store value -> Temp_Var4

	; Draw Koopaling's wand
	LDY Objects_Frame,X	; Y = current frame
	LDX Koopaling_WandFrame,Y
	LDY #$20
	JSR Object_Draw16x16Sprite

	BIT <Temp_Var3
	BVS PRG001_B43A	 ; If wand is horizontally flipped, jump to PRG001_B43A

	; Y += 4 (offset to next sprite because wand second half occurred second)
	INY
	INY
	INY
	INY

PRG001_B43A:

	; Horizontally flips the "staff" part of the wand sprite
	LDA Sprite_RAM+2,Y
	EOR #SPR_HFLIP
	STA Sprite_RAM+2,Y

	LDX <SlotIndexBackup	; X = Object's index 

	PLA		 	; Restore pre-offset X Hi
	STA <Objects_XHi,X	; Store as object's X Hi

	PLA		 	; Restore pre-offset X
	STA <Objects_X,X	; Store as object's X

	PLA		 	; Restore pre-offset Y Hi
	STA <Objects_YHi,X	; Store as object's Y Hi

	PLA		 	; Restore pre-offset Y
	STA <Objects_Y,X	; Store as object's Y

	JSR Object_DetermineHorzVis	; Set flags based on which sprites of this object are horizontally visible
	JMP Object_DetermineVertVis	; Set flags based on which sprites of this object are vertically visible (and do not return...)

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Draw_KoopalingBody:

	; Shift Temp_Var5; if bit set, skip this sprite
	LSR <Temp_Var5
	BCS PRG001_B4B4	 ; If carry set, jump to PRG001_B4B4 (RTS)

	LDA <Temp_Var8	 ; Holds Object's Flags1 (sprites horizontally off-screen)
	ASL A		 ; Shift value to the left
	STA <Temp_Var16	 ; -> Temp_Var16

	LDA <Temp_Var1	 ; Object's Y

	BCS PRG001_B466	 	; If sprite is not visible, jump to PRG001_B466

	STA Sprite_RAM,Y 	; Otherwise, store sprite Y

PRG001_B466:
	BIT <Temp_Var16	 
	BMI PRG001_B46D	 	; If next sprite is not visible, jump to PRG001_B46D

	STA Sprite_RAM+4,Y	; Otherwise, store next sprite Y

PRG001_B46D:
	BVS PRG001_B472	 	; If next sprite is not visible, jump to PRG001_B472

	STA Sprite_RAM+8,Y	; Otherwise, store next sprite Y

PRG001_B472:

	; Store all sprites' Xs
	LDA <Temp_Var2
	STA Sprite_RAM+3,Y
	ADD #$08
	STA Sprite_RAM+7,Y
	ADD #$08
	STA Sprite_RAM+11,Y

	LDA KPatTable,X
	STA Sprite_RAM+1,Y
	LDA KPatTable+1,X
	STA Sprite_RAM+5,Y
	LDA KPatTable+2,X
	STA Sprite_RAM+9,Y

	LDA <Temp_Var3
	ORA <Temp_Var4

	; Store combined attributes
	STA Sprite_RAM+2,Y 
	STA Sprite_RAM+6,Y
	STA Sprite_RAM+10,Y 

	BIT <Temp_Var3 
	BVC PRG001_B4B4	 ; If not horizontally flipped, jump to PRG001_B4B4 

	; Otherwise, reverse the sprites...
	LDA Sprite_RAM+1,Y 
	PHA	 
	LDA Sprite_RAM+9,Y 
	STA Sprite_RAM+1,Y 
	PLA	 
	STA Sprite_RAM+9,Y 

PRG001_B4B4:
	RTS		 ; Return

PRG001_B4B5:
	.byte $AF, $BF, $81, $41
	
Koopaling_WandGrab: 

	; Do the wand flashy colors effect!
	LDA #$9e	 
	STA RotatingColor_Cnt

PRG001_B4BE:
	INC Level_GetWandState	 ; Level_GetWandState = 4, 5, 6, or 7 depending how we got here

Koopaling_WandFall:
	RTS		 ; Return


Koopaling_TimeBonus:
	JSR DoTimeBonus	 
	BNE Koopaling_WandFall	 ; Not done running down time bonus, jump to Koopaling_WandFall (RTS)

	; All time depleted...

	LDA #$c0
	STA Objects_Timer,X	 ; Object timer = $C0

	BNE PRG001_B4BE	 ; Jump (technically always) to PRG001_B4BE

	; Defeated Koopaling vanishing air ship timer mask; smaller the timer,
	; the smaller the mask, and the faster it flickers
KDefeat_VanishMask:	.byte $01, $02, $04, $08

Koopaling_AirshipVanish:
	LDA Objects_Timer,X	 
	BNE PRG001_B4E6	 ; If timer is not expired, jump to PRG001_B4E6

	; Timer expired!

	; Play "King's Room" music (as Mario begins to fall)
	LDA #MUS2A_THRONEROOM
	STA Sound_QMusic2

	; Position all the clouds visible after airship vanishes semi-randomly
	JSR KDefeat_PositionClouds

	LDA #$ff
	STA Objects_Timer,X	 ; Set timer to $FF

	BNE PRG001_B4BE	 ; Jump (technically always) to PRG001_B4BE (next wand state)

PRG001_B4E6:
	CMP #$80
	BGE Koopaling_WandFall	 ; If timer < $80, jump to Koopaling_WandFall (RTS)

	; Could have just done this with right shifts?
	ASL A		; Bit 7 lost
	ASL A		; Bit 6 lost
	ROL A		; Bit 5 -> 0
	ROL A		; Bit 5 -> 1, Bit 4 -> 0 (Effectively, timer is divided by 16)
	AND #$03	; Cap 0 - 3

	TAY			 	; Y = 0 to 3
	LDA KDefeat_VanishMask,Y	; A = 1, 2, 4, or 8

	; The "flicker away" effect just takes advantage of forcing the scroll 
	; to the absolute top or absolute bottom, back and forth
	LDY #$00	 	; Y = 0 (scroll top)
	AND Objects_Timer,X	; Mask timer to control flicker rate
	BEQ PRG001_B4FD	 	; If masked value is zero, jump to PRG001_B4FD

	LDY #$ef	 ; Y = $EF (scroll bottom)

PRG001_B4FD:
	STY <Vert_Scroll ; Set scroll as appropriate!

	RTS		 ; Return


Koopaling_DoPlayerFall:
	LDA Objects_Timer,X	  
	BEQ PRG001_B4BE	 ; If timer expired, jump to PRG001_B4BE (next wand state)

PRG001_B505:
	JSR KDefeat_MoveClouds	; Move the clouds in the background

	; I suspect that there was an idea to have your time bonus
	; counted up as Mario fell instead of doing it beforehand...
	JMP DoTimeBonus	 ; Jump to DoTimeBonus ?? This basically amounts to an RTS ??

 Koopaling_FallOff:
	JSR PRG001_B505	 ; Keep doing stuff from Koopaling_DoPlayerFall
	BNE PRG001_B525	 ; If time bonus hasn't finished counting down, jump to PRG001_B525 (RTS) (not used!)

	LDA <Player_YHi
	CMP #$02
	BLT PRG001_B525	 ; If Player's Y Hi < 2, jump to PRG001_B525 (RTS)

	LDY Player_Current	; Y = Player_Current

	; When Level_ExitToMap goes non-zero, fall to king's room, not exit to map
	LDA #$01
	STA Player_FallToKing,Y

	LSR A
	STA Map_ReturnStatus	 ; Map status = 0 (level cleared)
	INC Level_ExitToMap	 ; Fall into king's room (in this context)

PRG001_B525:
	RTS		 ; Return


	; Initialized semi-random position of clouds shown after airship vanishes
KDefeat_CloudXs:	.byte $30, $18, $C0, $58, $80, $98, $18, $70
KDefeat_CloudYs:	.byte $10, $48, $68, $70, $98, $00, $30, $58
	
	; Positions the post-airship-vanishing clouds semi-randomly
KDefeat_PositionClouds:
	LDA <Counter_1
	AND #$03	
	TAY		 ; Y = 0 to 3

	; NOTE: Clouds use object coordinate memory, but are not really objects 
	; themselves, using custom sprite render routines and all...
	; So the ID is not set here because it's irrelevant!

	LDX #$04	 ; X = 4

PRG001_B53D:
	LDA #$01
	STA <Objects_YHi,X

	LDA KDefeat_CloudYs,Y
	STA <Objects_Y,X

	LDA KDefeat_CloudXs,Y
	STA <Objects_X,X

	LDA #$ff
	STA <Objects_YVel,X

	INY		 ; Y++
	DEX		 ; X--

	BPL PRG001_B53D	 ; While X >= 0, loop!

	LDX <SlotIndexBackup	; X = restored object index (what for?)

	RTS		 ; Return

PRG001_B556:	.byte -$40, -$2B, -$37, -$2D, -$21

KDefeat_MoveClouds:

	; Set pattern select 5 to table $36
	LDA #$36
	STA PatTable_BankSel+5

	LDA <Counter_1
	ASL A	
	ROL A	
	ROL A	
	ROL A
	AND #$03	 ; Cap 0 - 3
	STA <Temp_Var1	 ; Temp_Var1 = 0 to 3

	LDA Objects_Timer,X
	STA <Temp_Var2	 ; Temp_Var2 = timer 2

	LDX #$04	 ; X = 4
PRG001_B571:
	STX <Temp_Var3	 ; Backup 'X' into Temp_Var3

	JSR KDefeat_DrawClouds	; Draw clouds while Mario falls from airship
	JSR Object_ApplyYVel	 ; Apply Y velocity

	LDX <Temp_Var3	 ; Restore 'X' from Temp_Var3

	LDA PRG001_B556,X  

	LDY <Temp_Var2
	BNE PRG001_B584	 ; If Temp_Var2 (timer 2 value) <> 0, jump to PRG001_B584

	; Timer 2 expired

	; Essentially perform an ASR, if one existed, assuming negative value
	SEC
	ROR A

PRG001_B584:
	CMP <Objects_YVel,X
	BGE PRG001_B58C	 ; If cloud hasn't reached its "terminal velocity" yet, jump to PRG001_B58C

	LDA <Objects_YVel,X
	SBC #$00	 ; Subtracts the carry

PRG001_B58C:
	STA <Objects_YVel,X	; Update Y Vel

	LDA <Objects_YHi,X
	BPL PRG001_B5A1	 	; If object's Y Hi is >= 0, jump to PRG001_B5A1

	; If you get here, cloud has vanished, need to make a new one...

	LDY <Temp_Var1		 ; Y = Temp_Var1 (0 to 3 based on counter)

	; Get initial cloud Y position
	LDA KDefeat_CloudXs,Y
	STA <Objects_X,X

	; Y Hi = 0
	LDA #$00
	STA <Objects_YHi,X

	; Cloud Y = $C8
	LDA #$c8
	STA <Objects_Y,X

PRG001_B5A1:
	INC <Temp_Var1		 ; Temp_Var1++

	DEX		 ; X--
	BPL PRG001_B571	 ; While X >= 0, loop!

	LDX <SlotIndexBackup	; X = restore object slot index

	RTS		 ; Return

	; Widths of the different clouds
KDefeat_CloudWidths:
	.byte $03, $02, $02, $03, $03

	; Clouds are drawn manually, not actual objects of their own free will!
KDefeat_DrawClouds:
	LDA <Objects_YHi,X
	BNE PRG001_B5F5	 ; If object Y Hi <> 0, jump to PRG001_B5F5 (RTS)

	LDY Object_SprRAM,X	 ; Y = sprite RAM offset for this object

	; Temp_Var15 = object's X
	LDA <Objects_X,X
	STA <Temp_Var15	

	; Temp_Var16 = object's Y
	LDA <Objects_Y,X
	STA <Temp_Var16	

	; Get cloud width
	LDA KDefeat_CloudWidths,X
	TAX		 ; -> 'X'

PRG001_B5C1:
	; Store object's Y into sprite RAM
	LDA <Temp_Var16
	STA Sprite_RAM,Y

	; Set pattern $F9
	LDA #$f9
	STA Sprite_RAM+1,Y

	; Set attribute (palette 1)
	LDA #SPR_PAL1
	STA Sprite_RAM+2,Y

	; Set object's X into sprite RAM
	LDA <Temp_Var15	
	STA Sprite_RAM+3,Y

	; X += 8
	ADD #$08
	STA <Temp_Var15

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)
	DEX		 ; X--
	BPL PRG001_B5C1	 ; While X >= 0, loop!

	; Do left edge of cloud...

	; Change pattern to $F7
	LDA #$f7
	STA Sprite_RAM-3,Y

	; Horizontally flip with palette 1
	LDA #(SPR_HFLIP | SPR_PAL1)
	STA Sprite_RAM-2,Y

	; There's no point to this; this restores the loop counter we
	; came from, but it gets restored manually when we get back
	; due to corruption to the 'X' register after this return...
	LDX <Temp_Var3		 ; X = Temp_Var3

	; Do right edge of cloud...

	LDY Object_SprRAM,X	 ; Y = this object's sprite RAM position

	LDA #$f7
	STA Sprite_RAM+1,Y	 ; Change pattern to edge of cloud

PRG001_B5F5:
	RTS		 ; Return

	; Different impact counts for the heavy Koopalings Roy and Ludwig, sets Level_Vibration
	; Basically larger vibrations based on more hits to the Koopaling
KoopalingImpact_Count:
	.byte $20, $30, $40


	; Koopaling hits solid tiles and also causes the paralyzing Player
	; floor vibration, if it's the right Koopaling to do so..
Koopaling_DetectWorld:

	; Apply velocities and detect against world
	JSR Object_ApplyXVel
	JSR Object_ApplyYVel_NoLimit
	JSR Object_WorldDetectN1

	LDA World_Num
	CMP #$04	
	BEQ PRG001_B617	 ; If World = 4 (World 5, Roy), jump to PRG001_B617

	CMP #$06	 
	BEQ PRG001_B617	 ; If World = 6 (World 7, Ludwig), jump to PRG001_B617

	; Not World 5 (Roy) or World 7 (Ludwig) ...

	; Object Y velocity += 2 (fall)
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	JSR Object_HitGroundAlign	 ; Hit ground and align
	JMP PRG001_B654	 		; Jump to PRG001_B654

PRG001_B617:

	; World 5 (Roy) or World 7 (Ludwig) ...

	LDA <Objects_YVel,X
	BMI PRG001_B621	 ; If Y velocity < 0 (moving upward), jump to PRG001_B621

	CMP #$78	 
	BGE PRG001_B62E	 ; If Y velocity >= $78, jump to PRG001_B62E
	BLT PRG001_B624	 ; If Y velocity < $78, jump to PRG001_B624

PRG001_B621:
	JSR Negate	 ; Get absolute value of Y velocity

PRG001_B624:
	; Absolute value of Y velocity < $78

	; Basically add 1/8 current velocity to the Y velocity (Roy and Ludwig's fast fall rate)
	LSR A
	LSR A
	LSR A	
	ADD #$01
	ADC <Objects_YVel,X
	STA <Objects_YVel,X

PRG001_B62E:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_B654	 ; If Roy/Ludwig hasn't hit ground, jump to PRG001_B654

	LDA <Objects_YVel,X
	CMP #$20
	BLT PRG001_B651	 ; If Y velocity < $20, jump to PRG001_B651 (cutoff for shaking floor)

	; Slam floor sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDY <Objects_Var4,X	 ; Y = current Koopaling hit count

	LDA KoopalingImpact_Count,Y
	STA Level_Vibration	 	; Shake floor!

	LDY <Player_InAir
	BNE PRG001_B651	 	; If Player is mid-air, jump to PRG001_B651

	STA Objects_Var1,X	 ; If Player's on the ground, set Variable 1 to the same as the shake (used to paralyze Player)

PRG001_B651:
	JSR Object_HitGround	 ; Hit ground, align to floor

PRG001_B654:
	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG001_B65C	 ; If Koopaling did not hit ceiling, jump to PRG001_B65C

	STA <Objects_YVel,X	 ; Otherwise, Y vel = 0

PRG001_B65C:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG001_B668	 ; If Koopaling did not hit left or right wall, jump to PRG001_B668

	; Hit wall, turn around...
	JSR Object_AboutFace
	JSR Object_FlipFace

PRG001_B668:
	RTS		 ; Return

Lemmy_XLimits:		.byte 208, 32	; Lemmy's X coordinate limits (does not take "X Hi" into account)
Lemmy_XVelLimits:	.byte $18, -$18	; Lemmy's X velocity limits
Lemmy_XVelAccel:	.byte 1, -1	; Lemmy's X velocity acceleration

	; Converts the "0 if Player is to the right of object, 1 if to the left" 
	; to an appropriate horizontal flip
Koopaling_FacePlayerBit:	.byte SPR_HFLIP, $00

PRG001_B671:

	; World 6 (Lemmy)

	JSR DrawLemmyBall_AndHit	; Draw Lemmy and his ball, also detect Player touching his ball
	JSR Object_HitTestRespond	; Perform normal hit test and response 
	JSR Koopaling_DieByFire		; If hit by enough fireballs, battle ends

	LDA <Player_HaltGame
	ORA Objects_Timer2,X
	BNE PRG001_B6F1	 	; If game is halted or timer 2 is non-zero, jump to PRG001_B6F1

	; Get absolute value of X velocity
	LDA <Objects_XVel,X
	BPL PRG001_B688	
	JSR Negate
PRG001_B688:

	LSR A
	LSR A
	LSR A

	AND #$07	 ; A = (absolute value of X velocity) / 8, capped 0 - 7
	TAY		 ; -> 'Y'

	LDA KoopalingAnimSpd,Y
	ADD Objects_Var7,X
	STA Objects_Var7,X	 ; Koopaling's animation timer += KoopalingAnimSpd[Y]
	BCC PRG001_B6A0	 	; If no overflow, jump PRG001_B6A0

	INC Objects_Var6,X 	; Animation counter 
	INC Objects_Frame,X	; If overflow, Koopaling stepped, so go to next frame

PRG001_B6A0:

	; Alternate between frame 0 and 1 when "walking"
	LDA Objects_Frame,X
	AND #$01
	STA Objects_Frame,X

	LDA <Counter_1
	AND #$7f	
	BNE PRG001_B6B7	 ; 127 ticks, jump to PRG001_B6B7

	; Every 128 ticks...
	JSR Level_ObjCalcXDiffs	 ; Determine which side Player is on

	; 'Y' is set to 0 if Player is to the right of object, 1 if to the left
	LDA Koopaling_FacePlayerBit,Y	 ; Get appropriate flip bit
	STA Objects_FlipBits,X	 	; Set it!

PRG001_B6B7:
	LDA <Counter_1
	LSR A		
	BCS PRG001_B6D1	 ; Every other tick, jump to PRG001_B6D1

	DEC Objects_Var3,X	; Objects_Var3-- 
	BNE PRG001_B6D1	 	; If Objects_Var3[X] <> 0, jump to PRG001_B6D1

	INC Objects_TargetingXVal,X	 ; Objects_TargetingXVal++ 

	LDA RandomN,X
	AND #$3f	
	ORA #$80	
	STA Objects_Var3,X	 ; Random value $80-$BF -> Objects_Var3 

	JSR Lemmy_SpawnBall	 ; Lemmy will spawn another ball, if available

PRG001_B6D1:
	LDA Objects_TargetingXVal,X
	AND #$01
	TAY			; Y = 0 or 1
	LDA Lemmy_XLimits,Y
	CMP <Objects_X,X
	LDY #$00		; Y = 0
	BGE PRG001_B6E1		; If Lemmy is beyond his limit, jump to PRG001_B6E1

	INY			; Y = 1

PRG001_B6E1:
	LDA <Objects_XVel,X
	CMP Lemmy_XVelLimits,Y
	BEQ PRG001_B6EE	 	; If Lemmy is at his limit, jump to PRG001_B6EE

	ADD Lemmy_XVelAccel,Y
	STA <Objects_XVel,X	; Otherwise, apply acceleration

PRG001_B6EE:
	JSR Object_ApplyXVel	; Apply X Velocity

PRG001_B6F1:
	RTS		 ; Return

KoopalingAnimSpd:
	.byte $00, $20, $40, $50, $60, $70, $80, $A0

	; Lemmy's ball components, four frames
LemmyBall_Left:		.byte $DB, $F7, $F7, $DB
LemmyBall_Right:	.byte $F7, $DB, $DB, $F7 
LemmyBall_Attrs:	.byte $02, $42, $C2, $82

	; Lemmy has a special routine to draw his ball and detect getting hit by it
DrawLemmyBall_AndHit:
	LDY #$00	 ; Y = 0

	LDA Objects_Frame,X
	CMP #$02	 
	BGE PRG001_B710	 ; If frame >= 2, jump to PRG001_B710

	TAY		 ; Y = 1

PRG001_B710:
	STY <Temp_Var1	 ; Temp_Var1 = 0 or 1

	LDA <Objects_Y,X	; Get object's Y
	PHA		 	; Save it
	SUB <Temp_Var1		; Subtract 0 or 1
	STA <Objects_Y,X	; Store into object's Y

	LDA <Objects_YHi,X	; Get object's Y Hi
	PHA		 	; Save it
	SBC #$00	 	; Apply carry
	STA <Objects_YHi,X	; Store into object's Y Hi

	JSR Koopaling_DrawAndAnimate	 ; Draw and animate the Koopaling

	PLA		 	; Restore object's Y Hi
	STA <Objects_YHi,X	; Save it

	PLA		 	; Restore object's Y
	STA <Objects_Y,X	; Save it

	JSR Object_CalcSpriteXY_NoHi	 ; Calculate Sprite X and Y

	LDA <Objects_XVel,X
	ASL A		 ; A = X velocity << 1

	LDA Objects_Var6,X	 ; Get animation frame counter for Lemmy's ball
	BCC PRG001_B737	 ; If velocity negative, jump to PRG001_B737

	EOR #$03	 ; Invert part of Objects_Var6 we care about

PRG001_B737:
	AND #$03	 ; Mask lower 2 bits of Objects_Var6 (0-3)
	TAY		 ; -> 'Y'

	; Stores patterns for Lemmy's ball
	LDA LemmyBall_Left,Y
	STA Sprite_RAM+$19

	LDA LemmyBall_Right,Y
	STA Sprite_RAM+$1D

	; Store attributes for Lemmy's ball
	LDA LemmyBall_Attrs,Y
	STA Sprite_RAM+$1A
	STA Sprite_RAM+$1E

	LDA #$04	 ; A = 4

	LDY Objects_Timer2,X	; Y = timer 2
	BNE PRG001_B761	 	; If timer 2 is zero, jump to PRG001_B761

	; Non-zero timer...

	; Pushes horizontal flip bit into carry
	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA #$00	 ; A = 0
	BCS PRG001_B761	 ; If horizontally flipped, jump to PRG001_B761

	LDA #$08	 ; A = 8

PRG001_B761:
	ADD <Objects_SpriteX,X	 ; Add the Sprite X factor
	STA Sprite_RAM+$1B	 ; Store into sprite X
	STA <Temp_Var2		 ; -> Temp_Var2

	ADD #$08	 
	STA Sprite_RAM+$1F	 ; Store into second sprite X

	; Set sprite Y with +$20 offset
	LDA <Objects_SpriteY,X
	ADD #$20
	STA Sprite_RAM+$18
	STA Sprite_RAM+$1C


	; Check if Player is touching Lemmy's ball

	; X bound
	LDA <Player_SpriteX
	SBC <Temp_Var2
	ADD #$0c
	CMP #$18
	BGE PRG001_B799

	; Y bound
	LDA <Player_SpriteY
	SBC Sprite_RAM+$18
	ADD #$20
	CMP #$20
	BGE PRG001_B799

	; Offscreen
	LDA Player_OffScreen
	BNE PRG001_B799	 ; If Player is offscreen, jump to PRG001_B799 (RTS)

	JSR Player_GetHurt	 ; Hurt Player!

PRG001_B799:
	RTS		 ; Return

	; Set X velocity of Lemmy ball
LemmyBall_XVel:
	.byte -8, 8

Lemmy_SpawnBall:

	LDY #$02	; Y = 2
PRG001_B79E:
	LDA Objects_State,Y
	BEQ PRG001_B7A7	 ; If this object slot is dead/empty, jump to PRG001_B7A7

	DEY		 ; Y--
	BPL PRG001_B79E	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG001_B7A7:
	TYA		 ; A = Y
	TAX		 ; X = A (slot index for new object)

	JSR Level_PrepareNewObject	 ; Prepare new object!

	LDX <SlotIndexBackup	 ; X = original object slot index

	; New object in state 2 (normal operation)
	LDA #OBJSTATE_NORMAL
	STA Objects_State,Y

	; New object ID 
	LDA #OBJ_BOSSATTACK
	STA Level_ObjectID,Y

	; New object Y -- Koopaling Y + 32
	LDA <Objects_Y,X
	ADD #$20
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA Objects_YHi,Y

	; New object X -- Koopaling X + 4
	LDA <Objects_X,X
	ADD #$04
	STA Objects_X,Y
	LDA <Objects_XHi,X
	ADC #$00
	STA Objects_XHi,Y

	LDA Objects_TargetingXVal,X
	AND #$01
	TAX		; X = 0 or 1
	LDA LemmyBall_XVel,X
	STA Objects_XVel,Y	; Set X velocity

	LDA #$02
	STA Objects_SprAttr,Y	 ; Set sprite priority

	LDX <SlotIndexBackup		 ; Restore 'X' as object slot index yet again
	RTS		 ; Return


	; Wendy's ring thing X velocity (by facing direction)
Wendy_RingXVel: .byte $10, -$10

PRG001_B7EC:
	; World 3, Wendy ...
	JSR Lemmy_SpawnBall
	BMI PRG001_B819	 ; If unable to spawn, jump to PRG001_B819 (RTS)

	; Not sure what this is for?
	LDA #$01
	STA Objects_Var5,Y

	; Change spawned object Y to match Wendy
	LDA <Objects_Y,X
	STA Objects_Y,Y

	; Change spawned object Y Hi to match Wendy
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	; Set Y velocity to -$10
	LDA #-$10
	STA Objects_YVel,Y

	STY <Temp_Var1	 ; Save 'Y'

	; Y = 0 or 1, depending on facing direction
	LDY #$00
	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BNE PRG001_B811
	INY	

PRG001_B811:
	LDA Wendy_RingXVel,Y

	LDY <Temp_Var1	 ; Restore 'Y'

	; Set ring X velocity as appropriate!
	STA Objects_XVel,Y

PRG001_B819:
	RTS		 ; Return


	; Hmm, unused space?
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF


ObjInit_Bowser:

	; Bowser takes 34 fireball hits!
	LDA #34
	STA Objects_HitCount,X

	; Bowser is giant!
	INC Objects_IsGiant,X

	RTS		 ; Return


	; X Velocity applied to Player when bouncing off Bowser's head
Bowser_HeadBounceXVel:	.byte $10, -$10

ObjNorm_Bowser:

	; Set Bowser's pattern table selections
	LDA #$3a
	STA PatTable_BankSel+4
	LDA #$3b
	STA PatTable_BankSel+5

	LDA <Player_HaltGame
	BNE PRG001_B8D3	 ; If gameplay is halted, jump to PRG001_B8D3

	LDA Bowser_Counter1
	BEQ PRG001_B8A1	 ; If Bowser_Counter1 = 0, jump to PRG001_B8A1

	DEC Bowser_Counter1	 ; Bowser_Counter1--

PRG001_B8A1:
	LDA Bowser_Counter2
	AND #%00011111	 
	BEQ PRG001_B8AB	 ; Every 32 ticks of Bowser's second counter, jump to PRG001_B8AB

	DEC Bowser_Counter2	 ; Bowser_Counter2--

PRG001_B8AB:
	JSR Bowser_DoVar5Action	; Do Bowser's internal state action
	JSR Bowser_HopAndBreatheFire	; Bowser hops and breathes fireballs
	JSR Player_HitEnemy	 	; Do hit detection

	LDA Objects_PlayerHitStat,X
	BEQ PRG001_B8D3		; If Player hasn't hit Bowser, jump to PRG001_B8D3

	; Player hit Bowser...

	; Set timer 2 to 8
	LDA #$08
	STA Objects_Timer2,X

	LDA <Player_YVel
	BMI PRG001_B8D3	 ; If Player is moving upward, jump to PRG001_B8D3

	; Player bounces off Bowser's head!
	LDA #-$30
	STA <Player_YVel

	JSR Bowser_CalcPlayersSide	 ; Calculate the side of his head Player bounced off of

	; Apply an X Velocity when bouncing off Bowser's head
	LDA Bowser_HeadBounceXVel,Y
	STA <Player_XVel

	; Bounce sound
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

PRG001_B8D3:
	LDA <Objects_Var5,X
	BEQ PRG001_B8E0	 ; If the internal state = 0 (waiting to meet Player), jump to PRG001_B8E0

	JSR Bowser_Draw	 ; Draw Bowser!

	LDA <Objects_Var5,X	
	CMP #$01	 
	BEQ PRG001_B8E5	 ; If internal state = 1, jump to PRG001_B8E5 (RTS)

PRG001_B8E0:

	; Otherwise, mark Bowser as totally invisible horizontally (??)
	LDA #$ff
	STA Objects_SprHVis,X

PRG001_B8E5:
	RTS		 ; Return

Bowser_DoVar5Action:
	LDA <Objects_Var5,X
	JSR DynJump	 ; Jump dynamically by Objects_Var5

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_WaitForPlayer	; Internal state 0: Bowser waiting for Mario/Luigi to show up...
	.word Bowser_DoMovements	; Internal state 1: Bowser movements (jumping, busting floor, etc.)
	.word Bowser_FallAndSplat	; Internal state 2: Bowser fall (until he hits bottom, ba-bam! Only if dead, though)
	.word Bowser_WaitAndVictory	; Internal state 3: Wait until timer expires, then play victory song
	.word Bowser_DoTimeBonus	; Internal state 4: Convert remaining time to score
	.word Bowser_DoorAppear		; Internal state 5: Final door appears

Bowser_WaitForPlayer:
	LDA Objects_SprHVis,X
	BNE PRG001_B928	 ; If any of Bowser's sprites are horizontally off-screen, jump to PRG001_B928 (RTS)

	LDA <Horz_Scroll
	CMP #$07
	BGE PRG001_B928	 ; If Horz_Scroll >= 7, jump to PRG001_B928 (RTS)

	; Player got close enough; lock horizontal scroll and stop Player from moving
	LDA #$00
	STA <Horz_Scroll
	STA <Player_XVel

	; Player must land first
	LDA <Player_InAir
	BNE PRG001_B928	 ; If Player is midair, jump to PRG001_B928 (RTS)

	; Vert_Scroll = $EF (lowest scroll point)
	LDA #$ef
	STA <Vert_Scroll

	; Play Bowser's Theme
	LDA #MUS2B_BOWSER
	STA Sound_QMusic2

	INC LevelJctBQ_Flag	 ; LevelJctBQ_Flag = 1 (set like in a Big Question block area, i.e. no horizontal scrolling)

	; Lock vertical scroll
	LDA #$02
	STA Level_FreeVertScroll

	; Var4 = 3
	LDA #$03
	STA <Objects_Var4,X

	; Timer 3 = $30
	LDA #$30	 
	STA Objects_Timer3,X

	; Internal state = 1
	INC <Objects_Var5,X

PRG001_B928:
	RTS		 ; Return


Bowser_DoMovements:
	JSR Bowser_HandleIfDead	 ; Handle Bowser if he got killed

	LDA Level_NoStopCnt
	AND #%00011111
	ORA Bowser_Counter1
	BNE PRG001_B948	 ; If Bowser Counter 1 > 0 and except every 32nd tick, jump to PRG001_B948

	; Only when Bowser Counter 1 is expired and every 32 ticks of the no stop counter...

	LDA Objects_FlipBits,X

	PHA		 ; Save Bowser's flip bits

	JSR Bowser_FacePlayer	 ; Bowser face Player

	PLA		 ; Restore Bowser's flip bits

	CMP Objects_FlipBits,X
	BEQ PRG001_B948	 ; If Bowser has NOT changed facing direction, jump to PRG001_B948

	; Bowser changed facing direction

	; Set some bits on Bowser's Counter 2
	ORA #$13
	STA Bowser_Counter2

PRG001_B948:
	LDA <Objects_Var4,X
	JSR DynJump	 ; Jump dynamically by var 4

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bowser_FallToFloor	; 0: Fall to floor
	.word Bowser_JumpAndLandOnFloor	; 1: Jump and land on floor
	.word Bowser_AlignAndFall	; 2: Align to tile on the way down (will also use part of Bowser_JumpAndLandOnFloor)
	.word Bowser_BustFloorLookAround; 3: Bowser busts floor and looks around

PRG001_B955:	.byte $08, $05, $04, $05, $08
PRG001_B95A:	.byte $40, $40, $00, $00, $00


Bowser_FallToFloor:
	JSR Bowser_Counter3Do	 ; Update Bowser_Counter3

	LDA Bowser_Counter2
	AND #$1f	 
	BEQ PRG001_B97C	 ; Every 32 ticks of Bowser_Counter2, jump to PRG001_B97C

	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7, slower rate than Bowser_Counter2

	LDA Bowser_Counter2
	AND #SPR_HFLIP
	EOR PRG001_B95A,Y
	STA Objects_FlipBits,X

	LDA PRG001_B955,Y

PRG001_B97C:
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BNE PRG001_B9B5	 ; If timer is not expired, jump to PRG001_B9B5

	JSR Bowser_DetectTiles	 ; Detect the tiles under Bowser

	; Bowser fall up to $40 Y Velocity...
	LDA <Objects_YVel,X
	CMP #$40	 
	BGS PRG001_B98F	 ; If Bowser's Y Velocity >= $40, jump to PRG001_B98F

	INC <Objects_YVel,X	 ; Bowser's gravity

PRG001_B98F:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_B9A4	 ; If Bowser has NOT hit floor, jump to PRG001_B9A4 (RTS)

	JSR Object_HitGround	 ; Align to floor

	LDA #$10	; A = $10

	LDY Objects_Timer3,X
	BNE PRG001_B9A1	 ; If Timer 3 is not expired, jump to PRG001_B9A1

	LDA #$b0	 ; A = $B0

PRG001_B9A1:
	; Set Timer as appropriate
	STA Objects_Timer,X

PRG001_B9A4:
	RTS		 ; Return

	; Base X velocities by Player's distance away from Bowser when he attempts to jump and land on you
Bowser_XVelByDist:
	.byte $08, $10, $18, $20, $28, $30, $38, $40, $48, $50, $50, $50, $50, $50, $50, $50

PRG001_B9B5:
	LDA Bowser_Counter2 
	AND #$1f 
	BNE PRG001_B9BF	 ; Only continue 1:32 ticks, otherwise jump to PRG001_B9BF
 
	INC Objects_Frame,X	 ; Bowser's frame++

PRG001_B9BF:
	LDA Objects_Timer,X 
	CMP #$01 
	BEQ PRG001_B9F3	 ; If timer expired, jump to PRG001_B9F3

	CMP #$80 
	BNE PRG001_B9F2	 ; If timer <> $80, jump to PRG001_B9F2 (RTS) 

	; Jump and land on floor mode
	LDA #$01 
	STA <Objects_Var4,X
 
	; Bowser jump!
	LDA #-$60 
	STA <Objects_YVel,X
 
	JSR Bowser_CalcPlayersSide 
	STY <Temp_Var1		 ; Temp_Var1 = 0 or 1, depending on side Player is on
 
	; Get absolute value of X difference
	LDA <Temp_Var16 
	BPL PRG001_B9DE 
	JSR Negate 
PRG001_B9DE:

	LSR A 
	LSR A 
	LSR A 
	LSR A 
	AND #$0f 
	TAY		 ; Y = 0 to 15, number of tiles away Player is
 
 
	; Calculate Bowser's X velocity to target Player!
	LDA Bowser_XVelByDist,Y
	LDY <Temp_Var1 
	DEY	
	BNE PRG001_B9F0 
	JSR Negate
PRG001_B9F0: 
	STA <Objects_XVel,X 

PRG001_B9F2:
	RTS		 ; Return

PRG001_B9F3:
	; Little hop
	LDA #-$10 
	STA <Objects_YVel,X
 
	RTS		 ; Return

	; Used as a bit 7 invert to determine if Bowser is moving 
	; away from or towards the Player
Bowser_VsPlayerXVelNegBit:
	.byte $00, $80


Bowser_JumpAndLandOnFloor:
	LDA <Objects_YVel,X	 
	BPL PRG001_BA01	 ; If Bowser is on floor or falling, jump to PRG001_BA01

	JSR Bowser_Counter3Do	 ; Update Bowser's Counter 3

PRG001_BA01:

	; Bowser frame 0
	LDA #$00
	STA Objects_Frame,X

	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser's feet

	LDA <Objects_YVel,X
	BMI PRG001_BA11	 ; If Bowser is moving upward (jumping), jump to PRG001_BA11

	CMP #$50	 
	BGE PRG001_BA17	 ; If Bowser Y velocity >= $50, jump to PRG001_BA17

PRG001_BA11:

	; Bowser fall rate Y Vel += 3
	INC <Objects_YVel,X
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG001_BA17:

	LDA <Objects_YVel,X
	BPL PRG001_BA1F	 ; If Bowser is not moving upward, jump to PRG001_BA1F

	CMP #-$20
	BLT PRG001_BA4B	 ; If Bowser is moving upward faster than -$20, jump to PRG001_BA4B

PRG001_BA1F:

	; Bowser not moving upward... or not moving upward fast enough

	JSR Bowser_CalcPlayersSide	 ; Figure out which side Player is on

	LDA Bowser_VsPlayerXVelNegBit,Y
	EOR <Objects_XVel,X
	BPL PRG001_BA4B	 ; If Bowser's velocity is moving away from Player, jump to PRG001_BA4B

	JSR Level_ObjCalcYDiffs	 

	DEY		 ; Y--
	BEQ PRG001_BA4B	 ; If Y was 1, jump to PRG001_BA4B

	; Var4 = 2
	LDA #$02
	STA <Objects_Var4,X

	; Timer = $0A
	LDA #$0a
	STA Objects_Timer,X

	; Calculate an X position that targets Player and aligned to tile
	LDA <Objects_X,X
	ADD #$08
	AND #$f0
	STA Objects_TargetingXVal,X

	; Bowser jump!
	LDA #-$20
	STA <Objects_YVel,X

	; Stop Bowser's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG001_BA4B:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_BA76	 ; If Bowser has NOT hit floor, jump to PRG001_BA76

	; Bowser has hit floor...

	JSR Object_HitGround	 ; Align to floor ('A' = 0 at the end of this, hence the following assignment)

	STA <Objects_XVel,X	 ; Stop Bowser's horizontal movement

	; Vibrate floor from impact
	LDA #$2c
	STA Level_Vibration

	; Ba-bam sound!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Object timer = $35
	LDA #$35
	STA Objects_Timer,X

	LDA RandomN,X
	AND #$1f	
	ADC #$67	
	STA Objects_Timer3,X	 ; Timer 3 = Random $67 to $86
	STA Objects_Var7,X	 ; -> Var7

	; Var4 = 3
	LDA #$03
	STA <Objects_Var4,X

PRG001_BA76:
	RTS		 ; Return


Bowser_AlignAndFall:
	; Reset Bowser Counter 1
	LDA #$00
	STA Bowser_Counter1

	; Set Bowser to frame 6 (Bowser's falling frame)
	LDA #$06
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BEQ PRG001_BA96	; If timer expired, jump to PRG001_BA96

	LDA <Objects_X,X
	CMP Objects_TargetingXVal,X
	BEQ PRG001_BA95	; If Bowser reached the alignment X, jump to PRG001_BA95

	; Bowser moves towards the tile alignment
	INC <Objects_X,X
	BCC PRG001_BA95	; If carry clear, jump to PRG001_BA95

	; Don't let Bowser's X wrap around!
	DEC <Objects_X,X
	DEC <Objects_X,X

PRG001_BA95:
	RTS		 ; Return

PRG001_BA96:
	JSR Bowser_DetectTiles	 ; Detect tiles under Bowser

	LDA <Objects_YVel,X
	BMI PRG001_BAA1	 ; If Bowser is moving upward, jump to PRG001_BAA1

	CMP #$70
	BGE PRG001_BAA6	 ; If Bowser's Y Velocity >= $70, jump to PRG001_BAA6 (RTS)

PRG001_BAA1:

	; Bowser's rapid stomp fall!
	ADD #$06
	STA <Objects_YVel,X

PRG001_BAA6:
	JMP PRG001_BA4B	 ; Jump to PRG001_BA4B 


Bowser_BustFloorLookAround:
	JSR Bowser_DetectTiles	  ; Detect tiles under Bowser's feet

	LDA <Objects_YVel,X
	CMP #$40
	BGS PRG001_BAB6	 ; If Bowser's Y Velocity >= $40, jump to PRG001_BAB6

	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG001_BAB6:
	JSR Bowser_BustFloor	 ; Bust any bricks Bowser has hit

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG001_BAC2	 ; If Bowser has not hit floor, jump to PRG001_BAC2

	JSR Object_HitGround	 ; Align to floor

PRG001_BAC2;
	LDA Objects_Timer,X
	BEQ PRG001_BACD		; If timer expired, jump to PRG001_BACD

	; Bowser slam frame
	LDA #$07
	STA Objects_Frame,X

	RTS		 ; Return

PRG001_BACD:
	LDA Objects_Timer3,X
	BNE PRG001_BAF1	 ; If timer 3 is not expired, jump to PRG001_BAF1

	; Var 4 back to zero
	LDA #$00
	STA <Objects_Var4,X

	LDA RandomN,X
	AND #$7f
	ORA #$80
	STA Objects_Timer3,X	 ; Timer 3 = $7F to $FF

	RTS		 ; Return

	; Bowser look around frame
Bowser_LookAroundFrames:	.byte $04, $05, $05, $05, $04, $05, $05, $05

	; Bowser look around flip bits
Bowser_LookAroundFlipBits:	.byte $00, $00, $00, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_HFLIP

PRG001_BAF1:
	CMP #$20
	BLT PRG001_BB0B	 ; If timer 3 < $20, jump to PRG001_BB0B

	; When Bowser lands, he looks around a bit for a second

	LSR A
	LSR A
	ADD Objects_Var7,X	; ?? Not used in anything else Bowser does?
	AND #$07
	TAY		 ; Y = 0 to 7 

	; Set frame
	LDA Bowser_LookAroundFrames,Y
	STA Objects_Frame,X

	; Set flip bits
	LDA Bowser_LookAroundFlipBits,Y
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG001_BB0B:
	CMP #$0c
	LDA #$05	 ; A = 5
	BGE PRG001_BB13	 ; If timer 3 >= 5, jump to PRG001_BB13

	LDA #$08	 ; Otherwise, A = 8

PRG001_BB13:
	STA Objects_Frame,X	 ; Set Bowser frame

Bowser_FacePlayer:
	JSR Bowser_CalcPlayersSide

	; Bowser face Player!
	LDA Bowser_FlipToFace,Y
	STA Objects_FlipBits,X

	RTS		 ; Return


	; Set proper flip bit for Bowser to face Player
Bowser_FlipToFace:
	.byte SPR_HFLIP, $00

Bowser_HoppingFrames:
	.byte $00, $00, $03, $02, $00, $00, $00, $00

Bowser_HopAndBreatheFire:
	LDA Bowser_Counter1
	BEQ PRG001_BB46	 ; If Bowser_Counter1 = 0, jump to PRG001_BB46 (RTS)

	LSR A
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7

	; Bowser's little hopping animation
	LDA Bowser_HoppingFrames,Y
	STA Objects_Frame,X

	LDA Bowser_Counter1
	CMP #$10	 
	BNE PRG001_BB46	 ; If Bowser_Counter1 <> $10, jump to PRG001_BB46 (RTS)

	JSR Bowser_BreatheFire	 ; Bowser breathe's a fireball!

PRG001_BB46:
	RTS		 ; Return

	; Bowser's fireball X velocity and offset by direction
Bowser_FireballXVel:	.byte -$10, $10
Bowser_FireballXOff:	.byte -$08, $18

PRG001_BB4B:	.byte $00, $08, $10, $18, $08, $00, $00, $10
	
Bowser_BreatheFire:
	LDY #$04	; Y = 4
PRG001_BB55:
	LDA Objects_State,Y
	BEQ PRG001_BB5E	 ; If object is dead/empty, jump to PRG001_BB5E

	DEY		 ; Y--
	BPL PRG001_BB55	 ; While Y >= 0, loop

	RTS		 ; Return

PRG001_BB5E:
	TYA
	TAX		 ; X = new object's index

	JSR Level_PrepareNewObject	 ; Set up the new flame to be spawned 

	; Set object state to normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser's fireball
	LDA #OBJ_BOSSATTACK
	STA Level_ObjectID,X

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Bowser fall
	LDA #$10
	STA Objects_YVel,Y

	LDX <SlotIndexBackup	 ; Restore 'X' to Bowser's object slot index

	; Set fireball Y to Bowser's +16
	LDA <Objects_Y,X
	ADD #16
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA Objects_YHi,Y

	LDA Objects_FlipBits,X
	ASL A
	ASL A
	ROL A
	AND #$01
	TAX	
	STX <Temp_Var1		; X = 0 or 1, depending on if Bowser's horizontally flipped

	; Set X Velocity as appropriate
	LDA Bowser_FireballXVel,X
	STA Objects_XVel,Y

	LDX <SlotIndexBackup	 ; Restore 'X' to Bowser's object slot index

	; X Hi is just copied
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Set X appropriately offset from Bowser
	LDA <Objects_X,X
	LDX <Temp_Var1		
	ADD Bowser_FireballXOff,X
	STA Objects_X,Y	

	LDA RandomN,Y
	AND #$07	
	TAX		 ; X = random 0 to 7

	; A bit random how the fireball moves
	LDA PRG001_BB4B,X
	STA Objects_TargetingYVal,Y

	; Set fireball palette
	LDA #SPR_PAL1
	STA Objects_SprAttr,Y

	; Reset timer
	ASL A			; A = 0
	STA Objects_Timer,Y	

	; Fire breathing sound
	LDA #SND_LEVELFLAME
	STA Sound_QLevel2

	LDX <SlotIndexBackup	; Restore 'X' to Bowser's object slot index

	RTS		 ; Return


Bowser_Counter3Do:
	; If Bowser_Counter3 > 0, just decrement it.  Otherwise,
	; set it to some value $60 to $9F and set Bowser_Counter1 to $3F

	LDA Bowser_Counter3	  
	BNE PRG001_BBDC	 ; If Bowser_Counter3 <> 0, jump to PRG001_BBDC

	LDA RandomN,X
	AND #$3f
	ADC #$60
	STA Bowser_Counter3	 ; Bowser_Counter3 = $60 + (Random $00 to $3F)

	; Bowser Counter 1 = $3F
	LDA #$3f
	STA Bowser_Counter1

	RTS		 ; Return

PRG001_BBDC:
	DEC Bowser_Counter3	; Bowser_Counter3--
	RTS		 ; Return


	; Detect the left and right tiles underneath Bowser
Bowser_DetectTiles:
	; Apply Bowser's X and Y Velocities
	JSR Object_ApplyXVel	 
	JSR Object_ApplyYVel_NoLimit

	LDY <Objects_X,X	 ; Y = Bowser's X

	LDA <Objects_XVel,X
	BEQ PRG001_BBFC	 ; If Bowser is stopped horizontally, jump to PRG001_BBFC
	BMI PRG001_BBF4	 ; If Bowser is moving to the left, jump to PRG001_BBF4

	; Bowser moving to the right...

	; Prevent Bowser from moving off the right edge
	CPY #224
	BGE PRG001_BBF8	 ; If Bowser's X >= 224, jump to PRG001_BBF8
	BLT PRG001_BBFC	 ; Otherwise, jump to PRG001_BBFC

PRG001_BBF4:

	; Bowser moving to the left...

	; Prevent Bowser from moving off the left edge
	CPY #8
	BGE PRG001_BBFC	 ; If Bowser's X >= 8, jump to PRG001_BBFC

PRG001_BBF8:

	; Bowser could move off left or right edge, so stop him!
	LDA #$00
	STA <Objects_XVel,X

PRG001_BBFC:
	
	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_Var4,X
	CMP #$02
	BNE PRG001_BC0B	; If var 4 <> 2, jump to PRG001_BC0B

	; Store tile detected under Bowser's left
	LDA Object_TileFeet2
	STA Bowser_Tiles	 ; Store detected tile -> Bowser_Tiles

PRG001_BC0B:
	LDA <Objects_DetStat,X	; Get Bowser's detection status bits
	PHA		 	; Save them

	LDA <Objects_X,X	; Get Bowser's X
	PHA		 	; Save it

	; Detect the right tile under Bowser's feet
	ADD #16
	STA <Objects_X,X
	JSR Object_WorldDetectN1

	; Restore Bowser's X
	PLA
	STA <Objects_X,X

	PLA		 ; Restore Bowser's detection bits
	ORA <Objects_DetStat,X	 ; OR in the ones detected by the right tile check
	STA <Objects_DetStat,X	 ; Save the unified set (in case only one foot is actually on the floor)

	LDA <Objects_Var4,X
	CMP #$02
	BNE PRG001_BC2D	; If var 4 <> 2, jump to PRG001_BC2D

	; Store tile detected under Bowser's right
	LDA Object_TileFeet2
	STA Bowser_Tiles+1

PRG001_BC2D:
	RTS		 ; Return


	; X offsets to Bowser's tile under each side of him
Bowser_TileOffsets:	.byte 8, 24


	; Busts any breakable floor that Bowser has hit
Bowser_BustFloor:
	LDY #$01	 ; Y = 1 (two tiles to potentially smash)
PRG001_BC32:
	LDA Bowser_Tiles,Y	; Get this tile
	CMP #TILE2_SOLIDBRICK
	BNE PRG001_BC69	 	; If this tile is not the solid brick tile, jump to PRG001_BC69

	; Bowser hit brick!
	LDA #$00
	STA Bowser_Tiles,Y	; Clear this tile

	; Queue a block change to erase to background!
	LDA #CHNGTILE_DELETETOBG
	STA Level_ChgTileEvent

	; Aligned Bowser impact Y
	LDA <Objects_Y,X
	ADD #$30
	AND #$f0
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC #$00
	STA Level_BlockChgYHi

	; Aligned Bowser impact X
	LDA <Objects_X,X
	ADD Bowser_TileOffsets, Y
	AND #$f0
	STA Level_BlockChgXLo
	LDA <Objects_XHi,X
	ADC #$00
	STA Level_BlockChgXHi

	JMP PRG001_BC6D	 ; Jump to PRG001_BC6D

PRG001_BC69:
	DEY		; Y--
	BPL PRG001_BC32	; While Y >= 0, loop!

	RTS		 ; Return


PRG001_BC6D:

	; Smash block sound
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; Copy the bust values over (mainly because Bowser uses both)

	; Set the brick bust
	LDA #$02
	STA BrickBust_En

	; Brick bust upper Y
	LDA Level_BlockChgYLo
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr

	; Brick bust lower Y
	ADD #$08
	STA BrickBust_YLwr

	; Brick bust X
	LDA Level_BlockChgXLo
	SUB <Horz_Scroll	
	STA BrickBust_X

	; reset brick bust X distance, no horizontal
	LDA #$00
	STA BrickBust_XDist
	STA BrickBust_HEn

	; Brick bust Y velocity
	LDA #-$06
	STA BrickBust_YVel

	RTS		 ; Return


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
	; These are the patterns for every column of every row, by frame 
	; (12 sprites total per frame, last four values for padding?)
Bowser_SprPats:
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 0
	.byte $81, $83, $85, $71, $87, $89, $8B, $8D, $97, $99, $9B, $9D, $00, $00, $00, $00 ; Bowser frame 1
	.byte $9F, $A1, $A3, $A5, $A7, $A9, $AB, $AD, $8F, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 2
	.byte $9F, $A1, $B1, $A5, $B3, $B5, $B7, $AD, $B9, $91, $93, $95, $00, $00, $00, $00 ; Bowser frame 3
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $C9, $CB, $CB, $C9, $00, $00, $00, $FF ; Bowser frame 4
	.byte $71, $CF, $D1, $71, $D3, $D5, $F7, $D9, $DB, $DD, $DF, $E1, $00, $00, $00, $00 ; Bowser frame 5
	.byte $E3, $E5, $E5, $E3, $E7, $E9, $E9, $E7, $EB, $ED, $ED, $EB, $00, $00, $00, $FF ; Bowser frame 6
	.byte $71, $C3, $C3, $71, $C5, $C7, $C7, $C5, $EF, $F1, $F1, $EF, $00, $00, $00, $FF ; Bowser frame 7
	.byte $71, $CF, $D1, $71, $D3, $D5, $C1, $CD, $F9, $FB, $FD, $FF, $00, $00, $00, $00 ; Bowser frame 8

	; Sprite X offsets per sprite, horizontally flipped or not horizontally flipped
Bowser_SprXNotHFlipped:	.byte $00, $08, $10, $18, $00, $08, $10, $18, $00, $08, $10, $18
Bowser_SprXHFlipped:	.byte $18, $10, $08, $00, $18, $10, $08, $00, $18, $10, $08, $00

	; Sprite Y offsets per sprite, vertically flipped or not vertically flipped
Bowser_SprYNotVFlipped:	.byte $00, $00, $00, $00, $10, $10, $10, $10, $20, $20, $20, $20
Bowser_SprYVFlipped:	.byte $20, $20, $20, $20, $10, $10, $10, $10, $00, $00, $00, $00

	; Similar to Bowser_SprVVisLUT, marks sprite that should be
	; invisible if marked horizontally invisible
Bowser_SprHVisLUT:
	.byte $80, $40, $20, $10

	; Bowser's sprites are drawn straight through; this marks the
	; ones that should not be handled if vertically invisible
Bowser_SprVVisLUT:
	.byte $01, $01, $01, $01	; Top sprites
	.byte $02, $02, $02, $02	; Middle sprites
	.byte $04, $04, $04, $04	; Bottom sprites

	; Bowser uses fixed Sprite_RAM offsets, alternating which set he used every other tick
Bowser_SprRAMOff:
	.byte $50, $54, $58, $5C	; Top sprites
	.byte $60, $64, $68, $6C	; Middle sprites
	.byte $70, $74, $78, $7C	; Bottom sprites

	.byte $00, $00, $00, $00	; Unused, for alignment only (switches between these sets via 4 ASLs)

	.byte $DC, $D8, $D4, $D0	; Top sprites
	.byte $EC, $E8, $E4, $E0	; Middle sprites
	.byte $FC, $F8, $F4, $F0	; Bottom sprites


	; Bowser is a very large character drawn using 4x3 8x16-sized sprites
Bowser_Draw:
	JSR Object_CalcSpriteXY_NoHi	; Calculate the Sprite X and Y Low parts	 

	; Temp_Var1 = Bowser's Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; Temp_Var2 = Bowser's Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2	

	; Temp_Var3 and Temp_Var4 = Bowser's FlipBits
	LDA Objects_FlipBits,X
	STA <Temp_Var3		
	STA <Temp_Var4		

	; Temp_Var5 = Bowser's horizontal visibility flags
	LDA Objects_SprHVis,X
	STA <Temp_Var5	

	; Temp_Var6 = Bowser's vertical visibility flags
	LDA Objects_SprVVis,X
	STA <Temp_Var6

	LDY Objects_Frame,X
	CPY #$01
	BEQ PRG001_BDB4		; If Bowser's frame = 1, jump to PRG001_BDB4

	CPY #$07
	BNE PRG001_BDBB	 	; If Bowser's frame <> 7, jump to PRG001_BDBB

PRG001_BDB4:

	; Frame 7 is slightly lower than the others

	LDA <Temp_Var1
	ADD #$04
	STA <Temp_Var1

PRG001_BDBB:
	CPY #$08
	BEQ PRG001_BDD2	 ; If Bowser's frame = 8, jump to PRG001_BDD2

	CPY #$04
	BEQ PRG001_BDC7	 ; If Bowser's frame = 4, jump to PRG001_BDC7

	CPY #$06	 
	BLT PRG001_BDD2	 ; If Bowser's frame < 6, jump to PRG001_BDD2

PRG001_BDC7:

	; Bowser frame 4

	LDA Objects_FlipBits,X
	AND #SPR_VFLIP
	STA <Temp_Var3	 ; Temp_Var3 = $00 or SPR_VFLIP, depending whether Bowser is flipped vertically

	ORA #SPR_HFLIP
	STA <Temp_Var4	 ; Always set horizontal flip in Temp_Var4

PRG001_BDD2:
	LDA Objects_Frame,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var15	 ; Temp_Var15 = frame * 16

	LDA #$00
	STA <Temp_Var16

PRG001_BDDF:

	; This determines which Sprite_RAM offset table set we use.
	; Either 0 or 16, alternating every other frame.
	LDA <Counter_1
	AND #$01
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	ADD <Temp_Var16	 ; Temp_Var16 = current sprite we're on
	TAY		 ; -> 'Y'

	LDA Bowser_SprRAMOff,Y
	TAY		 ; Index -> 'Y'

	LDX <Temp_Var16	 ; X = current sprite

	LDA <Temp_Var6	 	; Get Bowser's vertical visibility flags
	AND Bowser_SprVVisLUT,X	
	BNE PRG001_BE49	 	; If this sprite should not be drawn due to vertically being off-screen, jump to PRG001_BE49

	; Sprites are 0 through 12, so each horizontal sprite is by modulus 4
	TXA
	AND #$03	; Essentially mod 4
	TAX
	LDA <Temp_Var5	 ; Temp_Var5 = 0 to 3 based on which horizontal sprite we're doing

	AND Bowser_SprHVisLUT,X
	BNE PRG001_BE49	 ; If this sprite should not be drawn due to beging horizontally off-screen, jump to PRG001_BE49

	LDA <Temp_Var15	
	ADD <Temp_Var16	 ; Temp_Var16 = (Bowser's frame * 16 [Temp_Var15]) + (which sprite we're on)
	TAX		 ; -> 'X'

	; Store pattern of this Bowser sprite
	LDA Bowser_SprPats,X
	STA Sprite_RAM+1,Y

	LDX <Temp_Var16	 ; X = Temp_Var16

	LDA <Temp_Var3
	BPL PRG001_BE1A	 ; If Bowser is not vertically flipped, jump to PRG001_BE1A

	; Otherwise, use the vertically flipped lookups
	TXA
	ADD #(Bowser_SprYVFlipped - Bowser_SprYNotVFlipped)
	TAX

PRG001_BE1A:
	LDA <Temp_Var1	 	; A = Temp_Var1 (Bowser's Sprite Y)
	ADD Bowser_SprYNotVFlipped,X	; Offset Y as appropriate for this sprite
	STA Sprite_RAM,Y	; Set sprite Y

	LDX <Temp_Var16		; X = Temp_Var16
	TXA		 	
	AND #$03	 	; Get which horizontal sprite (of 4) we're on
	CMP #$02	 	; Horizontal sprite 2 would be the beginning of the "right half" of Bowser

	LDA <Temp_Var3		; A = Temp_Var3 (Bowser's flip bits)
	BLT PRG001_BE30	 	; If we are on the left half of Bowser, jump to PRG001_BE30

	LDA <Temp_Var4		; A = Temp_Var4 (Bowser's flip bits alternate)

PRG001_BE30:
	ORA #SPR_PAL3	 	; Lock in palette 3
	STA Sprite_RAM+2,Y	; Store sprite attributes

	LDA <Temp_Var3
	AND #SPR_HFLIP
	BEQ PRG001_BE40	 ; If Bowser is not horizontally flipped, jump to PRG001_BE40

	; Otherwise, use the horizontally flipped lookups
	TXA		 
	ADD #(Bowser_SprXHFlipped - Bowser_SprXNotHFlipped)
	TAX

PRG001_BE40:
	LDA <Temp_Var2		 ; A = Temp_Var2 (Bowser's Sprite X)
	ADD Bowser_SprXNotHFlipped,X	 ; Offset X as appropriate for this sprite
	STA Sprite_RAM+3,Y	 ; Set sprite X

PRG001_BE49:
	INC <Temp_Var16		 ; Temp_Var16++ (next sprite)

	; Bowser is made of a total of 12 sprites (4x3)
	LDA <Temp_Var16
	CMP #12	 
	BNE PRG001_BDDF	 ; If Temp_Var16 <> 12, loop!

	LDX <SlotIndexBackup	 ; Restore 'X' as Bowser's object slot index

	RTS		 ; Return

Bowser_CalcPlayersSide:

	; Backup Bowser's X
	LDA <Objects_X,X
	PHA

	; +8 Bowser's X; calculation of which side the Player is on is offset
	ADD #$08
	STA <Objects_X,X
	JSR Level_ObjCalcXDiffs

	; Restore Bowser's X
	PLA
	STA <Objects_X,X

	RTS		 ; Return


Bowser_HandleIfDead:
	; Handle Bowser if he's dead either from falling or weapon

	LDA <Objects_YHi,X	 
	CMP #$01
	BLS PRG001_BE6F	 ; If Bowser is way up high, jump to PRG001_BE6F

	; Bowser's not too high...

	LDA <Objects_SpriteY,X
	CMP #$88
	BGE PRG001_BE7F	 ; If Bowser's Y >= $88, jump to PRG001_BE7F

	; Bowser's not too low yet

PRG001_BE6F:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG001_BE98	 ; If Bowser's state is Normal, jump to PRG001_BE98 (RTS)

	; Bowser's state not Normal, now set it to Normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Bowser got killed by weapon, set Bowser's Y velocity to -$30
	LDA #-$30
	STA <Objects_YVel,X

PRG001_BE7F:

	; Set Bowser's internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Disable timer
	LSR A	; A = 1
	STA Level_TimerEn

	; Set Bowser's frame to 6
	LDA #$06
	STA Objects_Frame,X

	; Clear Bowser's X Velocity and counter 1
	LDA #$00
	STA <Objects_XVel,X
	STA Bowser_Counter1

	; Set timer 3 to $30 (Delay until dramatic drop "song" begins)
	LDA #$30
	STA Objects_Timer3,X

PRG001_BE98:
	RTS		 ; Return


Bowser_FallAndSplat:
	LDY Objects_Timer3,X
	DEY		 ; Y--
	BNE PRG001_BEA4	 ; If timer 3 not expired, jump to PRG001_BEA4

	; Play dramatic Bowser fall
	LDA #MUS1_BOWSERFALL
	STA Sound_QMusic1

PRG001_BEA4:
	LDA Objects_HitCount,X
	CMP #$01
	BGS PRG001_BEB2	 ; If Bowser has at least one hit left, jump to PRG001_BEB2

	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

PRG001_BEB2:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	CMP #$25
	BGS PRG001_BEBD	 ; If Y velocity >= $25, jump to PRG001_BEBD

	INC <Objects_YVel,X	 ; Gravity while falling 

PRG001_BEBD:
	LDA <Objects_YHi,X
	CMP #$04	 
	BLS PRG001_BEDE	 ; If Bowser hasn't fallen down about 4 screens yet, jump to PRG001_BEDE

	; Bowser hits bottom...

	INC <Objects_Var5,X	 ; Objects_Var5 = 3

	; Set timer to $D0
	LDA #$d0
	STA Objects_Timer,X

	; Vibrate the floor 
	LDA #$80
	STA Level_Vibration

	; Ba-bam!
	LDA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA <Player_InAir
	BNE PRG001_BEDE		; If Player is mid-air, jump to PRG001_BEDE

	; Bounce Player if he's on the ground
	LDA #-$40
	STA <Player_YVel

	; Mark Player as mid-air
	INC <Player_InAir

PRG001_BEDE:
	LDA <Objects_Y,X	; Get Bowser's Y
	PHA			; Save it
	ADD #16			; +16
	STA <Objects_Y,X	; -> Bowser's Y

	LDA <Objects_YHi,X	; Get Bowser's Y Hi
	PHA		 	; Save it
	ADC #$00	 	; Apply carry
	STA <Objects_YHi,X	; -> Bowser's Y Hi

	JSR Object_DetermineVertVis	; Check if Bowser is vertically invisible

	; Restore Y and Y Hi
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	RTS		 ; Return

DoorAppear_YUpr:	.byte $60, $70
DoorAppear_X:	.byte $E8, $E8

PRG001_BEFB:	.byte $80, $88

Bowser_WaitAndVictory:
	LDA Objects_Timer,X	  
	BNE PRG001_BF09	 ; If timer hasn't expired, jump to PRG001_BF09 (RTS)

	; Play victory fanfare
	LDA #MUS1_WORLDVICTORY
	STA Sound_QMusic1

	INC <Objects_Var5,X	 ; Objects_Var5 = 3

PRG001_BF09:
	RTS		 ; Return

Bowser_DoTimeBonus:
	JSR DoTimeBonus	 ; Convert time to bonus score
	BNE PRG001_BF16	 ; If still counting down, jump to PRG001_BF16 (RTS)

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X

	INC <Objects_Var5,X	 ; Objects_Var5 = 4

PRG001_BF16:
	RTS		 ; Return


Bowser_DoorAppear:
	LDA Objects_Timer,X	  
	BEQ PRG001_BF45	 ; If timer expired, jump to PRG001_BF45

	; Otherwise...

	CMP #$10
	BNE PRG001_BF40	 ; If timer <> $10, jump to PRG001_BF40

	; Door appearance sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

	LDY #$01	 ; Y = 1 (two tiles for the final door)
PRG001_BF27:

	; Using brick bust for door change
	LDA #$01
	STA BrickBust_En,Y

	; Door appearance coordinates
	LDA DoorAppear_YUpr,Y
	STA BrickBust_YUpr,Y
	LDA DoorAppear_X,Y
	STA BrickBust_X,Y

	LDA #$1f
	STA BrickBust_HEn,Y

	DEY		 ; Y--
	BPL PRG001_BF27	; While Y >= 0, loop

PRG001_BF40:
	RTS		 ; Return

	; Different palette colors applied to door
Bowser_FinalDoorColorCycle:
	.byte $21, $2A, $31, $26

PRG001_BF45:
	; Patterns for door
	LDA #$3e 
	STA PatTable_BankSel+4 

	LDY #$01	 ; Y = 1 
PRG001_BF4C:
	LDX Object_SprRAM,Y	 ; X = Sprite RAM Offset
 
	; Store Y parts where door appears
	LDA DoorAppear_YUpr,Y 
	STA Sprite_RAM,X 
	STA Sprite_RAM+4,X
 
	; Door patterns
	LDA #$a1 
	STA Sprite_RAM+1,X 
	STA Sprite_RAM+5,X
 
	; Door attributes
	LDA #$01 
	STA Sprite_RAM+2,X 
	STA Sprite_RAM+6,X
 
	; Store X parts of door
	LDA DoorAppear_X,Y 
	STA Sprite_RAM+3,X 
	ADD #$08 
	STA Sprite_RAM+7,X 

	DEY		 ; Y-- 
	BPL PRG001_BF4C	 ; While Y >= 0, loop!
 
	LDA <Player_YHi 
	BEQ PRG001_BF9B	 ; If Player is not low, jump to PRG001_BF9B
 
	LDA <Player_X 
	SUB #$e4 
	CMP #$08 
	BGE PRG001_BF9B	 ; If Player is way to the right, jump to PRG001_BF9B

	LDA <Player_Y 
	CMP #$48 
	BLT PRG001_BF9B	 ; If Player is higher than Y 48, jump to PRG001_BF9B

	; Player is low enough and not way to the right
	LDA <Pad_Holding 
	AND #PAD_UP
	BEQ PRG001_BF9B	 ; If Player is not pressing UP, jump to PRG001_BF9B
 
	; Jump to princess rescue scene
	STA Player_RescuePrincess	; Flag for princess rescue! 
	LDA #$00 
	STA Map_ReturnStatus 
	INC Level_ExitToMap 

PRG001_BF9B:
	LDA <Counter_1 
	LSR A	 
	LSR A	 
	AND #$03	 ; A = 0 to 3 
	TAY		 ; -> 'Y'

	; Store cycle color into palette buffer
	LDA Bowser_FinalDoorColorCycle,Y 
	STA Palette_Buffer+$15 

	; Queue palette update!
	LDA #$06
	STA Graphics_Queue 

	LDX <SlotIndexBackup	; X = object slot index 
	RTS		 ; Return

; Rest of ROM bank was empty

