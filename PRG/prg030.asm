; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-11 19:37:01.275664050 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; STANDARD HORIZONTAL SCREEN

Tile_Mem_Addr:	
	; This breaks up the overall "tile" layout memory into screen-based chunks
	; With a screen width of 256 pixels, that makes 16 blocks across every "screen",
	; NTSC res of 224, two screens tall, is 448 / 16px-per-tile = 28 POTENTIAL rows per screen
	; but the status bar occludes one, so only 27 rows are stored... 
	; Up to 15 screens!
	.word Tile_Mem,       Tile_Mem+$01B0, Tile_Mem+$0360, Tile_Mem+$0510, Tile_Mem+$06C0, Tile_Mem+$0870, Tile_Mem+$0A20, Tile_Mem+$0BD0
	.word Tile_Mem+$0D80, Tile_Mem+$0F30, Tile_Mem+$10E0, Tile_Mem+$1290, Tile_Mem+$1440, Tile_Mem+$15F0, Tile_Mem+$17A0


	; ALTERNATE VERTICAL SCREEN

	; Each "screen" (stacked vertically) is made up of 15 rows of tiles
	; which amounts to $F0 bytes per screen; the following split LUT defines tile memory
	; offsets gapped by $F0... not sure why they had to make the address lookup into two LUTs
	; like they did, but whatever... 16 vertical screens available

	; High bytes are separate from low
Tile_MemH = HIGH(Tile_Mem)

	; Vertical low byte, per screen
Tile_Mem_AddrVL:
	.byte $00, $F0, $E0, $D0, $C0, $B0, $A0, $90, $80, $70, $60, $50, $40, $30, $20, $10

	; Vertical high byte, per screen
Tile_Mem_AddrVH:
	.byte Tile_MemH+$0, Tile_MemH+$0, Tile_MemH+$1, Tile_MemH+$2
	.byte Tile_MemH+$3, Tile_MemH+$4, Tile_MemH+$5, Tile_MemH+$6
	.byte Tile_MemH+$7, Tile_MemH+$8, Tile_MemH+$9, Tile_MemH+$A
	.byte Tile_MemH+$B, Tile_MemH+$C, Tile_MemH+$D, Tile_MemH+$E



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This table contains commands for Video_Misc_Updates which tells
; it how to generate certain graphical elements programatically
;
; Format:
;	[2B TVA][CMD][DATA]
;	TVA: Target Video Address, typ. inside the nametable somewhere
;	CMD: 	- Bit 7 set = Use vertical updates (32B) else use horizontal (1B)
;		- Bit 6 set = Means that there is only one byte of DATA, repeated
;		- Bits 0-5  = Count of bytes to write directly to PPU 
;	DATA: Raw byte(s) to write to the PPU, count specified by CMD
; After a data chunk has been read, a new TVA is expected, or a $00 byte which terminates the stream.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Remember that the left edge is typically clipped, so nothing is visible there...
Video_Upd_Table: ; $803E
	.word Graphics_Buffer	; $00 - Graphics buffer for dynamically generated content
	.word Video_DoStatusBarV; $01 - status bar (vertical level)
	.word Video_DoStatusBar	; $02 - status bar (typical)
	.word $A000		; $03 - ???
	.word $A06F		; $04 - ???
	.word Video_DoStatusBarHM; $05 - status bar appropriate for horizontal mirroring
	.word Video_DoPalUpd	; $06 - Updates palettes per values in the $07BE+ Palette_* vars; used during fade in/out routines
	.word Video_RoulBordAttr; $07 - Roulette sliders border and attribute settings
	.word Bonus_InstBoxTop	; $08 - Top of Bonus Game instruction box
	.word Bonus_InstBoxLine1; $09 - First line of Bonus Game instruction box
	.word Bonus_InstBoxLine2; $0A - Second line of Bonus Game instruction box
	.word Bonus_InstBoxLine3; $0B - Third line of Bonus Game instruction box
	.word Bonus_InstBoxBot	; $0C - Bottom of Bonus Game instruction box
	.word Video_NSpadeBG	; $0D - N-Spade candy striping background
	.word Video_DoWXMario00	; $0E - "World X" Intro, Mario (horizontal scroll at $00)
	.word Video_DoWXLuigi00	; $0F - "World X" Intro, Luigi (horizontal scroll at $00)
	.word Video_DoWXMario80	; $10 - "World X" Intro, Mario (horizontal scroll at $80)
	.word Video_DoWXLuigi80	; $11 - "World X" Intro, Luigi (horizontal scroll at $80)
	.word Video_DoGameOver00; $12 - "GAME OVER" Box (horizontal scroll at $00)
	.word Video_DoGameOver80; $13 - "GAME OVER" Box (horizontal scroll at $80)
	.word Video_Blackout	; $14 - Blacks out 3 colors, used during end-level triple card match; not sure what for?
	.word Video_3CMMushTop	; $15 - End Level Triple Card Match: Mushroom top
	.word Video_3CMFlowTop	; $16 - End Level Triple Card Match: Flower top
	.word Video_3CMStarTop	; $17 - End Level Triple Card Match: Star top
	.word Video_3CMMushLeft	; $18 - End Level Triple Card Match: Mushroom left spot
	.word Video_3CMFlowDiag	; $19 - End Level Triple Card Match: Flower inner diagonal
	.word Video_3CMStarTip	; $1A - End Level Triple Card Match: Star eyes and tips
	.word Video_3CMMushMid	; $1B - End Level Triple Card Match: Mushroom eyes and middle
	.word Video_3CMFlowMid	; $1C - End Level Triple Card Match: Flower middle
	.word Video_3CMStarSide	; $1D - End Level Triple Card Match: Star left/right sides
	.word Video_3CMMushRight; $1E - End Level Triple Card Match: Mushroom right spot
	.word Video_3CMFlowStem	; $1F - End Level Triple Card Match: Flower stem
	.word Video_3CMStarBot1	; $20 - End Level Triple Card Match: Star near bottom
	.word Video_3CMMushBot	; $21 - End Level Triple Card Match: Mushroom bottom
	.word Video_3CMFlowBot	; $22 - End Level Triple Card Match: Flower bottom
	.word Video_3CMStarBot2	; $23 - End Level Triple Card Match: Star bottom
	.word Video_3CMAppear1	; $24 - End Level Triple Card Match: Make big shape appear attribute change 1
	.word Video_3CMAppear2	; $25 - End Level Triple Card Match: Alters palette
	.word Video_3CMAppear3	; $26 - End Level Triple Card Match: Make big shape appear attribute change 2
	.word Video_3CMAppear4	; $27 - End Level Triple Card Match: Make big shape appear attribute change 3
	.word Video_3CMAppear5	; $28 - End Level Triple Card Match: Make big shape appear attribute change 4
	.word Video_3CMAppear6	; $29 - End Level Triple Card Match: Make big shape appear attribute change 5
	.word Video_3CMAppear7	; $2A - End Level Triple Card Match: Make big shape appear attribute change 6
	.word Video_DoW2WZ	; $2B - "WELCOME TO WARP ZONE" banner
	.word Video_YouGotCardH	; $2C - "YOU GOT A CARD" (and the card space) [for the End Level Triple Card Match]
	.word Video_CourseClear	; $2D - "COURSE CLEAR"
	.word Video_YouGotCard	; $2E - "YOU GOT A CARD" (and the card space) [for the End Level otherwise]

	; The status bar comes in three identical versions with different VRAM start addresses
	; Might as well make a macro out of that, eh?

	; NOTE!! If you want to edit the status bar, you should also sync up
	; with the "flip" data in PRG026 as noted below...
StatusBar	.macro

	; Sync next three with PRG026 Flip_TopBarCards
	vaddr \1 + $00
	.byte $02, $FC, $A0		; Upper left corner

	vaddr \1 + $02
	.byte VU_REPEAT | $12, $A1	; Bar across the top

	vaddr \1 + $14
	.byte $0C, $A2, $A0, $A1, $A1, $A3, $A1, $A1, $A3, $A1, $A1, $A2, $FC	; top of card slots

	; Sync this with PRG026 Flip_MidTStatCards
	vaddr \1 + $20
	.byte $20, $FC, $A6, $70, $71, $72, $73, $FE, $FE, $EF, $EF, $EF, $EF, $EF, $EF, $3C	; |WORLD  >>>>>>[P] $  | |  | |  | |  | |
	.byte $3D, $FE, $EC, $F0, $F0, $A7, $A6, $FE, $FE, $AA, $FE, $FE, $AA, $FE, $FE, $A7, $FC
	; Discrepency --------^  (Pattern is ... $FE, $F0 ... in PRG026 status bar graphics)

	; Sync this with PRG026 Flip_MidBStatCards
	vaddr \1 + $40
	; Discrepency --------v  (Pattern is ... $FE, $FE ... in PRG030 status bar)  Unimportant; inserts <M> which is replaced anyway
	.byte $20, $FC, $A6, $FE, $FE, $FB, $FE, $F3, $FE, $F0, $F0, $F0, $F0, $F0, $F0, $F0	; [M/L]x  000000 c000| etc.
	.byte $FE, $ED, $F4, $F0, $F0, $A7, $A6, $FE, $FE, $AA, $FE, $FE, $AA, $FE, $FE, $A7, $FC
	; Discrepency --------^  (Pattern is ... $F4, $F0 ... in PRG030 status bar graphics)

	; Sync next three with PRG026 Flip_BottomBarCards
	vaddr \1 + $60
	.byte $02, $FC, $A8	; Lower corner

	vaddr \1 + $62
	.byte VU_REPEAT | $12, $A4	; Bottom bar

	vaddr \1 + $74
	.byte $0C, $A5, $A8, $A4, $A4, $A9, $A4, $A4, $A9, $A4, $A4, $A5, $FC	; lower corner and card bottoms

	; End PRG026 sync

	vaddr \1 + $80
	.byte VU_REPEAT | $20, $FC	; black space

	vaddr \1 + $A0
	.byte VU_REPEAT | $20, $FC	; black space

	; Terminator
	.byte $00
	.endm

	; Typical status bar (vertical level)
Video_DoStatusBarV:
	StatusBar $2700

	; Typical status bar (non-vertical level)
Video_DoStatusBar:
	StatusBar $2B00

	; Status bar used when Horizontal Mirroring in effect (Roulette game)
Video_DoStatusBarHM:
	StatusBar $2300

Video_3CMStarTop:
	vaddr $208F
	.byte VU_REPEAT | $02, $A9
	vaddr $20AE
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $20B1
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $20ED
	.byte $01, $A9
	vaddr $20F2
	.byte $01, $A9
	vaddr $2108
	.byte VU_REPEAT | $06, $A9
	vaddr $2112
	.byte VU_REPEAT | $06, $A9
	.byte $00	; Terminator

Video_3CMStarTip:
	vaddr $2128
	.byte $01, $A9
	vaddr $2137
	.byte $01, $A9
	vaddr $2149
	.byte $01, $A9
	vaddr $214E
	.byte VU_VERT | VU_REPEAT | $03, $A9
	vaddr $2151
	.byte VU_VERT | VU_REPEAT | $03, $A9
	vaddr $2156
	.byte $01, $A9
	.byte $00	; Terminator

Video_3CMStarSide:
	vaddr $216A
	.byte $01, $A9
	vaddr $2175
	.byte $01, $A9
	vaddr $218B
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $2194
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $21CA
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $21D5
	.byte VU_VERT | VU_REPEAT | $02, $A9
	.byte $00	; Terminator

Video_3CMStarBot1:
	vaddr $2209
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $220F
	.byte VU_REPEAT | $42, $A9
	vaddr $2216
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $222D
	.byte VU_REPEAT | $02, $A9
	vaddr $2231
	.byte VU_REPEAT | $02, $A9
	.byte $00	; Terminator

Video_3CMStarBot2:
	vaddr $2248
	.byte $05, $A9, $FC, $FC, $A9, $A9
	vaddr $2253
	.byte $05, $A9, $A9, $FC, $FC, $A9
	vaddr $2268
	.byte VU_REPEAT | $03, $A9
	vaddr $2275
	.byte VU_REPEAT | $03, $A9
	.byte $00	; Terminator

Video_3CMAppear1:
	vaddr $23CA
	.byte VU_REPEAT | $04, $FF
	vaddr $23D2
	.byte VU_REPEAT | $04, $FF
	vaddr $23DA
	.byte VU_REPEAT | $04, $FF
	vaddr $23E2
	.byte VU_REPEAT | $04, $FF
	.byte $00	; Terminator

Video_3CMAppear3:
	vaddr $23D3
	.byte $02, $BF, $EF
	vaddr $23DB
	.byte $02, $FB, $FE
	.byte $00	; Terminator
	
Video_3CMAppear4:
	vaddr $23D3
	.byte $02, $6A, $9A
	vaddr $23DB
	.byte $02, $A6, $A9
	.byte $00	; Terminator

Video_3CMAppear5:
	vaddr $23CA
	.byte $04, $BF, $AF, $AF, $EF
	vaddr $23D2
	.byte $04, $BB, $55, $55, $EE
	vaddr $23DA
	.byte $04, $BB, $55, $55, $EE
	vaddr $23E2
	.byte $04, $FB, $FA, $FA, $FE
	.byte $00	; Terminator

Video_3CMAppear6:
	vaddr $23CA
	.byte $04, $7F, $5F, $5F, $DF
	vaddr $23D2
	.byte $04, $77, $55, $55, $DD
	vaddr $23DA
	.byte $04, $77, $55, $55, $DD
	vaddr $23E2
	.byte $04, $F7, $F5, $F5, $FD
	.byte $00	; Terminator

Video_3CMAppear7:
	vaddr $23CA
	.byte VU_REPEAT | $04, $55
	vaddr $23D2
	.byte VU_REPEAT | $04, $55
	vaddr $23DA
	.byte VU_REPEAT | $04, $55
	vaddr $23E2
	.byte VU_REPEAT | $04, $55
	.byte $00	; Terminator

	; Blacks out a little bit of the palette during end level triple-card match sequecnce
Video_Blackout:
	vaddr $3F0D
	.byte VU_REPEAT | $03, $0F, $00


Video_3CMAppear2:
	vaddr $3F05
	.byte $03

EndLevelCard_PalData:
	.byte $0F, $30, $3C
	vaddr $3F09
	.byte $03, $0F, $10, $2C
	vaddr $3F0D
	.byte VU_REPEAT | $03, $0F
	.byte $00	; Terminator

Video_YouGotCardH:
	vaddr $22C7
	.byte $13
	;       Y    O    U         G    O    T         A         C    A    R    D         |              |
	.byte $0D, $0E, $0A, $FC, $06, $0E, $09, $FC, $00, $FC, $05, $00, $02, $07, $FC, $26, $FE, $FE, $27
	vaddr $22B6
	.byte $04 ;  _    _    _   _
	;           |               |
	.byte      $20, $21, $21, $22

	vaddr $22F6
	.byte $04
	;       |              |
	.byte $26, $FE, $FE, $27

	vaddr $2316
	.byte $04
	;      |_    _    _   _|
	.byte $28, $24, $24, $25

	.byte $00	; Terminator

Video_CourseClear:
	vaddr $2889
	.byte $0E
	;       C    O    U    R    S    E         C    L    E    A    R         !
	.byte $85, $8E, $8A, $82, $83, $84, $FC, $85, $8B, $84, $80, $82, $FC, $9B, $00

Video_YouGotCard:
	vaddr $28E7
	.byte $13
	;       Y    O    U         G    O    T         A         C    A    R    D         |              |
	.byte $8D, $8E, $8A, $FC, $86, $8E, $89, $FC, $80, $FC, $85, $80, $82, $87, $FC, $A6, $FE, $FE, $A7

	vaddr $28D6
	.byte $04 ;  _    _    _   _
	;           |               |
	.byte      $A0, $A1, $A1, $A2

	vaddr $2916
	.byte $04
	;       |              |
	.byte $A6, $FE, $FE, $A7

	vaddr $2936
	.byte $04
	;      |_    _    _   _|
	.byte $A8, $A4, $A4, $A5
	.byte $00	; Terminator

	.byte $AF, $11

Map_Y_Starts:
	; Map Y start positions, World 1-8 (X is always $20)
	.byte $40, $A0, $A0, $40, $80, $60, $30, $50

	; A clear pattern set by Level_Tileset (for use with Clear_Nametable_Short)
ClearPattern_ByTileset:
	.byte $FF	; 0 - Map
	.byte $FC	; 1 - Plains
	.byte $FF	; 2 - Mini fortress style
	.byte $FC	; 3 - Hills style
	.byte $FC	; 4 - High-Up style
	.byte $FC	; 5 - pipe world plant infestation
	.byte $FC	; 6 - Water world
	.byte $FF	; 7 - Toad house
	.byte $FF	; 8 - Vertical pipe maze
	.byte $FC	; 9 - desert level
	.byte $FC	; 10 - airship
	.byte $FC	; 11 - Giant World
	.byte $FC	; 12 - ice level
	.byte $FC	; 13 - coin heaven / sky level
	.byte $FC	; 14 - underground
	.byte $FF	; 15 - bonus game intro
	.byte $FF	; 16 - spade game sliders
	.byte $FF	; 17 - N-spade
	.byte $FC	; 18 - 2P Vs


	.byte $AB, $83, $C6, $83, $CD, $83

	; This single byte is used in plant infestation levels to load the animation counter
PlantInfest_ACnt_MaxConst:	.byte (PlantInfest_PTPAC_End - PlantInfest_PatTablePerACnt - 1)
PlantInfest_PatTablePerACnt:
	.byte $60, $60, $60, $60, $60, $60, $60, $60, $60, $60, $62, $64, $66, $3E, $3E, $3E
	.byte $3E, $3E, $3E, $3E, $3E, $3E, $3E, $66, $64, $62, $06
PlantInfest_PTPAC_End

	.byte $34, $36, $38, $3A, $3C
	.byte $3E, $08, $34, $36, $38, $36, $34, $3A, $3E, $3A

	; List of C000 pages to switch to by Level_Tileset
PAGE_C000_ByTileset: ; $83D6
	.byte 10, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 22, 22, 22, 14

	; List of A000 pages to switch to by Level_Tileset
PAGE_A000_ByTileset: ; $83E9
	.byte 11, 15, 21, 16, 17, 19, 18, 18, 18, 20, 23, 19, 17, 19, 13, 26, 26, 26, 9

	; The normal level VROM page cycle set
PT2_Anim:	.byte $60, $62, $64, $66

PAUSE_Sprites:
	.byte $58, $F1, $03, $60	; P
	.byte $58, $F5, $03, $70	; A
	.byte $58, $F9, $03, $80	; U
	.byte $58, $FD, $03, $90	; S
	.byte $58, $FF, $03, $A0	; E
PAUSE_Sprites_End

	; The BGM per world (see also World_BGM_Restore in PRG010)
World_BGM:	
	.byte MUS2A_WORLD1, MUS2A_WORLD2, MUS2A_WORLD3, MUS2A_WORLD4
	.byte MUS2A_WORLD5, MUS2A_WORLD6, MUS2A_WORLD7, MUS2A_WORLD8
	.byte MUS2A_WARPWHISTLE

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; IntReset_Part2
	;
	; Part 2 of the Reset routine...
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IntReset_Part2:
	LDA PPU_STAT	 ;
	BPL IntReset_Part2 ; Wait until VBlank
	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg
	STA PPU_CTL1	 ; Most likely just to disable further Resets

	; Map_Unused7992 = 0 (used only in dead code it seems)
	LDA #$00
	STA Map_Unused7992

	; Note: This is setting up the address $7F00 @ $00/$01, the last page of SRAM
	LDY #$00	 ; Y = $00
	STY <Temp_Var1	 ; <Temp_Var1 = $00
	LDA #$7f	 ; A = $7F
	STA <Temp_Var2	 ; <Temp_Var2 = $7F

	; The following loop clears all of $6000 - $7FFF ... a lot of RAM!
PRG030_8437:
	LDA #$00	 	; A = 0
	STA [Temp_Var1],Y	; Clear 
	DEY			; Y--
	BNE PRG030_8437	 	; While Y is not zero, loop (since Y started at 0, this does a full 256 bytes)

	; This decrement then moves to $7E, $7D ... $60
	DEC <Temp_Var2	 ; Next lower page
	LDA <Temp_Var2	 ; Get page -> A
	CMP #$5f	 ; 
	BNE PRG030_8437	 ; If A <> $5F, loop again (clears down to $6000)

	; Clear $07FF - $0000, excluding $01xx
	LDY #$07
	JSR Clear_RAM_thru_ZeroPage

	; Reset_Latch = $5A (magic value that prevents reset vector from being run)
	LDA #$5a
	STA Reset_Latch

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; Middle byte of the N-Spade score
	LDA #HIGH(8000)
	STA Map_NSpade_NextScore+1

	; Lowest byte of the N-Spade score
	LDA #LOW(8000)
	STA Map_NSpade_NextScore+2

PRG030_845A:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	; Load title screen graphics
	LDA #$78
	STA PatTable_BankSel
	LDA #$7a	
	STA PatTable_BankSel+1
	LDA #$20	
	STA PatTable_BankSel+2
	LDA #$21	
	STA PatTable_BankSel+3
	LDA #$04	
	STA PatTable_BankSel+4
	LDA #$7f	
	STA PatTable_BankSel+5

	; Load page 24 into A000 and page 25 into C000
	LDA #24	 
	STA PAGE_A000
	LDA #25	 
	STA PAGE_C000
	JSR PRGROM_Change_Both2	

	LDA #$20
	STA Update_Select	 ; Update_Select = $20 (Title Screen)
	STA Raster_Effect	 ; Raster_Effect = $20 (Title Screen style)

	LDA #%10101000
	STA PPU_CTL1	 	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	JSR Do_Title_Screen	; Do the title screen!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BEGINNING INITIALIZATION OF WORLD MAP!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG030_84A0:

	; Load page 11 into A000 and page 10 into C000
	LDA #10
	STA PAGE_C000
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_Both2	


	JSR Map_Init	 ; Initialize map variables (page 11)

	LDA #$00
	STA Map_Operation	; Map_Operation = 0 ("World X" intro)
	STA BigQBlock_GotIt	; Clear the opened Big ? Block variable
	STA Map_Airship_Dest	; Map_Airship_Dest = 0
	STA Map_Got13Warp	; Clear the "Got 1-3 Warp Whistle" flag
	STA Map_Anchored	; Map_Anchored = 0 (not anchored yet)

	; Map_UnusedGOFlag = $F8?
	LDA #$f8
	STA <Map_UnusedGOFlag

	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg

	; Stop Update_Select activity temporarily while we initialize
	INC UpdSel_Disable

	; The following clears Map_Completions (stores completed levels on the map)
	LDY #$7f	 ; Y = $7F
	LDA #$00	 ; A = $00
PRG030_84D1:
	STA Map_Completions,Y
	DEY		 ; Y--
	BPL PRG030_84D1	 ; While Y >= 0, loop!

PRG030_84D7:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	; Init for lost bonus game??
	LDA #$2b
	STA Bonus_UnusedVH
	LDA #$35
	STA Bonus_UnusedVL

	LDA #$00
	STA Level_Tileset	; Level_Tileset = 0
	STA Map_Unused72C 	; Map_Unused72C = 0
	STA Map_March_Count	; Not sure about this
	STA Raster_Effect	; Raster Effects disabled
	STA UpdSel_Disable 	; Stop Update_Select activity
	STA Vert_Scroll_Off	; Vert_Scroll_Off = 0

	; Init for lost bonus game??
	LDA #$04
	STA BonusText_CharPause
	STA Bonus_DieCnt

	; Reload the timer tick for the next time it's used
	LDA #$28	
	STA Level_TimerTick

	; Unused699 = 3 (never used)
	LDA #$03	 
	STA Unused699

	; Update_Select = $C0
	LDA #$c0	 	
	STA Update_Select

	; Load world map graphics
	LDA #$14
	STA PatTable_BankSel
	LDA #$16
	STA PatTable_BankSel+1
	LDX #$20
	STX PatTable_BankSel+2
	INX
	STX PatTable_BankSel+3
	INX
	STX PatTable_BankSel+4
	INX
	STX PatTable_BankSel+5

	; Changes pages at A000 and C000 based on value Level_Tileset (0)
	JSR SetPages_ByTileset	 ;	A000 = Page 11, C000 = Page 10

	LDX Player_Current	; X = Player_Current
	LDA #(Inventory_Score - Inventory_Items)	; Base offset to score from Inventory_Items
	CPX #$00	 	; 
	BEQ PRG030_853F	 	; If X = 0 (Player is Mario), jump to PRG030_853F
	ADD #(Inventory_Score2 - Inventory_Score)	 ; Otherwise, add $23

PRG030_853F:
	TAY		 ; Y = $1F (Mario) or $42 (Luigi)

	; Copies the 3 byte score of this Player to the status bar
	; loading area to display their score...
	LDX #$00	 ; X = 0
PRG030_8542:
	LDA Inventory_Items,Y	; Starts at $1F or $42, score offset
	STA Player_Score,X	; Store into buffer area..
	INY		 	; Y++
	INX		 	; X++
	CPX #$03	 
	BNE PRG030_8542	 ; While X <> 3, loop


	; Init Player's on map
	LDX Total_Players
	DEX		 ; X = Total_Players-1
PRG030_8552:
	; Set Player's Y position
	LDA Map_Entered_Y,X
	STA <World_Map_Y,X

	; Set Player's X position
	LDA Map_Entered_XHi,X
	STA <World_Map_XHi,X
	LDA Map_Entered_X,X
	STA <World_Map_X,X

	LDA Map_Previous_UnusedPVal2,X
	STA <Map_UnusedPlayerVal2,X

	; Map_UnusedPlayerVal = $20 each Player (not used for anything)
	LDA #$20
	STA <Map_UnusedPlayerVal,X

	DEX		 ; X--
	BPL PRG030_8552	 ; If more players to initialize, loop!

	LDA #$00	 
	STA Level_Tileset	 ; Map uses Level_Tileset = 0
	STA World_EnterState	 ; World_EnterState = 0 (just arriving)
	STA <Map_EnterLevelFX	 ; Scratch = 0
	STA <Map_Intro_CurStripe ; Start with the first "strip" of erasing the World X intro box
	STA <Map_WarpWind_FX	 ; No warp whistle wind effects
	STA Map_Intro_Tick	 ; Map_Intro_Tick = 0 (forces init in some functions)

PRG030_857E:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	LDA #$01	 
	STA MMC3_MIRROR	 ; Set vertical mirroring

	LDX Player_Current	 ; X = current Player index

	LDA World_Map_Power,X	; X = Player's current world map power
	STA Map_Power_Disp	; Set as powerup currently displayed 

	LDY #$00	 ; "Darkness" flag (only works correctly on World 8 level 2)
	LDA World_Num	 ; A = World_Num
	CMP #$07	 
	BNE PRG030_85A5	 ; If this is NOT World 8, jump to PRG030_85A5

	; We're in World 8...
	LDA <World_Map_XHi,X
	CMP #$02	 
	BNE PRG030_85A5	 ; If NOT on the third level of World 8, jump to PRG030_85A5
	INY		 ; Activate darkness

PRG030_85A5:
	STY World_8_Dark ; Set the darkness flag

	; Not sure what this assignment means here?
	LDA #$00
	STA Bonus_UnusedFlag

	; Changes pages at A000 and C000 based on value Level_Tileset (0)
	JSR SetPages_ByTileset	 ;	A000 = Page 11, C000 = Page 10

	JSR Scroll_Map_SpriteBorder	; Draw sprite-based border on map

	; Set A000 page to 12
	LDA #12
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	JSR Map_Reload_with_Completions	 	; Load map and set already completed levels
	JSR Fill_Tile_AttrTable_ByTileset	; Load tile attribute tiles by the tileset

	LDA Inventory_Open	
	BNE PRG012_85CE		; If Inventory is open, jump to PRG012_85CE

	; If Inventory is not open
	LDX Player_Current	; X = Player_Current

	LDA Map_Previous_Dir,X 	; Get Player's previous moment direction
	STA <World_Map_Dir,X	; Restore it

PRG012_85CE:
	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync

	LDY Player_Current	; Y = current Player index

	; This sets up the scroll correctly given wherever the Player last was on the map
	LDA Map_Prev_XOff,Y	 
	STA <Scroll_Temp	 ; Scroll_Temp = X offset
	LDA Map_Prev_XHi,Y	 ; A = hi byte of X offset
	JSR Scroll_Update_Ranges ; Off to Scroll_Update_Ranges...

	LDA #$00	 
	STA <Scroll_LastDir	 ; Scroll_LastDir = 0

	LDA <Scroll_ColumnL	
	STA <Scroll_ColumnR	; Scroll_ColumnR = Scroll_ColumnL

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

	; This (re)draws the status bar
	LDA #$02
	JSR Video_Do_Update

	; Switch to page 26 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #26		
	STA MMC3_PAGE	 

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	LDA #$00	 		; Commit graphics in Graphics_Buffer
	JSR Video_Do_Update		; Do it!

	JSR Scroll_Dirty_Update 	; Do a full draw of the map tiles

	; Clear all the map object Y to zero!
	LDY #$0d	 ; Y = $D
	LDA #$00	 ; A = 0
PRG030_8617:
	STA Map_Object_ActY,Y
	DEY		 ; Y--
	BPL PRG030_8617	 ; While Y >= 0, loop!

	LDA World_8_Dark
	BEQ PRG030_8625	 	; If World_8_Dark = 0 (not doing the effect), jump to PRG030_8625

	JSR Map_W8DarknessFill	; Fill in the entire screen with black

PRG030_8625:
	LDA World_Num	 
	CMP #$08
	BNE PRG030_8634	 ; If World_Num <> 8 (World 9 / Warp Zone), jump to PRG030_8634

	LDA #$2b	
	JSR Video_Do_Update	 ; Print the "WELCOME TO WARP ZONE" banner
	JSR PRGROM_Change_A000	 ; Fix bank A000

PRG030_8634:
	LDY Player_Current	 ; Y = Player_Current
	LDA Map_Prev_XOff,Y	 ; Get player's previous X offset (low byte)
	STA <Horz_Scroll	 ; Set the scroll to that
	STA <Scroll_Temp	 
	LDA Map_Prev_XHi,Y	 ; Get player's previous X offset (high byte) 
	STA <Horz_Scroll_Hi	 ; Store as current scroll "high"
	JSR Scroll_Update_Ranges

PRG030_8646:
	JSR Map_DrawAndPan	 ; Draw and pan map as necessary

	; Pushes any buffered graphics thru
	LDA #$00	 	
	JSR Video_Do_Update	

	LDA Map_DrawPanState
	BNE PRG030_8646	 	; If some kind of map drawing/panning activity is occurring, loop around

	LDA Map_Operation
	BNE PRG030_86A2	 	; If map operation is anything besides zero, jump to PRG030_86A2

	; Map_Operation = 0 ... the "World X" intro
	; Used at the beginning of a world, and alternating players
	LDA Inventory_Open
	BNE PRG030_86A2	; If inventory is open, jump to PRG030_86A2

	; Set bank at A000 to page 11
	LDA #11	
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_IntroAttrSave	; Pick up the current attribute info under the box

	LDX #$0E 		; X = 14 (standard $00 aligned box)

	LDA <Horz_Scroll 	; A = Horz_Scroll
	BEQ PRG030_8670	 	; If Horz_Scroll = 0, jump to PRG030_8670

	LDX #$10		; Otherwise, X = 16 (map halfway scroll $80 aligned box)
PRG030_8670:
	LDA Player_Current
	BEQ PRG030_8676		; If Player_Current = 0 (Mario), jump to PRG030_8676
	INX		 	; Otherwise, increment X (use Luigi's name!)
PRG030_8676:
	TXA		 	; A = X ($0E/$0F, $10/$11)
	JSR Video_Do_Update	; Do the World X intro box!

	JSR Map_ConfigWorldIntro	; Apply the world number and lives count

	; Push the buffered update
	LDA #$00
	JSR Video_Do_Update	 

	LDX World_Num	 	
	LDY World_BGM,X		; Get BGM index for this world
	CPX #4	 	
	BNE PRG030_8698		; If we're NOT on world 5, jump to PRG030_8698

	; World 5 special handling (Sky part different music)
	LDX Player_Current	; X = Player_Current
	LDA <World_Map_XHi,X	; Get the high byte of this Player's X position
	BEQ PRG030_8698	 	; If it's equal to 0 (the "lower" part of the Sky World), jump to PRG030_8698

	; Otherwise...
	LDY #MUS2A_SKY	 ; Use Sky music!
	JMP PRG030_869F	 

PRG030_8698:
	; Either not world 5, or ground-side of world 5
	LDA Map_MusicBox_Cnt	
	BEQ PRG030_869F		; If Map_MusicBox_Cnt = 0, jump to PRG030_869F
	LDY #MUS2A_MUSICBOX	 	; Otherwise, play the music box song

PRG030_869F:
	STY Sound_QMusic2	; Play BGM!

PRG030_86A2:
	LDA #$00
	STA Inventory_Open	; Inventory_Open = 0

	LDA #$ef	 	
	STA <Vert_Scroll	; Vert_Scroll = $EF (map always stays at this height)

	LDA #$c0	 	
	STA Update_Select	; Update_Select = $C0 (Normal)

	; Switch bank A000 to page 11
	LDA #11	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000
	JSR Map_DoAnimations	; On page 11

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Switch bank A000 to page 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

WorldMap_Loop:
	JSR GraphicsBuf_Prep_And_WaitVSync	; This is probably just using it to VSync
	JSR Sprite_RAM_Clear	 		; Clear sprites!

	; Switch bank A000 to page 11 
	LDA #11
	STA PAGE_A000	
	JSR PRGROM_Change_A000
	JSR Map_DoAnimations	; On page 11 -- animate world map

	LDA InvFlip_Counter
	BNE PRG030_86F9	 	; If InvFlip_Counter <> 0, jump to PRG030_86F9

	LDA Inventory_Open	
	BEQ PRG030_8715	 	; If Inventory_Open = 0, jump to PRG030_8715

PRG030_86F9:
	; Inventory_Open <> 0 && InvFlip_Counter = 0 ...

	; Switch bank A000 to page 26
	LDA #26	
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Map_DoInventory_And_PoofFX	; Do everything with that inventory bar (On page 26)

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000
	JSR PRGROM_Change_A000	

	JSR World5_Sky_AddCloudDeco	 ; World 5 sky area gets an extra cloud sprite (strange?)
	JSR WorldMap_UpdateAndDraw	 ; Update and draw map graphics
	JMP WorldMap_Loop	 	; Loop back around...

PRG030_8715:
	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_DoMap	 		; Do the map!

	LDA Map_Operation
	CMP #$02	 
	BLT PRG030_8732	 		; If Map_Operation < 2, jump to PRG030_8732 

	; Map_Operation >= 2...

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR StatusBar_UpdateValues	; Update status bar

PRG030_8732:
	LDY Map_Operation
	CPY #$0d	 
	BNE PRG030_873F	 		; If Map_Operation <> $D (Normal), jump to PRG030_873F

	LDA <Map_WarpWind_FX
	CMP #$03	 
	BEQ PRG030_874F	 		; If Map_WarpWind_FX = 3 (initialize for warp island), jump to PRG030_874F

PRG030_873F:
	; Map_WarpWind_FX <> 3 or Map_Operation <> $D...

	CPY #$04
	BEQ PRG030_874F	 		; If Map_Operation <> $4, jump to PRG010_874F

	CPY #$0f	 
	BLT WorldMap_Loop	 	; If Map_Operation < $F (edge scroll), jump to WorldMap_Loop

	; Map_Operation >= $F...

	LDX Player_Current	
	LDA Map_Player_SkidBack,X
	BEQ PRG030_87BD			; If Map_Player_SkidBack = 0, jump to PRG030_87BD

PRG030_874F:
	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeOut	 		; Fade out
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Likely just using this for VSync

	; Disable the display
	LDA #$00	 
	STA <PPU_CTL2_Copy
	STA PPU_CTL2	 

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	LDA <Map_WarpWind_FX
	BNE PRG030_8772	 		; If Map_WarpWind_FX <> 0 (warp wind is active), jump to PRG030_8772

	LDA Map_Operation
	CMP #$04	 
	BNE PRG030_8775	 		; If Map_Operation <> 4, jump to PRG030_8775

PRG030_8772:
	JMP PRG030_857E			; Jump to PRG030_857E (partial loop back)

PRG030_8775:
	; Map_Operation <> 4

	LDX Player_Current

	; Store current map scroll positions and Player positions 
	; into the respective backup variables...
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X

	LDA <Horz_Scroll_Hi	
	STA Map_Prev_XHi,X

	LDA <World_Map_Y,X
	STA Map_Entered_Y,X

	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X

	LDA <World_Map_X,X
	STA Map_Entered_X,X

	LDA <Map_UnusedPlayerVal2,X
	STA Map_Previous_UnusedPVal2,X	

	LDA #$00
	STA Map_Player_SkidBack,X

PRG030_879B:
	; Switch to the other Player (if any!)
	INX
	STX Player_Current
	CPX Total_Players
	BNE PRG030_87A9	 	; If not at the total Player count, jump to PRG030_87A9

	LDA #$00	 
	STA Player_Current	; Otherwise, back to 0 (basically keeps at 0 for 1P or goes 0, 1, 0, 1...)
PRG030_87A9:

	LDA Player_Current
	TAX		 
	LDA Player_Lives,X	
	BMI PRG030_879B	 	; If Player's lives are negative (dead!), jump to PRG030_879B (makes assumption at least ONE Player is alive...)

	LDA #$00
	STA Map_Operation		; Map_Operation = 0
	STA Map_PlayerLost2PVs	; Clear Map_PlayerLost2PVs

	JMP PRG030_84D7	 	; Jump to PRG030_84D7 (partial loop)

PRG030_87BD:
	; Map_Operation >= $F...

	JSR GraphicsBuf_Prep_And_WaitVSync	; Vertical sync

	; Copy the Player's positions into respective backup variables
	LDX Player_Current
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X
	LDA <Horz_Scroll_Hi
	STA Map_Prev_XHi,X
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X	
	STA Map_Entered_X,X	
	LDA <Map_UnusedPlayerVal2,X	
	STA Map_Previous_UnusedPVal2,X	

	LDA #$00
	STA <Map_EnterLevelFX		; Map_EnterLevelFX = 0
	STA Map_EntTran_BorderLoop	; Map_EntTran_BorderLoop = 0
	STA Update_Select		; Update_Select = 0
	STA World_EnterState		; World_EnterState = 0
 
	JSR Map_Clear_EntTranMem	; Clear entrance transition memory

	; Set initial "high" parts of VRAM addresses
	LDA #$28	 
	STA Map_EntTran_BVAddrH	 	; top VRAM high
	STA Map_EntTran_BVAddrH+2	; left VRAM high
	STA Map_EntTran_BVAddrH+3	; right VRAM high

	LDA #$2a	 
	STA Map_EntTran_BVAddrH+1	; bottom VRAM high

	LDA #$00	 
	STA Map_EntTran_BVAddrL	 	; top VRAM low
	STA Map_EntTran_BVAddrL+3	; right VRAM low

	LDA #$1f	 
	STA Map_EntTran_BVAddrL+2	; left VRAM low
	STA Map_EntTran_TBCnt	 	; Map_EntTran_TBCnt also happens to be $1f

	LDA #$e0	 
	STA Map_EntTran_BVAddrL+1	; bottom VRAM low

	LDA #$17	 
	STA Map_EntTran_LRCnt	 	; Map_EntTran_LRCnt = $17


	; Top 0, bottom 1, right 2, left 3
	LDX #$03	 	; X = 3
PRG030_881D:
	LDA <Scroll_ColumnL
	AND #$0f
	ASL A	
	ADD Map_EntTran_BVAddrL,X	; adds 2 per column scrolled
	STA Map_EntTran_BVAddrL,X
	DEX		 	; X--
	BPL PRG030_881D	 	; While X >= 0, loop!

	LDA Map_EntTran_BVAddrL+2
	AND #$1f	 
	STA Map_EntTran_BVAddrL+2

	LDA #$30
	STA Map_EntTran_Cnt	 ; Map_EntTran_Cnt = $30

	LDA #SND_MAPENTERLEVEL
	STA Sound_QMap	 ; Play "enter level" sound effect!

	; Loop until V-Blank is not occurring
PRG030_883E:
	LDA PPU_STAT
	AND #$80	
	BNE PRG030_883E	

	LDA #%10101000		; sprites on PT2, 8x16 sprites, generate V-Blank NMIs
	STA PPU_CTL1	 
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	; The actual border rendering occurs in the interrupt's "Update_Select" routine
	; which calls "Map_EnterLevel_Effect" in PRG026
PRG030_884C:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Just VSyncs

	LDA #$01
	STA <Map_EnterLevelFX	; Map_EnterLevelFX = 1

	LDX Map_EntTran_BorderLoop	; Get current border loop counter (0-3: Top 0, bottom 1, right 2, left 3)
	TXA
	AND #$02
	BEQ PRG030_887F		 	; If Map_EntTran_BorderLoop & 2 = 0, jump to PRG030_887F (means jump if doing top/bottom)

	; Left/right edge sprite removal check...

	; This calculates the border's relative X position -> Temp_Var1
	LDA Map_EntTran_BVAddrL,X
	ASL A
	ASL A
	ASL A
	SUB <Horz_Scroll
	STA <Temp_Var1		; Temp_Var1 = (Map_EntTran_BVAddrL[X] << 3) - Horz_Scroll

	; This goes through all system sprites and removes them as the encroaching black border hits them
	LDX #$00	 	; X = 0
PRG030_8868:
	LDA Sprite_RAM+$03,X	; Get this sprite's X coordinate
	AND #$f8	 	; Only considering its nearest-8 position (aligned to the pattern-based border)
	CMP <Temp_Var1		
	BNE PRG030_8876	 	; If this sprite hasn't been touched yet, jump to PRG030_8876

	LDA #$f8	 
	STA Sprite_RAM+$00,X	; Set this sprite's Y to $F8 (make invisible)

PRG030_8876:
	DEX
	DEX
	DEX
	DEX		 	; X -= 4
	BNE PRG030_8868	 	; While X <> 0, loop!

	JMP PRG030_88A5	 	; Jump to PRG030_88A5

PRG030_887F:
	; Top/bottom edge sprite removal check...

	; This calculates the border's relative Y position -> Temp_Var1
	LDA Map_EntTran_BVAddrL,X
	AND #$c0	
	STA <Temp_Var1
	LDA Map_EntTran_BVAddrH,X
	LSR A		
	ROR <Temp_Var1	
	LSR A		
	ROR <Temp_Var1	

	LDX #$00	 	; X = 0
PRG030_8891:
	LDA Sprite_RAM+$00,X	; Get this sprite's Y position
	AND #$f0	 	; Only check its nearest-16 position (16 because of 16 pixel tall sprites)
	CMP <Temp_Var1
	BNE PRG030_889F	 	; If this sprite hasn't been touched yet, jump to PRG030_889F

	LDA #$f8	 
	STA Sprite_RAM+$00,X	; Set this sprite's Y to $F8 (make invisible)

PRG030_889F:
	DEX
	DEX
	DEX
	DEX		 	; X -= 4
	BNE PRG030_8891	 	; While X <> 0, loop!

PRG030_88A5:
	DEC Map_EntTran_Cnt	; Map_EntTran_Cnt--
	BMI PRG030_88AD	 	; If Map_EntTran_Cnt < 0, jump to PRG030_88AD

	JMP PRG030_884C	 	; Jump to PRG030_884C (loop)

PRG030_88AD:
	; Completed the entrance transition...

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Waiting for vertical sync

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!
	STA PPU_CTL1	 	

	; Disable display
	LDA #$00
	STA PPU_CTL2

	LDA #$04	
	STA Level_TimerMSD	; Level_TimerMSD = 4

PRG030_88C8:
	; Clearing scroll variables
	LDA #$00
	STA <Horz_Scroll_Hi
	STA <Horz_Scroll
	STA <Vert_Scroll_Hi
	STA <Vert_Scroll
	STA <Scroll_ColumnR
	STA <Scroll_ColumnL
	STA <Scroll_LastDir

	STA Coins_ThisLevel	 ; Clear "coins earned this level" counter
	STA Map_BonusCoinsReqd	 ; Clear the "coins required for bonus"
	STA Map_BonusType	 ; Clear the "bonus type"

	STA <Temp_Var1	; Temp_Var1 = 0

	LDX #$05	
	STX <Temp_Var2	; Temp_Var2 = 5

	; Going to clear memory from $9D to $01
	LDY #$9d	; Y = $9D
PRG030_88E9:
	STA [Temp_Var1],Y	; Clear this byte
	DEY		 	; Y--
	BNE PRG030_88E9	 	; While Y <> 0, loop!

	STA [Temp_Var1],Y	; And address $00 is cleared too (though this is technically unnecessary)

	LDA <Map_Enter2PFlag
	BEQ PRG030_891A	 	; If not entering 2P Vs mode, jump to PRG030_891A

	; 2P Vs mode begin!

	; Level_Tileset = 18 (2P Vs)
	LDA #18
	STA Level_Tileset

	JSR SetPages_ByTileset

	INC Map_2PVsGame	; Map_2PVsGame++ (play next game style)

	LDA Map_2PVsGame
	CMP #12
	BNE PRG030_890B	 ; If Map_2PVsGame <> 12 (overflow), jump to PRG030_890B

	; Otherwise, restart count
	LDA #$00
	STA Map_2PVsGame

PRG030_890B:
	ASL A	; Multiply game style by 2
	TAX	; -> 'X'

	; Load address to battlefield level data
	LDA Vs_Battlefields,X
	STA <Level_LayPtr_AddrL
	LDA Vs_Battlefields+1,X
	STA <Level_LayPtr_AddrH

	JMP PRG030_892A	 ; Jump to PRG030_892A

PRG030_891A:

	; Non-2P Mode begin!

	; Set bank C000 to page 22 and A000 to page 12
	LDA #22
	STA PAGE_C000
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	; The ultimate output is properly configured
	; Level_ObjPtr_AddrL/H and Level_ObjPtrOrig_AddrL/H (object list pointer)
	; Level_LayPtr_AddrL/H and Level_LayPtrH_AddrL/H (tile layout pointer)
	; Level_Tileset
	JSR Map_PrepareLevel	 

PRG030_892A:
	LDA World_Num
	CMP #$08	
	BNE PRG030_893F	 ; If World_Num <> 8 (World 9), jump to PRG030_893F

	; Warp zone special
	LDA #MUS1_STOPMUSIC	 
	STA Sound_QMusic1	; Stop BGM

	; The destination world is fed back out through Map_Warp_PrevWorld
	LDA Map_Warp_PrevWorld
	STA World_Num	 	; World_Num = Map_Warp_PrevWorld
	JMP PRG030_84A0	 	; Jump to PRG030_84A0 (initialize the world map!)

PRG030_893F:
	LDY Level_Tileset	; Y = Level_Tileset
	LDA ClearPattern_ByTileset,Y
	STA ClearPattern	 	; ClearPattern = ClearPattern_ByTileset[Y]

	CPY #$07	 
	BNE PRG030_8964	 	; If Level_Tileset <> 7 (Toad House), jump to PRG030_8964

	; Toad House object pointer override!

	; The object set pointer has different meaning for a Toad House!
	LDA <Level_ObjPtr_AddrL
	STA THouse_ID		; Toad House ID; not used, would have tracked boxes already opened (multiple visits perhaps??)
	LDA <Level_ObjPtr_AddrH
	STA THouse_Treasure	 

	; Force object set at TOADO (Toad and the message object)
	LDA #LOW(TOADO)
	STA <Level_ObjPtr_AddrL
	STA Level_ObjPtrOrig_AddrL	
	LDA #HIGH(TOADO)
	STA <Level_ObjPtr_AddrH
	STA Level_ObjPtrOrig_AddrH	

PRG030_8964:

	; Clears $7F bytes starting at Level_BlockGrabHitMem ($7E02)
	; Clear Level_BlockGrabHitMem (collected coins and 1-ups memory)
	LDY #$7f	; Y = $7f
	LDA #$00	; A = 0
PRG030_8968:
	STA Level_BlockGrabHitMem,Y
	DEY		 ; Y--
	BPL PRG030_8968	 ; While Y >= 0, loop!

	; Clears $80 bytes starting at Player_XHi ($75, gameplay context)
	LDY #$80	 ; Y = $80
	LDA #$00	 ; A = 0
	STA LevelJctBQ_Flag	 ; LevelJctBQ_Flag = 0 
PRG030_8975: 
	STA Player_XHi,Y
	DEY		 ; Y--
	BNE PRG030_8975	 ; While Y >= 0, loop!

PRG030_897B:
	; Level junctions enter here, to continue with preparation to display!

	LDA #$00	
	STA Vert_Scroll_Off	; Vert_Scroll_Off = 0

	; If Level_Tileset = 16 (Spade game sliding cards) or 17 (N-Spade), jump to PRG030_89AB
	LDA Level_Tileset
	CMP #16
	BEQ PRG030_89AB
	CMP #17
	BEQ PRG030_89AB	

	; Inline clone of "SetPages_ByTileset"
	; Change A000 and C000 pages by Level_Tileset
	LDY Level_Tileset
	LDA PAGE_C000_ByTileset,Y
	STA PAGE_C000	 
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000	 
	JSR PRGROM_Change_Both2

	JSR LevelLoad_ByTileset			; Load the level layout data!
	JSR Sprite_RAM_Clear			; Clear the sprites
	JSR Fill_Tile_AttrTable_ByTileset	; Load tile attribute tiles by the tileset

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

PRG030_89AB:
	JSR Reset_PPU_Clear_Nametables2		; Blank display, clear nametables
	JSR Sprite_RAM_Clear	 		; Clear the sprites

	; Select the first bank of BG VROM as specified by Level_BG_Page1_2
	LDY Level_BG_Page1_2
	LDA Level_BG_Pages1,Y
	STA PatTable_BankSel

	LDA Level_BG_Pages2,Y

	LDX Level_PSwitchCnt
	BEQ PRG030_89C4	 	; If P-Switch not active, jump to PRG030_89C4

	LDA #$3e	 	; Otherwise, force override to page $3E

PRG030_89C4:
	STA PatTable_BankSel+1	 ; Select second bank of BG VROM

	LDA Level_Tileset	
	CMP #16
	BEQ PRG030_89D1	 	; If Level_Tileset = 16 (Spade game sliders), jump to PRG030_89D1

	JMP PRG030_8A4E	 	; Otherwise, jump to PRG030_8A4E

PRG030_89D1:
	; Spade game sliders (Roulette Game)

	; Set pattern banks on sprite side... only really need the border sprites??
	LDY #$20
	STY PatTable_BankSel+2
	INY
	STY PatTable_BankSel+3
	INY
	STY PatTable_BankSel+4
	INY
	STY PatTable_BankSel+5

	; Horizontal mirroring
	LDA #$00
	STA MMC3_MIRROR

	JSR Roulette_DrawShapes	 	; Draw in the Roulette Shapes
	JSR Roulette_DrawBorderSprites	; Draw the sprite borders

	; Render Roulette borders and set attributes
	LDA #$07
	JSR Video_Do_Update

	; Status bar suitable for the horizontal mirroring mode
	LDA #$05
	JSR Video_Do_Update

	; Switch to page 26 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #26		
	STA MMC3_PAGE	 

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	; Push through what's in graphics buffer
	LDA #$00
	JSR Video_Do_Update

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Set scrolling to absolute top
	LDA #$00
	STA <Vert_Scroll

	; Resume Update_Select activity
	STA UpdSel_Disable

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

	; Enable the Roulette slider raster effect
	LDA #UPDATERASTER_SPADEGAME
	STA Update_Request

	; We actually get hung up here until afer the end of the Roulette
	; game when it has completely faded out due to Update_Request = UPDATERASTER_SPADEGAME
	JSR GraphicsBuf_Prep_And_WaitVSync

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Vertical mirroring
	LDA #$01
	STA MMC3_MIRROR

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Returning to map
	JMP PRG030_8FA1	 ; Jump to PRG030_8FA1

PRG030_8A4E:
	; Not spade game sliders

	CMP #17
	BEQ PRG030_8A55	 ; If Level_Tileset = 17 (N-Spade game), jump to PRG030_8A55
	JMP PRG030_8AE0	 ; Otherwise, jump to PRG030_8AE0

PRG030_8A55:
	; N-Spade Game

	; Load graphics for N-Spade
	LDY #$28
	STY PatTable_BankSel+2
	INY
	STY PatTable_BankSel+3
	INY
	INY
	STY PatTable_BankSel+5
	LDA #$5a
	STA PatTable_BankSel+4

	; Card_Index = $0E (this assignment isn't really used for anything)
	LDA #$0E
	STA Card_Index

	; Temp_Var1 = $20 (VRAM High Address for Clear_Nametable_Short)
	LDA #$20
	STA <Temp_Var1
	JSR Clear_Nametable_Short

	; Generate the candystripe background of the N-Spade game
	LDA #$0d
	JSR Video_Do_Update

PRG030_8A79:
	JSR Card_InitGame	 ; Do this stage of initialization

	LDA <Graphics_Queue
	JSR Video_Do_Update	 ; Push graphics update

	LDA Card_InitState
	CMP #$03
	BNE PRG030_8A79		; While Card_InitState <> 3, loop!

	; Status bar suitable for the card game
	LDA #$05
	JSR Video_Do_Update

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	; Push through what's in graphics buffer
	LDA #$00
	JSR Video_Do_Update

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Set scrolling to absolute top
	LDA #$00
	STA <Vert_Scroll

	; Resume Update_Select activity
	STA UpdSel_Disable

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	; Set bank at A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

PRG030_8AC0:
	JSR GraphicsBuf_Prep_And_WaitVSync	; VSync

	JSR NSpade_DoGame	 ; Run N-Spade game

	JSR StatusBar_UpdateValues	 ; Update status bar

	LDA <Level_ExitToMap
	BEQ PRG030_8AC0	 ; If we're not exiting to map, loop N-Spade game

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Set bank at A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

	JMP PRG030_8FA1	 ; Jump to PRG030_8FA1

PRG030_8AE0:
	CMP #18
	BNE PRG030_8AE7	 ; If Level_Tileset <> 18 (2P Vs), jump to PRG030_8AE7

	JMP Do_2PVsChallenge	 ; Jump Do_2PVsChallenge

PRG030_8AE7:
	; Normal gameplay...

	; Clear Update_Request
	LDA #$00
	STA Update_Request

	; Vertical mirroring
	LDA #$01
	STA MMC3_MIRROR

	LDA #$02	 ; A = 2
	LDX #$c0	 ; X = $C0 (Normal style updating)

	LDY Level_7Vertical
	BEQ PRG030_8B03	 	; If level is NOT a vertical one, jump to PRG030_8B03

	; Level is vertical!

	; Horizontal mirroring
	LDA #$00
	STA MMC3_MIRROR

	LDA #$01	 ; A = 1
	LDX #$80	 ; X = $80 (Vertical style updating)

PRG030_8B03:
	STX Update_Select	; Set Update_Select

	JSR Video_Do_Update	; Video update

	; Set bank at A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	JSR Scroll_Dirty_Update	 ; Entering level, do dirty update

	LDA Level_Tileset
	CMP #15
	BEQ PRG030_8B6D	 ; If Level_Tileset = 15 (Bonus game intro), jump to PRG030_8B6D

	; Changes pages at A000 and C000 to 26 and 6, respectively
	LDA #6
	STA PAGE_C000
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	JSR LevelLoad_CopyObjectList	 ; Copy in level objects!

	LDX Player_Current
	LDA Player_FallToKing,X
	BNE PRG030_8B6D	 	; If Player is bound for king, jump to PRG030_8B6D

	LDA Inventory_Open
	BNE PRG030_8B51	 	; If inventory is open (only normally happens at this point in Toad House), jump to PRG030_8B51

	LDA Level_JctCtl
	BNE PRG030_8B51	 	; If we're using a level junction override, jump to PRG030_8B51

	JMP PRG030_8B6D	 	; Otherwise, jump to PRG030_8B6D

PRG030_8B51:
	; Level junction override!  Copy in junction variables as appropriate
	LDA Level_Jct_HS
	STA <Horz_Scroll
	LDA Level_Jct_HSHi
	STA <Horz_Scroll_Hi

	LDA Level_Jct_VS
	STA <Vert_Scroll

	LDA Level_Jct_VSHi
	STA <Vert_Scroll_Hi

	; Junction complete (and inventory is NOT open)
	LDA #$00	 
	STA Inventory_Open
	STA Level_JctCtl

PRG030_8B6D:
	LDX Player_Current

	LDA Player_FallToKing,X
	BEQ PRG030_8B78	 	; If player is NOT bound for king's room, jump to PRG030_8B78

	JMP PRG030_9009	 ; Jump to PRG030_9009

PRG030_8B78:
	LDA #$00	
	STA Raster_Effect ; Raster_Effect = $00 (Normal status bar)
	STA UpdSel_Disable	; Resume Update_Select activity

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	LDA Level_Tileset
	CMP #15
	BNE PRG030_8B9A	 ; If Level_Tileset <> 15 (Bonus game intro), jump to PRG030_8B9A

	; Otherwise, set page @ C000 to 22
	LDA #22
	STA PAGE_C000
	JSR PRGROM_Change_Both2

PRG030_8B9A:
	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

	; Set page @ A000 as appropriate for this tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; This is the init code for the level "boxing out" effect removed in the US release

	; US VERSION DOES THIS:
	JMP PRG030_8CB8	 ; Jump to PRG030_8CB8 (skipping code related to the "Boxing out" effect, removed in US version)

	; Leftover optional code, see below
	LDA #$00
	STA <Map_EnterLevelFX		 ; Map_EnterLevelFX = 0

	; ORIGINAL VERSION DID THIS (addresses relate to original code!):
;	LDA Level_Tileset
;	CMP #15
;	BEQ PRG030_8BC2	 ; If Level_Tileset = 15 (bonus game intro), jump to PRG030_8BC2
;
;	LDA Map_UNK713
;	BEQ PRG030_8BC5	 ; If Map_UNK713 = 0, jump to PRG030_8BC5
;
;PRG030_8BC2:
;	JMP PRG030_8CC9	 ; Jump to PRG030_8CC9
;
;PRG030_8BC5:
;	LDA #$00
;	STA <Map_EnterLevelFX		 ; Map_EnterLevelFX = 0
;PRG030_8CC9:

	JSR Map_Clear_EntTranMem	 ; Clear entrance transition memory

	LDA #$ff
	STA Map_EntTran_Temp	 ; Map_EntTran_Temp = $ff

	LDA Level_7Vertical
	BEQ PRG030_8BD5	 	; If not a vertical level, jump to PRG030_8BD5

	; Set address as appropriate for vertical
	LDY Level_SizeOrig
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	JMP PRG030_8BDF	; Jump to PRG030_8BDF

PRG030_8BD5: 

	; First screen is always where non-vertical maps start
	LDA Tile_Mem_Addr
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1
	STA <Map_Tile_AddrH

PRG030_8BDF:
	LDA #$00	
	STA Map_EntTran_VLHalf	 ; Map_EntTran_VLHalf = 0

	LDA <Vert_Scroll
	BEQ PRG030_8BF4	 	; If Vert_Scroll = 0, jump to PRG030_8BF4

	; Otherwise, offset initial address by $F0 (15 rows) and
	; flag we're performing this on the lower vertical
	LDA <Map_Tile_AddrL
	ADD #$f0	 
	STA <Map_Tile_AddrL	; Map_Tile_AddrL += $F0

	LDA #$01
	STA Map_EntTran_VLHalf	 ; Map_EntTran_VLHalf = 1

PRG030_8BF4:
	LDY #$04	; Y = 4 (search begin)

PRG030_8BF6:
	LDA <Vert_Scroll
	CMP BoxOut_ByVStart,Y
	BEQ PRG030_8C00
	DEY		 ; Y--
	BPL PRG030_8BF6	 ; While Y >= 0, loop

PRG030_8C00:
	STY Map_EntTran_InitValIdx ; Store initial value index

	LDA BoxOut_InitVAddrH,Y	 ; Get initial high part of VRAM address
	STA Map_EntTran_BVAddrH
	STA Map_EntTran_BVAddrH+1
	STA Map_EntTran_BVAddrH+2
	STA Map_EntTran_BVAddrH+3

	; Copy in the four low bytes
	LDA BoxOut_InitVAddrL0,Y
	STA Map_EntTran_BVAddrL	

	LDA BoxOut_InitVAddrL2,Y
	STA Map_EntTran_BVAddrL+2

	LDA BoxOut_InitVAddrL1,Y
	STA Map_EntTran_BVAddrL+1

	LDA BoxOut_InitVAddrL3,Y
	STA Map_EntTran_BVAddrL+3

	LDA #$00
	STA Map_EntTran_BorderLoop	 ; Map_EntTran_BorderLoop = 0

	LDA #$04
	STA Map_EntTran_TBCnt	 ; Map_EntTran_TBCnt = 4

	LDY #$01	
	STY Map_EntTran_LRCnt	 ; Map_EntTran_LRCnt= 1

	LDA #$00	 
	STA Update_Select	; Insist (again!) that Update_Select = 0

PRG030_8C3E:
	JSR GraphicsBuf_Prep_And_WaitVSync	; VSync

	; Set page @ A000 as appropriate by Level_Tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDX Map_EntTran_BorderLoop	 ; X = current border index (0-3: Top 0, bottom 1, right 2, left 3)

	LDA Map_EntTran_BVAddrH,X	 ; Get high byte of VRAM addres
	STA Map_EntTran_VAddrH	 	; Store it

	LDA Map_EntTran_BVAddrL,X	 ; Get low byte of VRAM address
	STA Map_EntTran_VAddrL	 	; Store it

	LDA Map_EntTran_BorderLoop	 ; A = current border index (0-3: Top 0, bottom 1, right 2, left 3)
	AND #$02
	BNE PRG030_8C74	 		; If not updating top/bottom, jump to PRG030_8C74

	; top/bottom update...
	LDX Map_EntTran_TBCnt

	LDA #$01
	STA Map_EntTran_VRAMGap	 ; Map_EntTran_VRAMGap = 1

	LDA Map_EntTran_VAddrL
	AND #$01
	BEQ PRG030_8C8C	 ; If on even address, jump to PRG030_8C8C
	BNE PRG030_8C83	 ; If on odd address, jump to PRG030_8C83

PRG030_8C74:

	; left/right update...
	LDX Map_EntTran_LRCnt

	LDA #32
	STA Map_EntTran_VRAMGap	 ; PRG030_8C8C = 32

	LDA Map_EntTran_VAddrL
	AND #$20
	BEQ PRG030_8C8C	 ; If on 32 byte aligned address, jump to PRG030_8C8C

PRG030_8C83:
	JSR BoxOut_PutPatternInStrip	 ; Put an 8x8 pattern into the strip
	JSR BoxOut_SetThisBorderVRAM	 ; Set the VRAM offset for this border
	DEX		 		; X-- (counter decrement)
	BMI PRG030_8CAA	 		; If X < 0, jump to PRG030_8CAA

PRG030_8C8C:
	JSR BoxOut_PutPatternInStrip	 ; Put an 8x8 pattern into the strip
	DEX		 		; X-- (counter decrement)
	BMI PRG030_8CAA	 		; If X < 0, jump to PRG030_8CAA

	INC <Temp_Var14		 ; Temp_Var14++ (tile pattern layout high, jump to next pattern)

	LDA Map_EntTran_VRAMGap
	AND #$01	
	BEQ PRG030_8C9D	 	; If Map_EntTran_VRAMGap & 1 jump to PRG030_8C9D

	INC <Temp_Var14		 ; Temp_Var14++ (tile pattern layout high, jump to next pattern)

PRG030_8C9D:
	LDA [Temp_Var13],Y	 ; Get 8x8 pattern
	STA <Scroll_ColorStrip,X	 ; Store into strip

	JSR BoxOut_SetThisBorderVRAM	; Set border VRAM
	JSR BoxOut_SetThisBorderVRAM	; Called twice??
	DEX		 ; X--
	BPL PRG030_8C8C	 ; While X >= 0, loop!

PRG030_8CAA:
	LDA #$02
	STA <Map_EnterLevelFX	 ; Map_EnterLevelFX = 2 (begin the proper box out effect!)

	LDA Map_EntTran_Cnt
	CMP #$34	 
	BEQ PRG030_8CB8	 ; If Map_EntTran_Cnt = $34, jump to PRG030_8CB8
	JMP PRG030_8C3E	 ; Otherwise, loop!

PRG030_8CB8:
	; End of box-out effect (removed in US version)

	; Set page @ A000 as appropriate for Tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA #$00
	STA <Map_EnterLevelFX	 ; Map_EnterLevelFX = 0

	LDX #$c0	 	; X = $C0 (Normal style updating)
	LDA Level_7Vertical	
	BEQ PRG030_8CD1	 	; If not a vertical level, jump to PRG030_8CD1

	LDX #$80	 ; X = $80 (Vertical style updating)

PRG030_8CD1:
	STX Update_Select	 ; Set Update_Select as appropriate

	LDA Level_Tileset
	CMP #15	 
	BEQ PRG030_8CDE	 ; If Level_Tileset = 15 (bonus game intro), jump to PRG030_8CDE
	JMP PRG030_8DCB	 ; Jump to PRG030_8DCB

PRG030_8CDE:
	; Bonus game intro 

	LDA #$04
	STA BonusText_CharPause	; BonusText_CharPause = $04
	STA Bonus_UnusedFlag	; Bonus_UnusedFlag = $04

	; Set text VRAM pointer to $28C5
	LDA #$28
	STA BonusText_VH
	LDA #$c5
	STA BonusText_VL

	LDA #$2b
	STA ToadTalk_VH
	STA PatTable_BankSel+4	 ; Load host graphics

	LDA #$35
	STA ToadTalk_VL

	; BonusDie_YVel = -$60
	LDA #-$60
	STA <BonusDie_YVel

	; Set the die to Y = $78, X = $78
	LDA #$78
	STA <BonusDie_Y
	STA <BonusDie_X
	
	; Queue the bonus music
	LDA #MUS2A_BONUSGAME
	STA Level_MusicQueue

	; The Bonus Game Loop begins here...

BonusGame_Loop:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for VSync

	LDA SndCur_Map
	AND #SND_MAPENTERLEVEL
	BNE PRG030_8D23	 ; If the "entering" sound is still playing, jump to PRG030_8D23

	LDA Level_MusicQueue
	BEQ PRG030_8D23	 ; If nothing is in the music queue, jump to PRG030_8D23

	; Start the queued music
	STA Sound_QMusic2

	; Clear the music queue
	LDA #$00
	STA Level_MusicQueue

PRG030_8D23:
	JSR BonusGame_Do	 ; Run the Bonus Game
	JSR StatusBar_Fill_Score ; Update score

	LDA <Level_ExitToMap
	BEQ BonusGame_Loop	 ; If Level_ExitToMap = 0, loop!!

	; Exiting the Bonus Game loop...

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA Bonus_GameType
	CMP #BONUS_UNUSED_DDDD
	BNE PRG030_8D43	 ; If Bonus_GameType <> BONUS_UNUSED_DDDD (??!), jump to PRG030_8D43

	; BONUS_UNUSED_DDDD (??!) only...

	; Set Bonus_DDDD = 1 (??)
	LDA #$01
	STA Bonus_DDDD

	JMP PRG030_8D4A	 ; Jump to PRG030_8D4A

PRG030_8D43:
	CMP #BONUS_UNUSED_2RETURN
	BNE PRG030_8D4A	 ; If Bonus_GameType <> BONUS_UNUSED_2RETURN (??!), jump to PRG030_8D4A

	; BONUS_UNUSED_2RETURN (??!) only...

	JSR Bonus_Return2_SetMapPos	; Change Player's map position and mark them as having died??

PRG030_8D4A:
	; BonusText_CPos = 0
	LDA #$00
	STA BonusText_CPos
	STA Bonus_UnusedFlag	 ; Bonus_UnusedFlag = 0

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for vertical sync

	LDA #$00
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg

	; NOTE: This jumps to PRG030_8DC3, which returns to World Map, if the die is face value 1.
	; Seems like the die face logic for jumping to "Roulette" / "Card" is not implemented.
	LDA Bonus_DieCnt
	BEQ PRG030_8DC3	 ; If Bonus_DieCnt = 0 (Face value 1), jump to PRG030_8DC3

	LDY #$00	 ; Level tileset 0 (World Map)

	LDA Bonus_GameType
	CMP #BONUS_SPADE
	BNE PRG030_8D85	 ; If Bonus_GameType <> BONUS_SPADE, jump to PRG030_8D85

	; Select palettes
	LDA #$01
	STA PalSel_Tile_Colors
	LDA #$09
	STA PalSel_Obj_Colors

	LDY #16		; Level tileset 16 (Spade)

	BNE PRG030_8D95	 ; Jump (technically always) to PRG030_8D95

PRG030_8D85:
	CMP #BONUS_NSPADE
	BNE PRG030_8D95	 ; If Bonus_GameType <> BONUS_NSPADE, jump to PRG030_8D95

	; Select palettes
	LDA #$02
	STA PalSel_Tile_Colors
	LDA #$0a
	STA PalSel_Obj_Colors

	LDY #17		; Level tileset 17 (N-Spade)

PRG030_8D95:
	STY Level_Tileset	; Update Level_Tileset
	STY Level_BG_Page1_2	; Use proper BG patterns

	CPY #$00
	BEQ PRG030_8DC3	 ; If tileset = 0 (exit back to world map :(), jump to PRG030_8DC3


	; About to enter Spade / N-Spade game!

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	; A little cleanup loop...

	; Clears page 0 addresses $00-$FD, excluding $69-$74 (?)

	LDY #$fd	 ; Y = $FD
	LDA #$00	 ; A = 0
PRG030_BDA6:
	STA Temp_Var1,Y	 ; Clear this byte

PRG030_BDA9:
	DEY		 ; Y--

	CPY #World_Map_Y
	BGE PRG030_8DB2	 ; If Y >= World_Map_Y, jump to PRG030_8DB2

	; Range between $69-$74 is not cleared ... mainly protecting sound engine I think

	CPY #Video_Upd_AddrL
	BGE PRG030_BDA9	 ; If Y >= Video_Upd_AddrL, jump to PRG030_BDA9
PRG030_8DB2: 
	CPY #$ff
	BNE PRG030_BDA6	 ; If Y <> $FF (underflow), loop!


	; Clears memory $0400-$04CF (mainly Bonus game cleanup)
	LDY #$cf	 ; Y = $CF
PRG030_8DB8:
	STA Roulette_Pos,Y	; Clear this byte

	DEY		 ; Y--
	CPY #$ff
	BNE PRG030_8DB8	 ; If Y <> $FF (underflow), loop!

	JMP PRG030_897B	 ; Jump to PRG030_897B

PRG030_8DC3:

	; Exiting to world map...

	; Bonus_DieCnt = 0
	LDA #$00
	STA Bonus_DieCnt

	JMP PRG030_8FA8	; Jump to PRG030_8FA8 (proceed back to World Map)

PRG030_8DCB:
	LDY Level_Tileset
	CPY #$05
	BNE Level_MainLoop	 ; If Level_Tileset <> 5 (pipe world plant infestation), jump to Level_MainLoop

	LDA PlantInfest_ACnt_MaxConst	; A = [PlantInfest_ACnt_MaxConst] ($1A) (weird specific read??)
	STA PlantInfest_ACnt_Max	; PlantInfest_ACnt_Max = [PlantInfest_ACnt_MaxConst] ($1A)



	; LEVEL MAIN LOOP BEGIN!

Level_MainLoop:
	JSR GraphicsBuf_Prep_And_WaitVSync

	LDA SndCur_Map
	AND #$04	
	BNE PRG030_8DF4	; If enter level sound is still playing, jump to PRG030_8DF4

	LDA Level_MusicQueue
	BEQ PRG030_8DF4	 	; If Music Queue is empty, jump to PRG030_8DF4

	CMP SndCur_Music2
	BEQ PRG030_8DEF	 	; If we're queueing the BGM already playing, jump to PRG030_8DEF (don't re-queue)

	STA Sound_QMusic2	 ; Queue the song that's waiting in Level_MusicQueue

PRG030_8DEF:
	LDA #$00
	STA Level_MusicQueue	 ; Queue is emptied

PRG030_8DF4:
	LDA Level_TimerEn
	BMI PRG030_8E2E	 	; If bit 7 is set (animations disabled), jump to PRG030_8E2E

	LDY Level_Tileset
	CPY #$05	 
	BNE PRG030_8E1D	 	; If Level_Tileset <> 5 (pipe world plant infestation), jump to PRG030_8E1D


	; PLANT INFESTATION ALTERNATE ANIMATION

	; Specific animation style for the pirhana plant world thing in World 7
	LDA <Counter_1
	AND #$07
	BNE PRG030_8E2E 	; Only update every 8 ticks (otherwise, nothing)

	INC <PlantInfest_ACnt	; PlantInfest_ACnt++

	LDA <PlantInfest_ACnt
	CMP PlantInfest_ACnt_Max
	BNE PRG030_8E13	 	; If PlantInfest_ACnt <> PlantInfest_ACnt_Max, jump to PRG030_8E13

	LDA #$00	 
	STA <PlantInfest_ACnt	; PlantInfest_ACnt = 0

PRG030_8E13:

	; Set proper VROM for this animation count of the plant infestation animation
	TAY		; Y = PlantInfest_ACnt
	LDA PlantInfest_PatTablePerACnt,Y
	STA PatTable_BankSel+1

	JMP PRG030_8E5D	 ; Jump to PlantInfest_ACnt

PRG030_8E1D:
	CPY #$07
	BNE PRG030_8E24	 ; If Level_Tileset <> 7 (Toad House), jump to PRG030_8E24
	JMP PRG030_8EAD	 ; Toad House's also do not use the standard animations

PRG030_8E24:
	; NOT TOAD HOUSE

	LDA Level_PSwitchCnt
	BEQ PRG030_8E31	 	; If P-Switch is not active, jump to PRG030_8E31

	; Otherwise force pattern override to $3E
	LDA #$3e
	STA PatTable_BankSel+1

PRG030_8E2E:
	JMP PRG030_8E5D	 ; Jump to PRG030_8E5D (skip main anim code)

PRG030_8E31:
	CPY #10
	BNE PRG030_8E4F	 ; If Level_Tileset <> 10 (Airship), jump to PRG030_8E4F

	; AIRSHIP ONLY

	LDY PatTable_BankSel+1
	CPY #$6a	
	BEQ PRG030_8E5D	 ; If the current animation active pattern table is $6A (Airship standard), jump to PRG030_8E5D (do nothing)

	; Otherwise...
	LDA <Counter_1
	AND #$03	
	BNE PRG030_8E5D	 ; Only update every 4 ticks (otherwise nothing, jump to PRG030_8E5D)

	INY
	INY		; +2 pattern tables

	CPY #$76	 
	BNE PRG030_8E4A	 ; If we're at $76, jump to PRG030_8E4A

	LDY #$70	 ; Otherwise, use $70

PRG030_8E4A:
	STY PatTable_BankSel+1 ; Update active pattern table
	BNE PRG030_8E5D	 ; Jump (technically always) to PRG030_8E5D

PRG030_8E4F:
	; REGULAR LEVEL ANIMATIONS

	LDA <Counter_1
	AND #$18
	LSR A	
	LSR A	
	LSR A		
	TAX	        ; 0-3, changing every 8 ticks

	LDA PT2_Anim,X	
	STA PatTable_BankSel+1 ; Set pattern for this tick

PRG030_8E5D:
	; End of animations...

	LDA SndCur_Pause
	BNE PRG030_8E79	 ; Can't unpause game while pause sound is playing

	LDA <Pad_Input	
	AND #PAD_START
	BEQ PRG030_8E79	 ; If Player is NOT pressing START, jump to PRG030_8E79

	LDX #PAUSE_STOPMUSIC	 ; for Sound_QPause, pause sound

	LDA Level_PauseFlag
	EOR #$01	 
	STA Level_PauseFlag	 ; Toggle pause flag
 
	BNE PRG030_8E76	 ; If game is now paused, jump to PRG030_8E76

	LDX #PAUSE_RESUMEMUSIC	 ; for Sound_QPause, resume sound

PRG030_8E76:
	STX Sound_QPause ; Set appropriately

PRG030_8E79:
	LDA Level_PauseFlag
	BEQ PRG030_8EAD	 	; If not paused, jump to PRG030_8EAD

	; When game is paused...

	; Wow, what the heck did they remove here??
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP

	LDA #$32
	STA PatTable_BankSel+5	; Set patterns needed for P A U S E sprites

	JSR Sprite_RAM_Clear	 ; Clear other sprites

	; Copy in the P A U S E sprites
	LDY #(PAUSE_Sprites_End - PAUSE_Sprites - 1)
PRG030_8E9D:
	LDA PAUSE_Sprites,Y
	STA Sprite_RAM+$00,Y
	DEY		 ; Y--
	BPL PRG030_8E9D	 ; While Y >= 0, loop!

	; Updates palette
	LDA #$06	 
	STA <Graphics_Queue

	; Nothing else to do while paused; loop!
	JMP Level_MainLoop


PRG030_8EAD:
	; Not paused!

	LDA <Player_IsDying
	BNE PRG030_8ECC	 	; If Player is dying, jump to PRG030_8ECC

	LDY <Scroll_LastDir	; Y = Scroll_LastDir

	LDA Level_7Vertical
	BEQ PRG030_8EC3	 	; If level is NOT vertical, jump to PRG030_8EC3

	; Forms a value of current "scroll row" in upper 4 bits
	; and "current screen" in lower 4 bits -> Scroll_Temp
	LDA <Vert_Scroll
	AND #$f0	 
	ORA <Vert_Scroll_Hi
	STA <Scroll_Temp

	JMP PRG030_8EC9	 	; Jump to PRG030_8EC9

PRG030_8EC3:
	LDA <Horz_Scroll
	STA <Scroll_Temp	; Scroll_Temp = Horz_Scroll
	LDA <Horz_Scroll_Hi	; A = Horz_Scroll_Hi

PRG030_8EC9:
	JSR Scroll_Update_Ranges

PRG030_8ECC:
	LDA Level_JctCtl	 
	BEQ PRG030_8EE7	 	; If not junctioning, jump to PRG030_8EE7

	; Level junction!

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JMP HandleLevelJunction	; Handle the junction!

PRG030_8EE7:
	; Not junctioning...

	JSR Scroll_Update

	LDA #$00
	STA PAGE_C000	 ; Load page 0 @ C000

	LDA #$00
	STA Level_ScrollDiffH	 ; Level_ScrollDiffH = 0
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = 0

	LDA #$08	 
	STA PAGE_A000	 ; Load page 8 @ A000

	; Change both A000/C000 pages!
	JSR PRGROM_Change_Both2

	JSR Player_DoGameplay	 ; Does just about everything that makes the Player in gameplay mode!

	LDA <Player_IsDying
	CMP #$03
	BEQ PRG030_8F31	 ; If dead due to TIME UP, jump to PRG030_8F31

	; Load page 0 @ C000
	LDA #$00
	STA PAGE_C000
	JSR PRGROM_Change_Both2	 

	JSR Objects_HandleScrollAndUpdate

	; Load page 7 @ A000
	LDY #$07
	STY PAGE_A000
	JSR PRGROM_Change_A000

	JSR Scores_GiveAndDraw	 ; Give point awards and draw score sprites


	; Color rotation effects, lava, donut lifts, arrow platforms,
	; brick busts, water/waterfall visual effects, bubbles, splashes,
	; pop-up coins, Special Objects, Cannon Fires, Player Projectiles,
	; and, last but not least (well, maybe least), "shell kill flashes"!
	JSR Gameplay_UpdateAndDrawMisc

	LDA Level_HAutoScroll
	BEQ PRG030_8F31	 ; If Auto Horizontal Scrolling is NOT active, jump to PRG030_8F31

	; Load page 9 @ A000
	LDA #$09
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR AutoScroll_Do	 ; Perform auto scroll, if any

PRG030_8F31:
	LDA <Level_ExitToMap
	BEQ PRG030_8F42	 ; If Level_ExitToMap flag is not set, jump to PRG030_8F42

	LDX Player_Current	 ; X = Player_Current

	; Transfer Player's current power up to the World Map counterpart
	LDA <Player_Suit
	STA World_Map_Power,X

	; Level_GetWandState = 0
	LDA #$00
	STA Level_GetWandState

PRG030_8F42:

	; Load page 29 @ C000
	LDA #29
	STA PAGE_C000
	JSR PRGROM_Change_C000

	JSR BlockChange_Do	 ; Do Block Change event, if necessary

	; Load page 0 @ C000
	LDA #$00
	STA PAGE_C000
	JSR PRGROM_Change_C000

	; If scroll updates need to be committed, jump to PRG030_8F80 
	LDA Scroll_ToVRAMHi
	BNE PRG030_8F80
	LDA Scroll_ToVRAMHA
	BNE PRG030_8F80

	; No scroll updates need committed...

	LDA Level_SkipStatusBarUpd
	BNE PRG030_8F80	 ; If requesting we skip the status bar updates for this frame, jump to PRG030_8F80

	LDA <Graphics_Queue
	BNE PRG030_8F80	 ; If we have a video update to do, skip the status bar updates for this frame, jump to PRG030_8F80

	; Switch bank A000 to page 26
	LDA #26	
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA InvFlip_Counter
	BNE PRG030_8F7D	 ; If InvFlip_Counter <> 0 (flipping open Inventory), jump to PRG030_8F7D

	JSR StatusBar_UpdateValues	; Just update values on the status bar

	LDA Inventory_Open
	BEQ PRG030_8F85	 ; If Inventory is not open, jump to PRG030_8F85

PRG030_8F7D:
	JSR Map_DoInventory_And_PoofFX	; Do everything with that inventory bar (On page 26)

PRG030_8F80:

	; StatusBar_UpdFl = 0 (we just updated it)
	LDA #$00
	STA StatusBar_UpdFl

PRG030_8F85:

	; Level_SkipStatusBarUpd = 0 (only skip updating for one frame)
	LDA #$00
	STA Level_SkipStatusBarUpd

	LDA <Level_ExitToMap
	BEQ PRG030_9006	 ; If not exiting to map, jump to PRG030_9006 (Level_MainLoop)

	LDX Player_Current	 ; X = Player_Current

	; Map_Unused749 = 1 (just set here, never read back)
	LDA #$01
	STA Map_Unused749,X

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

PRG030_8FA1:
	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for VSync

PRG030_8FA8:
	; World_EnterState = 0
	LDA #$00
	STA World_EnterState

	; Disable the display
	STA <PPU_CTL2_Copy
	STA PPU_CTL2	 

PRG030_8FB2:
	LDA #$01	 
	STA MMC3_MIRROR	 ; Set vertical mirroring

	LDX Player_Current	 ; X = LDX Player_Current

	LDA Player_FallToKing,X
	BEQ PRG030_8FCA	 ; If not falling to the King's room, jump to PRG030_8FCA

	; Exiting to King's room...

	LDA Map_ReturnStatus
	BNE PRG030_8FCA	 ; If Player died, jump to PRG030_8FCA

	; Player is alive...

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	JMP PRG030_88C8	 ; Jump to PRG030_88C8

PRG030_8FCA:
	; Clear $06FF - $0000, excluding $01xx
	LDY #$06
	JSR Clear_RAM_thru_ZeroPage

	; Vert_Scroll_Off = 0
	LDA #$00
	STA Vert_Scroll_Off

	; Stop the music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	LDA Map_ReturnStatus
	BNE PRG030_8FFC	 ; If Player died, jump to PRG030_8FFC

	LDA Player_RescuePrincess
	BEQ PRG030_8FFC	 ; If not rescuing the Princess, jump to PRG030_8FFC

	; Load page 24 into A000 and page 25 into C000
	LDA #25
	STA PAGE_C000
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	LDA #%10101000
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA #$20
	STA Update_Select	 ; Update_Select = $20 (Title Screen... or ending in this case)

	JMP Rescue_Princess	 ; Do the Princess Rescue sequence!!

PRG030_8FFC:

	; Player died or not rescuing the princess...

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!
	STA PPU_CTL1	 	

	JMP PRG030_9097	 	; Jump to PRG030_9097

PRG030_9006:
	JMP Level_MainLoop	; Gameplay loop!

PRG030_9009:
	; Player is falling into king's room...

	LDA #$c0
	STA Update_Select	; Update_Select = $C0 (Normal)

	LDA #$00
	STA Raster_Effect	; Raster_Effect = $00 (Normal status bar)

	LDA #$00
	STA World_EnterState	; World_EnterState = 0
	STA <Level_ExitToMap	; Level_ExitToMap = 0 (not going to exit to map)

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR EndWorldLetter_GenerateText	; Generate the text for the end-of-world letter

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; Setup palette data

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in

	; Load font graphics
	LDA #$5e
	STA PatTable_BankSel+1

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

PRG030_904D:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; VSync

	JSR CineKing_DoWandReturn	 ; Do the returned wand scene!

	LDA <Level_ExitToMap
	BEQ PRG030_904D		; While Level_ExitToMap = 0, loop

	; Clear $06FF - $0000, excluding $01xx
	LDY #$06
	JSR Clear_RAM_thru_ZeroPage

	; Clear some relevant Player values
	LDX Total_Players
	DEX		 ; X = Total_Players - 1
	LDA #$00	 ; Clear value
PRG030_9062:
	STA Player_FallToKing,X
	STA Map_ReturnStatus
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X

	DEX		 ; X--
	BPL PRG030_9062	 ; While X >= 0, loop

	LDX Player_Current	 ; X = current Player index

	LDA #(Inventory_Score - Inventory_Items)	; Mario's score

	CPX #$00
	BEQ PRG030_907D	 ; If Player is Mario, jump to PRG030_907D
	ADD #(Inventory_Score2 - Inventory_Score)	; offset to Luigi's score
PRG030_907D:
	TAY		 ; Y = offset to score

	LDX #$00	 ; X = 0
PRG030_9080:
	LDA Player_Score,X
	STA Inventory_Items,Y
	INY		 ; Y++ (next byte of Inventory score)
	INX		 ; X++ (next byte of Player's score)
	CPX #$03
	BNE PRG030_9080	 ; If X <> 3, jump to PRG030_9080

	; Stop any music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	INC World_Num	 ; Go to next world!

	JMP PRG030_84A0	 	; Jump to PRG030_84A0 (initialize the world map!)

PRG030_9097:

	; Exiting to map somehow

	LDA #$c0
	STA Update_Select	; Update_Select = $C0 (Normal)

	LDA #$00
	STA Raster_Effect	; Raster_Effect = $00 (Normal status bar)


	; Need to transfer Player's "gameplay score" to their "inventory" score storage...

	LDX Player_Current	; X = Player_Current

	LDA #(Inventory_Score - Inventory_Items)	; Offset to Mario's Score

	CPX #$00
	BEQ PRG030_90AD	 ; If Player is Mario, jump to PRG030_90AD

	ADD #(Inventory_Items2 - Inventory_Items)	; Offset to Luigi's Score

PRG030_90AD:
	TAY		 ; -> 'Y'

	LDX #$00	 ; X = 0

PRG030_90B0:
	LDA Player_Score,X	 ; Get this byte of score
	STA Inventory_Items,Y	 ; Transfer into Mario/Luigi's specific score storage

	INY		 ; Y++ (next score storage byte)
	INX		 ; X++ (next gameplay score byte)

	CPX #$03
	BNE PRG030_90B0	 ; While X <> 3, loop!

	LDA Map_MusicBox_Cnt
	BEQ PRG030_90C4	 ; If Map_MusicBox_Cnt = 0, jump to PRG030_90C4

	DEC Map_MusicBox_Cnt	 ; Otherwise, one less turn with music box...

PRG030_90C4:
	LDY #$06	 ; Y = 6

	LDA Map_ReturnStatus
	BNE PRG030_910C	 ; If Player died, jump to PRG030_910C

	; Player did not die...

	; Toad House and bonuses jump to PRG030_9128
	LDA Level_Tileset
	CMP #15
	BGE PRG030_9128	 ; If Level_Tileset >= 15 (some kind of Bonus Game), jump to PRG030_9128
	CMP #$07
	BEQ PRG030_9128	 ; If Level_Tileset = 7 (Toad House), jump to PRG030_9128

	; Typical levels go here...

	LDX Player_Current	 ; X = Player_Current

	; Set bonus appearance coordinates at your last valid location!
	LDA Map_Previous_Y,X
	STA Map_BonusAppY
	LDA Map_Previous_XHi,X
	STA Map_BonusAppXHi
	LDA Map_Previous_X,X
	STA Map_BonusAppX

	LDA Map_Entered_Y,X
	STA Map_Previous_Y,X

	LDA Map_Entered_XHi,X
	STA Map_Previous_XHi,X

	LDA Map_Entered_X,X
	STA Map_Previous_X,X

	LDA Map_Prev_XOff,X
	STA Map_Prev_XOff2,X

	LDA Map_Prev_XHi,X
	STA Map_Prev_XHi2,X

	JMP PRG030_9128	 ; Jump to PRG030_9128

PRG030_910C:

	; Player returns to map dead

	LDY #$02	 ; Y = 2 (Will be the Map_Operation value)

	; Map_ReturnStatus = 0
	LDA #$00
	STA Map_ReturnStatus

	; Clear all Big ? Blocks bits
	STA BigQBlock_GotIt

	LDX Player_Current	 ; X = Player_Current

	; Skid backward
	LDA #$01
	STA Map_Player_SkidBack,X

	LDA Map_PlayerLost2PVs
	BNE PRG030_9128	 ; If Map_PlayerLost2PVs is set, jump to PRG030_9128

	DEC Player_Lives,X	; One less life for the Player...
	BMI PRG030_9133	 	; If fell below zero, GAMEOVER!; jump to PRG030_9133

PRG030_9128:

	; Stop any music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	STY Map_Operation	 ; Map_Operation = 2
	JMP PRG030_84D7	 	; Jump to PRG030_84D7

PRG030_9133:

	; GAME OVER!!

	; Set Player as twirling (in case they Continue...)
	LDA #$01	 
	STA World_Map_Twirl,X

	; Init map vars
	LDA #$00
	STA Level_Tileset
	STA <Map_EnterLevelFX
	STA <Map_WarpWind_FX
	STA Map_Intro_Tick

	; Map_GameOver_CursorY = $60
	LDA #$60
	STA Map_GameOver_CursorY

PRG030_9149:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA World_EnterState
	BNE PRG030_9163	 ; If World_EnterState <> 0, jump to PRG030_9163

	; Otherwise, gotta player the game over music!
	LDA #MUS1_GAMEOVER
	STA Sound_QMusic1

PRG030_9163:

	; Load up graphics
	LDA #$14
	STA PatTable_BankSel
	LDA #$16
	STA PatTable_BankSel+1
	LDX #$20
	STX PatTable_BankSel+2
	INX
	STX PatTable_BankSel+3
	INX
	STX PatTable_BankSel+4
	INX
	STX PatTable_BankSel+5
	JSR SetPages_ByTileset


	; Set both Players to their previous map values
	LDX Total_Players
	DEX		 ; X = Total_Players - 1

PRG030_9185:
	LDA Map_Entered_Y,X
	STA <World_Map_Y,X
	LDA Map_Entered_XHi,X
	STA <World_Map_XHi,X
	LDA Map_Entered_X,X
	STA <World_Map_X,X
	LDA Map_Previous_UnusedPVal2,X
	STA <Map_UnusedPlayerVal2,X

	; Set Player's previous travel direction
	LDA Map_Previous_Dir,X
	STA <World_Map_Dir,X

	DEX		 ; X--
	BPL PRG030_9185	; While X >= 0, loop!

	JSR Scroll_Map_SpriteBorder	 ; Keep that map border going!

	; Set page @ A000 to 12
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_Reload_with_Completions	 ; Load map and set already completed levels

	LDX Player_Current	 ; X = Player_Current

	; Set Player's previous movement direction
	LDA Map_Previous_Dir,X
	STA <World_Map_Dir,X

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDY #$00	 ; Y = 0

	LDA World_Num
	CMP #$07
	BNE PRG030_91D1	 ; If World_Num <> 7 (World 8), jump to PRG030_91D1

	; World 8 only...

	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_XHi,X
	CMP #$02
	BNE PRG030_91D1	 ; If Player is not on the "dark" part of World 8, jump to PRG030_91D1

	INY		 ; Y = 1 (enable the World 8 darkness)

PRG030_91D1:
	STY World_8_Dark	 ; Set World_8_Dark appropriately

	LDY Player_Current	 ; Y = Player_Current

	; Scroll updates
	LDA Map_Prev_XOff,Y
	STA <Scroll_Temp
	LDA Map_Prev_XHi,Y
	JSR Scroll_Update_Ranges

	LDA <Scroll_ColumnL
	STA <Scroll_ColumnR

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

	; This (re)draws the status bar
	LDA #$02
	JSR Video_Do_Update

	; Set page @ A000 to 26
	LDA #26		
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	JSR Scroll_Dirty_Update 	; Do a full draw of the map tiles

	LDA World_8_Dark
	BEQ PRG030_9214	 	; If World_8_Dark = 0 (not doing the effect), jump to PRG030_9214

	JSR Map_W8DarknessFill	; Fill in the entire screen with black

PRG030_9214:

	LDY Player_Current	 ; Y =  Player_Current

	LDA Map_Prev_XOff,Y
	STA <Horz_Scroll
	STA <Scroll_Temp
	LDA Map_Prev_XHi,Y
	STA <Horz_Scroll_Hi
	JSR Scroll_Update_Ranges

PRG030_9226:
	JSR Map_DrawAndPan	 ; Draw and pan map as necessary

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	LDA Map_DrawPanState
	BNE PRG030_9226	 	; If some kind of map drawing/panning activity is occurring, loop around

	LDA World_EnterState
	BNE PRG030_9257	 ; If World_EnterState <> 0, jump to PRG030_9257

	; Set page @ A000 to 11
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_IntroAttrSave	; Pick up the current attribute info under the box

	LDX #$12 		; X = $12 (standard $00 aligned GAME OVER box)

	LDA <Horz_Scroll 	; A = Horz_Scroll
	BEQ PRG030_924B	 	; If Horz_Scroll = 0, jump to PRG030_924B

	LDX #$13		; Otherwise, X = $13 (map halfway scroll $80 aligned GAME OVER box)

PRG030_924B:
	TXA		 ; A = X
	JSR Video_Do_Update	 ; Draw up the Game Over! box

	JSR GameOver_PatchPlayerName	 ; Add MARIO/LUIGI to gameover box

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

PRG030_9257:
	LDA #$ef	 	
	STA <Vert_Scroll	; Vert_Scroll = $EF (map always stays at this height)

	LDA #$c0	 	
	STA Update_Select	; Update_Select = $C0 (Normal)

	; Switch bank A000 to page 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

PRG030_927E:
	JSR GraphicsBuf_Prep_And_WaitVSync	; This is probably just using it to VSync
	JSR Sprite_RAM_Clear	 		; Clear sprites!
	JSR GameOver_Loop	 		; Do Gameover stuff
	JSR World5_Sky_AddCloudDeco	 	; World 5 sky area gets an extra cloud sprite (strange?)

	LDA GameOver_State

	CMP #$06
	BEQ PRG030_929C	 ; If GameOver_State = 6 (Player aligning to start panel Y), jump to PRG030_929C

	CMP #$09
	BNE PRG030_927E	 ; If GameOver_State <> 9 (Player did not choose to END), jump to PRG030_927E (loop around)

	; Player chose to END...

	LDA Total_Players
	CMP #$01
	BEQ PRG030_92B6	 ; If Total_Players = 1, jump to PRG030_92B6

	; More than 2 Players

PRG030_929C:
	
	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	; Fade out

	LDA GameOver_State
	CMP #$09
	BEQ PRG030_92B6	 ; If GameOver_State = 9 (Player chose to END), jump to PRG030_92B6

	JMP PRG030_9149	 ; Jump to PRG030_9149

PRG030_92B6:

	LDA #$00
	STA World_EnterState	 ; World_EnterState = 0 (just arriving)

	LDX Player_Current	 ; X = Player_Current

	LDA Map_GameOver_CursorY
	AND #$08
	BNE PRG030_932A	 ; If Player chose to END, jump to PRG030_932A

	; Player's live reset to 4
	LDA #$04
	STA Player_Lives,X

	; Set up position variables
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X
	LDA <Horz_Scroll_Hi
	STA Map_Prev_XHi,X
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X
	STA Map_Entered_X,X
	LDA <Map_UnusedPlayerVal2,X
	STA Map_Previous_UnusedPVal2,X

	; Reset map variables
	LDA #$00
	STA Map_Player_SkidBack,X
	STA World_EnterState
	STA Map_GameOver_CursorY
	STA BigQBlock_GotIt	; Didn't get any Big ? Blocks

	LDY #(Inventory_Coins - Inventory_Cards)	; Y = offset to Mario's coins

	CPX #$00
	BEQ PRG030_92FE	 ; If Player is Mario, jump to PRG030_92FE

	LDY #(Inventory_Coins2 - Inventory_Cards)	; Y = offset to Luigi's coins

PRG030_92FE:
	LDA #(Inventory_Coins - Inventory_Cards)
	STA <Temp_Var1		 ; Temp_Var1 = total bytes to clear

	LDA #$00	 ; A = 0
PRG030_9304:
	STA Inventory_Cards,Y	 ; Clear cards/coins

	DEY		 ; Y--
	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG030_9304	 ; While Temp_Var1 >= 0, loop

	LDY #$3f	 ; Y = $3F (End of Mario's Map Completions)

	CPX #$00
	BEQ PRG030_9314	 ; If Player is Mario, jump to PRG030_9314

	LDY #$7f	 ; Y = $7F (End of Luigi's Map Completions)

PRG030_9314:
	LDA #$3f
	STA <Temp_Var1	 ; Temp_Var1 = $3F
 
PRG030_9318:
	TYA
	EOR #$40
	TAX

	; Clear this Player's map completions
	LDA Map_Completions,X
	AND Map_Completions,Y
	STA Map_Completions,Y

	DEY		 ; Y--
	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG030_9318	 ; While Temp_Var1 >= 0, loop!

PRG030_932A:
	LDY Total_Players	 ; Y = Total_Players
	DEY		 ; Y = 0 if 1P, or 1 if 2P

PRG030_932E:
	LDA Player_Lives,Y
	BPL PRG030_933E	 ; If this Player isn't dead, jump to PRG030_933E

	DEY		 ; Y--
	BPL PRG030_932E	 ; While Y >= 0, loop

	; All Players are dead and have given up

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Reset game
	JMP IntReset_Part2

PRG030_933E:

	; A Player gave up, but there's one left

	JSR GameOver_PlayerQuitCleanup	 ; Performs some cleanup work for the Player who left

	; Map_Operation = 0
	LDY #$00
	STY Map_Operation

	LDX Player_Current	 ; X = Player_Current
	JMP PRG030_879B	 ; Jump to PRG030_879B


Do_2PVsChallenge:

	; 2P Vs Challenge!

	; Load page 14 @ C000
	LDA #14
	STA PAGE_C000
	JSR PRGROM_Change_Both2

	JSR Scroll_Dirty_Update	 ; Render the 2P Vs terrain

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Raster_Effect = $80
	LDA #$80
	STA Raster_Effect

	; Load graphics for 2P Vs
	LDY #$04
	STY PatTable_BankSel+2
	INY
	STY PatTable_BankSel+3
	INY
	STY PatTable_BankSel+4
	INY
	STY PatTable_BankSel+5

	; Play battle (2P Vs) music
	LDA #MUS2B_BATTLE
	STA Level_MusicQueue

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Set page @ A000 to 9
	LDA #$09
	STA PAGE_A000
	JSR PRGROM_Change_A000

PRG030_939A:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; V Sync

	LDA SndCur_Map
	AND #SND_MAPENTERLEVEL
	BNE PRG030_93B1	 ; If the level entrance sound is still playing, jump to PRG030_93B1

	LDA Level_MusicQueue
	BEQ PRG030_93B1	 ; If no BGM is queued, jump to PRG030_93B1

	; Play the queued music
	STA Sound_QMusic2

	; Clear music queue
	LDA #$00
	STA Level_MusicQueue

PRG030_93B1:
	JSR Sprite_RAM_Clear	 ; Clear Sprite RAM 
	JSR Vs_2PVsPauseHandler	 ; Handle pausing

	LDA Level_ExitToMap
	BEQ PRG030_939A	 ; If not exiting to map, loop 2P Vs!

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeOut	 		; Fade out

	; Stop 2P Vs music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	; Vertical sync

	; Disable display
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	LDX Map_PlayerLost2PVs
	DEX
	CPX Player_Current
	BNE PRG030_93E7	 ; If the Player who lost the match was not the Player whose turn it was, jump to PRG030_93E7

	JMP PRG030_946C	 ; Jump to PRG030_946C

PRG030_93E7:
	LDA #(Inventory_Score - Inventory_Items)	; Offset to Mario's score

	LDX Player_Current
	BEQ PRG030_93F1	 ; If current Player is Mario, jump to PRG030_93F1

	ADD #(Inventory_Score2 - Inventory_Score)	; Offset to Luigi's score

PRG030_93F1:
	TAY		 ; Y = offset to Player's score

	LDX #$00	 ; X = 0
PRG030_93F4:
	LDA Inventory_Items,Y
	STA Player_Score,X

	INY		 ; Y++ (next "inventory" score byte)
	INX		 ; X++ (next "active" score byte)

	CPX #$03
	BNE PRG030_93F4	; While X <> 3, loop!

	LDX Map_PlayerLost2PVs
	DEX
	TXA
	EOR #$01
	TAY		 ; Y = the OTHER Player's index

	; Swap all Player map position variables because the challenger lost!
	LDA Map_Previous_Y,Y
	STA <Temp_Var1
	LDA Map_Previous_XHi,Y
	STA <Temp_Var2
	LDA Map_Previous_X,Y
	STA <Temp_Var3
	LDA Map_Prev_XOff2,Y
	STA <Temp_Var4
	LDA Map_Prev_XHi2,Y
	STA <Temp_Var5
	LDA Map_Prev_XOff,Y
	STA <Temp_Var6
	LDA Map_Prev_XHi,Y
	STA <Temp_Var7
	LDA Map_Previous_Y,X
	STA Map_Previous_Y,Y
	LDA Map_Previous_XHi,X
	STA Map_Previous_XHi,Y
	LDA Map_Previous_X,X
	STA Map_Previous_X,Y
	LDA Map_Prev_XOff2,X
	STA Map_Prev_XOff2,Y
	LDA Map_Prev_XHi2,X
	STA Map_Prev_XHi2,Y
	LDA <Temp_Var1
	STA Map_Previous_Y,X
	LDA <Temp_Var2
	STA Map_Previous_XHi,X
	LDA <Temp_Var3
	STA Map_Previous_X,X
	LDA <Temp_Var4
	STA Map_Prev_XOff2,X
	LDA <Temp_Var5
	STA Map_Prev_XHi2,X
	LDA <Temp_Var6
	STA Map_Prev_XOff,X
	LDA <Temp_Var7
	STA Map_Prev_XHi,X

PRG030_946C:

	; Flag as "death" so challenger flies backward
	LDX Map_PlayerLost2PVs
	STX Map_ReturnStatus

	; Set new current Player
	DEX		 ; X--
	STX Player_Current

	JMP PRG030_8FB2	 ; Jump to PRG030_8FB2

GameOver_WhiteMapObjs:
	.byte MAPOBJ_NSPADE, MAPOBJ_WHITETOADHOUSE, MAPOBJ_UNK0C


GameOver_PlayerQuitCleanup:
	LDY Total_Players	; Y = Total_Players
	CPY #$01
	BEQ PRG030_948F	 	; If only a 1P game, jump to PRG030_948F

	; This is a 2P game

	DEY		 ; Y-- (Y = 1)
PRG030_9484:
	LDA Player_Lives,Y
	BPL PRG030_948E	 ; If this is the living Player, jump to PRG030_948E (RTS)

	DEY		 ; Y--
	BPL PRG030_9484	 ; While Y >= 0, loop!

	BMI PRG030_948F	 ; Jump to PRG030_948F

PRG030_948E:
	RTS		 ; Return

PRG030_948F:
	; BUG!! Apparently the game is SUPPOSED to delete all 
	; bonus objects after a game over, but code starts with
	; the wrong index (see immediately below) and that causes
	; this to not work correctly!  Strange, huh?

	; As my brother put it:
	; "It may have been because of the 2P mode. You can't punish
	; the other player because one of you sucks bad."

	LDX #-$04	; <-- BUG!  BAD INDEX!!  (Should be X = 2??)
PRG030_9491:
	LDY #(MAPOBJ_TOTAL-1)	 ; Y = (MAPOBJ_TOTAL-1) (all Map Objects)

PRG030_9493:
	LDA Map_Objects_IDs,Y
	BEQ PRG030_94A2	 ; If this Map Object is empty, jump to PRG030_94A2

	CMP GameOver_WhiteMapObjs,X
	BNE PRG030_94A2	 ; If this is NOT one of the "white" objects (White Toad House, Coin Ship, and the ??), jump to PRG030_94A2

	; Delete the bonus objects!  You don't deserve them!

	LDA #MAPOBJ_EMPTY
	STA Map_Objects_IDs,Y

PRG030_94A2:
	DEY		 ; Y--
	BPL PRG030_9493	 ; While Y >= 0, loop

	DEX		 ; X--
	BPL PRG030_9491	 ; While X >= 0, loop	<-- BUG! This will fail on the first pass!

	LDA #$00
	STA Map_NSpade_NextScore	 ; Highest byte in the N-Spade score = 0
	STA Map_Anchored ; Airship is no longer anchored

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; Middle byte of the N-Spade score
	LDA #HIGH(8000)
	STA Map_NSpade_NextScore+1

	; Lowest byte of the N-Spade score
	LDA #LOW(8000)
	STA Map_NSpade_NextScore+2

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SetPages_ByTileset
;
; This routine uses sets both A000 and C000 pages based on the active Level_Tileset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetPages_ByTileset:	; $94BB
	LDY Level_Tileset	 	; Y = Level_Tileset

	; Change A000 and C000 pages based on Page_A/C000_List
	LDA PAGE_C000_ByTileset,Y
	STA PAGE_C000
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000	 
	JMP PRGROM_Change_Both2		; JUMP to page routine, do not continue below...


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Video_Do_Update
;
; This very important subroutine takes an index value in 'A'
; and sets up to execute one of the Video_Upd_Table updates
; to the screen, e.g. A = 2 for the status bar.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Video_Do_Update:	; $94CD
	PHA		 ; Push A

	ASL A		 ; A << 1 (multiply by 2, looks up different address)
	TAY		 ; Y = A

	; Set update VRAM address high/low
	LDA Video_Upd_Table,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table+1,Y
	STA <Video_Upd_AddrH	

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Video_Misc_Updates	 

	PLA		 ; Pop A

	BNE PRG030_94EE	 ; If A <> 0, jump to PRG030_94EE
	STA Graphics_BufCnt	; Clear the buffer counter
	STA Graphics_Buffer	; Immediately terminate the buffer

PRG030_94EE:
	; Jump into SetPages_ByTileset to "correct" the tables back
	; (mainly A000)
	JMP SetPages_ByTileset

	; Select the attribute table (which loads 8 bytes into Tile_AttrTable)
TileAttribute_ByTileset:
	.word Tile_Attributes_TS0		; 0 - Map
	.word Tile_Attributes_TS1		; 1 - Plains [15]
	.word Tile_Attributes_TS2		; 2 - Mini fortress style [21]
	.word Tile_Attributes_TS3		; 3 - Hills style [16]
	.word Tile_Attributes_TS4_TS12		; 4 - High-Up style [17]
	.word Tile_Attributes_TS5_TS11_TS13	; 5 - pipe world plant infestation [19]
	.word Tile_Attributes_TS6_TS7_TS8	; 6 - Water world [18]
	.word Tile_Attributes_TS6_TS7_TS8	; 7 - Toad house [18]
	.word Tile_Attributes_TS6_TS7_TS8	; 8 - Vertical pipe maze [18]
	.word Tile_Attributes_TS9		; 9 - desert level [20]
	.word Tile_Attributes_TS10		; 10 - airship [23]
	.word Tile_Attributes_TS5_TS11_TS13	; 11 - Giant World [19]
	.word Tile_Attributes_TS4_TS12		; 12 - ice level [17]
	.word Tile_Attributes_TS5_TS11_TS13	; 13 - coin heaven / sky level [19]
	.word Tile_Attributes_TS14		; 14 - underground [13]
	.word Tile_Attributes_TS15_TS16_TS17	; 15 - bonus game intro [22]
	.word Tile_Attributes_TS15_TS16_TS17	; 16 - spade game sliders [22]
	.word Tile_Attributes_TS15_TS16_TS17	; 17 - N-spade [22]
	.word Tile_Attributes_TS18		; 18 - 2P Vs [14]

	; NOT USED Tile Attribute values (not valid either; incomplete set!)
Tile_Attributes_TS15_TS16_TS17:
	; Unused space
	.byte $FF, $FF, $FF, $FF


Fill_Tile_AttrTable_ByTileset:
	LDA Level_Tileset
	ASL A		 
	TAY		 	; Y = Level_Tileset << 1

	; Index into TileAttribute_ByTileset and store address to [Temp_Var2][Temp_Var1]
	LDA TileAttribute_ByTileset,Y
	STA <Temp_Var1		
	LDA TileAttribute_ByTileset+1,Y
	STA <Temp_Var2		

	LDY #$07		; Y = 7
PRG030_952C:
	LDA [Temp_Var1],Y	
	STA Tile_AttrTable,Y	
	DEY			; Y--
	BPL PRG030_952C	 	; While Y >= 0, loop!

	RTS			; Return

	; This LUTs are for the unused-in-US-release "Box out" effect when a level starts
	
	; This one selects the appropriate init values for everything
	; else based on what the vertical start position is...
BoxOut_ByVStart:	.byte $00, $30, $70, $B0, $EF	; Needs to sync with GamePlay_VStart

	; The init values, each column links to an above vertical start position
BoxOut_InitVAddrH:	.byte $21, $22, $23, $28, $29
BoxOut_InitVAddrL0:	.byte $6E, $2E, $2E, $6E, $6E
BoxOut_InitVAddrL1:	.byte $8E, $4E, $4E, $8E, $8E
BoxOut_InitVAddrL2:	.byte $73, $33, $33, $73, $73
BoxOut_InitVAddrL3:	.byte $6D, $2D, $2D, $6D, $6D

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Clear_EntTranMem
;
; Clears memory used by the entrance transition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Clear_EntTranMem:
	LDY #$1c	 ; Y = $1C
PRG030_9555:
	LDA #$00	 ; A = 0
	STA Map_EntTran_VLHalf,Y
	DEY		 ; Y--
	BPL PRG030_9555	 ; While Y >= 0, loop!
	RTS		 ; Return


BoxOut_SetThisBorderVRAM:
	; Map_EntTran_VAddrL/H += Map_EntTran_VRAMGap
	LDA Map_EntTran_VAddrL
	ADD Map_EntTran_VRAMGap
	STA Map_EntTran_VAddrL
	LDA Map_EntTran_VAddrH
	ADC #$00
	STA Map_EntTran_VAddrH

	LDA Map_EntTran_InitValIdx
	CMP #$04
	BEQ PRG030_95AD	 ; If the initial index was 4, jump to PRG030_95AD (RTS)

	LDA Map_EntTran_Temp
	CMP #$ff	 
	BNE PRG030_95AD	 ; If Map_EntTran_Temp <> $FF, jump to PRG030_95AD (RTS)

	LDY Map_EntTran_BorderLoop	 ; Y = current border index (0-3: Top 0, bottom 1, right 2, left 3)

	; Prevent out of range video writes
	LDA Map_EntTran_BVAddrH,Y
	CMP #$28	 
	BGE PRG030_95AD	 	; If border's VRAM high address >= $28, jump to PRG030_95AD (RTS)
 
	LDA Map_EntTran_VAddrH
	CMP #$23
	BLT PRG030_95AD	 	; If border's VRAM high address < $23, jump to PRG030_95AD (RTS)

	LDA Map_EntTran_VAddrL
	CMP #$c0
	BLT PRG030_95AD	 	; If border's VRAM low address < $C0, jump to PRG030_95AD (RTS)

	; Set VRAM address to [$28][Map_EntTran_BVAddrL & $1f]
	LDA #$28
	STA Map_EntTran_VAddrH

	LDA Map_EntTran_VAddrL
	AND #$1f
	STA Map_EntTran_VAddrL

	LDA Map_EntTran_BorderLoop	 ; A = current border index (0-3: Top 0, bottom 1, right 2, left 3)
	AND #$02	
	BEQ PRG030_95AD	 	; If not doing right side update, jump to PRG030_95AD (RTS)

	STX Map_EntTran_Temp	 ; Store X (LRCnt) into Map_EntTran_Temp

PRG030_95AD:
	RTS		 ; Return


	; As part of the "boxing out" effect, calculate adjusted VRAM 
	; addresses as fit to the arbitrary positioning of the screen
BoxOut_CalcOffsets:
	; I'll let someone else figure this out in particular,
	; I'm not as concerned about a removed effect...

	LDA Map_EntTran_VAddrL
	AND #$c0
	STA Map_EntTran_TileOff

	LDA Map_EntTran_VAddrH
	AND #$0f
	STA Map_EntTran_VAddrHAdj

	CLC
	ROR Map_EntTran_VAddrHAdj
	ROR Map_EntTran_TileOff
	CLC
	ROR Map_EntTran_VAddrHAdj
	ROR Map_EntTran_TileOff
	LDA Map_EntTran_VAddrL
	AND #$1f
	LSR A	
	ADD Map_EntTran_TileOff
	STA Map_EntTran_TileOff

	RTS		 ; Return


	; Determine which 8x8 of the tile layout we're going to need
BoxOut_CalcWhich8x8:
	LDA Map_EntTran_VAddrL
	AND #$01
	STA Map_EntTran_Tile8x8

	LDA Map_EntTran_VAddrL
	AND #$20	 
	BNE PRG030_95EF	

	ASL Map_EntTran_Tile8x8
	JMP PRG030_95F3	 	; Jump to PRG030_95F3

PRG030_95EF: 
	SEC		 
	ROL Map_EntTran_Tile8x8

PRG030_95F3:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Calc_NT2Addr_By_XY
;
; This calculates the Nametable 2 address where a modification
; is about to take place (e.g. when a hammer has broken a rock)
; X = X coordinate on map (e.g. MapPoof_X)
; A = Y coordinate on map (e.g. MapPoof_Y)
;
; High byte of address is in Temp_Var15
; Low byte of address is in Temp_Var16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Calc_NT2Addr_By_XY:

	; This rearranges 'A' such that the two highest bits become
	; the two lowest bits, and the other 6 are shifted up.
	; Basically a ROL without the carry being involved
	ASL A
	ADC #$00
	ASL A	
	ADC #$00
	STA <Temp_Var13	 	; Stored into Temp_Var13

	TXA		 	; A = X coordinate
	LSR A
	LSR A
	LSR A
	STA <Temp_Var14 	; Temp_Var14 = X coord >> 3
 
	LDA <Temp_Var13		; A = Temp_Var13
	AND #%11		; Get just the lower 2 bits (which are the upper 2 bits of Y coordinate)
	ORA #$28		; OR $28 (upper byte of video address for Nametable 2)
	STA <Temp_Var15		; Store into Temp_Var15

	LDA <Temp_Var13		; A = Temp_Var13
	AND #%11000000		; Get just the upper 2 bits of Temp_Var13
	ORA <Temp_Var14	; OR in Temp_Var14
	STA <Temp_Var16	; Store into Temp_Var16

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bonus_Prize1
;
; FOR UNUSED BONUS GAMES
; This is the routine used to give a prize for a roll of "2" on the die
; It's not completely clear what was intended, but that might be because
; the memory it is manipulating used to be something else once...
;
; It uses Inventory_Cards as the base but the only use of "Bonus_Prize1"
; is the lost bonus game die and it uses an input value of X = 3, which
; ultimately means we edit the first byte of Inventory_Score instead.
; But not in a "safe" way with carried arithmetic etc... which makes me
; think that memory space was once home to some other idea...
; And not that it'd make sense to "increment" your card storage either!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Bonus_Prize1:

	; Backup Y/X
	TYA
	PHA
	TXA
	PHA

	; Temp_Var16 = 0 (offset to Mario's Inventory)
	LDA #$00
	STA <Temp_Var16

	LDY Player_Current
	CPY #$00
	BEQ PRG030_962C	; If Player is Mario, jump to PRG030_962C

PRG030_9622:
	; Offset to Luigi's Inventory
	LDA <Temp_Var16
	ADD #(Inventory_Items2 - Inventory_Items)
	STA <Temp_Var16

	DEY		 ; Y will equal 1 here, so this just makes Y zero
	BNE PRG030_9622	 ; Jump technically NEVER to PRG030_9622 (?!)

PRG030_962C:
	TXA		 ; Input value -> 'A'

	ADD <Temp_Var16	 ; Add to offset value
	TAX		 ; -> 'X'

	INC Inventory_Cards,X	 ; The intention of this is unclear!

	; Restore X/Y
	PLA
	TAX
	PLA
	TAY

	RTS		 ; Return

BoxOut_PutPatternInStrip:
	JSR BoxOut_CalcOffsets	 ; Calculate offset to tile
	JSR BoxOut_CalcWhich8x8	 ; Calculate which 8x8 pattern of the tile layout we're going to use

	LDA Level_7Vertical
	BEQ PRG030_9654	 	; If level is not vertical, jump to PRG030_9654

	LDY Level_SizeOrig

	; Correct base address for vertical levels
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	JMP PRG030_965E	 	; Jump to PRG030_965E

PRG030_9654:
	; Correct base address for non-vertical levels
	LDA Tile_Mem_Addr
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1
	STA <Map_Tile_AddrH

PRG030_965E:
	LDA Map_EntTran_VAddrH
	AND #$08	 
	BEQ PRG030_966C	 ; If "high" address is not halfway through vertically, jump to PRG030_966C

	; Otherwise, offset halfway through screen
	LDA <Map_Tile_AddrL
	ADD #$f0
	STA <Map_Tile_AddrL	; Map_Tile_AddrL += $F0

PRG030_966C:
	LDA Level_Tileset
	ASL A		
	TAY		 

	; Set Temp_Var13/14 to point to the layout data for this Tileset
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var13	
	LDA TileLayout_ByTileset+1,Y
	STA <Temp_Var14	

	LDY Map_EntTran_TileOff
	LDA [Map_Tile_AddrL],Y	 ; Get the tile we're working on

	TAY		 
	LDA Map_EntTran_Tile8x8
	ADD <Temp_Var14		
	STA <Temp_Var14		
	LDA [Temp_Var13],Y	 ; Get the specific 8x8 tile of the tile we're working on

	STA <Scroll_ColorStrip,X ; Store into the strip
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Update_Ranges
;
; This subroutine updates Scroll_ColumnL/R based on
; where the screen has currently scrolled to...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Update_Ranges: 
	LDY Level_7Vertical
	BNE PRG030_96A5	 	; If Level_7Vertical, jump to PRG030_96A5

	; Non-vertical map
	; Expected that 'A' is currently set to the "Hi byte" of the X Scroll coordinate

	; This loop puts the lower 4 bits of the "hi byte" X into the 
	; upper 4 bits of Scroll_Temp, and shifts Scroll_Temp 4 bits down... or basically,
	; Scroll_Temp = (Scroll_Temp >> 4) | (A << 4)

	; Most importantly, this has taken a pixel-based scroll X and a "high byte" of X
	; scroll and combined them into a reduced accuracy (column-based) value of where
	; we're at horizontally...
	LDX #$03	 ; X = 3
PRG030_9695:
	LSR A		 ; Pushes the LSb -> Carry
	ROR <Scroll_Temp	 ; Shift everything in Scroll_Temp to the right, and pull in the carry
	DEX		 ; X--
	BPL PRG030_9695	 ; If X >= 0, loop!

	LDA <Scroll_Temp	; A = result from loop...
	STA <Scroll_ColumnL	; Store as the current "left side" column
	ADD #16	
	STA <Scroll_ColumnR	; Scroll_ColumnR = Scroll_ColumnL + 16 (always -- 256/16 = 16 columns spanning the screen)
	RTS			; Return!

PRG030_96A5:
	; Vertical level

	LDA <Scroll_Temp
	BEQ PRG030_96B7	 	; If Scroll_Temp = 0, jump to PRG030_96B7

	SUB #16			
	STA <Scroll_Temp	; Scroll_Temp -= 16

	CMP #$f0	 
	BLT PRG030_96B7	 ; If Scroll_Temp < $F0 (would only happen if it was previously $00-$0F), jump to PRG030_96B7

	SUB #17
	STA <Scroll_Temp	; Scroll_Temp -= 17

PRG030_96B7:
	LDA <Scroll_Temp	
	STA <Scroll_VOffsetT	; Scroll_VOffsetT = Scroll_Temp

	; Calculate bottom tile row offset

	ADD #$e0	 	; A = Scroll_Temp + $E0
	BCC PRG030_96C2	 	; If no carry occurred, jump to PRG030_96C2

	ADC #$10	 	; A = Scroll_Temp + $F0

PRG030_96C2:
	CMP #$f0	 	
	BLT PRG030_96CB	 	; If A < $F0, jump to PRG030_96CB
	AND #$0f	 	; A &= $F
	ADD #$01	 	; A += 1

PRG030_96CB:
	STA <Scroll_VOffsetB	; Update Scroll_VOffsetB
	RTS		 	; Return!

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Clear_RAM_thru_ZeroPage
	; 
	; Starting at the page provided in Y, this will clear everything
	; (except the stack space) $YY00 to $0000
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Clear_RAM_thru_ZeroPage:
	STY <Temp_Var2	 ; Save Y in <Temp_Var2
	LDY #$00	 ; Y = 0
	STY <Temp_Var1	 ; Clear <Temp_Var1
	TYA		 ; A = 0

	; Y is the initial input as the high byte of the address
	; low first then high, so [Temp_Var2][Temp_Var1]
PRG030_96D5:
	LDX <Temp_Var2	 ; X = current high byte of address in this case
	CPX #$01	 ; If we've reached the $01xx bank...
	BEQ PRG030_96DD	 ; ... skip the next line (don't clear the stack space!)
	STA [Temp_Var1],Y	 ; Otherwise, clear this byte
PRG030_96DD:
	DEY		 ; Y--
	BNE PRG030_96D5	 ; While Y <> 0, loop around again (goes $00, $FF, $FE, ... back to $00) again
	DEC <Temp_Var2	 ; Next lower bank
	BPL PRG030_96D5	 ; While we're >= bank $00
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GraphicsBuf_Prep_And_WaitVSync
;
; This subroutine takes Graphics_Queue and loads and address
; from Video_Upd_Table into the Video_Upd_Addr, then waits for
; a VBlank cycle to occur via reading the VBlank_Tick after
; force-setting it to zero.  This gets the system into a state
; where it can actually apply the update!
;
; See also GraphicsBuf_Prep_And_WaitVSyn2 in PRG024
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GraphicsBuf_Prep_And_WaitVSync:	; 96E5
	LDA <Graphics_Queue
	ASL A		 	
	TAY		 	; Y = Graphics_Queue * 2

	; Get the address where the video update data is
	LDA Video_Upd_Table,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table+1,Y
	STA <Video_Upd_AddrH	

	LDA #$01	
	STA <VBlank_TickEn	 ; Enable the VBlank tick
	LDA #$00	 
	STA <VBlank_Tick	 ; Force VBlank_Tick = 0, so we know when a VBlank has occurred

	; Waiting for VBlank...
PRG030_96FB:
	LDA <VBlank_Tick
	BPL PRG030_96FB	

	LDA #$00	 
	STA <VBlank_TickEn	 ; Disable the VBlank

	CLI		 ; Enable further masked interrupts
	RTS		 ; Return


	; Tile_Mem_ClearA/B form a way to rapidly clear all of the tile
	; memory to a specific value (A), used in conjunction with the
	; proper iterative loop...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tile_Mem_ClearA
;
; $1B0 is the size of one screen, so this essentially writes to the
; same place on all screens, offset by 'Y'.  Unfortunately since 
; one screen is $1B0, 'Y' cannot cover the entire space, so we have
; Tile_Mem_ClearB with a different offset...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Tile_Mem_ClearA:	; $9705
	STA Tile_Mem,Y	 
	STA Tile_Mem+$1B0,Y
	STA Tile_Mem+$360,Y
	STA Tile_Mem+$510,Y
	STA Tile_Mem+$6C0,Y
	STA Tile_Mem+$870,Y
	STA Tile_Mem+$A20,Y
	STA Tile_Mem+$BD0,Y
	STA Tile_Mem+$D80,Y
	STA Tile_Mem+$F30,Y
	STA Tile_Mem+$10E0,Y
	STA Tile_Mem+$1290,Y
	STA Tile_Mem+$1440,Y
	STA Tile_Mem+$15F0,Y
	STA Tile_Mem+$17A0,Y
	INY		 ; Y++

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tile_Mem_ClearB
;
; Similar to Tile_Mem_ClearA, writes to the same place on all screens,
; only this one begins at the 12th row (making up for the 'Y'
; register coming up short of a full screen)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Tile_Mem_ClearB:	; $9734
	STA Tile_Mem+$0C0,Y
	STA Tile_Mem+$270,Y
	STA Tile_Mem+$420,Y
	STA Tile_Mem+$5D0,Y
	STA Tile_Mem+$780,Y
	STA Tile_Mem+$930,Y
	STA Tile_Mem+$AE0,Y
	STA Tile_Mem+$C90,Y
	STA Tile_Mem+$E40,Y
	STA Tile_Mem+$FF0,Y
	STA Tile_Mem+$11A0,Y
	STA Tile_Mem+$1350,Y
	STA Tile_Mem+$1500,Y
	STA Tile_Mem+$16B0,Y
	STA Tile_Mem+$1860,Y
	RTS		 ; Return


	; Array of bank selections by Level_BG_Page1_2 
	; What LEVEL4_BGBANK_INDEX references
Level_BG_Pages1:
	.byte $00	;  0 Not Used
	.byte $08	;  1 Plains
	.byte $10	;  2 Fortress
	.byte $1C	;  3 Hills / Underground
	.byte $0C	;  4 High-Up
	.byte $58	;  5 Plant Infestation
	.byte $58	;  6 Underwater
	.byte $5C	;  7 Toad House
	.byte $58	;  8 Pipe Maze
	.byte $30	;  9 Desert
	.byte $34	; 10 Airship
	.byte $6E	; 11 Giant world
	.byte $18	; 12 Ice
	.byte $38	; 13 Sky
	.byte $1C	; 14 Not Used (Same as Hills / Underground)
	.byte $24	; 15 Bonus Room
	.byte $2C	; 16 Spade (Roulette)
	.byte $5C	; 17 N-Spade (Card)
	.byte $58	; 18 2P Vs
	.byte $6C	; 19 Hills / Underground alternate
	.byte $68	; 20 3-7 only
	.byte $34	; 21 World 8 War Vehicle
	.byte $28	; 22 Throne Room

Level_BG_Pages2:
	.byte $00	;  0 Not Used
	.byte $60	;  1 Plains
	.byte $60	;  2 Fortress
	.byte $60	;  3 Hills / Underground
	.byte $60	;  4 High-Up
	.byte $3E	;  5 Plant Infestation
	.byte $60	;  6 Underwater
	.byte $5E	;  7 Toad House
	.byte $60	;  8 Pipe Maze
	.byte $60	;  9 Desert
	.byte $6A	; 10 Airship
	.byte $60	; 11 Giant world
	.byte $60	; 12 Ice
	.byte $60	; 13 Sky
	.byte $60	; 14 Not Used (Same as Hills / Underground)
	.byte $5E	; 15 Bonus Room
	.byte $2E	; 16 Spade (Roulette)
	.byte $5E	; 17 N-Spade (Card)
	.byte $60	; 18 2P Vs
	.byte $60	; 19 Hills / Underground alternate
	.byte $60	; 20 3-7 only
	.byte $70	; 21 World 8 War Vehicle
	.byte $60	; 22 Throne Room


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad
;
; The master level loader function!  Without this, there's no game!
;
; This function performs all the work necessary to translate 
; "layout" data into functional geometry.  Note that based on
; the value of Level_Tileset, there are different "generators"
; that are employed, so while the overall macro format is consistent,
; the stylization and inner format may not be!
;
; Best to follow through to figure out the format to each "style"...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; There are 8 defined vertical start positions

	; Defines Player's Y "high" start
GamePlay_YHiStart:	.byte $01, $00, $00, $01, $00, $00, $00, $01

	; Defines Player's Y start
GamePlay_YStart:	.byte $70, $40, $00, $40, $70, $B0, $F0, $80

	; Defines screen vertical position starts
	; NOTE: If the "box out" effect were to be used, needs to sync with BoxOut_ByVStart
GamePlay_VStart:	.byte $EF, $00, $00, $EF, $30, $70, $B0, $EF

	; Available MSD time start values
GamePlay_TimeStart:	.byte 3, 4, 2, 0

	; Available BGMs for levels (16 possible with stock code, only 11 defined here)
GamePlay_BGM:
	.byte MUS2B_OVERWORLD	; 0
	.byte MUS2B_UNDERGROUND	; 1
	.byte MUS2B_UNDERWATER	; 2
	.byte MUS2B_FORTRESS	; 3
	.byte MUS2B_BOSS	; 4
	.byte MUS2B_AIRSHIP	; 5
	.byte MUS2B_BATTLE	; 6
	.byte MUS2B_TOADHOUSE	; 7
	.byte MUS2B_ATHLETIC	; 8
	.byte MUS2A_THRONEROOM	; 9
	.byte MUS2A_SKY		; 10


LevelLoad:	; $97B7

	; Clear loading variables
	LDA #$00
	STA TileAddr_Off
	STA LevLoad_Unused4
	STA LevLoad_Unused3
	STA LevLoad_Unused1
	STA LevLoad_Unused2

	LDY #$04	 ; Y = 4 (in case we're skipping first 4 bytes of header)

	; If we're using a "junction" device (door/pipe/etc.), we don't want to (incorrectly) set the "alternates"...
	LDA Level_JctCtl	 
	CMP #$80	 
	BEQ PRG030_980D	 ; If Level_JctCtl = $80, jump to PRG030_980D (use current Level_AltLayout/Level_AltObjects values)

	LDY #$00	 ; Y = 0

	; Get bytes 0-3 of layout data; pointers Level_AltLayout and Level_AltObjects

	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltLayout
	INY
	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltLayout+1
	INY		 

	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltObjects
	INY		
	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltObjects+1
	INY		

	LDA Level_JctCtl	
	BNE PRG030_980D	 ; If Level_JctCtl <> 0, jump to PRG030_980D (skip setting vertical start position)

	LDA [Level_LayPtr_AddrL],Y
	AND #%11100000
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 	; X = upper 3 bits, shifted down, from byte 4 (0-7)

	; Set up the vertical starting position!
	LDA GamePlay_YHiStart,X
	STA <Player_YHi		; Player_YHi = GamePlay_YHiStart[X]

	LDA GamePlay_YStart,X
	STA <Player_Y		; Player_Y = GamePlay_YStart[X]

	LDA #$00	 
	STA <Player_XHi		; Player_XHi = 0

	; Set the starting vertical position
	LDA GamePlay_VStart,X
	STA <Vert_Scroll	; Vert_Scroll = GamePlay_VStart[X]

PRG030_980D:

	; Set the width of the level (in screens) from byte 4
	LDA [Level_LayPtr_AddrL],Y
	AND #%00001111
	STA <Level_Width
	STA Level_SizeOrig	 

	;;;;;;;;;;;;;;;
	INY		 

	; First 3 bits of byte 5 determine the palette select for tiles
	LDA [Level_LayPtr_AddrL],Y
	AND #%00000111
	STA PalSel_Tile_Colors

	; Next 2 bits select an object palette, root value 8
	LDA [Level_LayPtr_AddrL],Y
	AND #%00011000
	LSR A		
	LSR A		
	LSR A		
	ORA #%00001000		; forces minimum value of 8
	STA PalSel_Obj_Colors

	; Next 2 bits sets Level_SelXStart (sets Player_X after level starts)
	LDA [Level_LayPtr_AddrL],Y
	AND #%01100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	STA Level_SelXStart	 

	; Finally, bit 7 sets Level_UnusedFlag (unused; only set, never read)
	LDA [Level_LayPtr_AddrL],Y
	AND #$80	
	STA Level_UnusedFlag 

	;;;;;;;;;;;;;;;
	INY		 

	; Bit 7 of byte 6 sets Level_PipeNotExit
	LDA [Level_LayPtr_AddrL],Y
	AND #$80	 
	STA Level_PipeNotExit

	; Bits 5-6 set Level_FreeVertScroll
	LDA [Level_LayPtr_AddrL],Y
	AND #%01100000
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	STA Level_FreeVertScroll

	CMP #$02
	BNE PRG030_9864	 ; If Level_FreeVertScroll <> 2 (arbitrary scroll lock), jump to PRG030_9864

	; Otherwise for a level started with the arbitrary lock, it picks Vert_Scroll = 0 (highest point)
	; if Vert_Scroll is less than $B0, otherwise it picks $EF (lowest point)
	; NOTE however that these two points are not required during normal gameplay; you can arbitrarily
	; lock to ANY Vert_Scroll value and it will work just fine!

	LDX #$00		; X = 0

	LDA <Vert_Scroll
	CMP #$b0
	BLT PRG030_985F	 	; If Vert_Scroll < $B0, jump to PRG030_985F

	LDX #$ef	 	; Otherwise, X = $EF

PRG030_985F:
	STX <Vert_Scroll	; Vert_Scroll = X
	STX Level_Jct_VS	; Level_Jct_VS = Vert_Scroll

PRG030_9864:

	; Bit 4 sets whether this level is a vertical one
	LDA [Level_LayPtr_AddrL],Y
	AND #%00010000
	STA Level_7Vertical
	BEQ PRG030_9893	 	; If not vertical, jump to PRG030_9893

	LDX Level_JctCtl
	BNE PRG030_987C	 	; If Level_JctCtl <> 0, jump to PRG030_987C

	; Start at bottom of vertical level
	LDA Level_SizeOrig
	STA <Vert_Scroll_Hi
	STA <Player_YHi		; Player's Y High is the same!
	JMP PRG030_9893	


PRG030_987C:
	LDA #$00	
	STA Level_SizeOrig	; ?? Why?

	LDA <Player_YHi	
	BEQ PRG030_988E	 	; If the Player Y high is zero, jump to PRG030_988E

	LDA <Level_Width
	STA <Vert_Scroll_Hi
	STA <Player_YHi	
	STA Level_SizeOrig

PRG030_988E:
	LDA <Vert_Scroll_Hi
	STA Level_Jct_VSHi	 ; Level_Jct_VSHi = Vert_Scroll_Hi

	; End of Vertical alternative

PRG030_9893:

	; Bits 0-3 set Level_AltTileset
	LDA [Level_LayPtr_AddrL],Y
	AND #$0f	
	STA Level_AltTileset

	;;;;;;;;;;;;;;;
	INY		; Y++	

	; Bits 5-7 of byte 7 set Level_InitAction (sets an action to begin level, see Level_InitAction_JumpTable)
	LDA [Level_LayPtr_AddrL],Y
	AND #%11100000	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA Level_InitAction

	; Bits 0-4 set Level_BG_Page1_2 (an index to which pages of BG graphics should be loaded)
	LDA [Level_LayPtr_AddrL],Y
	AND #%00011111	 
	STA Level_BG_Page1_2

	;;;;;;;;;;;;;;;
	INY		 ; Y++

	LDA Level_JctCtl
	BNE PRG030_98C8	 ; If using a junction device, don't set the time; jump to PRG030_98C8

	; Bits 6-7 of byte 8 select a time setting (0=300, 1=400, 2=200, 3=000 [unlimited])
	LDA [Level_LayPtr_AddrL],Y
	AND #%11000000	
	CLC		
	ROL A		
	ROL A		
	ROL A		
	TAX		
	LDA GamePlay_TimeStart,X
	STA Level_TimerMSD
	BNE PRG030_98C8	 	; If not using the 000 time, jump to PRG030_98C8

	INC Level_TimerEn	; Otherwise Level_TimerEn = 1 (disable the clock, hence unlimited time)

PRG030_98C8:

	; Bits 0-3 select a BGM
	LDA [Level_LayPtr_AddrL],Y
	AND #%00001111
	TAX
	LDA GamePlay_BGM,X	; A = target music
	LDX SndCur_Music2	; X = currently playing music

	CPX #MUS2B_PSWITCH
	BEQ PRG030_98DE		; If playing the P-Tab music, don't queue this song right now
	CPX #MUS2A_INVINCIBILITY		
	BEQ PRG030_98DE		; If playing the Invincibility music, don't queue this song right now

	; Queue this music to play
	STA Level_MusicQueue

PRG030_98DE:
	; Set this as the music to "restore" to when P-Tab / Invincibility ends
	STA Level_MusicQueueRestore

	; Level_LayPtr_AddrL/H += 9 (i.e. move pointer to after the header)
	LDA <Level_LayPtr_AddrL
	ADD #$09
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

PRG030_98EE:
	LDY #$00	 		; Y = 0 (beginning of post-header)

	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	CMP #$ff	 		
	BEQ PRG030_9934	 		; If $FF, jump to PRG030_9934 (RTS)

	; Otherwise...
	STA <Temp_Var15			; Store byte into Temp_Var15

	INY		 		; Y++
	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	STA <Temp_Var16		 	; Store into Temp_Var16

	INY				; Y++
	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	STA LL_ShapeDef	 		; Store into LL_ShapeDef

	INY		 		; Y++
	TYA		 		; A = Y

	; Add current offset into Level_LayPtr_AddrL/H, moving it ahead
	ADD <Level_LayPtr_AddrL
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	LDA <Temp_Var15		 	; Retrieve first byte we read
	AND #$e0	 
	CMP #$e0	 
	BNE PRG030_991E	 		; If its upper 3 bits are not all set, jump to PRG030_991E

	; *****************
	; Upper 3 bits of Temp_Var15 are ALL set... i.e. Temp_Var15 = 111x xxxx
	; *****************

	JSR LoadLevel_StoreJctStart 	; Temp_Var16 and LL_ShapeDef define junction start positions
	JMP PRG030_98EE	 		; Loop around

PRG030_991E:

	; *****************
	; Upper 3 bits of Temp_Var15 are NOT ALL set... i.e. Temp_Var15 DOES *NOT follow* the mask 111x xxxx
	; *****************

	; Temp_Var15 and Temp_Var16 are the input parameters to LoadLevel_Set_TileMemAddr,
	; which set, most importantly, "Map_Tile_Addr" to some root screen address, and
	; set "TileAddr_Off" as an offset value within that screen.

	; "Map_Tile_Addr" is formed Tile_Mem_Addr[ (Temp_Var16 & $F0) >> 3 ]
	;	- The upper 4 bits of Temp_Var16 select the starting screen
	;
	; "TileAddr_Off" is formed (Temp_Var15 << 4) | (Temp_Var16 & $f)
	;	- The lower 4 bits of Temp_Var15, and lower 4 bits of Temp_Var16
	JSR LoadLevel_Set_TileMemAddr

	LDA LL_ShapeDef
	AND #$f0
	BEQ PRG030_992E	 	; If upper 4 bits of LL_ShapeDef are all zero, jump to PRG030_992E

	; *****************
	; Upper 4 bits of LL_ShapeDef are NOT ALL clear... i.e. LL_ShapeDef DOES *NOT follow* the mask 0000 xxxx
	; *****************

	; Otherwise, we handle this as a construction command, and so turn
	; to the "generators" which define what the bytes mean...
	JSR LeveLoad_Generators	

	JMP PRG030_9931	 	; (Essentially) loop around (pointless jump, heh)

PRG030_992E:
	; *****************
	; Upper 4 bits of LL_ShapeDef are ALL NOT set... i.e. LL_ShapeDef = 0000 xxxx
	; *****************

	; This is a fixed-size construction type
	JSR LeveLoad_FixedSizeGens

PRG030_9931:
	JMP PRG030_98EE	 	; Loop around...

PRG030_9934:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Set_TileMemAddr
;
; Used while loading a level.  Sets the Map_Tile_AddrL/H pointer
; to a specified "screen", and also sets TileAddr_Off to an offset
; within that screen.
;
; Takes input parameters of Temp_Var15 and Temp_Var16 and from 
; there generates:
;
; Guide to help visualize the input:
; Temp_Var15 Temp_Var16
; FEDC BA98  7654 3210	<-- bits
;
;
; * Map_Tile_AddrL/H points to Tile_Mem_Addr(V)[7654 0] <-- '0' is a one-up shift, not bit 0 of Temp_Var16; (V) is the "Vertical" table, used if applicable
;
; * If 'C' (bit 4) of Temp_Var15 is set, then Map_Tile_AddrH is incremented
;
; * Temp_Var5 = Map_Tile_AddrH + 1 -- Pre-'C' increment, ONLY WHEN NOT VERTICAL (otherwise unassigned)
;
; * Temp_Var6 = Map_Tile_AddrH -- Post-'C' increment (i.e. equals whatever Map_Tile_AddrH does at end of function)
;
; * TileAddr_Off = BA98 3210 -OR- (Temp_Var15 << 4) | (Temp_Var16 & $f)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Set_TileMemAddr:
	; Upper 3 bits of first byte were all set...


	LDA <Temp_Var15	 ; Get that first byte
	ASL A		
	ASL A		
	ASL A		
	ASL A		
	STA <Temp_Var7	 ; Temp_Var7 = Temp_Var15 << 4 (take lower 4 bits and multiply by 16)

	LDA <Temp_Var16	 ; Second byte
	AND #$0f	 ; Lower 4 bits
	ORA <Temp_Var7	 ; Applied to Temp_Var7
	STA TileAddr_Off	 ; Stored into TileAddr_Off

	; TileAddr_Off = BA98 3210 -OR- (first byte << 4) | (second byte & $f)


	LDA <Temp_Var16	 ; Second byte
	AND #$f0	 ; Upper 4 bits
	LSR A		 
	LSR A		 
	LSR A		 
	TAX		 ; X = (Temp_Var16 & $F0) >> 3 (value in upper 4 bits times 2, 2 byte index for Tile_Mem_Addr)

	; X = 7654 0 <-- '0' is a one-up shift, not bit 0 of Temp_Var16

	LDA Level_7Vertical
	BEQ PRG030_9963	 ; If not a vertical level, jump to PRG030_9963

	; Vertical level

	TXA
	LSR A
	TAX		; X >>= 1 (single byte index, since the Tile_Mem_AddrV lookup is split into two tables)

	; Load the target address into Map_Tile_AddrH/L
	LDA Tile_Mem_AddrVL,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,X
	STA <Map_Tile_AddrH

	JMP PRG030_997F	 ; Jump to PRG030_997F

PRG030_9963:

	; Non-vertical level

	CPX #$1e
	BNE PRG030_9969	 ; If X <> $1E (the max value), jump to PRG030_9969

	; Otherwise, X -= 2
	DEX
	DEX

PRG030_9969:

	; Load the target address into Map_Tile_AddrH/L
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	STA <Temp_Var5	
	INC <Temp_Var5		; Temp_Var5 = Map_Tile_AddrH + 1

	LDA <Temp_Var15	
	AND #$10	
	BEQ PRG030_997F		; If bit 4 of the first byte is not set, jump to PRG030_997F

	; Otherwise, Map_Tile_AddrH++
	INC <Map_Tile_AddrH

PRG030_997F:
	LDA <Map_Tile_AddrH
	STA <Temp_Var6		; Temp_Var6 = Map_Tile_AddrH

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Randomize
;
; Shakes up the random number pool a bit!
; Anyone want to detail the algorithm, go right ahead...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Randomize:
	LDX #$00	
	LDY #$09	
	LDA Random_Pool	
	AND #$02	
	STA <Temp_Var1	
	LDA RandomN	
	AND #$02	
	EOR <Temp_Var1	
	CLC		
	BEQ PRG030_999A	
	SEC		
PRG030_999A:
	ROR Random_Pool,X
	INX		 
	DEY		 
	BNE PRG030_999A	 

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_RecordBlockHit
;
; Called after a coin is collected or a hidden 1-Up is found.
; This records those events so if the level is swapped with its
; alternate, these things do not retun.  Next best thing to
; actually having enough memory to hold both levels together...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RecordBlockHitBits:
	.byte $80, $40, $20, $10, $08, $04, $02, $01

Level_RecordBlockHit:

	; Currently Temp_Var13-16 are defined as follows:
	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo
	; ... of Player detection coordinates

	TYA
	PHA		 ; Save 'Y'

	TXA
	PHA		 ; Save 'X'

	LDA <Temp_Var16
	PHA		 ; Save Temp_Var16

	LDA <Temp_Var13
	PHA		 ; Save Temp_Var13

	; This converts Temp_Var15/Temp_Var16 into a tile row stored in Temp_Var16
	; Essentially a 16-bit right shift 4 bits
	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var16
	LDA <Temp_Var15
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var16
	STA <Temp_Var16

	; This turns Temp_Var13 into an index into Level_BlockGrabHitMem
	LDA <Temp_Var16
	AND #%11111000
	LSR A
	LSR A
	ORA <Temp_Var13
	STA <Temp_Var13

	LDA Level_JctFlag
	BEQ PRG030_99DC	 ; If we're not junctioning, jump to PRG030_99DC

	; If junctioning, Temp_Var13 += $40
	LDA <Temp_Var13
	ADD #$40
	STA <Temp_Var13

PRG030_99DC:
	LDA <Temp_Var16
	AND #$07
	TAX
	LDY <Temp_Var13
	LDA Level_BlockGrabHitMem,Y
	ORA RecordBlockHitBits,X
	STA Level_BlockGrabHitMem,Y

	; Restore everything we saved
	PLA
	STA <Temp_Var13
	PLA
	STA <Temp_Var16
	PLA
	TAX
	PLA
	TAY

	RTS		 ; Return

TileLayout_ByTileset:
	; Defines the 8x8 blocks to build a particular 16x16 "tile"

	.word Tile_Layout_TS0		; 0 - Map
	.word Tile_Layout_TS1		; 1 - Plains [15]
	.word Tile_Layout_TS2		; 2 - Mini fortress style [21]
	.word Tile_Layout_TS3		; 3 - Hills style [16]
	.word Tile_Layout_TS4_TS12	; 4 - High-Up style [17]
	.word Tile_Layout_TS5_TS11_TS13	; 5 - pipe world plant infestation [19]
	.word Tile_Layout_TS6_TS7_TS8	; 6 - Water world [18]
	.word Tile_Layout_TS6_TS7_TS8	; 7 - Toad house [18]
	.word Tile_Layout_TS6_TS7_TS8	; 8 - Vertical pipe maze [18]
	.word Tile_Layout_TS9		; 9 - desert level [20]
	.word Tile_Layout_TS10		; 10 - airship [23]
	.word Tile_Layout_TS5_TS11_TS13	; 11 - Giant World [19]
	.word Tile_Layout_TS4_TS12	; 12 - ice level [17]
	.word Tile_Layout_TS5_TS11_TS13	; 13 - coin heaven / sky level [19]
	.word Tile_Layout_TS14		; 14 - underground [13]
	.word Tile_Layout_TS15_TS16_TS17; 15 - bonus game intro [22]
	.word Tile_Layout_TS15_TS16_TS17; 16 - spade game sliders [22]
	.word Tile_Layout_TS15_TS16_TS17; 17 - N-spade [22]
	.word Tile_Layout_TS18		; 18 - 2P Vs [14]

LevelLoad_ByTileset:
	LDA Level_Tileset
	JSR DynJump

	; Page numbers are determined by PAGE_A000_ByTileset and PAGE_C000_ByTileset, indexed by Level_Tileset

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LT0			; 0 - Map [11] (not used, enters in the middle of WWFX_WarpIslandInit, and not in a logical place)
	.word LevelLoad_TS1		; 1 - Plains [15]
	.word LevelLoad_TS2		; 2 - Mini fortress style [21]
	.word LevelLoad_TS3		; 3 - Hills style [16]
	.word LevelLoad_TS4_TS12	; 4 - High-Up style [17]
	.word LevelLoad_TS5		; 5 - pipe world plant infestation [19]
	.word LevelLoad_TS6		; 6 - Water world [18]
	.word LevelLoad_TS7		; 7 - Toad house [18]
	.word LevelLoad_TS8		; 8 - Vertical pipe maze [18]
	.word LevelLoad_TS9		; 9 - desert level [20]
	.word LevelLoad_TS10		; 10 - airship [23]
	.word LevelLoad_TS5		; 11 - Giant World [19]
	.word LevelLoad_TS4_TS12	; 12 - ice level [17]
	.word LevelLoad_TS13		; 13 - coin heaven / sky level [19]
	.word LevelLoad_TS14		; 14 - underground [13]

	.word LevelLoad_TS15_TS16_TS17	; 15 - bonus game intro [22]
	.word LevelLoad_TS15_TS16_TS17	; 16 - spade game sliders [22]
	.word LevelLoad_TS15_TS16_TS17	; 17 - N-spade [22]
	.word LevelLoad_TS18		; 18 - 2P Vs [14]


; RegEx S&R:
; LDA LL_ShapeDef.*\n.*AND #\$0f.*\n.*STA <Temp_Var(.)		 ; .*
; LDA LL_ShapeDef\n\tAND #$0f\n\tSTA <Temp_Var\1		 ; Temp_Var\1 = lower 4 bits of LL_ShapeDef

; LDA LL_ShapeDef.*\n.*AND #\$0f.*\n.*TAX		 ; .*
; LDA LL_ShapeDef\n\tAND #$0f\n\tTAX		 ; X = lower 4 bits of LL_ShapeDef

; LDA <Temp_Var(.).*\n.*STA <Temp_Var(.)		 ; .*
; LDA <Temp_Var\1\n\tSTA <Temp_Var\2		 ; Temp_Var\2 = Temp_Var\1

; DEC <Temp_Var(.)		 ; .*
; DEC <Temp_Var\1		 ; Temp_Var\1--

; LDA <Map_Tile_AddrL.*\n.*STA <Temp_Var1.*\n.*LDA <Map_Tile_AddrH.*\n.*STA <Temp_Var2.*
;; Backup Map_Tile_AddrL/H into Temp_Var1/2\n\tLDA <Map_Tile_AddrL\n\tSTA <Temp_Var1\n\tLDA <Map_Tile_AddrH\n\tSTA <Temp_Var2

; LDA <Temp_Var1.*\n.*STA <Map_Tile_AddrL.*\n.*LDA <Temp_Var2.*\n.*STA <Map_Tile_AddrH.*
;; Restore Map_Tile_Addr from backup\n\tLDA <Temp_Var1\n\tSTA <Map_Tile_AddrL\n\tLDA <Temp_Var2\n\tSTA <Map_Tile_AddrH

LeveLoad_Generators:
	LDA Level_Tileset
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LT0B				; 0 - Map [11] (not used, enters in the middle of nowhere, in a not logical place)
	.word LoadLevel_Generator_TS1		; 1 - Plains [15]
	.word LoadLevel_Generator_TS2		; 2 - Mini fortress style [21]
	.word LoadLevel_Generator_TS3		; 3 - Hills style [16]
	.word LoadLevel_Generator_TS4_TS12	; 4 - High-Up style [17]
	.word LoadLevel_Generator_TS051113	; 5 - pipe world plant infestation [19]
	.word LoadLevel_Generator_TS678		; 6 - Water world [18]
	.word LoadLevel_Generator_TS678		; 7 - Toad house [18]
	.word LoadLevel_Generator_TS678		; 8 - Vertical pipe maze [18]
	.word LoadLevel_Generator_TS9		; 9 - desert level
	.word LoadLevel_Generator_TS10		; 10 - airship
	.word LoadLevel_Generator_TS051113	; 11 - Giant World
	.word LoadLevel_Generator_TS4_TS12	; 12 - ice level [17]
	.word LoadLevel_Generator_TS051113	; 13 - coin heaven / sky level [19]
	.word LoadLevel_Generator_TS14		; 14 - underground [13]
	.word LoadLevel_Generator_TS151617	; 15 - bonus game intro
	.word LoadLevel_Generator_TS151617	; 16 - spade game sliders
	.word LoadLevel_Generator_TS151617	; 17 - N-spade
	.word LoadLevel_Generator_TS18		; 18 - 2P Vs

LeveLoad_FixedSizeGens:
	LDA Level_Tileset
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LT0B				; 0 - Map [11] (not used, enters in the middle of nowhere, in a not logical place)
	.word LeveLoad_FixedSizeGen_TS1		; 1 - Plains
	.word LeveLoad_FixedSizeGen_TS2		; 2 - Mini fortress style
	.word LeveLoad_FixedSizeGen_TS3		; 3 - Hills style [16]
	.word LeveLoad_FixedSizeGen_TS4_TS12	; 4 - High-Up style [17]
	.word LeveLoad_FixedSizeGen_TS051113	; 5 - pipe world plant infestation [19]
	.word LeveLoad_FixedSizeGen_TS678	; 6 - Water world
	.word LeveLoad_FixedSizeGen_TS678	; 7 - Toad house
	.word LeveLoad_FixedSizeGen_TS678	; 8 - Vertical pipe maze
	.word LeveLoad_FixedSizeGen_TS9		; 9 - desert level
	.word LeveLoad_FixedSizeGen_TS10	; 10 - airship
	.word LeveLoad_FixedSizeGen_TS051113	; 11 - Giant World [19]
	.word LeveLoad_FixedSizeGen_TS4_TS12	; 12 - ice level [17]
	.word LeveLoad_FixedSizeGen_TS051113	; 13 - coin heaven / sky level [19]
	.word LeveLoad_FixedSizeGen_TS14	; 14 - underground [13]
	.word LeveLoad_FixedSizeGen_TS151617	; 15 - bonus game intro
	.word LeveLoad_FixedSizeGen_TS151617	; 16 - spade game sliders
	.word LeveLoad_FixedSizeGen_TS151617	; 17 - N-spade
	.word LeveLoad_FixedSizeGen_TS18	; 18 - 2P Vs

PRG030_9AA1:
	.byte $01, $FF

PRG030_9AA3:
	.byte $08, $F8

PRG030_9AA5:
	.byte $00, $08


TileLayoutPage_ByTileset:
	; A000 page selected per-Level_Tileset...
	.byte BANK(Tile_Layout_TS0)		; 0 - Map [11]
	.byte BANK(Tile_Layout_TS1)		; 1 - Plains [15]
	.byte BANK(Tile_Layout_TS2)		; 2 - Mini fortress style [21]
	.byte BANK(Tile_Layout_TS3)		; 3 - Hills style [16]
	.byte BANK(Tile_Layout_TS4_TS12)	; 4 - High-Up style [17]
	.byte BANK(Tile_Layout_TS5_TS11_TS13)	; 5 - pipe world plant infestation [19]
	.byte BANK(Tile_Layout_TS6_TS7_TS8)	; 6 - Water world [18]
	.byte BANK(Tile_Layout_TS6_TS7_TS8)	; 7 - Toad house [18]
	.byte BANK(Tile_Layout_TS6_TS7_TS8)	; 8 - Vertical pipe maze [18]
	.byte BANK(Tile_Layout_TS9)		; 9 - desert level [20]
	.byte BANK(Tile_Layout_TS10)		; 10 - airship [23]
	.byte BANK(Tile_Layout_TS5_TS11_TS13)	; 11 - Giant World [19]
	.byte BANK(Tile_Layout_TS4_TS12)	; 12 - ice level [17]
	.byte BANK(Tile_Layout_TS5_TS11_TS13)	; 13 - coin heaven / sky level [19]
	.byte BANK(Tile_Layout_TS14)		; 14 - underground [13]

	; THESE VALUES ARE WRONG!  Appears that they were not maintained?
	; It doesn't matter because these specialized cases go where they need to anyway!
	.byte 23				; 15 - bonus game intro (WRONG: Should be 22)
	.byte 23				; 16 - spade game sliders (WRONG: Should be 22)
	.byte 23				; 17 - N-spade (WRONG: Should be 22)
	.byte 16				; 18 - 2P Vs (WRONG: Should be 14)

	; CORRECT VALUES:
	;.byte BANK(Tile_Layout_TS15_TS16_TS17)	; 15 - bonus game intro [22]
	;.byte BANK(Tile_Layout_TS15_TS16_TS17)	; 16 - spade game sliders [22]
	;.byte BANK(Tile_Layout_TS15_TS16_TS17)	; 17 - N-spade [22]
	;.byte BANK(Tile_Layout_TS18)		; 18 - 2P Vs [14]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Dirty_Update
;
; This function performs a full-screen redraw of all tiles, 
; used when first showing map/level, but not for scrolling!
; (Though it does call the same routine USED for scrolling)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Dirty_Update:
	LDA Level_7Vertical
	BNE PRG030_9B10	 	; If level is vertical, jump to PRG030_9B10

	; Non-vertical level
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	STA <Scroll_RightUpd,X	; Current horizontal scroll stored into appropriate left/right value

PRG030_9AC5:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	; Buffers a single 8x8 column of tiles
	JSR Scroll_DoColumn

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; Commits the buffer
	JSR Scroll_Commit_Column

	LDX <Scroll_LastDir	 ; X = Scroll_LastDir
	LDA <Scroll_RightUpd,X	 ; A = Get the last 8 pixel location update
	ADD PRG030_9AA3,X	 ; Add an appropriate offset given the direction of travel
	STA <Scroll_RightUpd,X	 ; Update it!

	; Produce the attribute data and commits the buffer
	JSR Scroll_Do_AttrColumn
	JSR Scroll_Commit_Column

	LDX <Scroll_LastDir	; Last direction to index the following
	LDA <Scroll_RightUpd,X	; Get updated column
	AND #$08	 	; Every half screen
	CMP PRG030_9AA5,X
	BNE PRG030_9B02	 	; For updating on half-tiles (??), jump to PRG030_9B02
	LDA <Scroll_ColumnR,X	
	ADD PRG030_9AA1,X
	STA <Scroll_ColumnR,X

PRG030_9B02:
	DEC Scroll_Cols2Upd	 ; Scroll_Cols2Upd--
	BNE PRG030_9AC5	 ; While Scroll_Cols2Upd <> 0, loop!

	LDA #$ff
	STA <Scroll_RightUpd		 ; Scroll_RightUpd = $ff (marker as in "not last updated"; flat for dirty)
	STA <Scroll_LeftUpd		 ; Scroll_LeftUpd = $ff (marker as in "not last updated"; flat for dirty)
	JMP SetPages_ByTileset	 ; JUMP to SetPages_ByTileset to reset pages (will take care of the RTS)

PRG030_9B10:

	; Scroll_LastDir = 0
	LDA #$00
	STA <Scroll_LastDir

	; Vert_Scroll = $E0
	LDA #$e0
	STA <Vert_Scroll

	; Scroll_RightUpd = $E8
	ADD #$08
	STA <Scroll_RightUpd

	; Scroll_ColumnR = (Level_SizeOrig - 1) | $E0
	LDY Level_SizeOrig	 ; Y = Level_SizeOrig
	DEY		 ; Y--
	TYA
	ORA #$e0
	STA <Scroll_ColumnR

PRG030_9B26:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	JSR VScroll_PageAndDoPatAttrRow	 ; Do the row of patterns and attributes for vertical scroll

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Scroll_ToVRAM_Apply	 ; Applies Scroll_ToVRAMHi and Scroll_ToVRAMHA updates
	JSR Scroll_ToVRAM_Apply	 ; Applies Scroll_ToVRAMHi and Scroll_ToVRAMHA updates

	LDA <Vert_Scroll
	ADD #$08
	STA <Vert_Scroll

	CMP #$f0
	BNE PRG030_9B59	 ; If not changing to new screen, jump to PRG030_9B59

	INC <Scroll_VOffsetT		 ; Scroll_VOffsetT++

	; Loop vertical offset to new screen
	LDA <Scroll_VOffsetT
	AND #$0f
	STA <Scroll_VOffsetT

	JMP PRG030_9B66	 ; Jump to PRG030_9B66

PRG030_9B59:
	LDA <Vert_Scroll
	AND #$08
	BNE PRG030_9B66	 ; If only halfway vertically through tile row, jump to PRG030_9B66

	; Otherwise, go to next row
	LDA <Scroll_VOffsetT
	ADD #$10
	STA <Scroll_VOffsetT

PRG030_9B66:
	LDA <Vert_Scroll
	CMP #$d0
	BNE PRG030_9B26	 ; While Vert_Scroll <> $D0, loop!

	LDA #$00
	STA <Vert_Scroll	; Vert_Scroll = 0
	STA <Scroll_VertUpd	; Scroll_VertUpd = 0

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Update
;
; This subroutine updates one column of tiles worth
; of scroll (tile and attribute) as needed per
; changes in Horz_Scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Update:
	LDA Level_7Vertical
	BNE PRG030_9BB2	 	; If this is a vertical scroller world, jump to PRG030_9BB2

	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	AND #$f8		; Only caring about every 8 pixels (for valid comparison to Scroll_RightUpd)
	CMP <Scroll_RightUpd,X	; Compared to whichever update applies to the last scroll
	BEQ PRG030_9BA9	 	; If we are updated completely, jump to PRG030_9BA9

	; Otherwise ...
	TAY		 	; Y = A (Horz_Scroll, 8 pixel aligned)

	LDA Scroll_Cols2Upd
	BNE PRG030_9B9B	 	; If columns remain to be updated, jump to PRG030_9B9B

	LDA <Horz_Scroll
	AND #$07		; How many pixels across a tile boundary of 8 (0 - 7)

	CPX #$00
	BNE PRG030_9B97	 	; If last scroll direction <> 0 (last moved left), jump to PRG030_9B97

	; Last moved right...
	CMP #$02
	BGE PRG030_9B9B	 	; If greater-or-equal to 2 pixels to the right, jump to PRG030_9B9B

	JMP PRG030_9BA9	 	; Otherwise, jump to PRG030_9BA9

PRG030_9B97:
	; Last moved left...

	CMP #$05
	BGE PRG030_9BA9	 ; If greater-or-equal to 5 pixels in (complement to 2 pixels from right case), jump to PRG030_9BA9

	; Otherwise...

PRG030_9B9B:
	STY <Scroll_RightUpd,X	 ; Store our right/left update

	LDA <Scroll_LastDir
	EOR #$01	 
	TAX		 
	LDA #$ff	 
	STA <Scroll_RightUpd,X	 ; Store $FF on the other side

	JSR Scroll_DoColumn	 ; Render a column of tiles...

PRG030_9BA9:
	LDA Scroll_UpdAttrFlag	
	BEQ PRG030_9BB1	 	; If Scroll_UpdAttrFlag is not set (not time to update attributes), jump to PRG030_9BB1 (RTS)

	JSR Scroll_Do_AttrColumn ; Otherwise, Render a column of attributes...

PRG030_9BB1:
	RTS		 ; Return


PRG030_9BB2:
	LDA <Vert_Scroll
	AND #$f8
	CMP <Scroll_VertUpd
	BEQ PRG030_9BD2	 ; If the vertical scroll hasn't changed 8 pixels, jump to PRG030_9BD2 (RTS)

	; Otherwise, change the Scroll_VertUpd value
	LDA <Vert_Scroll
	AND #$f8
	STA <Scroll_VertUpd

VScroll_PageAndDoPatAttrRow:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	JSR VScroll_CalcPatternVRAMAddr	 ; Calculate start of pattern row
	JSR VScroll_DoPatternAndAttrRow	 ; Do the pattern row AND attributes

PRG030_9BD2:
	RTS		 ; Return

PRG030_9BD3:	.byte $00, $01

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_DoColumn	
;
; This subroutine renders a "column" of 8x8 blocks for the
; screen scrolling.  Also used by the "dirty update" routine
; to sweep across and render the blocks...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_DoColumn:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Scroll_RightUpd,X	; Related last update value
	AND #$08	 	; Take just whether we've moved onto an 8
	LSR A		 	
	LSR A		 
	LSR A		 
	STA <Scroll_OddEven	; <Scroll_OddEven is 0 for 0, 1 for 8
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	AND #$0f	 	; A is now 0-15
	CPX #$00	 	
	BNE PRG030_9BFD	 	; If Scroll_LastDir = 0 (last scrolled right), jump to PRG030_9BFD

	; Last scrolled left
	CMP #$04	 	
	BGE PRG030_9C01	 ; If the horizontal scroll is 4-15, jump to PRG030_9C01
	JMP PRG030_9C06	 ; Otherwise, jump to PRG030_9C06

PRG030_9BFD:
	; Last scrolled right
	CMP #12	
	BGE PRG030_9C06	 ; If the horizontal scroll is 12-15, jump to PRG030_9C06

PRG030_9C01:	; (Scrolled left and scroll is 4-15) OR (Scrolled right and scroll is 0-11)

	; Scroll_UpdAttrFlag = 1 (time to update attributes!)
	LDA #$01
	STA Scroll_UpdAttrFlag

PRG030_9C06:
	LDA Level_Tileset 
	ASL A		 ; A = Level_Tileset << 1 (index into TileLayout_ByTileset)
	TAY		 ; -> 'Y'

	; A tile is laid out like:
	; 02
	; 13

	; Store the low byte of the address into Temp_Var11/Temp_Var13
	; This defines addresses used to look up the construction of a tile
	; by its index number; note that top and bottom half use a common
	; low byte.
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var11		 
	STA <Temp_Var13		 

	; The following takes the high byte of the "TileLayout_ByTileset"
	; and either adds nothing or a jump of 512, and still adds a jump of
	; 256 to the after address 
	LDX TileLayout_ByTileset+1,Y	; X = High byte of address (block 0 of tile)
	LDA <Scroll_OddEven		; A = Scroll_OddEven
	BEQ PRG030_9C1B			; If Scroll_OddEven = 0, jump to PRG030_9C1B
	INX		 		; +256 (block 1)
	INX		 		; +256 (block 2) beginning of the right half

PRG030_9C1B:
	STX <Temp_Var12		; High byte [?] into Temp_Var12
	INX		 		; block 1 or 3, depending on Scroll_OddEven
	STX <Temp_Var14		; High byte [?] into Temp_Var14

	LDX <Scroll_LastDir		; X = Scroll_LastDir
	LDA <Scroll_ColumnR,X	 	; A = appropriate current column (right or left)
	AND #$f0	 	 	; Checking what screen we're on (every 16 columns is a screen's worth)
	LSR A		 
	LSR A		 
	LSR A		 
	TAY		 		; Y = ((Scroll_ColumnR & $F0) >> 3), or basically, 2 for every screen we've moved (for indexing...)

	; Set the address of the tiles we need to modify!
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var15	
	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var16	

	LDA #26	 		; Number of rows to update (NTSC res of 224, two screens tall, is 448 / 16px-per-tile = 26)
	STA <Temp_Var1		; Temp_Var1 = 26 (see immediately above)
	LDA <Scroll_ColumnR,X	; Get the column we're on
	AND #$0f	 	; Make it relative to THIS screen, 0-15
	STA <Temp_Var2		; Temp_Var2 stores this value

	LDX #$00	 	; X = 0
PRG030_9C40:
	LDY <Temp_Var2		; Y = Temp_Var2 (screen relative column)
	LDA [Temp_Var15],Y	; Get tile to display
	TAY		 	; Tile becomes offset 'Y'

	; Store the top block for this tile
	LDA [Temp_Var11],Y
	STA Scroll_PatStrip,X

	; Store the bottom block for this tile
	LDA [Temp_Var13],Y
	STA Scroll_PatStrip+1,X

	LDA <Temp_Var2
	ADD #16	
	STA <Temp_Var2	 	; Temp_Var2 += 16 (next row in this column is 16 bytes down)
	BCC PRG030_9C5A	 	; If we haven't overflowed, jump to PRG030_9C5A
	INC <Temp_Var16	; Otherwise we need to increment the upper part of the tile address
PRG030_9C5A:
	INX		 
	INX		 ; X += 2 (two tiles added)

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG030_9C40	 ; If more tiles to go, loop!


	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Scroll_ColumnR,X	; A = last column value
	AND #$0f	 	; Screen column relative
	ASL A		 	; A << 1 (0, 2, 4, ... E)
	ORA <Scroll_OddEven	; Apply the odd/even (forms an 8x8 current column)
	STA Scroll_LastCol8	; Store this in Scroll_LastCol8

	LDA #$20	 	; 
	STA Scroll_ToVRAMHi	; Scroll_ToVRAMHi = $20
	JMP SetPages_ByTileset	; JUMP to SetPages_ByTileset (restores page A000 most importantly, and will do the RTS)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Do_AttrColumn
;
; This subroutine renders a "column" of attributes for the
; screen scrolling.  Also used by the "dirty update" routine
; to sweep across and render the blocks...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG030_9C74:
	.byte $F1, $01

PRG030_9C76:
	.byte $ff, $0f

Scroll_Do_AttrColumn:
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDY <Scroll_ColumnR,X	; Y = get column
	TYA		 	; A = Y
	AND #$01	 	; Get odd/even
	BEQ PRG030_9C87	 	; If even, jump to PRG030_9C87

	TYA		 	; A = back to column again
	ADD PRG030_9C76,X	; Add appropriate value, whether going right or left (-1 or +15)
	TAY		 	; Y = A

PRG030_9C87:
	STY <Temp_Var1		; column, possibly offset, into Temp_Var1
	LDA #$00	 	
	STA <Temp_Var2		; Temp_Var2 = 0

PRG030_9C8D:
	LDA <Temp_Var1		; A = Temp_Var1 (column, possibly offset)
	AND #$f0	 	; Figure out which SCREEN we're on
	LSR A		 
	LSR A		 
	LSR A		 	; A >> 3 (2 byte per screen index)
	TAY		 	; Y = A

	; Setup pointer to tile memory we need to be focusing on!
	LDA Tile_Mem_Addr,Y	
	STA <Temp_Var15		
	LDA Tile_Mem_Addr+1,Y	
	STA <Temp_Var16	

	LDX <Temp_Var2	 	; X = Temp_Var2
	LDA <Temp_Var1	 	; A = Temp_Var1
	AND #$0f	 	; Current screen-relative column
	TAY		 	; Y = A (screen relative column)
PRG030_9CA6:
	LDA [Temp_Var15],Y	; Get next tile
	AND #$c0	 	; Set attributes based on the "range" of the tile, like palette 0 for tiles 00-3f, palette 1 for tiles 40-7f, etc.
	STA <Scroll_ColorStrip,X	; Store this into the attribute strip
	TYA		 	; A = Y (the tile offset)
	ADD #16		 	; A += 16 (every tile row is 16 bytes)
	TAY		 	; Y = A
	BCC PRG030_9CB5	 	; If we didn't overflow, jump to PRG030_9CB5
	INC <Temp_Var16	; Increment the high byte
PRG030_9CB5:
	INX			; X++ (next byte in the Scroll_ColorStrip)
	STX <Temp_Var2		; Temp_Var2 = X
	CPX #27	
	BNE PRG030_9CD0	 	; If X <> 27, jump to PRG030_9CD0

	; X is 27, we need to go to the next page
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDY <Scroll_ColumnR,X	; Get the column
	TYA		 	; A = Y
	AND #$01	 	; 
	BNE PRG030_9CCB	 	; If odd, jump to PRG030_9CCB
	TYA			; A = Y (back to the column)
	ADD PRG030_9C74,X
	TAY		 	; -> 'Y'
PRG030_9CCB:
	STY <Temp_Var1		; -> Temp_Var1
	JMP PRG030_9C8D	 	; Loop around again...

PRG030_9CD0:
	CPX #54
	BNE PRG030_9CA6	 ; If A <> 54, loop!


	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0 

PRG030_9CD8:
	; Attributes store colors for 4 tiles in one byte, this
	; forms the coloring information for all four blocks; this
	; also explains the odd-but-necessary offsets
	LDA <Scroll_ColorStrip,X
	LSR A		 
	LSR A		 ; A >>= 2
	ORA <Scroll_ColorStrip+27,X
	LSR A		 
	LSR A		 ; A >>= 2 
	ORA <Scroll_ColorStrip+1,X
	LSR A		 
	LSR A		 ; A >>= 2
	ORA <Scroll_ColorStrip+28,X

	STA Scroll_AttrStrip,Y
	INX		 ; X++
	INX		 ; X++
	CPY #$07	 
	BNE PRG030_9CF8	 ; If Y <> 7, jump to PRG030_9CF8

	; Only store half the attribute data on row 7
	LDA Scroll_AttrStrip,Y	
	AND #$0f
	STA Scroll_AttrStrip,Y	
	DEX		 ; X--	; Redo other half later!

PRG030_9CF8:
	INY		 ; Y++
	CPY #14	 	 
	BNE PRG030_9CD8	 ; If Y <> 14, loop!

	LDA #$23	 
	STA Scroll_ToVRAMHA	; Scroll_ToVRAMHA = $23
	LDX <Scroll_LastDir	
	LDA <Scroll_ColumnR,X	; Get column
	AND #$0f	 	; Screen relative
	LSR A		 	; A >> 1 (every two blocks when dealing with attributes)
	ORA #$c0	 	; $C0 is the base offset into Attribute Table 0/2
	STA Scroll_LastAttr	; Store into Scroll_LastAttr

	; Scroll_UpdAttrFlag = 0
	LDA #$00	 
	STA Scroll_UpdAttrFlag

	RTS		 	; Return!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_CalcPatternVRAMAddr
;
; Calculates Scroll_ToVRAMHi/Lo for patterns for the current vertical scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
VScroll_CalcPatternVRAMAddr:
	LDX <Scroll_LastDir	; X = Scroll_LastDir

	; Calculate VRAM High into nametable for this offset
	LDA <Scroll_VOffsetT,X
	AND #$c0
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	ADD #$20
	STA Scroll_ToVRAMHi

	; Calculate VRAM Low into nametable for this offset
	LDA <Scroll_VOffsetT,X
	AND #$30
	ASL A
	ASL A
	STA Scroll_LastOff8

	LDA <Vert_Scroll
	AND #$08
	BEQ PRG030_9D3E	 ; If not on odd row, jump to PRG030_9D3E (RTS)

	; +32 bytes to offset to reach next tile row in VRAM
	LDA Scroll_LastOff8
	ADD #32
	STA Scroll_LastOff8

PRG030_9D3E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_DoPatternAndAttrRow
;
; This subroutine renders a "row" of 8x8 blocks for the vertical
; screen scrolling.  Also creates the attributes for the same.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
VScroll_DoPatternAndAttrRow:
	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$0f
	TAY		 ; Y = offset column

	; Get address of tile at this vertical position
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Temp_Var9 = offset at leftmost column in current row
	LDA <Scroll_VOffsetT,X
	AND #$f0
	STA <Temp_Var9

	; Temp_Var10 = 0
	LDA #$00
	STA <Temp_Var10

PRG030_9D5A:
	LDY <Temp_Var9		 ; Y = current offset along row
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	STA <Temp_Var11		 ; -> Temp_Var11

	INC <Temp_Var9		 ; Temp_Var9++ (next column)

	JSR TileLayout_GetBaseAddr	 ; Get tile layout address -> Temp_Var13/14

	LDX <Temp_Var10		 ; X = Temp_Var10

	LDA <Vert_Scroll
	AND #$08
	BEQ PRG030_9D6F	 ; If not vertically halfway on the tile, jump to PRG030_9D6F

	INC <Temp_Var14		 ; Otherwise, Temp_Var14++ (next row of layout)

PRG030_9D6F:
	LDA [Temp_Var13],Y	 ; Get pattern of tile
	STA Scroll_PatStrip,X	 ; Store into pattern strip

	INX		 ; X++ (next pattern strip byte)

	; Temp_Var14 += 2 (next adjacent tile pattern)
	INC <Temp_Var14
	INC <Temp_Var14

	LDA [Temp_Var13],Y	 ; Get pattern of tile
	STA Scroll_PatStrip,X	 ; Store into pattern strip

	INX		 ; X++ (next pattern strip byte)

	STX <Temp_Var10		 ; X -> Temp_Var10

	CPX #$20
	BLT PRG030_9D5A	 ; If not at end of strip row, loop

	LDA Scroll_LastOff8
	CMP #$20
	BEQ PRG030_9D92	 ; If Scroll_LastOff8 = $20 (end of top row), jump to PRG030_9D92

	CMP #$a0
	BEQ PRG030_9D92	 ; If Scroll_LastOff8 = $A0 (end of bottom row), jump to PRG030_9D92

	BNE PRG030_9D98	 ; Otherwise, jump to PRG030_9D98 (RTS)

PRG030_9D92:
	JSR VScroll_CalcAttributeVRAMAddr	; Calculate the attribute VRAM addresses
	JSR Scroll_Do_AttrRow	 		; Do row of attributes

PRG030_9D98:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_CalcAttributeVRAMAddr
;
; Calculates Scroll_ToVRAMHA/Scroll_LastAttr for attributes for the current vertical scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
VScroll_CalcAttributeVRAMAddr:

	; VRAM High address to attributes
	LDA #$23
	STA Scroll_ToVRAMHA

	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	; VRAM Low address to attributes
	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$c0
	LSR A
	LSR A
	ADD #$c0
	STA Scroll_LastAttr

	LDA <Scroll_VOffsetT,X
	AND #$20
	BEQ PRG030_9DBB	

	; Scroll_LastAttr += 8
	LDA Scroll_LastAttr
	ADD #$08
	STA Scroll_LastAttr

PRG030_9DBB:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Do_AttrRow
;
; This subroutine renders a "row" of attributes for the
; screen scrolling.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Do_AttrRow:
	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$0f
	TAY		 ; Y = offset column

	; Get address of tile at this vertical position
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Temp_Var9 = offset at leftmost column in current row
	LDA <Scroll_VOffsetT,X
	AND #$f0
	STA <Temp_Var9

	AND #$10
	BNE PRG030_9DDE

	LDA <Temp_Var9
	ADD #$10
	STA <Temp_Var9 

PRG030_9DDE:
	INC <Temp_Var9		 ; Temp_Var9++ (next column)

	; Temp_Var8 = 0
	LDA #$00
	STA <Temp_Var8
PRG030_9DE4:
	LDY <Temp_Var9		 ; Y = current offset along row
	JSR VScroll_TileQuads2Attrs	 ; Create attribute bits out of tile values

	; Y -= 15 (previous row; 15 because VScroll_TileQuads2Attrs already subtracted 1)
	TYA
	SUB #$0f
	TAY

	JSR VScroll_TileQuads2Attrs	 ; Create attribute bits out of tile values

	; Temp_Var9 += 2 (next 2 columns over)
	INC <Temp_Var9
	INC <Temp_Var9

	; Temp_Var8++ (next Scroll_AttrStrip byte)
	INC <Temp_Var8

	LDA <Temp_Var8
	CMP #$08
	BLT PRG030_9DE4	 ; While not at end of row, loop

	LDA Scroll_LastAttr
	CMP #$f8
	BNE PRG030_9E11

	LDY #$07	 ; Y = 7
PRG030_9E06:

	LDA Scroll_AttrStrip,Y
	AND #$0f
	STA Scroll_AttrStrip,Y

	DEY		 ; Y--
	BPL PRG030_9E06	 ; While Y >= 0, loop

PRG030_9E11:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; TileLayout_GetBaseAddr
;
; Set layout pointer for the active tileset -> Temp_Var13/14
; also reloads 'Y' with the tile in Temp_Var11
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TileLayout_GetBaseAddr:
	LDA Level_Tileset 
	ASL A
	TAX		 ; X = Level_Tileset * 2

	; Set Temp_Var13/14 to point to the layout data for this Tileset
	LDA TileLayout_ByTileset,X
	STA <Temp_Var13
	LDA TileLayout_ByTileset+1,X
	STA <Temp_Var14

	LDY <Temp_Var11		 ; Y = tile temp

	RTS		 ; Return


VScroll_TileQuads2Attrs:
	LDX <Temp_Var8		 ; X = Temp_Var8 (Scroll_AttrStrip offset)

	LDA [Map_Tile_AddrL],Y	 ; Get the tile

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits
	ASL A
	ROL Scroll_AttrStrip,X
	ASL A
	ROL Scroll_AttrStrip,X

	DEY		 ; Y--

	LDA [Map_Tile_AddrL],Y	 ; Get the tile

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits
	ASL A
	ROL Scroll_AttrStrip,X
	ASL A
	ROL Scroll_AttrStrip,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileV
;
; Gets tile in vertical level
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileV:	; $9E3C 

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	LDA <Temp_Var13	 ; A = Temp_Var13 (Y Hi)
	PHA		 ; Save it
	TAY		 ; Y = Y Hi

	LDA <Temp_Var14	 ; A = Temp_Var14 (Y Lo)
	PHA		 ; Save it

	JSR LevelJct_GetVScreenH

	STA <Temp_Var14	 ; Adjusted Y for vertical -> Temp_Var14

	; Select root offset into tile memory
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Combine positions into Temp_Var15 to form tile mem offset
	LDA <Temp_Var14
	AND #$f0
	STA <Temp_Var15

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var15

	TAY		 ; Offset -> 'Y'

	PLA		 ; Restore original value for Temp_Var14
	STA <Temp_Var14	 ; Store it

	PLA		 ; Restore original value for Temp_Var13
	STA <Temp_Var13	 ; Store it

	LDA [Map_Tile_AddrL],Y	 ; Get tile
	STA <Level_Tile	 ; Store into Level_Tile

	RTS		 ; Return


	; This is basically a lookup for any given "Player Y Hi" shifted up 4 bits
PRG030_9E6C:
	.byte $00, $10, $20, $30, $40, $50, $60, $70, $80, $90, $A0, $B0, $C0, $D0, $E0, $F0

	; Translates the Player position into appropriate "high" value
	; as Vertical describes it ($0(00), $0(F0), $1(E0), ...)
LevelJct_GetVScreenH:
	; Y = Player_YHi
	; A = Player_Y

	CPY #$00
	BLS PRG030_9E8E	 ; If Y < 0 (i.e. if the Player Y High is less than zero, which shouldn't happen!), jump to PRG030_9E8E (RTS)

	ADD PRG030_9E6C,Y	; Player_Y += Player_YHi[Y]
	BCS PRG030_9E8A	 	; If carry set (overflow occurred), jump to PRG030_9E8A

	CMP #$f0	
	BLT PRG030_9E8E	 	; If result is < $F0, jump to PRG030_9E8E

PRG030_9E8A:
	; Add $10 and roll over 'Y' (Considered in the lower vertical half)
	ADD #$10
	INY	

PRG030_9E8E:
	RTS		 ; Return


	; Something similar to LevelJct_GetVScreenH, but I'm 
	; not quite following the purpose
LevelJct_GetVScreenH2:
	; A = Player_Y
	; Y = Player_YHi
	CPY #$00
	BLS PRG030_9E9A	 ; If YHi < 0 (shouldn't happen?), jump to PRG030_9E9A

	SUB PRG030_9E6C,Y
	BCS PRG030_9E9A	 ; If carry set, jump to PRG030_9E9A

	DEY		 ; Y--

PRG030_9E9A:
	RTS		 ; Return


; FIXME: Anybody want to claim this??
; $9E9B
	.byte $F0, $20

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileAndSlope_Normal
;
; Get tile and slope for given position and offset
; for non-vertical ("normal") levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileAndSlope_Normal:	; $9E9D

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	; Clear slope array
	LDA #$00	
	STA <Player_Slopes
	STA <Player_Slopes+1	; Not used; see below with Temp_Var1 assignment
	STA <Player_Slopes+2	; Not used; see below with Temp_Var1 assignment

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Level_TileOff	 ; Level_TileOff = Temp_Var16 >> 4 (current column Player is in)

	LDA <Temp_Var15
	AND #$0f	
	ASL A		
	TAX		 ; X = (Temp_Var15 & $0F) << 1 (current "high" part of Player X shifted up by 1, indexing Tile Mem)

	; Set Map_Tile_AddrL/H to appropriate screen based on Player's position
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	LDA <Temp_Var13
	BEQ PRG030_9EC3	 ; If Temp_Var13 (Y Hi) = 0, jump to PRG030_9EC3

	INC <Map_Tile_AddrH ; Otherwise, go to second half of screen

PRG030_9EC3:
	LDA <Temp_Var14
	AND #$f0
	ORA <Level_TileOff	 ; Level_TileOff gets the Player's current row in the upper 4 bits

	; Level_TileOff is now Player's current offset in Tile Mem from the selected pointer

	STA <Temp_Var12		 ; ... and copied into Temp_Var12

	TAY		 	; Y = current offset
	LDA [Map_Tile_AddrL],Y	; Get tile here
	STA <Level_Tile	; Store into Level_Tile

	LDY Level_Tileset
	CPY #3
	BEQ PRG030_9EDB	 ; If Level_Tileset = 3 (Hills style), jump to PRG030_9EDB

	CPY #14
	BNE PRG030_9F0D	 ; If Level_Tileset <> 14 (Underground), jump to PRG030_9F0D

PRG030_9EDB:
	; NOTE: Temp_Var1 = 0 and is used directly; at one time there was probably some kind
	; of loop here that would have implicated Player_Slopes+1 and Player_Slopes+2
	LDA #$00
	STA <Temp_Var1		 ; Temp_Var1 = 0

	LDY <Temp_Var12		 ; Y = current offset in Tile Mem
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	STA <Temp_Var2		 ; Store into Temp_Var2

	AND #$c0
	CLC
	ROL A
	ROL A
	ROL A
	TAY		; Y = tile quadrant (0 to 3)

	LDA <Temp_Var2		 ; Re-get tile
	CMP Tile_AttrTable,Y
	BLT PRG030_9F0D	 	; If it's less than the tile specified in Tile_AttrTable[Y], jump to PRG030_9F0D

	TYA
	ASL A
	TAX		 ; X = Y (tile quadrant) << 1 (two byte index)

	; Temp_Var3/4 are loaded with address inside PRG000_C000
	LDA Level_SlopeSetByQuad,X
	STA <Temp_Var3
	LDA Level_SlopeSetByQuad+1,X
	STA <Temp_Var4

	LDX <Temp_Var1	 	; X = Temp_Var1 (always 0)
	LDA <Temp_Var2	 	; A = Temp_Var2 (the retrieved tile)
	SUB Tile_AttrTable,Y	; Subtract the root tile value
	TAY		 	; Y = result

	LDA [Temp_Var3],Y		; Get value 
	STA <Player_Slopes,X	; Store into Player_Slopes

PRG030_9F0D:
	LDA <Level_Tile	; A = Level_Tile (the tile retrieved)
	RTS		 ; Return

	; Probably unused space
	.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff


PRG030_SUB_9F40:
	LDA #$00
	STA Raster_State 	; Reset Raster_State

	LDA Update_Request
	JMP PRG031_F499

	; Filler space
	.byte $ff, $ff, $ff, $ff, $ff

	; Sub part of A0 mode of IRQ
PRG030_SUB_9F50:
	; Some kind of delay loop?
	LDX #$17	 ; X = $17
PRG030_9F52:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG030_9F52 ; While X > 0, loop

	; Latch this value, and force it into the counter!
	STA MMC3_IRQLATCH
	STA MMC3_IRQDISABLE
	STA MMC3_IRQENABLE
	RTS		 ; Return

	; Probably unused space
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF

IntIRQ_32PixelPartition_Part5:

	; Some kind of delay loop?
	LDX #$13	 ; X = $13
PRG030_9F80:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG030_9F80 ; While X > 0, loop

	; More NOPs
	NOP
	NOP
	NOP

	STA MMC3_IRQLATCH ; Latch A (last set to 27!)
	STA MMC3_IRQENABLE ; Enable IRQ again
	JMP PRG031_FA3C	 ; Jump to PRG031_FA3C

	; Unused space
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF

IntIRQ_32PixelPartition_Part2:	; $9FA0
	LDA Update_Request	 
	AND #UPDATERASTER_32PIXSHOWSPR
	BNE PRG030_9FAA	 ; If UPDATERASTER_32PIXSHOWSPR is set, go to PRG030_9FAA

	; Otherwise, change loaded pattern tables to hide sprites that fall beneath the 32 pixel partition
	JMP IntIRQ_32PixPart_HideSprites

PRG030_9FAA:

	; I think the following NOPs and loop are to help synchronize the IRQ
	; routine if it didn't perform the IntIRQ_32PixPart_HideSprites step
	NOP
	NOP
	NOP

	LDX #$03	 ; X = 3
PRG030_9FAF:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG030_9FAF	 ; While X > 0, loop

	JMP IntIRQ_32PixelPartition_Part3

; NOTE: The remaining ROM space was all blank ($FF)

