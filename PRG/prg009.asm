; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:36.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

	; Number of lives per card combination; mainly to give the 2, 3, 5
Vs_LivesReward:
	.byte $00, $02, $03, $01, $05, $01, $01, $01	; None, Mushroom, Flower, Mix, Star, Mix, Mix, Mix

	; This seems like it had an intended purpose that didn't work out...
	; It could allow for different sounds for triple card combinations.
Vs_xUpSndTable:	.byte $00, SND_LEVEL1UP, SND_LEVEL1UP, SND_LEVEL1UP, SND_LEVEL1UP, SND_LEVEL1UP, SND_LEVEL1UP, SND_LEVEL1UP

	; Same deal as above; could have been used for different count
	; values, but not really employed at all...
Vs_xUpInitCount:
	.byte $00, $01, $01, $01, $01, $01, $01, $01

Vs_CardAwardLives:
	JSR Vs_DrawxUps	 ; Draw "x Up" messages

	LDX #$00	 ; X = 0
	LDY #$00	 ; Y = 0

	JSR PRG009_A026

	LDX #(Inventory_Cards2 - Inventory_Cards)	; Offset to Luigi's cards 
	LDY #$01	 ; Y = 1

PRG009_A026:
	STY <Temp_Var1	 ; Temp_Var1 = Y (Player index)
	STX <Temp_Var2	 ; Temp_Var2 = X (Player's card index, offset into Inventory_Cards)

	; Basically looking to see if Player has three cards; if so, jump to PRG009_A03E
	LDA Inventory_Cards,X
	BEQ PRG009_A039	 ; If card slot 1 is empty, jump to PRG009_A039 (RTS)

	LDA Inventory_Cards+1,X
	BEQ PRG009_A039	 ; If card slot 2 is empty, jump to PRG009_A039 (RTS)

	LDA Inventory_Cards+2,X
	BNE PRG009_A03E	 ; If card slot 3 is NOT empty, jump to PRG009_A03E

PRG009_A039:
	RTS		 ; Return

Vs_CardWeight:	.byte $00, $01, $02, $04	; None, Mushroom, Flower, Star

PRG009_A03E:

	; This following produces a non-zero value for any combination of cards.
	; If you have all the same card, it will produce exactly the "weight"
	; value as in Vs_CardWeight, otherwise it will be "something else"
	LDY Inventory_Cards,X	 ; Get first card

	LDA Vs_CardWeight,Y	 ; Get first card bit value
 
	LDY Inventory_Cards+1,X	 ; Get second card
	ORA Vs_CardWeight,Y	 ; OR with second

	LDY Inventory_Cards+2,X	 ; Get third card
	ORA Vs_CardWeight,Y	 ; And OR with third

	TAY		 	; Result -> 'Y'

	LDX <Temp_Var1		 ; X = Temp_Var1

	; Technically this just plays the "1-up" sound, but it could have been
	; used to play different sounds for card triples or something.
	LDA Sound_QLevel1
	ORA Vs_xUpSndTable,Y
	STA Sound_QLevel1

	; Load initial Vs_xUpCnt value
	LDA Vs_xUpInitCount,Y
	STA Vs_xUpCnt,X

	; Set X at Player's X
	LDA Vs_PlayerX,X
	STA Vs_xUpX,X

	; Set Y at Player's Y - 8
	LDA Vs_PlayerY,X
	SUB #$08
	STA Vs_xUpY,X

	LDA Vs_LivesReward,Y
	PHA		 ; Save lives to be awarded

	; Set Vs_xUpLives
	STA Vs_xUpLives,X

	; Add to Player's lives
	ADD Player_Lives,X
	STA Player_Lives,X

	PLA		 ; Restore awarded lives value
	BEQ PRG009_A08F	 ; If no award (shouldn't happen??), jump to PRG009_A08F (RTS)

	LDX <Temp_Var2	 ; X = Temp_Var2

	; Clear Player's cards
	LDA #$00
	STA Inventory_Cards,X
	STA Inventory_Cards+1,X
	STA Inventory_Cards+2,X

PRG009_A08F:
	RTS		 ; Return


Vs_xUpPattern_L:	.byte $F3, $71, $73, $FF, $65	; 1, 2, 3, INVALID, 5 lives
Vs_xUpPattern_R:	.byte $FF, $67, $67, $FF, $67	; 1, 2, 3, INVALID, 5 lives

Vs_xUp_SprRAMOff:	.byte $B0, $B8	; Sprite RAM offset for the "x Up"
	
Vs_DrawxUps:
	LDX #$01	 ; X = 1
PRG009_A09E:
	STX <Temp_Var1	 ; X -> Temp_Var1

	JSR Vs_xUpDraw	 ; Draw "x Up"

	DEX		 ; X--
	BPL PRG009_A09E	 ; While X >= 0, loop

	RTS		 ; Return

Vs_xUpDraw:
	LDA Vs_xUpCnt,X	 
	BEQ PRG009_A0B5	 ; If this "x Up" is not in use, jump to PRG009_A0B5 (RTS)

	CMP #$20
	BLT PRG009_A0B6	 ; If the "x Up" counter < $20, jump to PRG009_A0B6

	; "x Up" counter cleared
	LDA #$00
	STA Vs_xUpCnt,X

PRG009_A0B5:
	RTS		 ; Return

PRG009_A0B6:
	LDA <Vs_IsPaused
	BNE PRG009_A0C2	 ; If 2P Vs is paused, jump to PRG009_A0C2

	LDA <Counter_1
	LSR A
	BCC PRG009_A0C2	 ; Every other tick, jump to PRG009_A0C2

	INC Vs_xUpCnt,X	 ; Vs_xUpCnt++

PRG009_A0C2:
	LDY Vs_xUp_SprRAMOff,X	 ; Y = Sprite RAM offset for the "x Up"

	; Set "x Up" sprite Y
	LDA Vs_xUpY,X
	SUB Vs_xUpCnt,X
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Left "x Up" sprite X
	LDA Vs_xUpX,X
	STA Sprite_RAM+$03,Y

	; Right "x Up" sprite X
	ADD #$08
	STA Sprite_RAM+$07,Y

	; Attributes for "x Up" sprite
	LDA #SPR_PAL2
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	; X = number of lives earned
	LDA Vs_xUpLives,X
	TAX

	; Set left pattern
	LDA Vs_xUpPattern_L-1,X	; -1 because "0 lives" isn't valid
	STA Sprite_RAM+$01,Y

	; Set right pattern
	LDA Vs_xUpPattern_R-1,X	; -1 because "0 lives" isn't valid
	STA Sprite_RAM+$05,Y

	LDX <Temp_Var1	 ; Restore 'X'

	RTS		 ; Return

	; Graphics buffer commands to put a "coin" in the Player's top screen status
Vs_PlayerCoinStatCmds:
	vaddr $2000	; will be patched

	; Draw "coin" (repeat length of 1 is silly)
	.byte VU_REPEAT | 1, $2C

	; Terminator
	.byte $00
Vs_PlayerCoinStatCmds_End

	; Base VRAM offset for Mario/Luigi top screen coin status
Vs_PlayerCoinStatBaseVRAM:
	.byte $48, $53

	; X offset by card face
Card_XOffset:	.byte 0, 16, 32

	; Pattern for card sprite by card face
Card_Patterns:	.byte $E7, $E9, $EB
	

Vs_DrawPlayerCards:
	; Temp_Var1 = 0 (Sprite RAM offset for cards)
	LDA #$00
	STA <Temp_Var1

	; Temp_Var2 = 2 (current card of Player)
	LDA #$02
	STA <Temp_Var2

PRG009_A10E:
	LDX #$02	 ; X = 2 (3 cards to draw)
PRG009_A110:
	LDY <Temp_Var2	 ; Y = Temp_Var2 (current card of Player)

	STX <Temp_Var4	 ; Backup 'X'

	LDA Inventory_Cards,Y
	BEQ PRG009_A165	 ; If this card slot is empty, jump to PRG009_A165

	TAY		 ; Card Face -> 'Y'

	LDA Card_Patterns-1,Y	 ; Get pattern for this card (-1 since 0 is empty)

	LDY <Temp_Var1		 ; Y = Temp_Var1 (Sprite RAM offset for cards)

	; Set left and right card sprites to this pattern
	STA Sprite_RAM+$D1,Y
	STA Sprite_RAM+$D5,Y

	; Left/right sprites Y = 208
	LDA #208
	STA Sprite_RAM+$D0,Y
	STA Sprite_RAM+$D4,Y

	LDX #$00	 ; X = 0

	CPY #$08
	BEQ PRG009_A138	 ; If Y = $08, jump to PRG009_A138

	INX		 ; X++

	CPY #$18
	BNE PRG009_A144	 ; If Y <> $18, jump to PRG009_A144

PRG009_A138:
	LDA Vs_CardFlash,X
	BEQ PRG009_A144	 ; If this card is not flashing, jump to PRG009_A144

	; Perform palette cycling
	LSR A
	LSR A
	AND #$03

	JMP PRG009_A146	 ; Jump to PRG009_A146

PRG009_A144:
	LDA #SPR_PAL3

PRG009_A146: 
	; Set left/right card sprite attributes
	STA Sprite_RAM+$D2,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$D6,Y

	LDX <Temp_Var4	 ; Restore 'X'

	LDA #16		 ; A = 16	; Mario card base X

	CPY #$18
	BLT PRG009_A158	 ; If Y < $18, jump to PRG009_A158

	LDA #192	 ; A = 192	; Luigi card base X

PRG009_A158:

	; Set left card sprite X
	ADD Card_XOffset,X	; Add offset for this card
	STA Sprite_RAM+$D3,Y

	; Set right card sprite X
	ADD #$08
	STA Sprite_RAM+$D7,Y

PRG009_A165:

	; Temp_Var1 += 8 (two sprites over)
	LDA <Temp_Var1
	ADD #$08
	STA <Temp_Var1

	DEC <Temp_Var2	 ; Temp_Var2-- (Player's previous card)

	DEX		 ; X--
	BPL PRG009_A110	 ; While X >= 0, loop

	LDY <Temp_Var2	 ; Y = Temp_Var2
	BPL PRG009_A180	 ; If Temp_Var2 >= 0 (only happens at the end of Luigi's cards), jump to PRG009_A180 (RTS)

	; Temp_Var1 = $18 (Luigi's card base sprite offset)
	LDA #$18
	STA <Temp_Var1

	; Set Temp_Var2 as offset to Luigi's last card
	LDY #(Inventory_Cards2 - Inventory_Cards + 2)
	STY <Temp_Var2

	JMP PRG009_A10E	 ; Jump to PRG009_A10E

PRG009_A180:
	RTS		 ; Return


	; Adds recently collected coin to top screen status area
Vs_PlayerAddCoinToStatus:

	; Backup 'X'
	TXA
	PHA

	LDY #$00	 ; Y = 0

	LDX Graphics_BufCnt	 ; X = current graphics buffer count
PRG009_A188:
	LDA Vs_PlayerCoinStatCmds,Y
	STA Graphics_Buffer+$00,X

	INX		 ; X++ (next graphics buffer byte)
	INY		 ; Y++ (next byte of command data)

	CPY #(Vs_PlayerCoinStatCmds_End - Vs_PlayerCoinStatCmds)
	BNE PRG009_A188	; While not the last byte of command data, loop!

	LDY <Temp_Var16	 ; Y = Temp_Var16 (current Player index)
	LDA Vs_PlayerCoinStatBaseVRAM,Y	 ; Get base VRAM offset for coin
	ADD Vs_PlayerCoins,Y	 ; Offset to specific coin they just got
	STA Graphics_Buffer-4,X	 ; Set this as the VRAM low
	
	DEX		 	; X--
	STX Graphics_BufCnt	; Update Graphics_BufCnt

	; Restore 'X'
	PLA
	TAX

	RTS		 ; Return


Vs_2PVsPauseHandler:
	LDA SndCur_Pause	 
	BNE PRG009_A1DC	 ; If playing pause sound, jump to PRG009_A1DC

	LDA <Controller1Press
	AND #PAD_START
	BEQ PRG009_A1DC	 ; If Player 1 is not pressing START, jump to PRG009_A1DC

	; Toggle Vs_IsPaused
	LDA <Vs_IsPaused
	EOR #$01
	STA <Vs_IsPaused

	BNE PRG009_A1CC	 ; If paused, jump to PRG009_A1CC

	; Resume music from pause
	LDA #PAUSE_RESUMEMUSIC
	STA Sound_QPause

	; Restore halt timers from backup
	LDX #$0e	 ; X = $0E
PRG009_A1C1:
	LDA Vs_HaltTimerBackup,X
	STA Vs_PlayerHaltTimer,X

	DEX		 ; X--
	BPL PRG009_A1C1	 ; While X >= 0, loop

	BMI PRG009_A1DC	 ; Otherwise, jump to PRG009_A1DC

PRG009_A1CC:

	; Stop music for pause
	LDA #PAUSE_STOPMUSIC
	STA Sound_QPause

	; Backup halt timers
	LDX #$0e	 ; X = $0E
PRG009_A1D3:
	LDA Vs_PlayerHaltTimer,X
	STA Vs_HaltTimerBackup,X

	DEX		 ; X--
	BPL PRG009_A1D3	 ; While X >= 0, loop

PRG009_A1DC:
	LDA <Vs_IsPaused
	BEQ PRG009_A1EA	 ; If 2P Vs is paused, jump to PRG009_A1EA

	; Set all halt timers to $FF
	LDX #$0e	 ; X = $0E
	LDA #$ff	 ; A = $FF
PRG009_A1E4:
	STA Vs_PlayerHaltTimer,X

	DEX		 ; X--
	BPL PRG009_A1E4	 ; While X >= 0, loop

PRG009_A1EA:
	LDA Vs_State
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Vs_2PVsInit
	.word Vs_2PVsRun


	; This calculates the correct value for the Vs_EnemySetByGameType table by enemy set (2P Vs Enemy Set -> VsES)
VsES	.func (\1 - Vs_5EnemySets) / 5
Vs_EnemySetByGameType:
	.byte VsES(VsES_SpinyAll)	;  0: Spiny Only
	.byte VsES(VsES_FFlyAll)	;  1: Fighter Fly Only
	.byte VsES(VsES_SpinyFFly)	;  2: Spiny and Fighter Fly
	.byte VsES(VsES_SpinyAll)	;  3: Static coins (ENEMY SET NOT USED)
	.byte VsES(VsES_SpinySStep)	;  4: Spiny and Sidestepper
	.byte VsES(VsES_FFlySStep)	;  5: Fighter Fly and Sidestepper
	.byte VsES(VsES_SStepAll)	;  6: Sidestepper Only
	.byte VsES(VsES_SpinyAll)	;  7: Coin Fountain
	.byte VsES(VsES_SpinyAll)	;  8: Spiny Only
	.byte VsES(VsES_FFlyAll)	;  9: Fighter Fly Only 
	.byte VsES(VsES_SStepAll)	; 10: Sidestepper Only
	.byte VsES(VsES_SpinyAll)	; 11: Ladder and [?] blocks (ENEMY SET NOT USED)


Vs_2PVsInit:

	; Clear all 2P Vs memory
	LDY #$00	; Y = 0
	LDA #$00	; A = 0
PRG009_A204:
	STA Vs_MemStart,Y
	STA Vs_MemStart+$0100,Y

	DEY		; Y--
	BNE PRG009_A204	; While Y <> 0, loop

	; Seed Vs_Random
	LDA <Counter_1
	ORA #$91
	STA Vs_Random

	INC Vs_State	 ; Vs_State = 1

	LDY Map_2PVsGame ; Y = Map_2PVsGame (game style)

	; Set value for Vs_EnemySet
	LDA Vs_EnemySetByGameType,Y
	STA Vs_EnemySet

	TYA		 ; Y = Map_2PVsGame (game style)
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Vs_DoNothing	;  0: Spiny Only
	.word Vs_DoNothing	;  1: Fighter Fly Only
	.word Vs_DoNothing	;  2: Spiny and Fighter Fly
	.word Vs_LayoutCoins	;  3: Static coins
	.word Vs_DoNothing	;  4: Spiny and Sidestepper
	.word Vs_DoNothing	;  5: Fighter Fly and Sidestepper
	.word Vs_DoNothing	;  6: Sidestepper Only
	.word Vs_DoNothing 	;  7: Coin Fountain
	.word Vs_DoNothing	; 8: Spiny Only
	.word Vs_DoNothing	; 9: Fighter Fly Only 
	.word Vs_DoNothing	; 10: Sidestepper Only
	.word Vs_HideCoins	; 11: Ladder and [?] blocks


Vs_DoNothing:
	RTS

	; All possible X/Y coordinates that coins may be hidden in the [?] block game
Vs_HiddenCoinX:	.byte $14, $34, $54, $A4, $C4, $E4, $14, $34, $54, $A4, $C4, $E4, $24, $D4
Vs_HiddenCoinY:	.byte $20, $20, $20, $20, $20, $20, $70, $70, $70, $70, $70, $70, $C0, $C0

Vs_HideCoins:

	; Set cascading Var1 values across the blocks
	LDX #$0d	; X = $0D
PRG009_A25B:
	TXA
	STA <Temp_Var1,X
	DEX		 ; X--
	BPL PRG009_A25B	 ; While X >= 0, loop!

	; Temp_Var15/16 = $FF
	LDA #$ff
	STA <Temp_Var15
	STA <Temp_Var16

	LDX #$04	 ; X = 4
PRG009_A269:
	JSR PRG009_A287
	TAY		 ; Y = This object's Temp_Var1 value

	; Set hiding spot for coin
	LDA Vs_HiddenCoinX,Y
	STA Vs_ObjectsX,X
	LDA Vs_HiddenCoinY,Y
	STA Vs_ObjectsY,X

	; Coin is in normal state
	LDA #$01
	STA Vs_ObjectState,X

	; It's a coin!
	LDA #VSOBJID_COIN
	STA Vs_ObjectId,X

	DEX		 ; X--
	BPL PRG009_A269	 ; While X >= 0, loop

	RTS		 ; Return

PRG009_A287:
	JSR Vs_Randomize ; Stir up randomness
	AND #$0f
	TAY		 ; Y = 0 to 15, random

	LDA Temp_Var1,Y
	BMI PRG009_A287	 ; If Temp_Var1+Y < 0, loop

	PHA		 ; Save Temp_Var1

	; Temp_Var1 = $FF
	LDA #$ff
	STA Temp_Var1,Y

	PLA		 ; Restore Temp_Var1

	RTS		 ; Return

Vs_CoinLayoutX:	.byte $10, $E8, $2C, $CC, $7C
Vs_CoinLayoutY:	.byte $48, $48, $B0, $B0, $30

Vs_LayoutCoins:
	LDX #$04	; X = 4
PRG009_A2A6:
	INC Vs_ObjectState,X	 ; Set coin to normal stat

	; It's a coin!
	LDA #VSOBJID_COIN
	STA Vs_ObjectId,X

	; Set coin Y and X
	LDA Vs_CoinLayoutY,X
	STA Vs_ObjectsY,X
	LDA Vs_CoinLayoutX,X
	STA Vs_ObjectsX,X

	JSR Vs_PrepareNewObject	 ; Prepare coin

	DEX		 ; X--
	BPL PRG009_A2A6	 ; While X >= 0, loop

	RTS		 ; Return


Vs_2PVsRun:
	JSR Vs_DrawPlayerCards	 ; Draw Mario and Luigi's cards
	JSR Vs_CardAwardLives	 ; Award lives if Player has three cards

	LDA Map_2PVsGame	 ; Y = Map_2PVsGame (game style)
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Vs_GameTypical	;  0: Spiny Only
	.word Vs_GameTypical	;  1: Fighter Fly Only
	.word Vs_GameTypical	;  2: Spiny and Fighter Fly
	.word Vs_GameCoins	;  3: Static coins
	.word Vs_GameTypical	;  4: Spiny and Sidestepper
	.word Vs_GameTypical	;  5: Fighter Fly and Sidestepper
	.word Vs_GameTypical	;  6: Sidestepper Only
	.word Vs_GameFountain	;  7: Coin Fountain
	.word Vs_GameTypical	;  8: Spiny Only
	.word Vs_GameTypical	;  9: Fighter Fly Only 
	.word Vs_GameTypical	; 10: Sidestepper Only
	.word Vs_GameLadder	; 11: Ladder and [?] blocks


Vs_GameTypical:
	JSR Vs_PlayerMove	 	; Player movements and collisions with world and eachother
	JSR Vs_SpawnEnemies	 	; Periodically spawn enemies who emerge from the pipes until five exist
	JSR Vs_ObjectsUpdateAndDraw	; Update and draw objects
	JSR Vs_BumpBlocksUpdateAndDraw	; Update and draw bumped blocks
	JSR Vs_UpdateAndDrawPOW	 	; Update and draw POW Block
	RTS		 ; Return

Vs_GameLadder:
	JSR Vs_PlayerMove	 	; Player movements and collisions with world and eachother
	JSR Vs_ObjectsUpdateAndDraw	; Update and draw objects
	RTS		 ; Return

Vs_GameFountain:
	JSR Vs_PlayerMove	 	; Player movements and collisions with world and eachother
	JSR Vs_FountainSpray	 	; Spray of coins and fireballs
	JSR Vs_ObjectsUpdateAndDraw	; Update and draw objects
	RTS		 ; Return

; FIXME: Anybody want to claim this?  Perhaps a piece of a lost "game"?
; $A306
	JSR Vs_UNKGAME	; Unknown "game"?  After a long delay, Mario loses...
	RTS		 ; Return

Vs_GameCoins:
	JSR Vs_PlayerMove	 	; Player movements and collisions with world and eachother
	JSR Vs_ObjectsUpdateAndDraw	; Update and draw objects
	JSR Vs_BumpBlocksUpdateAndDraw	; Update and draw bumped blocks
	RTS		 ; Return

Vs_UNKGAME:
	LDA <Counter_1
	AND #$07
	BNE PRG009_A327	 ; 1:8 ticks proceed, otherwise jump to PRG009_A327

	INC Vs_UNKGAMECnt ; Vs_UNKGAMECnt++
	BNE PRG009_A327	 ; If Vs_UNKGAMECnt did not overflow, jump to PRG009_A327 (RTS)

	; Automatically decides Mario lost??
	LDA #$01
	STA Map_PlayerLost2PVs

	JMP PRG009_A431	 ; Jump to PRG009_A431

PRG009_A327:
	RTS		 ; Return


Vs_FountainSpray:
	LDA <Counter_1
	AND #$07			; 7:8 ticks...
	ORA Vs_PlayerHaltTimer		; ... if Mario is halted ...
	ORA Vs_PlayerHaltTimer+1	; ... if Luigi is halted ...
	ORA Vs_TimeToExit		; ... if we're exiting ...
	ORA <Vs_IsPaused		; ... or the game is paused ...
	BNE PRG009_A343	 		; ... jump to PRG009_A343 (RTS)

	LDX #$09	 ; X = 9
PRG009_A33B:
	LDA Vs_ObjectState,X
	BEQ PRG009_A344	 ; If this object slot is dead/empty, jump to PRG009_A344

	DEX		 ; X--
	BPL PRG009_A33B	 ; While X >= 0, loop

PRG009_A343:
	RTS		 ; Return


PRG009_A344:
	INC Vs_ObjectState,X	 ; Object is put into normal state

	; Decide whether a coin or a fireball is going to come out...
	LDY #VSOBJID_COIN

	LDA Vs_Random+2
	AND #$1c
	BNE PRG009_A352	 ; Randomly jump to PRG009_A352

	LDY #VSOBJID_FIREBALL_FOUNTAIN

PRG009_A352:

	; Set next object coming out of pipe
	TYA
	STA Vs_ObjectId,X

	; Set object starting position (top of pipe)
	LDA #176
	STA Vs_ObjectsY,X
	LDA #124
	STA Vs_ObjectsX,X

	; Random Y velocity
	JSR Vs_Randomize ; Stir up randomness
	AND #$0f
	ADC #-$58
	STA Vs_ObjectYVel,X

	; Random X velocity
	JSR Vs_Randomize ; Stir up randomness
	AND #$1f	; 0 to $20
	SBC #$10	; -$10 to $10
	STA Vs_ObjectXVel,X

	JSR Vs_PrepareNewObject	 ; Setup this new object

	INC Vs_ObjectVar1,X	 ; Vs_ObjectVar1 = 1

	; Initially emerging from pipe
	LDA #$30
	STA Vs_ObjectPipeTimer,X

	RTS		 ; Return

	; Y velocity of stomped card
Vs_CardStompYVel:
	.byte -$48, -$48, -$38	; Mushroom, Flower, Star

Vs_PlayerPopCard:
	LDX #$02	 ; X = 2 (Relative card index)
	LDY #$02	 ; Y = 2 (Mario's third card)

	LDA Vs_CurIndex
	BEQ PRG009_A38E	 ; If Player is Mario, jump to PRG009_A38E

	; Set Y as offset to Luigi's third card
	LDY #(Inventory_Cards2 - Inventory_Cards + 2)

PRG009_A38E:

	; card offset -> Temp_Var1
	STY <Temp_Var1

	LDA Inventory_Cards,Y
	BNE PRG009_A39D	 ; If Player has a card in this slot, jump to PRG009_A39D

	DEY		 ; Y-- (previous card)
	DEX		 ; X-- (decrement relative index)

	BPL PRG009_A38E	 ; While X >= 0, loop!

	LDX Vs_CurIndex ; Restore X as Vs_CurIndex
	RTS		 ; Return


PRG009_A39D:
	LDX #$0b	 ; X = $B (all object slots)
PRG009_A39F:
	LDA Vs_ObjectState,X
	BEQ PRG009_A3AD	 ; If this object slot is dead/empty, jump to PRG009_A3AD

	DEX		 ; X--

	CPX #$0a
	BNE PRG009_A39F	 ; While X <> $0A, loop (so ... it won't loop??)

	LDX Vs_CurIndex ; Restore X as Vs_CurIndex
	RTS		 ; Return

PRG009_A3AD:
	LDA Inventory_Cards,Y
	TAY		 ; Y = current card face 
	ADD #(VSOBJID_MUSHROOMCARD-1)
	STA Vs_ObjectId,X	; Set proper object ID for the card

	; Set Y Velocity of card
	LDA Vs_CardStompYVel-1,Y
	STA Vs_ObjectYVel,X

	; Vs_ObjectState = 1 (Normal operation)
	INC Vs_ObjectState,X

	LDY <Temp_Var1	 ; Y = Temp_Var1

	; Player lost this card
	LDA #$00
	STA Inventory_Cards,Y

	JSR Vs_PrepareNewObject	 ; Prepare new card object

	LDY Vs_CurIndex	 ; Y = current Player index

	; Set card X at Player X
	LDA Vs_PlayerX,Y
	STA Vs_ObjectsX,X

	ASL A		 ; Sets carry if Player is on right half of field

	; Set card's X velocity to $06 or -$06
	LDA #$06	; A = $06 if on left side of field
	BCC PRG009_A3DA	 ; If carry clear (on left side of field), jump to PRG009_A3DA
	LDA #-$06	 ; A = -$06 if on right side of field
PRG009_A3DA:
	STA Vs_ObjectXVel,X

	; Set card Y at Player Y
	LDA Vs_PlayerY,Y
	STA Vs_ObjectsY,X

	; Object Y Hi = 0
	LDA #$00
	STA Vs_ObjectYHi,X

	; Vs_EnemyGetUpTimer = $20
	LDA #$20
	STA Vs_EnemyGetUpTimer,X

	LDX Vs_CurIndex ; Restore X as Vs_CurIndex
	RTS		 ; Return

Vs_PlayerMove:
	LDX #$01	
PRG009_A3F3: 
	STX Vs_CurIndex

	LDA Vs_IsPaused
	BNE PRG009_A40B	 ; If 2P Vs is paused, jump to PRG009_A40B

	LDA Vs_PlayerCnt,X
	BEQ PRG009_A403	 ; If Vs_PlayerCnt = 0, jump to PRG009_A403

	DEC Vs_PlayerCnt,X	 ; Vs_PlayerCnt--

PRG009_A403:
	LDA Vs_CardFlash,X
	BEQ PRG009_A40B	 ; If Vs_CardFlash = 0, jump to PRG009_A40B

	DEC Vs_CardFlash,X	 ; Vs_CardFlash--

PRG009_A40B:
	JSR Vs_PlayerDoMovements	; Do Player movements

	; Clear Player Y offset
	LDA #$00
	STA Vs_PlayerYOff,X

	DEX		 ; X--
	BPL PRG009_A3F3	; While X >= 0

	JSR VsPlayer_BumpEachother	 ; Handle Players bumping into eachother

	RTS		 ; Return

Vs_PlayerDoMovements:
	LDA Vs_PlayerHaltTimer,X	 
	BEQ PRG009_A424	 ; If Player is not halted, jump to PRG009_A424

	DEC Vs_PlayerHaltTimer,X	 ; Vs_PlayerHaltTimer--
	BNE PRG009_A43D	 ; As long as Player remains halted, jump to PRG009_A43D

PRG009_A424:
	LDY Vs_TimeToExit
	BEQ PRG009_A445	 ; If not time to exit, jump to PRG009_A445

	; Waiting to exit...

	TXA
	BNE PRG009_A43D	 ; If this is Luigi, jump to PRG009_A43D (only one Player needs to do counter work)

	DEC Vs_TimeToExit	 ; Vs_TimeToExit--

	BNE PRG009_A43D	 ; If ticks remain on Vs_TimeToExit, jump to PRG009_A43D

PRG009_A431:

	; NOTE: If you RTS here, you can see the game operate where a dead Player 
	; is allowed to resume!  Interesting lost effect... (see around PRG009_A79A)

	; Flag to exit to map!
	LDA #$01
	STA Level_ExitToMap

	; Vs_State = 0
	LSR A
	STA Vs_State

	; Do not return to caller!!
	PLA
	PLA

PRG009_A43C:
	RTS		 ; Return

PRG009_A43D:

	; Player is halted...

	LDA Vs_PlayerState,X
	BEQ PRG009_A43C	 ; If Vs_PlayerState = 0 (Init), jump to PRG009_A43C (RTS)

	JMP Vs_PlayerDraw	 ; Otherwise, jump to Vs_PlayerDraw

PRG009_A445:
	LDA Vs_PlayerState,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word VsPlayer_Init	; 0: Initialize, set starting position
	.word VsPlayer_Normal	; 1: Normal operation
	.word VsPlayer_Dying	; 2: Dying
	.word VsPlayer_Climbing	; 3: Climbing

	; Player initial X position (Mario/Luigi, coin fountain Mario/Luigi)
Vs_PlayerInitX:		.byte $40, $B0, $10, $E0

	; Player initial direction (Mario/Luigi)
Vs_PlayerInitDir:	.byte $01, $02

VsPlayer_Init:
	LDY Vs_PlayerCnt,X
	BEQ PRG009_A468	 ; If Vs_PlayerCnt = 0, jump to PRG009_A468

	DEY		 ; Y--

	BNE PRG009_A491	 ; If more than one tick remains, jump to PRG009_A491 (RTS)

	INX		 ; X++ (guarenteed non-zero)
	STX Map_PlayerLost2PVs	 ; Flag Player as to not lose a life when we go back to the map

	JMP PRG009_A431	 ; Jump to PRG009_A431 (exit to map)

PRG009_A468:
	; Halt horizontal and vertical movement
	LDA #$00
	STA Vs_PlayerXVel,X
	STA Vs_PlayerYVel,X

	; Set Player to "Normal" state
	LDA #$01
	STA Vs_PlayerState,X

	TXA
	TAY	; Y = Player index

	; Set Player initial facing direction
	LDA Vs_PlayerInitDir,Y
	STA Vs_PlayerDir,X

	; Set Player initial Y = $90
	LDA #$90
	STA Vs_PlayerY,X

	LDA Map_2PVsGame
	CMP #$07
	BNE PRG009_A48B	 ; If Map_2PVsGame <> 7 (coin fountain), jump to PRG009_A48B

	; Coin fountain only; Y += 2
	INY
	INY

PRG009_A48B:

	; Set Player initial X
	LDA Vs_PlayerInitX,Y
	STA Vs_PlayerX,X

PRG009_A491:
	RTS		 ; Return

Vs_WalkCntRate:
	.byte $10, $20, $40, $60, $80, $A0, $C0, $E0

	; Sets X velocity after Player hits a wall (only used in bonus games where wall blocking is possible)
Vs_PlayerBlockXVel:
	.byte $04, -$04	; Right, Left

	; Only certain Map_2PVsGame styles even have walls to worry about...
	; Set value to non-zero (1) to enable wall hits
Vs_PlayerWallEnable:
	.byte $00	;  0: Spiny Only
	.byte $00	;  1: Fighter Fly Only
	.byte $00	;  2: Spiny and Fighter Fly
	.byte $00	;  3: Static coins
	.byte $00	;  4: Spiny and Sidestepper
	.byte $00	;  5: Fighter Fly and Sidestepper
	.byte $00	;  6: Sidestepper Only
	.byte $01	;  7: Coin Fountain
	.byte $00	;  8: Spiny Only
	.byte $00	;  9: Fighter Fly Only 
	.byte $00	; 10: Sidestepper Only
	.byte $01	; 11: Ladder and [?] blocks

VsPlayer_Normal:
	LDA Vs_PlayerBumpTimer	 
	BNE PRG009_A4CF	 ; If Vs_PlayerBumpTimer <> 0, jump to PRG009_A4CF

	LDA <Controller1,X
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG009_A4CF	 ; If Player is not pressing up or down, jump to PRG009_A4CF

	; Player is pressing up or down...

	AND Vs_PlayerDetStat,X
	BNE PRG009_A4CF	 ; If Player is pressing a direction into a way they are blocked, jump to PRG009_A4CF

	LDA Vs_PlayerTileU,X
	CMP #TILE18_LADDER
	BNE PRG009_A4CF	 ; If this is not the ladder tile, jump to PRG009_A4CF

	; Halt Player's velocity
	LDA #$00
	STA Vs_PlayerXVel,X
	STA Vs_PlayerYVel,X

	; Set Ladder Climbing state
	LDA #$03
	STA Vs_PlayerState,X

	JMP Vs_PlayerDraw	 ; Jump to Vs_PlayerDraw

PRG009_A4CF:

	; Player not climbing ladder...

	LDA <Controller1,X
	BEQ PRG009_A4D8	 ; If Player not pressing anything, jump to PRG009_A4D8

	; Vs_PlayerFlashInv = 0
	LDA #$00
	STA Vs_PlayerFlashInv,X

PRG009_A4D8:
	LDA Vs_PlayerDizzy,X
	BEQ PRG009_A4EA	 ; If Player is not stomped, jump to PRG009_A4EA

	CMP #$08
	BNE PRG009_A4E4	 ; If Vs_PlayerDizzy <> 8, jump to PRG009_A4E4

	JSR Vs_PlayerPopCard	 ; Pop out Player's card!

PRG009_A4E4:

	; Something removed here...
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP

PRG009_A4EA:
	LDA <Controller1,X
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG009_A546	 ; If Player is not pressing left or right, jump to PRG009_A546

	; Player is pressing left or right...

	; Set Player direction by direction press
	STA Vs_PlayerDir,X

	LSR A
	BCC PRG009_A51E	 ; If Player pushed left, jump to PRG009_A51E

	; Player pushed right

	LDA <Controller1,X
	AND #PAD_B
	BEQ PRG009_A509	 ; If Player did not push B, jump to PRG009_A509

	; Player pushed B...

	LDA Vs_PlayerXVel,X
	CMP #$18
	BGS PRG009_A506	 ; If Player X Velocity >= $18, jump to PRG009_A506

	ADD #$01	 ; Otherwise, +1 to X Velocity

PRG009_A506:
	JMP PRG009_A543	 ; Jump to PRG009_A543 (set Player X velocity)

PRG009_A509:

	; Player did not push B...

	LDA Vs_PlayerXVel,X
	CMP #$0c
	BEQ PRG009_A51B	 ; If Player X Velocity = $0C, jump to PRG009_A51B
	BGS PRG009_A518	 ; If Player X Velocity > $0C, jump to PRG009_A518

	ADD #$01	 ; +1 to X Velocity

	JMP PRG009_A543	 ; Jump to PRG009_A543 (set Player X velocity)

PRG009_A518:
	SUB #$01	 ; Player going too fast, -1 to X Velocity

PRG009_A51B:
	JMP PRG009_A543	 ; Jump to PRG009_A543 (set Player X velocity)

PRG009_A51E:

	; Player pushed left

	LDA <Controller1,X
	AND #PAD_B
	BEQ PRG009_A531	 ; If Player did not push B, jump to PRG009_A531

	; Player pushed B...

	LDA Vs_PlayerXVel,X
	CMP #-$17
	BLS PRG009_A52E	 ; If Player X Velocity < -$17, jump to PRG009_A52E

	SUB #$01	 ; Otherwise, -1 to X Velocity

PRG009_A52E:
	JMP PRG009_A543	 ; Jump to PRG009_A543 (set Player X velocity)

PRG009_A531:

	; Player did not push B...

	LDA Vs_PlayerXVel,X
	CMP #-$0C
	BEQ PRG009_A543	 ; If Player's X velocity = -$0C, jump to PRG009_A543
	BLS PRG009_A540	 ; If Player's X velocity < -$0C, jump to PRG009_A540

	SUB #$01	 ; -1 to X Velocity

	JMP PRG009_A543	 ; Jump to PRG009_A543 (set Player X velocity)

PRG009_A540:
	ADD #$01	 ; Player going too fast, +1 to X Velocity

PRG009_A543:
	; Set Player X velocity
	STA Vs_PlayerXVel,X

PRG009_A546:
	LDA Vs_PlayerDetStat,X
	AND #$04
	BEQ PRG009_A552	 ; If Player has not hit ground, jump to PRG009_A552

	LDA Vs_PlayerYVel,X
	BPL PRG009_A555	 ; If Player is moving downward, jump to PRG009_A555

PRG009_A552:
	JMP PRG009_A5ED	 ; Otherwise, jump to PRG009_A5ED

PRG009_A555:

	; Player is moving downard

	LDA Vs_PlayerY,X	; Get Player Y
	AND #~%00000111		; Align to nearest 8
	ADD Vs_PlayerYOff,X	; Apply Y offset
	STA Vs_PlayerY,X	; -> Player Y

	LDA #$00
	STA Vs_PlayerYVel,X	; Halt Player vertical movement
	STA Vs_PlayerJumped,X	; Clear Player jumped flag

	LDY Vs_PlayerTileL,X
	CPY #TILE18_BOUNCEDBLOCK
	BNE PRG009_A588	 ; If Player is NOT standing on a bounced block, jump to PRG009_A588

	; Player got hit from underneath!

	LDA Vs_PlayerDetStat,X
	AND #%11000000	; Mask out Player hit from underneath left/right bits

	LDY #$08	 ; Y = $08 (Player hit on left side)

	CMP #%11000000
	BEQ PRG009_A585	; If Player hit on both left and right side, jump to PRG009_A585

	CMP #%10000000
	BEQ PRG009_A581	; If Player hit on left side, jump to PRG009_A581

	LDY #-$08	 ; Y = -$08 (Player hit on right side)

PRG009_A581:

	; Set Player's X velocity
	TYA
	STA Vs_PlayerXVel,X

PRG009_A585:
	JMP PRG009_A58D	 ; Jump to PRG009_A5AD

PRG009_A588:
	LDY Vs_POWBlockCnt
	BEQ PRG009_A5AD	 ; If Vs_POWBlockCnt = 0 (no POW occuring), jump to PRG009_A5AD

	; POW block occuring...

PRG009_A58D:

	; Set Player dizzy
	LDA #$12
	STA Vs_PlayerDizzy,X

	; Play Player knocked about sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	LDA #-$38
	JMP PRG009_A5CE	 ; Jump to PRG009_A5CE (set Player Y Velocity)

	; Table of values that gives Player a different jump height based on movement speed
Vs_PlayerJumpHeightBySpd:
	.byte -$42, -$42, -$42, -$42, -$42, -$42, -$42, -$36, -$38, -$3A, -$3C, -$3E, -$40, -$42
	
PRG009_A5AD:

	; No POW block occuring

	LDA <Controller1Press,X
	BPL PRG009_A5D1	 ; If Player is NOT pressing A, jump to PRG009_A5D1

	; Play jump sound!
	LDA Sound_QPlayer
	ORA #SND_PLAYERJUMP
	STA Sound_QPlayer

	; Player jumped!
	LDA #$01
	STA Vs_PlayerJumped,X

	; Get absolute value of Player's X velocity
	LDA Vs_PlayerXVel,X
	BPL PRG009_A5C8	 ; If Player is not moving left, jump to PRG009_A5C8
	NEG	; Otherwise, negate (get absolute value)
PRG009_A5C8:

	LSR A
	LSR A
	TAY		 ; Y = absolute value of Player's X velocity / 4

	LDA Vs_PlayerJumpHeightBySpd,Y	 ; Get appropriate jump height

PRG009_A5CE:
	STA Vs_PlayerYVel,X	 ; Set Player's Y velocity

PRG009_A5D1:
	LDA <Controller1,X
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG009_A5ED	 ; If Player is pressing left or right, jump to PRG009_A5ED

	; Player is not pressing left or right...

	LDA Vs_PlayerXVel,X
	BEQ PRG009_A5ED	 ; If Player is not moving horizontally, jump to PRG009_A5ED
	BPL PRG009_A5E7	 ; If Player is moving to the right, jump to PRG009_A5E7

	; Player is moving to the left...

	ADD #$01	 ; +1 to X Velocity (slow down)

	STA Vs_PlayerXVel,X	 ; Update X velocity
	JMP PRG009_A5ED	 ; Jump to PRG009_A5ED

PRG009_A5E7:

	; Player is moving to the right...

	SUB #$01	 ; -1 to X Velocity (slow down)
	STA Vs_PlayerXVel,X	 ; Update X velocity

PRG009_A5ED:
	LDY Map_2PVsGame	 ; Y = Map_2PVsGame (field style)

	LDA Vs_PlayerWallEnable,Y
	BEQ PRG009_A610	 ; If walls are not enabled on this game style, jump to PRG009_A610

	LDA #$01	; A = 1 (Player moving to the right)

	LDY Vs_PlayerXVel,X
	BPL PRG009_A5FD	 ; If Player's is not moving to the left, jump to PRG009_A5FD

	ASL A		 ; A = 2 (Player moving to the left)

PRG009_A5FD:
	AND Vs_PlayerDetStat,X
	BEQ PRG009_A610	 ; If Player is not moving in direction they're blocked in, jump to PRG009_A610

	AND <Controller1,X
	BEQ PRG009_A60A	 ; If Player is not pressing the same direction as the direction they're blocked in, jump to PRG009_A60A

	; Player is pushing against their blocking direction...

	TAY		 	; Blocking direction bit -> 'Y' (1 or 2)
	LDA Vs_PlayerBlockXVel-1,Y	; Set X velocity to small value in response to block

PRG009_A60A:
	STA Vs_PlayerXVel,X	 ; Set blocked X velocity
	JMP PRG009_A613	 ; Jump to PRG009_A613

PRG009_A610:
	JSR Vs_ApplyXVel	 ; Apply Player's X velocity

PRG009_A613:
	LDA Vs_PlayerStick,X
	BEQ PRG009_A61D	 ; If Player is not sticking, jump to PRG009_A61D

	DEC Vs_PlayerStick,X	 ; Vs_PlayerStick--
	BNE PRG009_A662	 ; While Player remains stuck, jump to PRG009_A662

PRG009_A61D:
	LDY Vs_PlayerYVel,X
	BPL PRG009_A644	 ; If Player is moving downward, jump to PRG009_A644

	; Player is moving upward...

	LDA Vs_PlayerDetStat,X
	AND #$08
	BEQ PRG009_A644	 ; If Player has not hit ceiling, jump to PRG009_A644

	; Player "sticks" to the block he hit
	TYA
	EOR #$ff	 ; Sort of negate the Y velocity
	LSR A
	LSR A
	LSR A		 ; Divide by 8
	ADC #$04	 ; +4
	STA Vs_PlayerStick,X	; Set Vs_PlayerStick

	; Halt vertical movement
	LDA #$00
	STA Vs_PlayerYVel,X

	LDA Vs_PlayerY,X
	AND #$f0	; Align to grid
	ADD #14		; +14
	STA Vs_PlayerY,X

PRG009_A644:
	JSR Vs_ApplyYVel	 ; Apply Y Velocity

	LDA Vs_PlayerYVel,X
	BMI PRG009_A650	 ; If Player is moving upward, jump to PRG009_A650

	; Player is moving downward...

	CMP #$40
	BGE PRG009_A662	 ; If Player is falling >= $40, jump to PRG009_A662

PRG009_A650:
	LDA Vs_PlayerYVel,X
	BPL PRG009_A659	 ; If Player is moving downward, jump to PRG009_A659

	; Player is moving upward...

	LDY <Controller1,X
	BMI PRG009_A65C	 ; If Player is pressing A, jump to PRG009_A65C

PRG009_A659:
	ADD #$03	; +3 to Y velocity

PRG009_A65C:
	ADD #$02	 ; +2 to Y velocity
	STA Vs_PlayerYVel,X	 ; Update Y velocity

PRG009_A662:
	LDY #$00	 ; Y = 0

	LDA Vs_PlayerXVel,X
	BNE PRG009_A66E	 ; If Player is moving horizontally, jump to PRG009_A66E

	; Player is not moving horizontally...

	STA Vs_PlayerClimbFrame,X	; Clear Vs_PlayerClimbFrame

	BEQ PRG009_A6A1	 ; Jump (technically always) to PRG009_A6A1

PRG009_A66E:

	; Player is moving horizontally...

	LDY #$01	 ; Y = 1 (Player is moving to the right)

	ASL A		; Push sign bit into carry
	BCC PRG009_A675	 ; If Player is moving to the right, jump to PRG009_A675

	LDY #$02	 ; Y = 2 (Player is moving to the left)

PRG009_A675:
	TYA		 ; A = 1 or 2

	LDY #$02	 ; Y = 2 (skidding turnaround frame)

	CMP Vs_PlayerDir,X
	BEQ PRG009_A67F	 ; If Player has not turned around, jump to PRG009_A67F
	BNE PRG009_A6A1	 ; Otherwise, jump to PRG009_A6A1

PRG009_A67F:

	; Player has not turned around...

	LDA Vs_PlayerXVel,X
	BPL PRG009_A689	 ; If X velocity is positive, jump to PRG009_A689
	NEG		; Otherwise, negate it (absolute value)
PRG009_A689:

	LSR A
	LSR A		; Divide by 4
	TAY		 ; Y = absolute value of Player X velocity / 4

	; Add to Vs_PlayerWalkCnt based on how fast Player is moving
	LDA Vs_PlayerWalkCnt,X
	ADD Vs_WalkCntRate,Y	
	STA Vs_PlayerWalkCnt,X	
	BCC PRG009_A69B	 ; If didn't overflow, jump to PRG009_A69B

	INC Vs_PlayerWalkFrame,X	 ; Otherwise, toggle walk frame
PRG009_A69B:

	LDA Vs_PlayerWalkFrame,X
	AND #$01
	TAY		 ; Y = 0 or 1 (walking frames)

PRG009_A6A1:
	LDA Vs_PlayerDetStat,X
	AND #$04
	BNE PRG009_A6B1	 ; If Player is on ground, jump to PRG009_A6B1

	; Player not on ground...

	LDY #$03	 ; Y = 3 (jumping/falling frame)

	LDA Vs_PlayerJumped,X
	BNE PRG009_A6B1	 ; If Player had jumped, jump to PRG009_A6B1

	LDY #$01	 ; Y = 1 (Non-jump falling frame)

PRG009_A6B1:
	LDA Vs_PlayerDizzy,X
	BEQ PRG009_A6BB	 ; If Player is not dizzy, jump to PRG009_A6BB

	DEC Vs_PlayerDizzy,X	 ; Vs_PlayerDizzy--

	LDY #$04	 ; Y = 4 (Dizzy frame)

PRG009_A6BB:
	LDA Vs_PlayerKick,X
	BEQ PRG009_A6C5	 ; If Player is not kicking, jump to PRG009_A6C5

	DEC Vs_PlayerKick,X	 ; Vs_PlayerKick--

	LDY #$05	 ; Y = 5 (Kicking frame)

PRG009_A6C5:
	TYA		 ; Appropriate frame -> 'A'
	STA Vs_PlayerFrame,X	 ; Set appropriate frame

	CMP #$02
	BNE PRG009_A6D5	 ; If Vs_PlayerFrame <> 2 (skidding turnaround), jump to PRG009_A6D5

	; Player skidding noise
	LDA Sound_QLevel2
	ORA #SND_LEVELSKID
	STA Sound_QLevel2

PRG009_A6D5:
	JSR Vs_PlayerDraw	 ; Draw Player
	JSR Vs_CollideAgainstWorld ; Collide Player against world

	RTS		 ; Return


VsPlayer_Climbing:
	LDA <Controller1,X	 
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG009_A6FE	 ; If Player is pressing neither up nor down, jump to PRG009_A6FE

	; Player is pressing UP or DOWN...

	AND Vs_PlayerDetStat,X
	BNE PRG009_A6FE	 ; If Player is blocked in the direction they want to go, jump to PRG009_A6FE

	LDA Vs_PlayerX,X
	AND #$0f	 ; Player distance across tile
	BEQ PRG009_A6FE	 ; If Player is on left edge of tile, jump to PRG009_A6FE

	; This is to scoot Player towards center of ladder
	CMP #$08
	LDY #$01	 ; Y = 1 (Player is on right half of tile)
	BGE PRG009_A6F6	 ; If Player is on right half of tile, jump to PRG009_A6F6
	LDY #-$01	 ; Y = -1 (Player is on left half of tile)
PRG009_A6F6:
	TYA
	ADD Vs_PlayerX,X
	STA Vs_PlayerX,X	; Update Player X

PRG009_A6FE:
	LDA <Controller1,X
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG009_A734	 ; If Player is pressing neither up nor down, jump to PRG009_A734

	; Player is pressing UP or DOWN...

	STA <Temp_Var1		 ; Store whichever is the case -> Temp_Var1

	AND Vs_PlayerDetStat,X
	BNE PRG009_A754	 ; If Player is blocked in the direction they want to go, jump to PRG009_A754

	LDA <Temp_Var1
	CMP #PAD_UP
	BNE PRG009_A72E	 ; If Player is not pressing UP, jump to PRG009_A72E

	; Player is pressing UP...

	LDA #TILE18_LADDER
	CMP Vs_PlayerTileU,X
	BNE PRG009_A754	 ; If Player is not detecting ladder, jump to PRG009_A754

	DEC Vs_PlayerY,X	 ; Player Y -- (climb up!)

	JSR Vs_CollideAgainstWorld ; Collide Player against world

	LDA Vs_PlayerTileU,X
	CMP #TILE18_LADDER
	BEQ PRG009_A728	 ; If Player remains on ladder, jump to PRG009_A728

	INC Vs_PlayerY,X	 ; Otherwise, Player Y ++ (un-climb)

PRG009_A728:
	INC Vs_PlayerClimbFrame,X	 ; Vs_PlayerClimbFrame++
	JMP PRG009_A764	 ; Jump to PRG009_A764

PRG009_A72E:
	INC Vs_PlayerY,X	 ; Player Y ++ (climb dowm!)
	INC Vs_PlayerClimbFrame,X	 ; Vs_PlayerClimbFrame++

PRG009_A734:
	LDA <Controller1,X
	AND #(PAD_LEFT | PAD_RIGHT)
	STA <Temp_Var1	 ; Player pressing left/right -> Temp_Var1

	; Player is pressing left/right while on the ladder...

	AND Vs_PlayerDetStat,X
	BNE PRG009_A74D	 ; If Player is being blocked in the direction they want to go, jump to PRG009_A74D

	LSR <Temp_Var1
	BCC PRG009_A746	 ; If Player is not pressing RIGHT, jump to PRG009_A746

	; Player is pressing RIGHT...

	INC Vs_PlayerX,X	 ; Player X ++ (climb to the right)

PRG009_A746:
	LSR <Temp_Var1
	BCC PRG009_A74D	 ; If Player is not pressing LEFT, jump to PRG009_A74D

	DEC Vs_PlayerX,X	 ; Player X -- (climb to the left)

PRG009_A74D:
	LDA Vs_PlayerTileU,X
	CMP #TILE18_LADDER
	BEQ PRG009_A764	 ; If Player is still detecting ladder, jump to PRG009_A764

PRG009_A754:
	; Player is off ladder...

	; Return to "normal" state
	LDA #$01
	STA Vs_PlayerState,X

	; Halt movement and clear jump variable
	LDA #$00
	STA Vs_PlayerXVel,X
	STA Vs_PlayerYVel,X
	STA Vs_PlayerJumped,X

PRG009_A764: 

	; Set climbing frame
	LDA #$07
	STA Vs_PlayerFrame,X

	JSR Vs_CollideAgainstWorld	 ; Collide Player against world

	; Flip Player back and forth every 4 ticks
	LDA Vs_PlayerClimbFrame,X
	AND #$04
	LSR A
	LSR A
	ADC #$01
	STA Vs_PlayerDir,X
	JMP Vs_PlayerDraw


VsPlayer_Dying:

	; Set dying frame!
	LDA #$06	 
	STA Vs_PlayerFrame,X

	JSR Vs_PlayerDraw	 ; Draw Player

	LDA Vs_PlayerCnt,X
	BNE PRG009_A7B3	 ; If Player counter not expired, jump to PRG009_A7B3 (RTS)

	JSR Vs_ApplyYVel	 ; Apply Y Velocity

	LDA Vs_PlayerYVel,X
	BMI PRG009_A794	 ; If Player is moving upward, jump to PRG009_A794

	CMP #$40
	BGE PRG009_A79A	 ; If Player is falling >= $40, jump to PRG009_A79A

PRG009_A794:
	; Player Y Velocity += 2 (gravity)
	INC Vs_PlayerYVel,X
	INC Vs_PlayerYVel,X

PRG009_A79A:
	LDA Vs_PlayerY,X
	CMP #240
	BLT PRG009_A7B3	 ; If Player Y < 240 (bottom of screen), jump to PRG009_A7B3 (RTS)


	LDA Vs_PlayerYHi,X
	BNE PRG009_A7B3	 ; If Player is vertically off-screen, jump to PRG009_A7B3 (RTS)


	; Hmm!  It looks like they were possibly intended a dead Player to be able to resume??
	; Appears to be a lost effect that is never given a chance to occur...
	; See near PRG009_A431 how to re-enable this effect!

	; Vs_PlayerCnt = $40
	LDA #$40
	STA Vs_PlayerCnt,X

	; Make flashing invincible
	STA Vs_PlayerFlashInv,X

	; Player state = 0 (re-init)
	LDA #$00
	STA Vs_PlayerState,X

PRG009_A7B3:
	RTS		 ; Return

Vs_DetStatLoopXOff:	
	.byte $08	; 0: ceiling hit (left)
	.byte $08	; 1: ceiling hit (right)
	.byte $02	; 2: left wall hit
	.byte $0E	; 3: right wall hit
	.byte $04	; 4: floor hit (left)
	.byte $0C	; 5: floor hit (right)

	.byte $04, $04, $00, $08, $04, $04


Vs_DetStatLoopYOff:
	.byte $00	; 0: ceiling hit (left)
	.byte $00	; 1: ceiling hit (right)
	.byte $08	; 2: left wall hit
	.byte $08	; 3: right wall hit
	.byte $10	; 4: floor hit (left)
	.byte $10	; 5: floor hit (right)

	; Detection status bits that are set by the different checks
Vs_DetStatLoop:
	.byte $08	; 0: ceiling hit
	.byte $08	; 1: ceiling hit
	.byte $02	; 2: left wall hit
	.byte $01	; 3: right wall hit
	.byte $04	; 4: floor hit
	.byte $04	; 5: floor hit
Vs_DetStatLoop_End

Vs_DetStatLoopUnderHit:
	.byte $00
	.byte $00
	.byte $00
	.byte $00
	.byte $80	; Hit from underneath, left
	.byte $40	; Hit from underneath, right



	; Collides Players (X = 0 for Mario, X = 1 for Luigi) or Objects (X = 2 + object index)
	; against the tiles that construct the 2P Vs battle field
Vs_CollideAgainstWorld:
	; Temp_Var14 = player/object detection status bits
	LDA Vs_PlayerDetStat,X	 
	STA <Temp_Var14

	; Clear all Player/object detection info
	LDA #$00
	STA Vs_PlayerDetStat,X
	STA Vs_PlayerTileL,X
	STA Vs_PlayerTileU,X

	LDY #(Vs_DetStatLoop_End - Vs_DetStatLoop - 1)
PRG009_A7E4:
	STY <Temp_Var16	 ; Backup 'Y'

	LDA Vs_PlayerY,X 	; Get Player/Object's Y
	ADD Vs_DetStatLoopYOff,Y	; Y offset for this loop
	AND #$f0	 	; Align to grid
	STA <Temp_Var1		; -> Temp_Var1

	CPX #$02
	BLT PRG009_A801	 ; If X < 2 (Player, not object), jump to PRG009_A801

	LDA Vs_ObjectId-2,X
	CMP #VSOBJID_COIN
	BNE PRG009_A801	 ; If this is not a coin, jump to PRG009_A801 

	; Y += 6
	TYA
	ADD #$06
	TAY

PRG009_A801:
	LDA Vs_PlayerX,X	 ; Get Player/Object's X
	ADD Vs_DetStatLoopXOff,Y	 ; Apply X offset for this loop
	STA <Temp_Var2		 ; -> Temp_Var2

	JSR Vs_GetTileAndCheckSolid	 ; Get appropriate tile near Player/Object

	LDY <Temp_Var16	 ; Y = Temp_Var16 (loop index)

	BGE PRG009_A814	 ; If tile >= the solid tile in this quadrant, jump to PRG009_A814

	JMP PRG009_A931	 ; Jump to PRG009_A931

PRG009_A814:
	CPY #$02
	BGE PRG009_A868	 ; If Y >= 2 (not detecting a ceiling hit), jump to PRG009_A868

	; Ceiling hit checks...

	LDA Vs_PlayerY,X
	CMP #208
	BGE PRG009_A865	 ; If Player/Object Y >= 208, jump to PRG009_A865

	AND #$0f	 ; Player/Object position within tile
	CMP #$09
	BGE PRG009_A828	 ; If Player/Object is too low within tile, jump to PRG009_A828

	JMP PRG009_A931	 ; Otherwise, Jump to PRG009_A931

PRG009_A828: 
	CPX #$02
	BGE PRG009_A865	 ; If X >= 2 (Object, not Player), jump to PRG009_A931

	LDA Vs_PlayerYVel,X
	BPL PRG009_A865	 ; If Player is moving downward, jump to PRG009_A931

	LDA Vs_PlayerBlkHitCnt,X
	BNE PRG009_A865	 ; If Vs_PlayerBlkHitCnt <> 0 (a hit block is still active), jump to PRG009_A865

	LDA Map_2PVsGame
	CMP #11
	BEQ PRG009_A865	 ; If Map_2PVsGame = 11 ([?] block game), jump to PRG009_A865

	LDY <Temp_Var3	 ; Y = Temp_Var3 (last detected tile offset)

	; Block was hit; remove it temporarily
	LDA #TILE18_BOUNCEDBLOCK
	STA Tile_Mem,Y

	; Record offset to bounce block that was hit
	TYA
	STA Vs_PlayerBlkHit,X

	LDA Vs_PlayerY,X
	AND #$f0	 ; Align to grid 
	STA Vs_PlayerBlkHitY,X	 ; -> Vs_PlayerBlkHitY

	LDA Vs_PlayerX,X
	ADD #$08	 ; +8 (centering)
	AND #$f0	 ; Align to grid
	STA Vs_PlayerBlkHitX,X	 ; -> Vs_PlayerBlkHitX

	; Vs_PlayerBlkHitCnt = $0E
	LDA #$0e
	STA Vs_PlayerBlkHitCnt,X

	; Vs_PlayerBlkHitYVel = -$20
	LDA #-$20
	STA Vs_PlayerBlkHitYVel,X

PRG009_A865:
	JMP PRG009_A907	 ; Jump to PRG009_A907

PRG009_A868:
	CPY #$04
	BGE PRG009_A8EA	 ; If Y >= 4 (not detecting a wall hit), jump to PRG009_A8EA

	; Wall hit checks...

	CPX #$02
	BGE PRG009_A8E7	 ; If X >= 2 (Object, not Player), jump to PRG009_A8E7

	LDA Map_2PVsGame
	CMP #11
	BNE PRG009_A8E7	 ; If Map_2PVsGame <> 11 ([?] block game), jump to PRG009_A8E7

	LDA Vs_PlayerState,X
	CMP #$03
	BEQ PRG009_A8E7	 ; If Vs_PlayerState = 3 (ladder climbing), jump to PRG009_A8E7

	LDA <Temp_Var14	 ; Get detection status
	AND #$04
	BEQ PRG009_A8E7	 ; If Player is not on floor, jump to PRG009_A8E7

	LDA <Controller1Press,X
	AND #PAD_B
	BEQ PRG009_A8E7	 ; If Player is NOT pressing B, jump to PRG009_A8E7

	; Player is going to kick a [?] block in game 11!!

	; Vs_PlayerKick = $0C
	LDA #$0c
	STA Vs_PlayerKick,X

	; Play kick sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	LDY <Temp_Var3	 ; Y = Temp_Var3 (last detected tile offset)

	; Clear the [?] block from tile memory
	LDA #$00
	STA Tile_Mem,Y

	JSR Vs_EraseLastTile	 ; Erase the kicked block from the BG

	LDX #$06	 ; X = 6
PRG009_A8A3:
	LDA Vs_ObjectState,X
	BEQ PRG009_A8AD	 ; If this object slot is dead/empty, jump to PRG009_A8AD

	DEX		 ; X--
	BPL PRG009_A8A3	 ; While X >= 0, loop!

	LDX #$06	 ; X = 6 on failure
PRG009_A8AD:
	STX <Temp_Var1		 ; Object index -> Temp_Var1

	JSR Vs_PrepareNewObject	 ; Prepare new object

	INC Vs_ObjectState,X	 ; Set its state to 1

	; It's a kicked block!
	LDA #VSOBJID_KICKEDBLOCK
	STA Vs_ObjectId,X

	; Set kicked block Y
	LDA <Temp_Var3	 ; A = Temp_Var3 (last detected tile offset)
	AND #$f0	 ; Keep just the row
	STA Vs_ObjectsY,X

	; Set kicked block X
	LDA <Temp_Var3
	ASL A
	ASL A
	ASL A
	ASL A		; Shift the column up (multiply by 16)
	STA Vs_ObjectsX,X

	; Kicked block Y Vel = -$40
	LDA #-$40
	STA Vs_ObjectYVel,X

	LDY #$10	 ; Y = $10 (kick to the right)

	LDA Vs_ObjectsX,X	; Get Player X
	LDX Vs_CurIndex	; X = current Player index
	CMP Vs_PlayerX,X
	BGE PRG009_A8DE	 ; If block is to the right of Player, jump to PRG009_A8DE

	LDY #-$10	 ; Y = -$10 (kick to the left)

PRG009_A8DE:
	LDX <Temp_Var1	 ; X = object index

	; Set kicked block X velocity
	TYA
	STA Vs_ObjectXVel,X

	LDX Vs_CurIndex	 ; Restore X to Player index

PRG009_A8E7:
	JMP PRG009_A907	 ; Jump to PRG009_A907

PRG009_A8EA:

	; Floor hit checks

	LDA Vs_PlayerY,X
	AND #$0f	 ; Vertical distance within tile
	CMP #$06
	BGE PRG009_A931	 ; If Player's distance from top of tile >= 6, jump to PRG009_A931

	; Player is near top of tile...

	LDA Vs_PlayerYVel,X
	BMI PRG009_A931	 ; If Player is moving upward, jump to PRG009_A931

	; Player is moving downward...

	LDY <Temp_Var3	 ; Y = Temp_Var3 (last detected tile offset)

	LDA Vs_PlayerTileL,X	 ; Grab the tile beneath the Player's feet
	CMP #TILE18_BOUNCEDBLOCK
	BEQ PRG009_A907	 ; If this is a bounced block tile, jump to PRG009_A907

	; Update tile at Player's feet
	LDA Tile_Mem,Y
	STA Vs_PlayerTileL,X

PRG009_A907:
	LDY <Temp_Var16	 ; Y = Temp_Var16 (loop index)

	; Set correct bit for this impact style
	LDA Vs_PlayerDetStat,X
	ORA Vs_DetStatLoop,Y
	STA Vs_PlayerDetStat,X

	CPX #$02 
	BLT PRG009_A91D	 ; If X < 2 (Player, not object), jump to PRG009_A91D

	; Objects only...

	LDA Vs_ObjectId-2,X
	CMP #$01
	BEQ PRG009_A928	 ; If Vs_ObjectId = 1 (lost object ??? has bad jump address ???), jump to PRG009_A928

PRG009_A91D:
	LDY <Temp_Var3	 ; Y = Temp_Var3 (last detected tile offset)

	LDA Tile_Mem,Y	 ; Get tile

	LDY <Temp_Var16	 ; Y = Temp_Var16 (loop index)

	CMP #TILE18_BOUNCEDBLOCK
	BNE PRG009_A931	 ; If this is not a bounced block, jump to PRG009_A931

PRG009_A928:
	; Set appropriate "hit from underneath" bit
	LDA Vs_PlayerDetStat,X
	ORA Vs_DetStatLoopUnderHit,Y
	STA Vs_PlayerDetStat,X

PRG009_A931:
	CPY #$02
	BGE PRG009_A944	 ; If Y >= 2 (not detecting a ceiling hit), jump to PRG009_A944

	LDY <Temp_Var3	 ; Y = Temp_Var3 (last detected tile offset)

	LDA Vs_PlayerTileU,X
	CMP #TILE18_LADDER
	BEQ PRG009_A944	 ; If Player is detecting a ladder tile, jump to PRG009_A944

	; Otherwise, update tile detected above Player's feet
	LDA Tile_Mem,Y
	STA Vs_PlayerTileU,X

PRG009_A944:
	LDY <Temp_Var16	 ; Y = Temp_Var16 (loop index)

	DEY		 ; Y--
	BMI PRG009_A94C	 ; If Y < 0, jump to PRG009_A94C (RTS)

	JMP PRG009_A7E4	 ; Otherwise, loop!

PRG009_A94C:
	RTS		 ; Return


	; Removes the last detected tile
Vs_EraseLastTile:
	LDY Graphics_BufCnt	; Y = current graphics buffer count

	; Temp_Var4/5 = VRAM High/Low addresses
	LDA #%00001000	; Will become $20 and some change when done
	STA <Temp_Var4	; -> Temp_Var4
	LDA <Temp_Var3	; A = Temp_Var3 (last detected tile offset)
	AND #$f0	; Just the "row" value
	ASL A		; Bit 7 -> carry
	ROL <Temp_Var4	; %0001000a
	ASL A		; Bit 7 (old 6) -> carry
	ROL <Temp_Var4	; %001000ab
	STA <Temp_Var5	; -> Temp_Var5

	LDA <Temp_Var3	; A = Temp_Var3 (last detected tile offset)
	ASL A		; Shift left
	AND #%00011111	; Mask out column value, left shifted
	ADD <Temp_Var5	; Add Temp_Var5

	; Set VRAM low addresses
	STA Graphics_Buffer+$01,Y	; Upper row
	ADD #32				; +32 bytes to next to row
	STA Graphics_Buffer+$05,Y 	; Lower row

	; Set VRAM high addresses
	LDA <Temp_Var4
	STA Graphics_Buffer+$00,Y	; Upper row
	STA Graphics_Buffer+$04,Y	; Lower row

	; Run length 2
	LDA #(VU_REPEAT | 2)
	STA Graphics_Buffer+$02,Y	; Upper row
	STA Graphics_Buffer+$06,Y	; Lower row

	; Pattern $FF
	LDA #$ff
	STA Graphics_Buffer+$03,Y	; Upper row
	STA Graphics_Buffer+$07,Y	; Lower row

	; Terminator!
	LDA #$00
	STA Graphics_Buffer+$08,Y

	; +8 to graphics buffer counter
	TYA
	ADD #$08
	STA Graphics_BufCnt

	RTS		 ; Return

	; Temp_Var1 is Y location
	; Temp_Var2 is X location
Vs_GetTileAndCheckSolid:

	; Calculate a row/column offset
	LDA <Temp_Var2		 
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var1
	TAY		 ; -> 'Y'
	STY <Temp_Var3	 ; -> Temp_Var3

	LDA Tile_Mem,Y	 ; Get tile here
	PHA		 ; Save it

	; Calculate tile quadrant
	ASL A
	ROL <Temp_Var15
	ASL A
	ROL <Temp_Var15
	LDA <Temp_Var15
	AND #$03
	TAY		 ; -> 'Y'

	PLA		 ; Restore tile

	CMP Tile_AttrTable+4,Y	 ; Run comparison against solidity range (2P Vs doesn't concern itself with top/side/bottom specifics)
	RTS		 ; Return


Vs_ObjectCollideAgainstWorld:

	; Vs_CollideAgainstWorld supports objects when X >= 2
	TXA		 
	ADD #$02
	TAX

	JSR Vs_CollideAgainstWorld	 ; Collide object against world

	LDX Vs_CurIndex	 ; Restore X = current object index

	RTS		 ; Return

	; Player sprite patterns used for the two Player sprites per frame
Vs_PlayerSprPats:
	.byte $C5, $C7	; 0: Stand/walk
	.byte $C1, $C3	; 1: Walk/non-jump fall
	.byte $D1, $D3	; 2: Skidding turnaround
	.byte $CD, $CF	; 3: Jump/jump fall
	.byte $C9, $CB	; 4: Dizzy
	.byte $D5, $D7	; 5: Kicking
	.byte $D9, $D9	; 6: Dying
	.byte $DB, $DD	; 7: Climbing

	; Flip bits based on Player's facing direction
Vs_PlayerFlipBits:	.byte SPR_HFLIP, $00

Vs_PlayerDraw:
	LDA Vs_PlayerYHi,X
	BNE PRG009_AA4D	 ; If Player is vertically off-screen, jump to PRG009_AA4D (RTS)

	LDA Vs_PlayerFlashInv,X
	BEQ PRG009_A9E3	 ; If Player is flashing invincible, jump to PRG009_A9E3

	LDA <Counter_1
	AND #$02
	BNE PRG009_AA4D	 ; 2 ticks on, 2 ticks off; jump to PRG009_AA4D (RTS)

PRG009_A9E3:
	TXA
	ASL A
	ASL A
	ASL A
	TAY	; Y = player index * 8 = 0 or 8 (Sprite RAM offset)

	; Set left and right sprite Xs
	LDA Vs_PlayerX,X
	STA Sprite_RAM+$23,Y
	ADD #$08
	STA Sprite_RAM+$27,Y

	; Set left and right sprite Ys
	LDA Vs_PlayerY,X
	STA Sprite_RAM+$20,Y
	STA Sprite_RAM+$24,Y

	LDA Vs_PlayerDir,X
	TAX		 ; X = Player direction
	PHA		 ; Save it

	; Set flip bits on Player sprites
	LDA Vs_PlayerFlipBits-1,X
	ORA Vs_CurIndex
	STA Sprite_RAM+$22,Y
	STA Sprite_RAM+$26,Y

	LDX Vs_CurIndex	 ; X = Player index

	LDA Vs_PlayerFrame,X
	ASL A
	TAX		 ; X = player frame * 2

	PLA		 ; Restore Player direction

	CMP #$01
	BEQ PRG009_AA2A	 ; If Player direction = 1 (rightward), jump to PRG009_AA2A

	; Leftward

	; Left/right sprite patterns
	LDA Vs_PlayerSprPats,X
	STA Sprite_RAM+$21,Y
	LDA Vs_PlayerSprPats+1,X
	STA Sprite_RAM+$25,Y

	JMP PRG009_AA36	 ; Jump to PRG009_AA36

PRG009_AA2A:

	; Rightward

	; Left/right sprite patterns
	LDA Vs_PlayerSprPats,X
	STA Sprite_RAM+$25,Y
	LDA Vs_PlayerSprPats+1,X
	STA Sprite_RAM+$21,Y

PRG009_AA36:
	LDX Vs_CurIndex	 ; X = Player index

	; Seems like the better option would be to check the current frame or for 
	; both patterns being the same like elsewhere, but whatever!
	LDA Vs_PlayerState,X
	CMP #$02
	BNE PRG009_AA4D	 ; If Player state <> 2 (Dying), jump to PRG009_AA4D (RTS)

	; Mirror Player sprite
	LDA Sprite_RAM+$22,Y
	AND #$03		; Keep palette setting
	STA Sprite_RAM+$22,Y
	ORA #SPR_HFLIP		; Flip right sprite (Dying frame is mirrored)
	STA Sprite_RAM+$26,Y

PRG009_AA4D:
	RTS		 ; Return


	; Handles Players bumping in to eachother
VsPlayer_BumpEachother:
	LDA Vs_PlayerState
	CMP #$02
	BEQ PRG009_AA87	 ; If Mario's state = 2 (Dying), jump to PRG009_AA87 (RTS)

	LDA Vs_PlayerState+1
	CMP #$02
	BEQ PRG009_AA87	 ; If Luigi's state = 2 (Dying), jump to PRG009_AA87 (RTS)

	LDA Vs_PlayerBumpTimer
	BNE PRG009_AA84	 ; If bump timer not expired, jump to  PRG009_AA84

	LDX #$01	 ; X = 1 (Luigi first)
	LDY #$04	 ; Y = 4 (do Luigi's box)
PRG009_AA65:
	JSR VsPlayer_CalcBoundBox	 ; Calculate bounding box for this Player

	; Y -= 4 (do Mario's box)
	DEY
	DEY
	DEY
	DEY

	DEX		 ; X--
	BPL PRG009_AA65	 ; While X >= 0, loop

	JSR Vs_CheckBoxCollision	 ; Check if Players collided with eachother
	BCC PRG009_AA87	 ; If Mario and Luigi did not collide, jump to PRG009_AA87 (RTS)

	; Set both Players to "normal" state
	LDA #$01
	STA Vs_PlayerState
	STA Vs_PlayerState+1

	; Vs_PlayerBumpTimer
	LDA #$08
	STA Vs_PlayerBumpTimer

	JMP PRG009_AA95	 ; Jump to PRG009_AA95

PRG009_AA84:
	DEC Vs_PlayerBumpTimer	 ; Vs_PlayerBumpTimer--

PRG009_AA87:
	RTS		 ; Return

VsPlayer_BounceOffOtherXVel:
	.byte $10, -$10, $10, -$10

	; These tables are designed so that they can be index by 
	; Mario or Luigi and values correctly set by situation
VsPlayer_BounceOffOtherYVel:
	.byte -$30, $00, -$30

VsPlayer_BounceOffOtherDizzy:
	.byte $00, $12, $00

VsPlayer_BounceOffOtherSnd:
	.byte $00, SND_PLAYERSWIM, $00
	
PRG009_AA95:
	LDA Vs_PlayerY
	SUB Vs_PlayerY+1 ; Calculate difference between Mario and Luigi's Y
	PHP		 ; Save CPU status

	BPL PRG009_AAA4	 ; If difference is not negative, jump to PRG009_AAA4
	NEG		; Otherwise, negate it!  (Absolute value)
PRG009_AAA4:
	CMP #$08
	BLT PRG009_AAF7	 ; If Player's Y difference < 8, jump to PRG009_AAF7

	; Player's Y difference >= 8...

	LDY #$00	 ; Y = 0 (Mario is above Luigi)

	PLP		 ; Restore CPU status
	BCC PRG009_AAAE	 ; If Mario is above Luigi, jump to PRG009_AAAE

	INY		 ; Y = 1 (Luigi is above Mario)

PRG009_AAAE:
	LDA VsPlayer_BounceOffOtherYVel,Y
	AND Vs_PlayerYVel
	BMI PRG009_AAD2	 	; If Mario is moving upward, jump to PRG009_AAD2

	; Bounce off Luigi's head!
	LDA VsPlayer_BounceOffOtherYVel,Y
	STA Vs_PlayerYVel

	LDA Vs_PlayerDetStat
	AND #$04
	BEQ PRG009_AAD2		; If Mario is NOT on solid ground, jump to PRG009_AAD2

	; Set Mario as dizzy
	LDA VsPlayer_BounceOffOtherDizzy,Y
	STA Vs_PlayerDizzy

	; Play stomped-on-other-Player sound
	LDA Sound_QPlayer
	ORA VsPlayer_BounceOffOtherSnd,Y
	STA Sound_QPlayer

PRG009_AAD2:
	LDA VsPlayer_BounceOffOtherYVel+1,Y
	AND Vs_PlayerYVel+1
	BMI PRG009_AAF6	 	; If Luigi is moving upward, jump to PRG009_AAF6 (RTS)

	; Bounce off Mario's head!
	LDA VsPlayer_BounceOffOtherYVel+1,Y
	STA Vs_PlayerYVel+1

	LDA Vs_PlayerDetStat+1
	AND #$04
	BEQ PRG009_AAF6		; If Luigi is NOT on solid ground, jump to PRG009_AAF6 (RTS)

	; Set Luigi as dizzy
	LDA VsPlayer_BounceOffOtherDizzy+1,Y
	STA Vs_PlayerDizzy+1

	; Play stomped-on-other-Player sound
	LDA Sound_QPlayer
	ORA VsPlayer_BounceOffOtherSnd+1,Y
	STA Sound_QPlayer

PRG009_AAF6:
	RTS		 ; Return

PRG009_AAF7:
	PLP		 ; Restore CPU status

	LDY #$00	 ; Y = 0 (Mario is to the right of Luigi)

	LDA Vs_PlayerX
	CMP Vs_PlayerX+1
	BGE PRG009_AB03	 ; If Mario's X >= Luigi's X, jump to PRG009_AB03

	INY		 ; Y = 1 (Mario is to the left of Luigi)

PRG009_AB03:
	EOR Vs_PlayerX+1
	BPL PRG009_AB15

	LDA #239
	CMP Vs_PlayerX
	BLT PRG009_AB14	 ; If Mario's X >= 239, jump to PRG009_AB14

	CMP Vs_PlayerX+1
	BGE PRG009_AB15	 ; If Luigi's X < 239, jump to PRG009_AB15

PRG009_AB14:
	INY		 ; Y = 2

PRG009_AB15:

	; Set each Player's X velocities
	LDA VsPlayer_BounceOffOtherXVel,Y
	STA Vs_PlayerXVel
	LDA VsPlayer_BounceOffOtherXVel+1,Y
	STA Vs_PlayerXVel+1

	; Set proper Player directions as a result
	TYA
	AND #$01
	ADD #$01
	STA Vs_PlayerDir+1
	EOR #$03
	STA Vs_PlayerDir

	RTS		 ; Return


VsPlayer_CalcBoundBox:

	; Expected input: 
	;	X = 0 for Mario, X = 1 for Luigi
	;	Y = 0 for Mario's bounding box, Y = 4 for Luigi's bounding box
	;
	; Result:
	;	Temp_Var1/5 = top
	;	Temp_Var2/6 = left
	;	Temp_Var3/7 = bottom offset
	;	Temp_Var4/8 = right offset

	; Temp_Var1+Y = Mario/Luigi's Y + 2 (top)
	LDA Vs_PlayerY,X
	ADD #$02
	STA Temp_Var1,Y

	; Temp_Var3+Y = 14 (bottom offset)
	LDA #14
	STA Temp_Var3,Y

	; Temp_Var2+Y = Mario/Luigi's X + 4 (left)
	LDA Vs_PlayerX,X
	ADD #$04
	STA Temp_Var2,Y

	; Temp_Var4+Y = 8 (right offset)
	LDA #$08
	STA Temp_Var4,Y

	RTS		 ; Return


	; Returns carry set if the two bounding boxes collided
Vs_CheckBoxCollision:

	; Backup 'X'
	TXA		 
	PHA

	LDX #$01	 ; X = 1 (do both bounding boxes)
PRG009_AB51:
	LDA <Temp_Var5,X
	SUB <Temp_Var1,X
	ADD <Temp_Var7,X
	STA <Temp_Var9
	LDA <Temp_Var3,X
	ADD <Temp_Var7,X
	CMP <Temp_Var9
	BCC PRG009_AB67	 ; If did not impact, jump to PRG009_AB67

	DEX		 ; X--
	BPL PRG009_AB51	 ; While X >= 0, loop!

PRG009_AB67:

	; Restore 'X'
	PLA
	TAX

	RTS		 ; Return

	; "Enemy Set" constants
ES_SPINY	= 0
ES_FIGHTERFLY	= 1
ES_SIDESTEPPER	= 2

Vs_5EnemySets:
VsES_SpinyAll:		.byte ES_SPINY, ES_SPINY, ES_SPINY, ES_SPINY, ES_SPINY
VsES_FFlyAll:		.byte ES_FIGHTERFLY, ES_FIGHTERFLY, ES_FIGHTERFLY, ES_FIGHTERFLY, ES_FIGHTERFLY
VsES_SpinyFFly:		.byte ES_SPINY, ES_FIGHTERFLY, ES_SPINY, ES_FIGHTERFLY, ES_SPINY
VsES_SpinySStep:	.byte ES_SPINY, ES_SIDESTEPPER, ES_SPINY, ES_SIDESTEPPER, ES_SPINY
VsES_FFlySStep:		.byte ES_FIGHTERFLY, ES_SIDESTEPPER, ES_FIGHTERFLY, ES_SIDESTEPPER, ES_FIGHTERFLY
VsES_SStepAll:		.byte ES_SIDESTEPPER, ES_SIDESTEPPER, ES_SIDESTEPPER, ES_SIDESTEPPER, ES_SIDESTEPPER

	; Enemy starting X
Vs_SpawnEnemyStartX:		.byte 16, 224

	; Starting X velocity for non-last enemy
Vs_SpawnEnemyStartXVel:		.byte $06, -$06, $06

	; Starting X velocity for last enemy (fast!)
Vs_SpawnEnemyStartXVelFast:	.byte $10, -$10, $10

	; Fireball starting X
Vs_HFireballX:		.byte 8, 232

	; Fireball starting X velocity
Vs_HFireballXVel:	.byte $10, -$10


	; Enemy spawner
Vs_SpawnEnemies:
	LDA Vs_PlayerHaltTimer	 	; If Mario is halting ...
	ORA Vs_PlayerHaltTimer+1	; ... or Luigi is halting ...
	ORA Vs_TimeToExit	; ... or we're timing out to exit ...
	BNE PRG009_ABBE	 	; ... then jump to PRG009_ABBE (RTS)

	INC Vs_SpawnCnt	 ; Vs_SpawnCnt++

	LDA Vs_SpawnCnt
	AND #$1f
	BNE PRG009_ABBF	 ; 1:32 ticks proceed, otherwise jump to PRG009_ABBF

	INC Vs_TooLongCnt ; Vs_TooLongCnt++
	BNE PRG009_ABBF	 ; If Vs_TooLongCnt <> 0, jump to PRG009_ABBF

	; Vs_TooLongCnt = 0... game is going on too long!  Spawn game ender fireball!

	JSR PRG009_ABD0	 ; Find open slot

	TXA
	BMI PRG009_ABBF	 ; If no open slot, jump to PRG009_ABBF

	; Set Y velocity = $10
	LDA #$10
	STA Vs_ObjectYVel,X

	; This is the game ender fireball
	LDA #VSOBJID_FIREBALL_ENDER
	STA Vs_ObjectId,X

PRG009_ABBE:
	RTS		 ; Return


PRG009_ABBF:
	LDA Vs_SpawnCnt
	CMP #$80
	BNE PRG009_AC3E	 ; If Vs_SpawnCnt <> $80, jump to PRG009_AC3E (just spawn an enemy)

	; Vs_SpawnCnt = $80... (this attempts to create a fireball)

	INC Vs_SpawnCnt2	; Vs_SpawnCnt2++
	LDA Vs_SpawnCnt2
	AND #$07
	BNE PRG009_AC3E	 ; Every 8 Vs_SpawnCnt2 proceed, otherwise jump to PRG009_AC3E (just spawn an enemy)

PRG009_ABD0:
	LDX #$06	 ; X = 6 (search through first seven object slots)
	JSR Vs_NewEnemy	 ; Get us a new enemy
	TXA
	BMI PRG009_AC3D	 ; If no objects slots were available, jump to PRG009_AC3D (RTS)

	DEC Vs_EnemyCount	 ; Vs_EnemyCount--

	CPX #$05
	BGE PRG009_ABE2	 ; If X >= 5, jump to PRG009_ABE2

	JMP Vs_ObjectDestroy	 ; Jump to Vs_ObjectDestroy

PRG009_ABE2:
	LDA Vs_SpawnCnt2
	LSR A
	AND #$01
	TAY		 ; Y = 0 or 1 

	; Set starting position of horizontal fireball
	LDA Vs_HFireballXVel,Y
	STA Vs_ObjectXVel,X

	; Set X Velocity of horizontal fireball
	LDA Vs_HFireballX,Y
	STA Vs_ObjectsX,X

	JSR Vs_Randomize ; Stir up randomness

	LDA Vs_Random+2
	AND #$01
	TAY		 ; Y = 0 or 1

	; Set fireball to appear at Player's Y position
	LDA Vs_PlayerY,Y
	STA Vs_ObjectsY,X

	; It's a fireball!
	LDA #VSOBJID_FIREBALL_HORZ
	STA Vs_ObjectId,X

	; Fireball has no vertical movement yet
	LDA #$00
	STA Vs_ObjectYVel,X
	STA Vs_ObjectVar1,X	; Unneccessary because of call to Vs_PrepareNewObject

	JSR Vs_PrepareNewObject	 ; Prepare the fireball's other vars

	; Vs_EnemyGetUpTimer = $20
	LDA #$20
	STA Vs_EnemyGetUpTimer,X

	RTS		 ; Return


Vs_PrepareNewObject:
	LDA #$00	 
	STA Vs_ObjectYHi,X
	STA Vs_ObjectVar1,X
	STA Vs_ObjectTileL,X
	STA Vs_ObjectIsLast,X
	STA Vs_ObjectIsAngry,X
	STA Vs_ObjectPipeTimer,X
	STA Vs_ObjHaltTimer,X
	STA Vs_ObjectTimer3,X
	STA Vs_ObjTimer2,X
	STA Vs_EnemyGetUpTimer,X
	STA Vs_ObjectRestoreXVel,X

PRG009_AC3D:
	RTS		 ; Return


PRG009_AC3E:

	; Actual enemy spawner...

	LDA Vs_EnemyCount
	CMP #$05
	BEQ PRG009_AC3D	 ; If we already have 5 enemies, jump to PRG009_AC3D (RTS)

	LDA Vs_SpawnCnt
	AND #$ff
	BNE PRG009_AC3D	 ; If Vs_SpawnCnt <> 0, jump to PRG009_AC3D

	; Multiply Vs_EnemySet by 5 (why not just store it that way??)
	LDA Vs_EnemySet
	ASL A
	ASL A
	ADC Vs_EnemySet

	; Add current enemy count as offset value
	ADC Vs_EnemyCount
	TAY		 ; -> 'Y'

	; Spawn correct enemy
	LDA Vs_5EnemySets,Y
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Vs_SpawnSpiny
	.word Vs_SpawnFighterFly
	.word Vs_SpawnSidestepper

Vs_SpawnSidestepper:
	JSR Vs_SpawnSpiny	 
	TXA
	BMI PRG009_AC7F	 ; If no object slot was available, jump to PRG009_AC7F (RTS)

	; Make this one a Sidestepper!
	LDA #VSOBJID_SIDESTEPPER
	STA Vs_ObjectId,X

	LDA Vs_AngrySidesteppers
	BEQ PRG009_AC7F	 ; If not due any angry Sidesteppers, jump to PRG009_AC7F

	DEC Vs_AngrySidesteppers	 ; Vs_AngrySidesteppers--

	; This one is an ANGRY Sidestepper!
	LDA #$01
	STA Vs_ObjectIsAngry,X

	JSR PRG009_ACB6	; Partial re-init

PRG009_AC7F:
	RTS		 ; Return

Vs_SpawnFighterFly:
	JSR Vs_SpawnSpiny	 
	TXA
	BMI PRG009_AC8B	 ; If no object slot was available, jump to PRG009_AC8B (RTS)

	; Make this one a Fighter Fly!
	LDA #VSOBJID_FIGHTERFLY
	STA Vs_ObjectId,X

PRG009_AC8B:
	RTS		 ; Return

Vs_SpawnSpiny:
	LDX #$04

	; Finds an empty slot (hopefully) and preps a new enemy (by default a Spiny unless you override)
Vs_NewEnemy:
	LDA Vs_ObjectState,X
	BEQ PRG009_AC97	 ; If this slot is dead/empty, jump to PRG009_AC97

	DEX		 ; X--
	BPL Vs_NewEnemy	 ; While X >= 0, loop!

	; Return on failure
	RTS		 ; Return

PRG009_AC97:
	INC Vs_EnemyCount	 ; Vs_EnemyCount++

	; Set new enemy's state = 1
	LDA #$01
	STA Vs_ObjectState,X

	; Enemy Y = 32
	LDA #32
	STA Vs_ObjectsY,X

	; Enemy Y Vel = 0
	LDA #$00
	STA Vs_ObjectYVel,X

	; Default is Spiny
	LDA #VSOBJID_SPINY
	STA Vs_ObjectId,X

	JSR Vs_PrepareNewObject	 ; Prepare new enemy

	; Vs_ObjectPipeTimer = $30
	LDA #$30
	STA Vs_ObjectPipeTimer,X

PRG009_ACB6:
	; Set Enemy X
	LDA Vs_EnemyCount
	AND #$01
	TAY	; Y = 0 or 1 (Every other enemy starts on opposite side)

	LDA Vs_SpawnEnemyStartX,Y
	STA Vs_ObjectsX,X

PRG009_ACC2:
	LDA Vs_EnemyCount
	CMP #$05
	BNE PRG009_ACD4	 ; If Vs_EnemyCount <> 5, jump to PRG009_ACD4

	LDA Vs_NextObjectIsLast
	BEQ PRG009_ACD4	 ; If next object out is NOT the last one, jump to PRG009_ACD4

	; Flag this enemy as the last one
	STA Vs_ObjectIsLast,X

	; Y += 3 (use Vs_SpawnEnemyStartXVelFast)
	INY
	INY
	INY

PRG009_ACD4:

	; Set starting X velocity
	LDA Vs_SpawnEnemyStartXVel,Y
	STA Vs_ObjectXVel,X

	RTS		 ; Return

	; Pool of possible Sprite RAM offsets
Vs_ObjectSprRAMOffsets:
	.byte $30, $98, $38, $90, $40, $88, $48, $80, $50, $78, $58, $70, $60, $68, $30, $98
	.byte $38, $90, $40, $88, $48, $80, $50, $78, $58, $70, $60

Vs_ObjectsUpdateAndDraw:
	; This rotates the Sprite RAM offset selections to mitigate sprite 
	; scanline overload blanking, as used elsewhere in SMB3...
	DEC Vs_ObjectSprRAMSel	 ; Vs_ObjectSprRAMSel--
	BPL PRG009_AD00	 ; If Vs_ObjectSprRAMSel >= 0, jump to PRG009_AD00

	; Reset Vs_ObjectSprRAMSel to $0D
	LDA #$0d
	STA Vs_ObjectSprRAMSel

PRG009_AD00:
	LDX #$0b	 ; X = $0B (all objects)
PRG009_AD02:
	STX Vs_CurIndex	 ; Update Vs_CurIndex with current object index

	; Calculate the Sprite RAM offset 
	TXA
	ADD Vs_ObjectSprRAMSel
	TAY
	LDA Vs_ObjectSprRAMOffsets,Y
	STA Vs_ObjectSprRAMOff

	JSR Vs_Randomize 	; Stir up randomness

	JSR Vs_ObjectDoState	; Object runs state action

	DEX		 ; X--
	BPL PRG009_AD02	 ; While X >= 0, loop

PRG009_AD1A:
	RTS		 ; Return


Vs_ObjectDoState:
	LDA Vs_ObjHaltTimer,X
	BEQ PRG009_AD23	 ; If halt timer = 0, jump to PRG009_AD23

	DEC Vs_ObjHaltTimer,X	 ; Otherwise, decrement

PRG009_AD23:
	LDA Vs_ObjTimer2,X
	BEQ PRG009_AD2B	 ; If timer 2 = 0, jump to PRG009_AD2B

	DEC Vs_ObjTimer2,X	 ; Otherwise, decrement

PRG009_AD2B:
	LDA Vs_ObjectState,X
	BEQ PRG009_AD1A	 ; If this object slot is dead/empty, jump to PRG009_AD1A (RTS)

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG009_AD1A		; 0: Dead/empty (not used, RTS)
	.word Vs_ObjStateNormal		; 1: Normal operation
	.word Vs_ObjStateFlippedOver	; 2: Flipped over
	.word Vs_ObjStateDying		; 3: Dying (literally kicked off)

Vs_ObjStateNormal:
	LDA Vs_ObjHaltTimer,X
	ORA Vs_ObjTimer2,X
	BEQ PRG009_AD53	 ; If halt timer and timer 2 are expired, jump to PRG009_AD53:

	JSR Vs_ObjectCollideAgainstWorld ; Collide object against world
	JSR Vs_EnemyHandleHitUnder	 ; Handle enemy getting hit from underneath

	LDA Vs_ObjectId,X
	CMP #VSOBJID_COIN
	BEQ PRG009_AD63	 ; If this is a coin, jump to PRG009_AD63

	JMP PRG009_B01D	 ; Otherwise, Jump to PRG009_B01D

PRG009_AD53:
	LDA Vs_ObjectTimer3,X
	BEQ PRG009_AD5B		; If Vs_ObjectTimer3 = 0, jump to PRG009_AD5B

	DEC Vs_ObjectTimer3,X	; Vs_ObjectTimer3--

PRG009_AD5B:
	LDA Vs_ObjectPipeTimer,X
	BEQ PRG009_AD63	 	; If Vs_ObjectPipeTimer = 0, jump to PRG009_AD63

	DEC Vs_ObjectPipeTimer,X	; Vs_ObjectPipeTimer--

PRG009_AD63:
	LDA Vs_EnemyGetUpTimer,X
	BEQ PRG009_AD6B	 ; If Vs_EnemyGetUpTimer = 0, jump to PRG009_AD6B

	DEC Vs_EnemyGetUpTimer,X ; Vs_EnemyGetUpTimer--

PRG009_AD6B:
	LDA #$01	 ; A = 1 (object moving to the right)

	LDY Vs_ObjectXVel,X
	BPL PRG009_AD74	 ; If object is moving to the right, jump to PRG009_AD74

	LDA #$02	 ; A = 2 (object moving to the left)

PRG009_AD74:
	STA Vs_ObjectDir,X	 ; Set Vs_ObjectDir

	LDA #$04	 ; A = 4 (object moving downward)

	LDY Vs_ObjectYVel,X
	BPL PRG009_AD80	 ; If object is moving downward, jump to PRG009_AD80

	LDA #$08	 ; A = 8 (object moving upward)

PRG009_AD80:
	STA Vs_ObjectVDir,X	 ; Set Vs_ObjectVDir

	LDA Vs_ObjectId,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Vs_SpinyAndSidesteppers	;  0: Spiny
	.word Vs_EnemyPipeXVel		;  1: INVALID JUMP ADDRESS
	.word Vs_SpinyAndSidesteppers	;  2: Sidestepper
	.word Vs_FighterFly		;  3: Fighter Fly
	.word Vs_Fireballs		;  4: Horizontal Fireball
	.word Vs_Fireballs		;  5: Game Ender Fireball
	.word Vs_Fireballs		;  6: Fountain Fireball
	.word Vs_Coin			;  7: Coin
	.word Vs_CardMushroomOrStar	;  8: Mushroom card
	.word Vs_CardFlower		;  9: Flower card
	.word Vs_CardMushroomOrStar	; 10: Star card
	.word Vs_KickedBlock		; 11: Kicked [?] block

Vs_KickedBlock:
	JSR Vs_ObjectApplyXVel	 ; Apply X Velocity
	JSR Vs_ObjectApplyYVel	 ; Apply Y Velocity

	LDA Vs_ObjectYVel,X
	BMI PRG009_ADB0	 ; If block is moving upward, jump to PRG009_ADB0

	CMP #$7d
	BGE PRG009_ADB9	 ; If block is falling >= $7D, jump to PRG009_ADB9

PRG009_ADB0: 

	; Y Vel += 3
	INC Vs_ObjectYVel,X
	INC Vs_ObjectYVel,X
	INC Vs_ObjectYVel,X

PRG009_ADB9:
	LDA Vs_ObjectYHi,X
	BEQ PRG009_ADC1	 ; If block is not vertically off-screen, jump to PRG009_ADC1

	JMP Vs_ObjectDestroy	 ; Otherwise, remove block

PRG009_ADC1:
	JSR Vs_ObjectDraw	 ; Draw block
	RTS		 ; Return

Vs_CardFlower:
	LDA #$00
	STA Vs_ObjectXVel,X

Vs_CardMushroomOrStar:
	JSR Vs_ObjectApplyXVel	 ; Apply X Velocity
	JSR Vs_ObjectApplyYVel	 ; Apply Y Velocity

	JSR Vs_ObjectCollideAgainstWorld ; Collide object against world

	INC Vs_ObjectYVel,X	 ; Vs_ObjectYVel++ (gravity)

	LDA Vs_ObjectId,X
	CMP #VSOBJID_STARCARD
	BEQ PRG009_ADED	 ; If this is a star card, jump to PRG009_ADED

	INC Vs_ObjectYVel,X	 ; Vs_ObjectYVel++ (heavier gravity on other cards)

	LDA Vs_ObjectDetStat,X
	AND #$03
	AND Vs_ObjectDir,X
	BEQ PRG009_ADED	 ; If card has not hit wall in direction of travel, jump to PRG009_ADED

	JSR Vs_ObjectReverseXVel	 ; Reverse direction of card

PRG009_ADED:
	LDA Vs_ObjectYHi,X
	BNE PRG009_AE22	 ; If card is vertically off-screen, jump to PRG009_AE22 (RTS)

	LDA Vs_ObjectDetStat,X
	AND #$04
	BEQ PRG009_AE10	 ; If card has not hit floor, jump to PRG009_AE10

	JSR Vs_ObjectHitFloor	 ; Align object to floor

	LDA Vs_ObjectId,X
	CMP #VSOBJID_STARCARD
	BNE PRG009_AE0D	 ; If this is not a star card, jump to PRG009_AE0D

	LDA Vs_ObjectYVel,X
	BMI PRG009_AE0D	 ; If card is moving upward, jump to PRG009_AE0D

	; Card bounces!
	LDA #-$24
	STA Vs_ObjectYVel,X

PRG009_AE0D:
	JSR Vs_EnemyHandleHitUnder	 ; Handle card getting hit from underneath

PRG009_AE10:
	LDY Vs_ObjectId,X	; Y = object ID

	LDX Vs_ObjectBasePatIndex,Y	 ; X = pattern index

	LDA <Counter_1
	LSR A
	LSR A
	AND #$03	 ; A = 0 to 3 by counter

	JSR PRG009_B13F	 ; Jump into draw routine

	JSR Vs_ObjectPlayerCollide	; Do Player-to-objects collisions

PRG009_AE22:
	RTS		 ; Return

	; Spinning coin patterns
Vs_CoinPats:
	.byte $09, $0F, $0D, $0F

	; Coin collected "twinkle" patterns
Vs_CoinTwinklePats:
	.byte $91, $91, $91, $95, $91, $95, $95, $95
	

Vs_Coin:
	LDY Vs_EnemyGetUpTimer,X
	BEQ PRG009_AE3A	 ; If Vs_EnemyGetUpTimer = 0, jump to PRG009_AE3A

	; Coin is "twinkling" away...

	DEY		 ; Y--
	BNE PRG009_AE6C	 ; If ticks remain, jump to PRG009_AE6C

	JMP Vs_ObjectDestroy	 ; Otherwise, destroy object

PRG009_AE3A:
	LDA Vs_TimeToExit
	ORA Vs_IsPaused	
	ORA Vs_ObjHaltTimer,X
	BNE PRG009_AE6C	 ; If exiting, paused, or coin is halted, jump to PRG009_AE6C

	JSR Vs_ObjectCollideAgainstWorld ; Collide object against world

	LDA Vs_ObjectVar1,X
	BEQ PRG009_AE66	 ; If Vs_ObjectVar1 = 0, jump to PRG009_AE66

	JSR Vs_ObjectApplyXVel	 ; Apply X Velocity
	JSR Vs_ObjectApplyYVel	 ; Apply Y Velocity

	; Y Vel += 2 (gravity)
	INC Vs_ObjectYVel,X
	INC Vs_ObjectYVel,X

	LDA Vs_ObjectsY,X
	CMP #224
	BLT PRG009_AE66	 ; If coin Y < 224, jump to PRG009_AE66

	; Coin is gone
	LDA #$00
	STA Vs_ObjectState,X

	RTS		 ; Return

PRG009_AE66:
	JSR Vs_ObjectPlayerCollide	; Do Player-to-objects collisions

	INC Vs_ObjectAnimCnt,X	 ; Vs_ObjectAnimCnt++

PRG009_AE6C:
	LDY Vs_ObjectSprRAMOff	 ; Y = Sprite RAM offset

	LDA Vs_EnemyGetUpTimer,X
	BEQ PRG009_AE88	 ; If Vs_EnemyGetUpTimer = 0, jump to  PRG009_AE88

	LDA Sprite_RAM+$00
	CMP #$f8
	BEQ PRG009_AE86	 ; If sprite is unused, jump to PRG009_AE86

	LDA Sprite_RAM+$08
	CMP #$f8
	BNE PRG009_AE88	 ; If sprite is in use, jump to PRG009_AE88

	LDY #$08	 ; Y = 8
	BNE PRG009_AE88	 ; Jump (technically always) to PRG009_AE88

PRG009_AE86:
	LDY #$00	 ; Y = 0

PRG009_AE88:
	LDA Map_2PVsGame
	CMP #11
	BNE PRG009_AE96	 ; If this is not the [?] block game, jump to PRG009_AE96

	LDA Vs_ObjectDetStat,X
	AND #$03
	BNE PRG009_AEFD	 ; If hit a wall, jump to PRG009_AEFD

PRG009_AE96:
	LDA #$00
	CMP Vs_ObjectPipeTimer,X

	LDA #SPR_PAL3

	BGE PRG009_AEA1

	LDA #(SPR_PAL3 | SPR_BEHINDBG)	; Coin still emerging from fountain

PRG009_AEA1:
	STA Sprite_RAM+$02,Y	 ; Set coin attributes

	; Set coin sprite Y
	LDA Vs_ObjectsY,X
	STA Sprite_RAM+$00,Y

	; Set coin sprite X
	LDA Vs_ObjectsX,X
	STA Sprite_RAM+$03,Y

	LDA Vs_EnemyGetUpTimer,X
	BEQ PRG009_AEE8	 ; If Vs_EnemyGetUpTimer = 0 (coin not "twinkling" away), jump to PRG009_AEE8

	LSR A		; Divide by 2
	AND #$07	; Cap 0 to 7
	TAX		; X = 0 to 7

	; Set left coin twinkle sprite pattern
	LDA Vs_CoinTwinklePats,X
	STA Sprite_RAM+$01,Y

	; Set right coin twinkle sprite pattern
	ADD #$02	 ; +2 
	STA Sprite_RAM+$05,Y

	LDX Vs_CurIndex	 ; X = object index

	; Set sprite Y
	LDA Vs_ObjectsY,X
	STA Sprite_RAM+$04,Y

	; Set left sprite X
	LDA Vs_ObjectsX,X
	SUB #$04
	STA Sprite_RAM+$03,Y

	; Set right sprite X
	ADD #$08
	STA Sprite_RAM+$07,Y

	; Set sprite attributes
	LDA #SPR_PAL3
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	JMP PRG009_AEFD	 ; Jump to PRG009_AEFD (RTS)

PRG009_AEE8:
	LDA Vs_ObjectAnimCnt,X
	LSR A
	LSR A
	ADD Vs_CurIndex	; keeps it interesting
	AND #$03
	TAY		 ; Y = 0 to 3

	; Set sprite pattern
	LDA Vs_CoinPats,Y	 ; Get coin pattern
	LDY Vs_ObjectSprRAMOff	 ; Y = Sprite RAM offset
	STA Sprite_RAM+$01,Y	 ; Store pattern

PRG009_AEFD:
	RTS		 ; Return

	; The X position of the bottom pipes for an enemy to enter into
Vs_BottomPipeEntranceX:	.byte 208, 32

	; How far in the enemy scooting in to the pipe goes before being put back up top
Vs_BottomPipeLimitX:	.byte 224, 16

	; X velocity for enemy inside pipe
Vs_EnemyPipeXVel:	.byte $06, -$06

Vs_EnemyMove:
	LDA Vs_ObjectXVel,X
	PHA		 ; Save X velocity

	LDA Vs_ObjectPipeTimer,X
	BEQ PRG009_AF16	 ; If Vs_ObjectPipeTimer = 0, jump to PRG009_AF16 (RTS)

	LDY Vs_ObjectDir,X	 ; Y = object's direction

	; Set enemy to use reduced pipe X velocity
	LDA Vs_EnemyPipeXVel-1,Y
	STA Vs_ObjectXVel,X

PRG009_AF16:
	JSR Vs_ObjectApplyXVel	 ; Apply X Velocity

	; Restore X velocity
	PLA
	STA Vs_ObjectXVel,X

	RTS		 ; Return

Vs_FighterFly:
	JSR Vs_EnemyUsePipes	; Enter into bottom pipes and come out the top pipes

	LDY Vs_EnemyGetUpTimer,X	; Y = Vs_EnemyGetUpTimer
	BEQ PRG009_AF2E	 ; If Vs_EnemyGetUpTimer = 0, jump to PRG009_AF2E

	DEY		 ; Y--

	BNE PRG009_AF40	 ; If enemy still hasn't gotten up, jump to PRG009_AF40

	; Enemy hops up!
	LDA #-$1C
	STA Vs_ObjectYVel,X

PRG009_AF2E:
	JSR Vs_EnemyMove	 ; Recurse!

	JSR Vs_ObjectApplyYVel	 ; Apply Y Velocity

	LDA Vs_ObjectYVel,X
	BMI PRG009_AF3D	 ; If enemy is moving upward, jump to PRG009_AF3D

	CMP #$40
	BGE PRG009_AF40	 ; If object is falling >= $40, jump to PRG009_AF40

PRG009_AF3D:
	INC Vs_ObjectYVel,X	 ; Object's Y Vel++ (gravity)

PRG009_AF40:
	JSR Vs_ObjectCollideAgainstWorld ; Collide object against world

	LDA Vs_ObjectDetStat,X
	AND #$04
	BNE PRG009_AF56	 ; If object has hit floor, jump to PRG009_AF56

	; Object has not hit floor...

	; Vs_ObjectAnimCnt += 4
	LDA Vs_ObjectAnimCnt,X
	ADD #$04
	STA Vs_ObjectAnimCnt,X

	JMP PRG009_AF7C	 ; Jump to PRG009_AF7C

PRG009_AF56:

	; Object hit floor...

	; Vs_ObjectAnimCnt = 8
	ASL A		 ; A = 8
	STA Vs_ObjectAnimCnt,X

	LDA Vs_EnemyGetUpTimer,X
	BNE PRG009_AF64	 ; If Vs_EnemyGetUpTimer <> 0, jump to PRG009_AF64

	; Vs_EnemyGetUpTimer = $10
	LDA #$10
	STA Vs_EnemyGetUpTimer,X

PRG009_AF64:
	JSR Vs_ObjectHitFloor		 ; Align object to floor
	JSR Vs_EnemyHandleHitUnder	 ; Handle enemy getting hit from underneath

	LDA Vs_ObjectPipeTimer,X
	BEQ PRG009_AF7C	 ; If Vs_ObjectPipeTimer = 0, jump to PRG009_AF7C

	; Vs_EnemyGetUpTimer = 0
	LDA #$00
	STA Vs_EnemyGetUpTimer,X

	; Halt vertical movement
	STA Vs_ObjectYVel,X

	; Vs_ObjectAnimCnt = current counter value
	LDA <Counter_1
	STA Vs_ObjectAnimCnt,X

PRG009_AF7C:
	JMP PRG009_B01D	 ; Jump to PRG009_B01D


Vs_EnemyUsePipes:
	LDA Vs_ObjectsY,X
	CMP #160
	BLT PRG009_AFB8	 ; If Object Y < 160, jump to PRG009_AFB8 (RTS)

	LDY Vs_ObjectDir,X	 ; Y = object's direction

	LDA Vs_ObjectsX,X
	CMP Vs_BottomPipeEntranceX-1,Y
	BNE PRG009_AF98	 ; If object is not at the edge of one of the bottom pipes, jump to PRG009_AF98

	; Object entered pipe!  Vs_ObjectPipeTimer = $60
	LDA #$60
	STA Vs_ObjectPipeTimer,X

	BNE PRG009_AFB8	 ; Jump (technically always) to PRG009_AFB8 (RTS)

PRG009_AF98:
	CMP Vs_BottomPipeLimitX-1,Y
	BNE PRG009_AFB8	 ; If enemy is not yet at the inner limit of the pipe, jump to PRG009_AFB8 (RTS)

	; Object Y = 32
	LDA #32
	STA Vs_ObjectsY,X

	LDA RandomN
	AND #$01
	TAY		 ; Y = 0 or 1

	; Restart at top pipe one side or the other
	LDA Vs_SpawnEnemyStartX,Y
	STA Vs_ObjectsX,X

	EOR Vs_ObjectXVel,X
	BPL PRG009_AFB6	 ; If enemy was traveling in the direction appropriate for the pipe they're emerging from, jump to PRG009_AFB6

	JSR Vs_ObjectReverseXVel	; Correct the X velocity

PRG009_AFB6:

	; Do not return to caller!!
	PLA
	PLA

PRG009_AFB8:
	RTS		 ; Return

Vs_SpinyAndSidesteppers:
	JSR Vs_EnemyUsePipes	; Enter into bottom pipes and come out the top pipes
	JSR Vs_EnemyMove	; Do enemy movements
	JSR Vs_ObjectApplyYVel	; Apply Y Velocity

	LDA Vs_ObjectYVel,X
	BMI PRG009_AFCB	 ; If object is moving upward, jump to PRG009_AFCB

	CMP #$40
	BGE PRG009_AFD1	 ; If object is falling >= $40, jump to PRG009_AFD1

PRG009_AFCB:

	; Vs_ObjectYVel += 2 (gravity)
	INC Vs_ObjectYVel,X
	INC Vs_ObjectYVel,X

PRG009_AFD1:
	JSR Vs_ObjectCollideAgainstWorld ; Collide object against world

	LDA Vs_ObjectDetStat,X
	AND #$04
	BNE PRG009_AFE1	 ; If object hit floor, jump to PRG009_AFE1

	; Set Vs_ObjectAnimCnt
	STA Vs_ObjectAnimCnt,X

	JMP PRG009_B01D	 ; Jump to PRG009_B01D

PRG009_AFE1:
	LDA Vs_ObjectYVel,X
	PHA		 ; Save Y Velocity

	JSR Vs_ObjectHitFloor	 	; Align object to floor
	JSR Vs_EnemyHandleHitUnder	; Handle enemy getting hit from underneath

	LDA Vs_ObjectId,X
	CMP #VSOBJID_SIDESTEPPER
	BNE PRG009_AFF5	 ; If this is not a Sidestepper, jump to PRG009_AFF5

	; Vs_ObjectAnimCnt++
	INC Vs_ObjectAnimCnt,X

PRG009_AFF5:
	LDA Vs_ObjectIsLast,X
	ORA Vs_ObjectIsAngry,X
	BEQ PRG009_B000	 ; If object is neither last nor angry, jump to PRG009_B000

	; Vs_ObjectAnimCnt++
	INC Vs_ObjectAnimCnt,X

PRG009_B000:
	; Vs_ObjectAnimCnt++
	INC Vs_ObjectAnimCnt,X

	LDA Vs_ObjectPipeTimer,X
	BEQ PRG009_B00B	 ; If object is not in a pipe, jump to PRG009_B00B

	; Vs_ObjectAnimCnt++
	INC Vs_ObjectAnimCnt,X

PRG009_B00B:
	PLA		 ; Restore Y velocity

	CMP #$10
	BLT PRG009_B01D	 ; If Y Velocity < $10, jump to PRG009_B01D

	LDA Vs_ObjectRestoreXVel,X
	BEQ PRG009_B01D	 ; If object does not have an X velocity to restore, jump PRG009_B01D

	; Restore the X Velocity
	STA Vs_ObjectXVel,X

	; Clear Vs_ObjectRestoreXVel
	LDA #$00
	STA Vs_ObjectRestoreXVel,X

PRG009_B01D:
	JSR Vs_ObjectDraw	 	; Draw object
	JSR Vs_ObjectBumpOffOthers	; Bump off and turn away from other objects
	JSR Vs_ObjectPlayerCollide	; Do Player-to-objects collisions
	RTS		 ; Return

Vs_ObjectHitFloor:
	; Align object to floor
	LDA Vs_ObjectsY,X
	AND #$f0
	STA Vs_ObjectsY,X

	; Halt vertical movement
	LDA #$00
	STA Vs_ObjectYVel,X

PRG009_B034:
	RTS		 ; Return

Vs_EnemyHandleHitUnder:
	LDA Vs_ObjectYVel,X
	BMI PRG009_B034	 ; If object is moving upward, jump to PRG009_B034 (RTS)

	LDA Vs_ObjectPipeTimer,X
	BNE PRG009_B034	 ; If Vs_ObjectPipeTimer <> 0, jump to PRG009_B034 (RTS)

	LDA Vs_ObjectTileL,X
	CMP #TILE18_BOUNCEDBLOCK
	BEQ PRG009_B04B	 ; If enemy has been hit from underneath, jump to PRG009_B04B

	LDA Vs_POWBlockCnt
	BEQ PRG009_B0C0	 ; If a POW block is not active, jump to PRG009_B0C0

PRG009_B04B:

	; Enemy hit from underneath OR a POW block is active...

	; Play enemy flip sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	; Clear halt timer / 2
	LDA #$00
	STA Vs_ObjHaltTimer,X
	STA Vs_ObjTimer2,X

	LDA Vs_ObjectId,X
	CMP #VSOBJID_MUSHROOMCARD
	BGE PRG009_B09C	 ; If object is one of the cards (mainly), jump to PRG009_B09C

	CMP #VSOBJID_SIDESTEPPER
	BNE PRG009_B080	 ; If this is NOT a Sidestepper, jump to PRG009_B080

	; Sidesteppers only...

	LDA Vs_ObjectState,X
	CMP #$02
	BEQ PRG009_B080	 ; If Sidestepper's state = 2, jump to PRG009_B080

	LDA Vs_ObjectIsAngry,X
	BNE PRG009_B080	 ; If Sidestepper is already angry, jump to PRG009_B080

	; Flag as angry Sidestepper!
	LDA #$01
	STA Vs_ObjectIsAngry,X

	; Bump up to next speed grade
	LDA Vs_ObjectXVel,X
	JSR Vs_ObjectMoveFaster

	JMP PRG009_B097	 ; Jump to PRG009_B097

PRG009_B080:

	; Toggles between state 1 (Normal) and 2 (Flipped over)
	LDA Vs_ObjectState,X
	EOR #$03
	STA Vs_ObjectState,X

	CMP #$01
	BNE PRG009_B097	 ; If enemy was flipped over, jump to PRG009_B097

	LDY Vs_ObjectDir,X
	DEY		 ; zero-base the direction

	JSR PRG009_ACC2	 ; Partial re-init

	LDA #$00	 ; Vs_EnemyGetUpTimer (will be) 0

	BEQ PRG009_B099	 ; Jump (technically always) to PRG009_B099

PRG009_B097:
	LDA #$ff	 ; Vs_EnemyGetUpTimer (will be) $FF

PRG009_B099:
	STA Vs_EnemyGetUpTimer,X

PRG009_B09C:
	LDA Vs_ObjectTileL,X
	CMP #TILE18_BOUNCEDBLOCK
	BNE PRG009_B0BB	 ; If enemy has NOT been hit from underneath, jump to PRG009_B0BB

	LDA Vs_ObjectDetStat,X
	AND #%11000000	; Mask out hit from underneath left/right bits
	CMP #%11000000
	BEQ PRG009_B0BB	 ; If hit from underneath on left and right side, jump to PRG009_B0BB

	LDY #$01	 ; Y = $01 (Object hit on left side)
	ASL A
	BCC PRG009_B0B2	 ; If object hit on left side, jump to PRG009_B0B2

	DEY		 ; Y = $00 (Object hit on right side)

PRG009_B0B2:

	; Record current X velocity to restore it later
	LDA Vs_ObjectXVel,X
	STA Vs_ObjectRestoreXVel,X

	JSR PRG009_ACC2	 ; Partial re-init

PRG009_B0BB:
	; Enemy bounce!
	LDA #-$20
	STA Vs_ObjectYVel,X

PRG009_B0C0:
	RTS		 ; Return

	; Base sprite attribute per object type
Vs_ObjectPalette:
	.byte SPR_PAL3	; Spiny
	.byte SPR_PAL3
	.byte SPR_PAL3	; Sidestepper
	.byte SPR_PAL3	; Fighter Fly
	.byte SPR_PAL3	; Horizontal Fireball
	.byte SPR_PAL3	; Game Ender Fireball
	.byte SPR_PAL3	; Fountain Fireball 
	.byte SPR_PAL3	; Coin
	.byte SPR_PAL3	; Mushroom card
	.byte SPR_PAL3	; Flower card
	.byte SPR_PAL3	; Star card
	.byte SPR_PAL2	; Kicked block (from [?] block match)


	; Base sprite pattern for objects
Vs_PatIdx:	.func \1 - Vs_ObjPatterns
Vs_ObjectBasePatIndex:
	.byte Vs_PatIdx(Vs_PatSpiny)	; Spiny
	.byte Vs_PatIdx(Vs_PatSpiny)
	.byte Vs_PatIdx(Vs_PatSStep)	; Sidestepper
	.byte Vs_PatIdx(Vs_PatFFly)	; Fighter Fly
	.byte Vs_PatIdx(Vs_PatFBall)	; Horizontal Fireball
	.byte Vs_PatIdx(Vs_PatFBall)	; Game Ender Fireball
	.byte Vs_PatIdx(Vs_PatFBall)	; Fountain Fireball 
	.byte Vs_PatIdx(Vs_PatCoin)	; Coin
	.byte Vs_PatIdx(Vs_PatMush)	; Mushroom card
	.byte Vs_PatIdx(Vs_PatFlower)	; Flower card
	.byte Vs_PatIdx(Vs_PatStar)	; Star card
	.byte Vs_PatIdx(Vs_PatKBlock)	; Kicked block (from [?] block match)

	; 0 = Sprites unchanged 
	; 1 = Mirror both on odd frame
	; 2 = Mirrored object
Vs_ObjectDrawStyle:
	.byte $00	; Spiny
	.byte $00
	.byte $01	; Sidestepper
	.byte $02	; Fighter Fly
	.byte $00	; Horizontal Fireball
	.byte $00	; Game Ender Fireball
	.byte $00	; Fountain Fireball 
	.byte $00	; Coin
	.byte $02	; Mushroom card
	.byte $02	; Flower card
	.byte $02	; Star card
	.byte $02	; Kicked block (from [?] block match)

	;.byte $00	; Spiny
	;.byte $00
	;.byte $04	; Sidestepper
	;.byte $0C	; Fighter Fly
	;.byte $08	; Horizontal Fireball
	;.byte $08	; Game Ender Fireball
	;.byte $08	; Fountain Fireball 
	;.byte $10	; Coin
	;.byte $12	; Mushroom card
	;.byte $14	; Flower card
	;.byte $16	; Star card
	;.byte $18	; Kicked block (from [?] block match)

	; Left/right sprite patterns of objects
Vs_ObjPatterns:
Vs_PatSpiny:	.byte $B5, $B7
		.byte $B1, $B3
Vs_PatSStep:	.byte $8D, $8F
		.byte $9D, $9F
Vs_PatFBall:	.byte $A1, $A3
		.byte $A5, $A7
Vs_PatFFly:	.byte $ED, $ED
		.byte $EF, $EF
Vs_PatCoin:	.byte $09, $09
Vs_PatMush:	.byte $E7, $E7
Vs_PatFlower:	.byte $E9, $E9
Vs_PatStar:	.byte $EB, $EB
Vs_PatKBlock:	.byte $37, $37
Vs_PatFBall2:	.byte $91, $93
		.byte $95, $97
Vs_PatSpinyFlip:.byte $B1, $B3
		.byte $E1, $F1

Vs_FireballBaseAnimCnt:
	.byte $08, $08, $08, $00, $08, $00, $00, $00, $00, $00, $00, $08, $00, $08, $08, $08

Vs_ObjectDraw:
	; If this is one of the fireballs, jump to PRG009_B122, otherwise jump to PRG009_B139
	LDY Vs_ObjectId,X
	CPY #VSOBJID_FIREBALL_HORZ
	BEQ PRG009_B122
	CPY #VSOBJID_FIREBALL_ENDER
	BNE PRG009_B139

PRG009_B122:

	; One of the fireballs...

	LDA Vs_EnemyGetUpTimer,X
	BEQ PRG009_B139	 ; If Vs_EnemyGetUpTimer = 0, jump to PRG009_B139

	LSR A
	LSR A
	AND #$0f
	TAY		 ; Y = 0 to $F

	; Set base animation counter
	LDA Vs_FireballBaseAnimCnt,Y
	STA Vs_ObjectAnimCnt,X

	LDX #Vs_PatIdx(Vs_PatFBall2)	 ; Fireball base pattern index
	LDA #SPR_PAL3	 ; Fireball palette

	JMP PRG009_B13F	 ; Jump to PRG009_B13F

PRG009_B139:

	; Not one of the fireballs...

	LDX Vs_ObjectBasePatIndex,Y 	; X = base pattern index
	LDA Vs_ObjectPalette,Y	 	; A = palette

PRG009_B13F:
	; A/X -> Temp_Var1/2
	STA <Temp_Var1	; Sprite attribute
	STX <Temp_Var2	; Sprite base pattern index

	LDX Vs_CurIndex	 ; X = restore object index

	LDA Vs_ObjectYHi,X
	BEQ PRG009_B14C	 ; If object is not vertically off-screen, jump to PRG009_B14C

	RTS		 ; Return

PRG009_B14C:
	LDY Vs_ObjectId,X

	; Temp_Var5 = active draw style
	LDA Vs_ObjectDrawStyle,Y
	STA <Temp_Var5

	LDA Vs_ObjectIsLast,X
	BEQ PRG009_B15D	 ; If this is not the last object, jump to PRG009_B15D

	; Last enemy turns blue
	LDA #SPR_PAL2
	STA <Temp_Var1

PRG009_B15D:

	; Temp_Var4 = Object's Y
	LDA Vs_ObjectsY,X
	STA <Temp_Var4

	LDY #0	 	; Y = 0 (additional attributes)

	LDA Vs_ObjectState,X
	CMP #$02
	BLT PRG009_B180	 ; If object is not flipped over or dying, jump to PRG009_B180

	LDA Vs_ObjectId,X
	CMP #VSOBJID_FIGHTERFLY
	BEQ PRG009_B180	 ; If this is a Fighter Fly, jump to PRG009_B180

	; Object flipped over or dying, not a Fighter Fly...

	CMP #VSOBJID_SIDESTEPPER
	BGE PRG009_B17E	 ; If this is not a Spiny, jump to PRG009_B17E

	; Spiny only...

	; Temp_Var4 (Object Y) += 2 (Flipped over Spiny is wedged into the ground a little)
	INC <Temp_Var4
	INC <Temp_Var4

	; Alternate flipped Spiny pattern index
	LDA #Vs_PatIdx(Vs_PatSpinyFlip)
	STA <Temp_Var2

PRG009_B17E:
	LDY #SPR_VFLIP	; Flipped over!

PRG009_B180:
	LDA Vs_ObjectPipeTimer,X
	BEQ PRG009_B18D	 ; If Vs_ObjectPipeTimer = 0, jump to PRG009_B18D

	; Temp_Var4 (Object Y) -= 3 (slight step up when going in to the pipe)
	DEC <Temp_Var4
	DEC <Temp_Var4
	DEC <Temp_Var4

	LDY #SPR_BEHINDBG	; Entering pipe, go behind BG

PRG009_B18D:
	LDA Vs_ObjectState,X
	CMP #$01
	BEQ PRG009_B19F	 ; If object is in normal operation state, jump to PRG009_B19F

	LDA Vs_ObjectId,X
	CMP #VSOBJID_SPINY
	BEQ PRG009_B19F	 ; If this is a Spiny, jump to PRG009_B19F

	; Not a Spiny, not in normal state
	TYA
	ORA #SPR_VFLIP
	TAY

PRG009_B19F:
	STY <Temp_Var3		 ; Sprite attributes -> Temp_Var3

	LDY Vs_ObjectSprRAMOff	 ; Y = Sprite RAM Offset

	; Left sprite X
	LDA Vs_ObjectsX,X
	ADD Vs_ObjectXOff
	STA Sprite_RAM+$03,Y

	; Right sprite X
	ADD #$08
	STA Sprite_RAM+$07,Y

	; Clears Vs_ObjectXOff
	LDA #$00
	STA Vs_ObjectXOff

	; Left/right Sprite Y
	LDA <Temp_Var4
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	LDA <Temp_Var5
	AND #$01
	BEQ PRG009_B1D9	 ; If this is not draw style 1 (Flip both on odd frame), jump to PRG009_B1D9

	; Draw style 1 (Flip both on odd frame)

	LDA Vs_ObjectAnimCnt,X

	LDY #$00	 ; Y = 0

	AND #$08
	BEQ PRG009_B1D2	 ; 8 ticks on, 8 ticks off; jump to PRG009_B1D2

	LDY #SPR_HFLIP	 ; Y = SPR_HFLIP

PRG009_B1D2:
	TYA		 ; Sprite attribute change -> 'A'

	LDY Vs_ObjectSprRAMOff	 ; Y = Sprite RAM offset

	JMP PRG009_B1E3	 ; Jump to PRG009_B1E3

PRG009_B1D9:

	; Not draw style 1 ...

	LDA Vs_ObjectDir,X
	LSR A		 ; Sets carry if direction = 1 (right)

	LDA #$00
	BCC PRG009_B1E3	 ; If direction was left, jump to PRG009_B1E3

	LDA #SPR_HFLIP	 ; Otherwise, we need to flip

PRG009_B1E3:
	ORA <Temp_Var1	 ; Combine flip attribute with palette
	ORA <Temp_Var3	 ; Combine other decided attributes from above

	; Set left/right sprite attributes
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	LDA <Temp_Var5
	AND #$02
	BEQ PRG009_B200	 ; If this is not draw style 2, jump to PRG009_B200

	; Mirror object
	LDA Sprite_RAM+$02,Y
	AND #~SPR_HFLIP
	STA Sprite_RAM+$02,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y

PRG009_B200:
	LDA Vs_ObjectId,X
	CMP #VSOBJID_SIDESTEPPER
	BNE PRG009_B212	 ; If this is not a Sidestepper, jump to PRG009_B212

	LDA Vs_ObjectIsAngry,X

	LDX <Temp_Var2	 ; X = Temp_Var2 (base pattern index)

	AND #$01
	BNE PRG009_B225	 ; If Sidestepper is angry, jump to PRG009_B225
	BEQ PRG009_B227	 ; Otherwise, jump to PRG009_B227

PRG009_B212:

	; Not a Sidestepper...

	LDA <Temp_Var5
	AND #$01
	BEQ PRG009_B21C	 ; If this is not draw style 1, jump to PRG009_B21C

	; Draw style 1 (Flip both on odd frame)

	LDA #$00	 ; A = 0
	BEQ PRG009_B21F	 ; Jump (technically always) to PRG009_B21F

PRG009_B21C:
	LDA Vs_ObjectAnimCnt,X	 ; A = animation counter

PRG009_B21F:
	LDX <Temp_Var2	 ; X = Temp_Var2 (base pattern index)

	AND #$08
	BEQ PRG009_B227	 ; 8 ticks on, 8 ticks off; jump to PRG009_B227

PRG009_B225:

	; X += 2 (two patterns over)
	INX
	INX

PRG009_B227:
	LDA Sprite_RAM+$02,Y
	AND #SPR_HFLIP
	BEQ PRG009_B23D	 ; If not horizontally flipped, jump to PRG009_B23D

	; Set left and right patterns for flip
	LDA Vs_ObjPatterns,X
	STA Sprite_RAM+$05,Y
	LDA Vs_ObjPatterns+1,X
	STA Sprite_RAM+$01,Y

	JMP PRG009_B249	 ; Jump to PRG009_B249

PRG009_B23D:

	; Set left and right patterns 
	LDA Vs_ObjPatterns,X
	STA Sprite_RAM+$01,Y
	LDA Vs_ObjPatterns+1,X
	STA Sprite_RAM+$05,Y

PRG009_B249:
	LDX Vs_CurIndex	 ; Restore X as object index
	RTS		 ; Return

Vs_ObjectBumpOffOthers:
	CPX #$00
	BEQ PRG009_B264	 ; If this is the first object slot, jump to PRG009_B264 (RTS)
	
	; This limits how intensely we run this routine
	TXA
	ADD <Counter_1
	LSR A		
	BCC PRG009_B264	 ; If carry not set, jump to PRG009_B264 (RTS)

	; object index -> 'Y'
	TXA
	TAY

	DEY		 ; Y-- (consider previous object)

	STY <Temp_Var16	 ; Temp_Var16 = index of previous object

PRG009_B25D:
	JSR Vs_ObjectBumpOffEachother	 ; Bump off eachother if one runs into the other

	DEC <Temp_Var16	 ; Temp_Var16--
	BPL PRG009_B25D	 ; While objects remain, loop!

PRG009_B264:
	RTS		 ; Return

Vs_ObjectBumpOffEachother:
	LDY <Temp_Var16		; Y = Temp_Var16

	LDA Vs_ObjectId,Y
	CMP #VSOBJID_FIREBALL_HORZ
	BEQ PRG009_B249	 ; If this is the horizontal fireball, jump to PRG009_B249 (fireball doesn't collide with other objects)

	CMP #VSOBJID_FIREBALL_ENDER
	BEQ PRG009_B249	 ; If this is the ender fireball, jump to PRG009_B249 (fireball doesn't collide with other objects)

	LDA Vs_ObjectState,Y
	BEQ PRG009_B249	 ; If this slot is dead/empty, jump to PRG009_B249

	CMP #$03
	BGE PRG009_B283	 ; If object is dying, jump to PRG009_B283

	LDA Vs_ObjectPipeTimer,X
	ORA Vs_ObjectPipeTimer,Y
	BEQ PRG009_B286	 ; If neither of the objects is going through a pipe, jump to PRG009_B286

PRG009_B283:
	JMP PRG009_B30B	 ; One of them is going through a pipe; jump to PRG009_B30B (don't proceed)

PRG009_B286:
	LDA Vs_ObjectTimer3,X
	BEQ PRG009_B290	 ; If timer 3 is expired, jump to PRG009_B290

	LDA Vs_ObjectTimer3,Y	; this is unnecessary
	BNE PRG009_B30B	 ; If timer 3 not expired, jump to PRG009_B30B

PRG009_B290:
	LDX <Temp_Var16	 ; X = the other object's index

	; Calculate other object's bounding box
	LDY #$04	 ; Y = 4 (secondary bounding box)
	JSR VsPlayer_CalcObjBoundBox

	; Calculate object's bounding box
	LDX Vs_CurIndex	 ; Restore X to main object index
	LDY #$00	 ; Y = 0 (primary bounding box)
	JSR VsPlayer_CalcObjBoundBox

	JSR Vs_CheckBoxCollision
	BCC PRG009_B30B	 ; If no collision occurred, jump to PRG009_B30B

	LDY <Temp_Var16		 ; Y = Temp_Var16 (the other object's index)

	LDA Vs_ObjectDetStat,X
	AND Vs_ObjectDetStat,Y
	AND #$04
	BEQ PRG009_B30B	 ; If one or the other object is not on the floor, jump to PRG009_B30B

	LDA Vs_ObjHaltTimer,X
	BNE PRG009_B2DA	 ; If halt timer is not expired, jump to PRG009_B2DA

	; Timer 3 = $28
	LDA #$28
	STA Vs_ObjectTimer3,X

	LDA Vs_ObjectState,X
	CMP #$01
	BNE PRG009_B2CB	 ; If main object's state <> 1 (Normal), jump to PRG009_B2CB

	; Halt Timer = $10
	LDA #$10
	STA Vs_ObjHaltTimer,X

	; Vs_ObjectAnimCnt = 8
	LDA #$08
	STA Vs_ObjectAnimCnt,X

PRG009_B2CB:
	LDA Vs_ObjectsX,X
	CMP Vs_ObjectsX,Y
	ROR A
	EOR Vs_ObjectXVel,X
	BMI PRG009_B2DA	 ; If objects are moving the same direction, jump to PRG009_B2DA

	; Turn around main object
	JSR Vs_ObjectReverseXVel

PRG009_B2DA:
	LDA Vs_ObjHaltTimer,Y
	BNE PRG009_B30B	 ; If halt timer not expired, jump to PRG009_B30B

	; Timer 3 = $28
	LDA #$28
	STA Vs_ObjectTimer3,Y

	LDA Vs_ObjectState,Y
	CMP #$01
	BNE PRG009_B2F5	 ; If state <> 1 (Normal), jump to PRG009_B2F5

	; Halt Timer = $10
	LDA #$10
	STA Vs_ObjHaltTimer,Y

	; Vs_ObjectAnimCnt = 8
	LDA #$08
	STA Vs_ObjectAnimCnt,Y

PRG009_B2F5:
	LDA Vs_ObjectsX,Y
	CMP Vs_ObjectsX,X
	ROR A
	EOR Vs_ObjectXVel,Y
	BMI PRG009_B306	 ; If objects are moving the same direction, jump to PRG009_B306

	; Make OTHER object turn around
	LDX <Temp_Var16
	JSR Vs_ObjectReverseXVel

PRG009_B306:
	; Restore Y as other object's index and X as main object's index
	LDY <Temp_Var16
	LDX Vs_CurIndex

PRG009_B30B:
	LDX Vs_CurIndex	 ; Restore X as current object index

	RTS		 ; Return

Vs_ObjectReverseXVel:

	; Negate the X velocity
	LDA Vs_ObjectXVel,X
	NEG
	STA Vs_ObjectXVel,X

	RTS		 ; Return

	; Determine whether Player is to the right or left of object
Vs_GetPlayerDirFromObj:
	LDA Vs_PlayerX,Y
	LDY #$00	; Y = 0 (Player is to the right of object)
	SBC Vs_ObjectsX,X
	BPL PRG009_B326	; If Player is to the right of object, jump to PRG009_B326
	INY		; Y = 1 (Player is to the left of object)
PRG009_B326:
	RTS		 ; Return

VsPlayer_CalcObjBoundBox:
	; Result:
	;	Temp_Var1/5 = top
	;	Temp_Var2/6 = left
	;	Temp_Var3/7 = bottom offset
	;	Temp_Var4/8 = right offset

	; Temp_Var1+Y = Object's Y + 6 (top)
	LDA Vs_ObjectsY,X
	ADD #$06
	STA Temp_Var1,Y

	; Temp_Var3+4 = 4 (bottom offset)
	LDA #$04
	STA Temp_Var3,Y

	; Temp_Var2+Y = Object's X + 2 (left)
	LDA Vs_ObjectsX,X
	ADD #$02
	STA Temp_Var2,Y

	; Temp_Var4+Y = 12 (for enemies) or 5 (otherwise)  (right offset)
	LDA Vs_ObjectId,X
	CMP #VSOBJID_COIN
	LDA #12
	BLT PRG009_B349	 ; If this is one of the enemies, jump to PRG009_B349
	LDA #$05
PRG009_B349:
	STA Temp_Var4,Y	 ; -> Temp_Var4+Y

PRG009_B34C:
	RTS		 ; Return

	; Kicked off object X velocity
Vs_ObjectKickedXVel:	.byte -$20, $20

Vs_ObjectPlayerCollide:
	LDA Vs_PlayerState
	CMP #$03
	BEQ PRG009_B35A	 ; If Mario is climbing, jump to PRG009_B35A

	CMP #$01
	BNE PRG009_B34C	 ; If Mario is not in normal state (Init/Dying), jump to PRG009_B34C (RTS)

PRG009_B35A
	LDA Vs_PlayerState+1
	CMP #$03
	BEQ PRG009_B365	 ; If Luigi is climbing, jump to PRG009_B365

	CMP #$01
	BNE PRG009_B34C	 ; If Luigi is not in normal state (Init/Dying), jump to PRG009_B34C (RTS)

PRG009_B365:

	; Both Players are alive and well...

	; This limits how intensely we run this routine
	TXA
	ADD <Counter_1
	LSR A		
	BCS PRG009_B34C	 ; If carry set, jump to PRG009_B34C (RTS)

	LDA Vs_ObjectId,X
	CMP #VSOBJID_FIREBALL_FOUNTAIN
	BEQ PRG009_B378	 ; If this is the fountain fireball, jump to PRG009_B378

	LDA Vs_ObjectPipeTimer,X
	BNE PRG009_B34C	 ; If this object is currently in a pipe, jump to PRG009_B34C (RTS)

PRG009_B378:
	LDA #$01
	STA <Temp_Var16	 ; Temp_Var16 = 1 (both Players)
PRG009_B37C:
	LDX <Temp_Var16		 ; X = current Player index

	LDA Vs_PlayerState,X
	CMP #$01
	BNE PRG009_B38A	 ; If Player is no longer in normal state (probably got killed), jump to PRG009_B38A

	LDA Vs_PlayerFlashInv,X
	BEQ PRG009_B38D	 ; If Player is not flashing invincible, jump to PRG009_B38D

PRG009_B38A:
	JMP PRG009_B443	 ; Jump to PRG009_B443 (don't consider this Player <-> object collision)

PRG009_B38D:

	; Calculate Player's bounding box as secondary
	LDY #$04	 ; Y = 4 (secondary bounding box)
	JSR VsPlayer_CalcBoundBox

	; Calculate object's bounding box
	LDY #$00	 ; Y = 0 (primary bounding box)
	LDX Vs_CurIndex	 ; X = object's index
	JSR VsPlayer_CalcObjBoundBox

	JSR Vs_CheckBoxCollision
	LDY <Temp_Var16	 ; Y = Temp_Var16 (current player index)
	BCC PRG009_B38A	 ; If Player and objecta are not touching, jump to PRG009_B38A

	LDA Vs_ObjectId,X
	CMP #VSOBJID_MUSHROOMCARD
	BLT PRG009_B3AB	 ; If object is not one of the cards, jump to PRG009_B3AB

	; BUG!! 
	; Many know it as the "Fire card" glitch, where a kicked [?] block can be
	; "collected" as a "card" when the game is paused while the block is touching
	; a Player; this is the initial cause of it, that we use the card handler for
	; all object IDs >= VSOBJID_MUSHROOMCARD...

	; But what I haven't determined yet is the precise series of events that makes
	; this happen, because it's not like you always grab the "Fire Card"...

	JMP Vs_GrabCardObject	 ; Otherwise, jump to Vs_GrabCardObject

PRG009_B3AB:
	CMP #VSOBJID_COIN
	BNE PRG009_B3F1	 ; If this is not a coin, jump to PRG009_B3F1

	; Coin only...

	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1

	; Vs_EnemyGetUpTimer used as coins "twinkle" away...
	LDA #$0f
	STA Vs_EnemyGetUpTimer,X

	; Player has another coin!
	LDA Vs_PlayerCoins,Y
	ADD #$01
	STA Vs_PlayerCoins,Y

	LDA Vs_PlayerCoins
	ADD Vs_PlayerCoins+1
	CMP #$05
	BNE PRG009_B3ED	 ; If not all 5 coins have been found (in [?] block game), jump to PRG009_B3ED

Vs_EndGame:
	; Stop all enemies
	LDY #$0b	 ; Y = $B (all objects)
	LDA #$ff	 ; A = $FF
PRG009_B3D4:
	STA Vs_ObjHaltTimer,Y
	DEY		 ; Y--
	BPL PRG009_B3D4	 ; While Y >= 0, loop!

	LDY #$01	 ; Y = 1 (Mario lost)
	LDA Vs_PlayerCoins
	CMP Vs_PlayerCoins+1
	BLT PRG009_B3E5	 ; If Mario has less coins than Luigi, jump to PRG009_B3E5

	INY		 ; Y = 2 (Luigi lost)

PRG009_B3E5:
	STY Map_PlayerLost2PVs	 ; Set Map_PlayerLost2PVs appropriately

	; Vs_TimeToExit = $80
	LDA #$80
	STA Vs_TimeToExit

PRG009_B3ED:
	JSR Vs_PlayerAddCoinToStatus	 ; Add coin to status bar
	RTS		 ; Return

PRG009_B3F1:

	; Not a coin, not a card...

	LDA Vs_ObjectState,X
	CMP #$01
	BNE PRG009_B44E	 ; If enemy is not in "normal" state, jump to PRG009_B44E

	; Enemy in normal state...

	; Stop all enemies
	LDY #$0b	 ; Y = $B (all objects)
	LDA #$ff	 ; A = $FF
PRG009_B3FC:
	STA Vs_ObjHaltTimer,Y
	DEY		 ; Y--
	BPL PRG009_B3FC	 ; While Y >= 0, loop!

	LDA <Temp_Var16
	EOR #$01
	TAY	 ; Y = opposite Player index

	; Opposite Player runs halt timer
	LDA #$ff
	STA Vs_PlayerHaltTimer,Y

	LDY <Temp_Var16	 ; Y = killed Player index

	; Set impacted object's Vs_ObjectAnimCnt = $20
	LDA #$20
	STA Vs_ObjectAnimCnt,X

	; Vs_PlayerCnt = $20
	STA Vs_PlayerCnt,Y

	; Play death music!
	LDA Sound_QMusic1
	ORA #MUS1_PLAYERDEATH
	STA Sound_QMusic1

	; Set Player state to Dying!
	LDA #$02
	STA Vs_PlayerState,Y

	; Player moves upward
	LDA #-$30
	STA Vs_PlayerYVel,Y

	; If one of the fireballs got you, jump to PRG009_B43B
	LDA Vs_ObjectId,X
	CMP #VSOBJID_FIREBALL_HORZ
	BEQ PRG009_B43B
	CMP #VSOBJID_FIREBALL_ENDER
	BEQ PRG009_B43B

	; Set object to face Player!
	JSR Vs_GetPlayerDirFromObj
	INY		 ; Y++
	TYA
	STA Vs_ObjectDir,X

PRG009_B43B: 
	LDX Vs_CurIndex	 ; Restore X as current object index
	RTS		 ; Return

; $B43F
	DEY		 ; Y-- 
	JSR PRG009_ACC2	 ; Partial re-init

PRG009_B443:
	DEC <Temp_Var16	 ; Temp_Var16--
	BMI PRG009_B44A	 ; If done, jump to PRG009_B44A
	JMP PRG009_B37C	 ; Otherwise, loop!

PRG009_B44A:
	LDX Vs_CurIndex	 ; Restore X as object index

	RTS		 ; Return

PRG009_B44E:

	; Enemy that is flipped over!

	; Player kick sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	LDA Vs_PlayerXVel,Y
	LDY #$00	 ; Y = 0 (Player is moving rightward)
	CMP #$00
	BMI PRG009_B460	 ; If Player is moving to the left, jump to PRG009_B460
	INY		 ; Y = 1 (Player is moving leftward)
PRG009_B460:

	; Set X velocity appropriate for kicked off object
	LDA Vs_ObjectKickedXVel,Y
	STA Vs_ObjectXVel,X

	LDY <Temp_Var16	 ; Y = current Player index

	; Set object to Dying state
	LDA #$03
	STA Vs_ObjectState,X

	; Kicked object upward
	LDA #-$20
	STA Vs_ObjectYVel,X

	; Player does kicking animation
	LDA #$0c
	STA Vs_PlayerKick,Y

	; Player gets a coin for this
	LDA Vs_PlayerCoins,Y
	ADD #$01
	STA Vs_PlayerCoins,Y

	LDA Vs_PlayerCoins
	ADD Vs_PlayerCoins+1
	CMP #$05
	BEQ PRG009_B4AF	 ; If all five enemies have been kicked off, jump to PRG009_B4AF

	; Not all 5 have been kicked off yet...

	CMP #$04
	BNE PRG009_B4B2	 ; If we're not on our fourth kick (one enemy left), jump to PRG009_B4B2

	; Set Vs_NextObjectIsLast; because it is!
	INC Vs_NextObjectIsLast

	LDX #$04	 ; X = 4
PRG009_B494:
	LDA Vs_ObjectState,X
	BEQ PRG009_B49D	 ; If object slot is dead/empty, jump to PRG009_B49D

	CMP #$03
	BLT PRG009_B4A2	 ; If object is not dying, jump to PRG009_B4A2

PRG009_B49D:
	DEX		 ; X--
	BPL PRG009_B494	 ; While X >= 0, loop
	BMI PRG009_B4B2	 ; Otherwise, jump to PRG009_B4B2

PRG009_B4A2:
	; Bump up to next speed grade
	LDA Vs_ObjectXVel,X
	JSR Vs_ObjectMoveFaster

	; Set object as last
	LDA #$01
	STA Vs_ObjectIsLast,X

	BNE PRG009_B4B2	 ; Jump (technically always) to PRG009_B4B2

PRG009_B4AF:
	JSR Vs_EndGame	 ; Set up game to end

PRG009_B4B2:
	LDX Vs_CurIndex	 ; Restore X as object index
	LDY <Temp_Var16	 ; Y = current Player index

	; Set kicking frame
	LDA #$05
	STA Vs_PlayerFrame,Y

	JSR Vs_PlayerAddCoinToStatus	 ; Add coin to status bar

	RTS		 ; Return

Vs_GrabCardObject:
	LDA Vs_EnemyGetUpTimer,X
	BNE PRG009_B4F4	 ; If Vs_EnemyGetUpTimer <> 0 (Card not ready to be grabbed yet), jump to PRG009_B4F4

	JSR Vs_ObjectDestroy	 ; Got the card; remove object

	; Play got card sound!
	LDA Sound_QMap
	ORA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

	LDY <Temp_Var16	 ; Y = Temp_Var16 (Player index)

	; Flash picked up card
	LDA #$40
	STA Vs_CardFlash,Y

	LDY #$00	 ; Y = 0 (Mario's cards)

	LDA <Temp_Var16
	BEQ PRG009_B4DF	 ; If this is Mario, jump to PRG009_B4DF

	LDY #(Inventory_Cards2 - Inventory_Cards)	; Offset to Luigi's cards

PRG009_B4DF:

	; Move other cards over
	LDA Inventory_Cards+1,Y
	STA Inventory_Cards+2,Y
	LDA Inventory_Cards,Y
	STA Inventory_Cards+1,Y

	; Give card
	LDA Vs_ObjectId,X
	SUB #(VSOBJID_MUSHROOMCARD - 1)	; -1 because "0" is none, "1" is Mushroom card, etc.
	STA Inventory_Cards,Y

PRG009_B4F4:
	RTS		 ; Return

PRG009_B4F5:
	.byte $02, $02, $04, $08, $10, $10

	; When an object "gets up" from being flipped over, it's a little faster than before!
	; Different ranges depending on what the previous X velocity was; and for each direction.
Vs_ObjectGetUpXVel:
	.byte $0A, -$0A	; old abs X Vel < $0A
	.byte $0C, -$0C	; old abs X Vel < $0C
	.byte $10, -$10	; otherwise


Vs_ObjStateFlippedOver:
	LDA Vs_ObjHaltTimer,X
	BNE PRG009_B580	 ; If halt timer <> 0, jump to PRG009_B580

	; Vs_ObjectAnimCnt = 0 (don't animate when flipped over)
	LDA #$00
	STA Vs_ObjectAnimCnt,X

	LDA Vs_EnemyGetUpTimer,X
	BNE PRG009_B543	 ; If enemy still hasn't got up, jump to PRG009_B543

	JSR Vs_ObjectDraw	 ; Draw object

	; Enemy got up; set state back to normal
	LDA #$01
	STA Vs_ObjectState,X

	LDA Vs_ObjectRestoreXVel,X	; Get X velocity from before being flipped
	PHA 		; Save this value

	; Clear Vs_ObjectRestoreXVel
	LDA #$00
	STA Vs_ObjectRestoreXVel,X

	PLA		 ; Restore X velocity

Vs_ObjectMoveFaster:
	PHP		 ; Save CPU status
	BPL PRG009_B52A	 ; If X velocity >= 0, jump to PRG009_B52A
	NEG		 ; Otherwise, negate (absolute value)
PRG009_B52A:
	LDY #$00	 ; Y = 0

	CMP #$0a
	BLT PRG009_B532	 ; If X velocity < $0A, jump to PRG009_B532

	INY
	INY	; Y = 2

PRG009_B532:
	CMP #$0c
	BLT PRG009_B538	 ; If X velocity < $0C, jump to PRG009_B538

	INY
	INY	; Y = 4

PRG009_B538:
	PLP		 ; Restore CPU status
	BPL PRG009_B53C	 ; If X velocity >= 0, jump to PRG009_B53C

	INY		 ; Otherwise, Y++

PRG009_B53C:

	; Set "faster" X velocity
	LDA Vs_ObjectGetUpXVel,Y
	STA Vs_ObjectXVel,X

	RTS		 ; Return


PRG009_B543:
	LDA <Counter_1
	AND #$01
	BNE PRG009_B54C	 ; Every other tick, jump to PRG009_B54C

	DEC Vs_EnemyGetUpTimer,X	 ; Vs_EnemyGetUpTimer--

PRG009_B54C:
	LDA Vs_EnemyGetUpTimer,X
	CMP #$60
	BGE PRG009_B568	 ; If Vs_EnemyGetUpTimer >= $60, jump to PRG009_B568

	LSR A
	LSR A
	LSR A
	LSR A
	LSR A	; Divide by 32
	TAY		 ; Y = 0 to 2

	LDA <Counter_1
	AND PRG009_B4F5,Y
	BEQ PRG009_B568	 ; If masked value = 0, jump to PRG009_B568

	INC Vs_ObjectXOff ; Object X++

	; Vs_ObjectAnimCnt = 8
	LDA #$08
	STA Vs_ObjectAnimCnt,X

PRG009_B568:
	JSR Vs_ObjectCollideAgainstWorld ; Collide object against world

	LDA Vs_ObjectDetStat,X
	AND #$04
	BEQ PRG009_B57D	 ; If object has not hit floor, jump to PRG009_B57D

	JSR Vs_ObjectHitFloor	 ; Align object to floor

	; Halt horizontal movement
	LDA #$00
	STA Vs_ObjectXVel,X

	JSR Vs_EnemyHandleHitUnder	 ; Handle enemy getting hit from underneath

PRG009_B57D:
	JSR Vs_ObjectMoveAndFall	 ; Object move and fall

PRG009_B580:
	JMP PRG009_B01D	 ; Jump to PRG009_B01D

Vs_ObjectMoveAndFall:
	JSR Vs_ObjectApplyXVel	 ; Apply X Velocity
	JSR Vs_ObjectApplyYVel	 ; Apply Y Velocity

	LDA Vs_ObjectYVel,X
	BMI PRG009_B592	 ; If object is moving upward, jump to PRG009_B592

	CMP #$40
	BGE PRG009_B598	 ; If object is falling >= $40, jump to PRG009_B598

PRG009_B592:

	; Y Vel += 2 (gravity)
	INC Vs_ObjectYVel,X
	INC Vs_ObjectYVel,X

PRG009_B598:
	RTS		 ; Return


Vs_ObjStateDying:
	LDA Vs_ObjectIsLast,X
	BNE PRG009_B5A3	 ; If this is the last object, jump to PRG009_B5A3

	LDA Vs_ObjHaltTimer,X
	BNE PRG009_B5D1	 ; If object is halted, jump to PRG009_B5D1

PRG009_B5A3:
	LDA Vs_ObjectsY,X
	CMP #224
	BLT PRG009_B5B5	 ; If object Y < 224, jump to PRG009_B5B5

	LDA Vs_ObjectYHi,X
	BNE PRG009_B5B5	 ; If object is verticall off-screen, jump to PRG009_B5B5

Vs_ObjectDestroy:
	LDA #$00
	STA Vs_ObjectState,X

	RTS		 ; Return

PRG009_B5B5:
	JSR Vs_ObjectMoveAndFall	 ; Object move and fall

	INC Vs_ObjectYVel,X	 ; Y Vel ++ (gravity

	LDA <Counter_1
	AND #$01
	BNE PRG009_B5D1	 ; Every other tick, jump to PRG009_B5D1

	LDA Vs_ObjectXVel,X
	BEQ PRG009_B5D1	 ; If object is not moving horizontally, jump to PRG009_B5D1
	BMI PRG009_B5CE	 ; If object is moving leftward, jump to PRG009_B5CE

	DEC Vs_ObjectXVel,X	 ; Slow down (moving leftward)
	DEC Vs_ObjectXVel,X	 ; Just to overcome the following INC
PRG009_B5CE:
	INC Vs_ObjectXVel,X	 ; Slow down (moving rightward)

PRG009_B5D1:
	JMP Vs_ObjectDraw	 ; Draw object and don't come back

PRG009_B5D4:
	RTS		 ; Return

	; Vertical scroll settings for POW block shake
Vs_POWVertShakes:	.byte $00, $01, $04, $03

Vs_POWPatterns:
	.byte $B9, $BB	; Initial POW
	.byte $99, $9B	; One hit
	.byte $89, $8B	; Two hits (and after this it's gone)

Vs_POWHeight:
	.byte $01	; Initial POW
	.byte $04	; One hit
	.byte $06	; Two hits (and after this it's gone)

Vs_POW_X	= 120
Vs_POW_Y	= 152

Vs_UpdateAndDrawPOW:

	; Temp_Var1 = Vs_POWBlockCnt
	LDA Vs_POWBlockCnt
	STA <Temp_Var1

	BEQ PRG009_B5F5	 ; If Vs_POWBlockCnt = 0, jump to PRG009_B5F5

	DEC Vs_POWBlockCnt	 ; Vs_POWBlockCnt--
	LSR A
	AND #$03
	TAY		 ; Y = 0 to 3

	; Shake vertical scroll
	LDA Vs_POWVertShakes,Y
	STA <Vert_Scroll

PRG009_B5F5:
	LDA Vs_POWHits
	CMP #$03
	BEQ PRG009_B5D4	 ; If POW block is used up, jump to PRG009_B5D4 (RTS)

	; Set POW block sprite Ys
	LDA #Vs_POW_Y
	SUB <Vert_Scroll
	STA Sprite_RAM+$10
	STA Sprite_RAM+$14

	; Set POW block sprite Xs
	LDA #Vs_POW_X
	STA Sprite_RAM+$13
	ADD #$08
	STA Sprite_RAM+$17

	LDA Vs_POWHits
	ASL A	
	TAY	 ; Y = Vs_POWHits * 2

	; Set POW block sprite patterns
	LDA Vs_POWPatterns,Y
	STA Sprite_RAM+$11
	LDA Vs_POWPatterns+1,Y
	STA Sprite_RAM+$15

	; Set POW block sprite attributes
	LDA #SPR_PAL2
	STA Sprite_RAM+$12
	STA Sprite_RAM+$16

	LDX #$01	 ; X = 1 (both Players)
PRG009_B62D:
	LDA Vs_POWHits
	CMP #$03
	BEQ PRG009_B6AD	 ; If POW block was used up, jump to PRG009_B6AD

	LDA Vs_PlayerState,X
	CMP #$01
	BNE PRG009_B6AD	 ; If Player is no longer in normal state, jump to PRG009_B6AD

	; Calculate Player's bounding box
	LDY #$00	 ; Y = 0
	JSR VsPlayer_CalcBoundBox

	; Calculate POW block's bounding box
	LDA #Vs_POW_Y
	STA <Temp_Var5
	LDA #Vs_POW_X 
	STA <Temp_Var6
	LDA #16
	STA <Temp_Var8
	LDY Vs_POWHits
	SUB Vs_POWHeight,Y
	STA <Temp_Var7	

	JSR Vs_CheckBoxCollision
	BCC PRG009_B6AD	 ; If Player and POW block are not touching, jump to PRG009_B6AD

	LDY Vs_POWHits	 ; Y = POW block hits so far

	LDA Vs_POWHeight,Y
	STA Vs_PlayerYOff,X
	LDA Vs_PlayerY,X
	SUB Vs_PlayerYOff,X

	CMP #(Vs_POW_Y - 11)
	BGE PRG009_B67A	 ; If Player is lower than the top of POW block, jump to PRG009_B67A

	; Player is above top of POW block...

	LDA Vs_PlayerYVel,X
	BMI PRG009_B6AD	 ; If Player is moving upward (away from POW block), jump to PRG009_B6AD

	; Flag Player as on floor (on top of POW block)
	LDA #$04
	STA Vs_PlayerDetStat,X

	BEQ PRG009_B6AD	 ; Jump technically NEVER to PRG009_B6AD (an inconsequential mistake here)

PRG009_B67A:

	; Player is lower than top of POW block...

	LDA Vs_PlayerY,X
	ADD Vs_PlayerYOff,X
	CMP #(Vs_POW_Y + 9)
	BLT PRG009_B6AD	 ; If Player is too low, jump to PRG009_B6AD

	LDA Vs_PlayerYVel,X
	BPL PRG009_B6AD	 ; If Player is not moving upward (toward POW block), jump to PRG009_B6AD

	; POW block hit sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	INC Vs_POWHits	 ; Vs_POWHits++

	; Halt Player's upward movement
	LDA #$00
	STA Vs_PlayerYVel,X

	; Ensure Player is beneath POW block
	LDA #(Vs_POW_Y + 17)
	SUB Vs_PlayerYOff,X
	STA Vs_PlayerY,X

	; Player "sticks" to POW block for a moment
	LDA #$08
	STA Vs_PlayerStick,X

	; Vs_POWBlockCnt = $10
	LDA #$10
	STA Vs_POWBlockCnt

PRG009_B6AD:
	DEX		 ; X--
	BMI PRG009_B6B3	 ; If X < 0, jump to PRG009_B6B3 (RTS)
	JMP PRG009_B62D	; Otherwise, loop!

PRG009_B6B3:
	RTS		 ; Return

Vs_FireballYVelAccel:	.byte -$01, $01
Vs_FireballYVelLimit:	.byte -$10, $10

Vs_FireballXLimit:
	.byte 232, 8
	
Vs_Fireballs:
	LDA Vs_EnemyGetUpTimer,X
	BEQ PRG009_B6C9	 ; If Vs_EnemyGetUpTimer = 0, jump to  PRG009_B6C9

	CMP #$20
	BNE PRG009_B6C6	 ; If Vs_EnemyGetUpTimer >= $20, jump to PRG009_B6C6 (Vs_ObjectDraw)

	JMP Vs_ObjectDestroy	 ; Destroy the object and don't come back

PRG009_B6C6:
	JMP Vs_ObjectDraw	 ; Draw object and don't come back

PRG009_B6C9:
	JSR Vs_ObjectDraw	 ; Draw object

	; Vs_ObjectAnimCnt += 2
	INC Vs_ObjectAnimCnt,X
	INC Vs_ObjectAnimCnt,X

	LDA Vs_ObjectAnimCnt,X
	AND #$10
	BEQ PRG009_B6F2	 ; 16 ticks on, 16 ticks off; jump to PRG009_B6F2

	; Reverse patterns
	LDA Sprite_RAM+$01,Y
	PHA
	LDA Sprite_RAM+$05,Y
	STA Sprite_RAM+$01,Y
	PLA
	STA Sprite_RAM+$05,Y

	; Other sprite of fireball is H/V flipped
	LDA Sprite_RAM+$02,Y
	EOR #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

PRG009_B6F2:
	LDY Vs_ObjectDir,X	 ; Y = object direction

	LDA Vs_ObjectsX,X
	CMP Vs_FireballXLimit-1,Y
	BNE PRG009_B709	 ; If fireball is not at X limit, jump to PRG009_B709

	LDA Vs_ObjectId,X
	CMP #VSOBJID_FIREBALL_HORZ
	BNE PRG009_B709	 ; If this is not the horizontal fireball, jump to PRG009_B709

	; Vs_EnemyGetUpTimer = $40
	LDA #$40
	STA Vs_EnemyGetUpTimer,X

PRG009_B709:
	JSR Vs_ObjectPlayerCollide	; Do Player-to-objects collisions
	JSR Vs_ObjectCollideAgainstWorld ; Collide object against world

	LDA Vs_POWBlockCnt
	BNE PRG009_B71B	 ; If POW block is active, jump to PRG009_B71B

	LDA Vs_ObjectTileL,X
	CMP #TILE18_BOUNCEDBLOCK
	BNE PRG009_B720	 ; If fireball did not touch a bounced block, jump to PRG009_B720

PRG009_B71B:

	; Vs_EnemyGetUpTimer = $40
	LDA #$40
	STA Vs_EnemyGetUpTimer,X

PRG009_B720:
	LDA Vs_ObjectId,X
	CMP #VSOBJID_FIREBALL_HORZ
	BNE PRG009_B746	 ; If this is not the horizontal fireball, jump to PRG009_B746

	JSR Vs_ObjectApplyXVel	 ; Apply X Velocity
	JSR Vs_ObjectApplyYVel	 ; Apply Y Velocity

	; Determine vertical direction of fireball
	LDA Vs_ObjectVar1,X
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate fireball vertically
	LDA Vs_ObjectYVel,X
	ADD Vs_FireballYVelAccel,Y
	STA Vs_ObjectYVel,X

	CMP Vs_FireballYVelLimit,Y
	BNE PRG009_B745	 ; If fireball is not at Y Vel limit, jump to PRG009_B745

	INC Vs_ObjectVar1,X	 ; Vs_ObjectVar1++ (change vertical direction)

PRG009_B745:
	RTS		 ; Return

PRG009_B746:
	CMP #VSOBJID_FIREBALL_FOUNTAIN
	BEQ PRG009_B773	 ; If this is the fountain fireball, jump to PRG009_B773

	; Not the fountain fireball

	LDA Vs_ObjectDetStat,X
	AND #$03
	AND Vs_ObjectDir,X
	BEQ PRG009_B757	 ; If fireball did not hit wall in the direction it was headed, jump to PRG009_B757

	JSR Vs_ObjectReverseXVel	 ; Otherwise, reverse horizontal direction

PRG009_B757:
	LDA Vs_ObjectDetStat,X
	AND #$0c
	AND Vs_ObjectVDir,X
	BEQ PRG009_B76C	 ; If fireball did not hit floor/ceiling in the direction it was headed, jump to PRG009_B76C

	; Otherwise, reverse vertical direction
	LDA Vs_ObjectYVel,X
	NEG
	STA Vs_ObjectYVel,X

PRG009_B76C:
	JSR Vs_ObjectApplyXVel	 ; Apply X Velocity
	JSR Vs_ObjectApplyYVel	 ; Apply Y Velocity
	RTS		 ; Return

PRG009_B773:
	JSR PRG009_B76C	 ; Apply velocities

	INC Vs_ObjectYVel,X	 ; Vs_ObjectYVel++
	INC Vs_ObjectYVel,X	 ; Vs_ObjectXVel++

	LDA Vs_ObjectsY,X
	CMP #224
	BLT PRG009_B788	 ; If object Y < 224, jump to PRG009_B788

	; Set object to dead/empty
	LDA #$00
	STA Vs_ObjectState,X

PRG009_B788:
	RTS		 ; Return

Vs_BumpBlocksUpdateAndDraw:

	LDX #$01	; X = 1 (both Players)
PRG009_B78B:
	STX Vs_CurIndex	; Update current index
	TXA
	ADD Vs_ObjectSprRAMSel
	TAY	 ; Y = Sprite RAM offset

	; Get Sprite RAM offset
	LDA Vs_ObjectSprRAMOffsets+$C,Y
	STA Vs_ObjectSprRAMOff

	LDA Vs_PlayerBlkHitCnt,X
	BEQ PRG009_B7BA	; If this Player's block hit counter = 0, jump to PRG009_B7BA

	PHA		 ; Save block hit count value

	CMP #$0e
	BNE PRG009_B7A7	 ; If the block hit count value <> $0E, jump to PRG009_B7A7

	JSR Vs_EraseBlockHitTile	 ; Erase the bounce block (again?)

PRG009_B7A7:
	PLA		 ; Restore block hit count value
	CMP #$01
	BNE PRG009_B7B7	 ; If block hit count value <> $01, jump to PRG009_B7B7

	JSR Vs_RestoreBlockHitTile	 ; Restore the bounce block

	; Put the tile back into the tile grid memory
	LDY Vs_PlayerBlkHit,X	 ; Y = offset to hit bounce block
	LDA #TILE18_BOUNCEBLOCK
	STA Tile_Mem,Y

PRG009_B7B7:
	JSR Vs_BumpBlockUpdateAndDraw	 ; Update and draw the bumped block

PRG009_B7BA:
	DEX		 ; X--
	BPL PRG009_B78B	 ; While X >= 0, loop

	RTS		 ; Return

Vs_BumpBlockUpdateAndDraw:
	LDA <Vs_IsPaused	 ; If the game is paused...
	ORA Vs_PlayerHaltTimer	 ; ... Mario is halted ...
	ORA Vs_PlayerHaltTimer+1 ; ... Luigi is halted ...
	ORA Vs_TimeToExit	 ; ... or game is exiting ...
	BNE PRG009_B7DA	 	 ; ... then jump to PRG009_B7DA

	DEC Vs_PlayerBlkHitCnt,X	 ; Vs_PlayerBlkHitCnt--

	JSR Vs_BumpBlockApplyYVel	 ; Apply bump block's Y velocity

	; Vs_PlayerBlkHitYVel += 5
	LDA Vs_PlayerBlkHitYVel,X
	ADD #$05
	STA Vs_PlayerBlkHitYVel,X

PRG009_B7DA:
	LDY Vs_ObjectSprRAMOff	 ; Y = bump block's Sprite RAM offset

	; Set bump block sprite Xs
	LDA Vs_PlayerBlkHitX,X
	STA Sprite_RAM+$03,Y
	ADD #$08
	STA Sprite_RAM+$07,Y

	; Set bump block sprite Ys
	LDA Vs_PlayerBlkHitY,X
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Set bump block sprite attributes
	LDA #SPR_PAL2
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	; Set bump block sprite patterns
	LDA #$81
	STA Sprite_RAM+$01,Y
	LDA #$83
	STA Sprite_RAM+$05,Y

	RTS		 ; Return


	; Restores the bounce block that was hit (offset in Vs_PlayerBlkHit)
Vs_RestoreBlockHitTile:

	; Patterns to restore hit bounce block
	LDA #$02
	STA <Temp_Var13
	LDA #$03
	STA <Temp_Var14
	LDA #$12
	STA <Temp_Var15
	LDA #$13
	STA <Temp_Var16


	JMP PRG009_B822	 ; Jump to PRG009_B822

	; Erases the bounce block that was hit (offset in Vs_PlayerBlkHit)
Vs_EraseBlockHitTile:

	; Temp_Var13 to 16 = $FF (patterns to erase hit bounce block)
	LDA #$ff
	STA <Temp_Var13
	STA <Temp_Var14
	STA <Temp_Var15
	STA <Temp_Var16

PRG009_B822:	
	LDY Graphics_BufCnt	 ; Y = current graphics buffer counter

	; Temp_Var4 = 8
	LDA #$08
	STA <Temp_Var4

	LDA Vs_PlayerBlkHit,X
	PHA		 ; Save Tile_Mem offset to block that was hit

	; Temp_Var4/5 = VRAM High/Low addresses
	AND #$f0	; Just the "row" value
	ASL A		; Bit 7 -> carry
	ROL <Temp_Var4	; %0001000a
	ASL A		; Bit 7 (old 6) -> carry
	ROL <Temp_Var4	; %001000ab
	STA <Temp_Var5	; -> Temp_Var5

	PLA		 ; Restore Tile_Mem offset

	ASL A		; Shift left
	AND #%00011111	; Mask out column value, left shifted
	ADD <Temp_Var5	; Add Temp_Var5

	; Set VRAM low addresses
	STA Graphics_Buffer+$01,Y	; Upper row
	ADD #32				; +32 bytes to next to row
	STA Graphics_Buffer+$06,Y 	; Lower row

	; Set VRAM high addresses
	LDA <Temp_Var4
	STA Graphics_Buffer+$00,Y	; Upper row
	STA Graphics_Buffer+$05,Y	; Lower row

	; Run length 2
	LDA #2
	STA Graphics_Buffer+$02,Y	; Upper row
	STA Graphics_Buffer+$07,Y	; Lower row

	; Four patterns that make up the block
	LDA <Temp_Var13
	STA Graphics_Buffer+$03,Y
	LDA <Temp_Var14
	STA Graphics_Buffer+$04,Y
	LDA <Temp_Var15	
	STA Graphics_Buffer+$08,Y
	LDA <Temp_Var16	
	STA Graphics_Buffer+$09,Y

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$0A,Y

	; +10 to graphics buffer counter
	TYA
	ADD #$0A
	STA Graphics_BufCnt

	RTS		 ; Return


Vs_BumpBlockApplyYVel:
	TXA
	ADD #(Vs_PlayerBlkHitYVel - Vs_PlayerYVel)	; Offset to bump block Y Velocity
	BPL PRG009_B888

Vs_ObjectApplyXVel:
	TXA		 
	ADD #(Vs_ObjectXVel - Vs_ObjectYVel + 2)	; +2 so to get passed the Vs_PlayerXVel vars
	BPL PRG009_B888

Vs_ObjectApplyYVel:
	TXA
	ADD #$02	; +2 so to get passed the Vs_PlayerYVel vars

PRG009_B888:
	TAX		; Update X

	JSR Vs_ApplyYVel ; Apply X or Y velocity, as appropriate

	LDX Vs_CurIndex	 ; Restore 'X' as object index

	RTS		 ; Return

Vs_ApplyXVel:
	; Update X velocity instead of Y velocity
	TXA		 
	ADD #(Vs_PlayerXVel - Vs_PlayerYVel)
	TAX

	JSR Vs_ApplyYVel	 ; Really apply X velocity!

	LDX Vs_CurIndex ; Restore X as Vs_CurIndex
	RTS		 ; Return

Vs_ApplyYVel:
	LDA Vs_PlayerYVel,X	; Get Velocity
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 	; Fractional part shifted up
	ADD Vs_PlayerYVelFrac,X	 
	STA Vs_PlayerYVelFrac,X	; Add to Player/Object's vel fractional accumulator

	PHP		 ; Save CPU status

	LDY #$00	 ; Y = 0 (positive high part)


	LDA Vs_PlayerYVel,X	; Get Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PRG009_B8BB	 ; If the value was not negatively signed, jump to PRG009_B8BB
	ORA #%11110000	 ; Otherwise, apply a sign extension
	DEY		 ; Y = $FF (negative high part)
PRG009_B8BB:
	PLP		 ; Restore CPU state

	ADC Vs_PlayerY,X
	STA Vs_PlayerY,X	 ; Add with carry

	ROL A		 ; Essentially puts carry into 'A'

	CPX #(Vs_PlayerXVel - Vs_PlayerYVel)
	BGE PRG009_B8CF	 ; If this is the Player/Object X, then do not concern with the "high" part, jump to PRG009_B8CF (RTS)

	ROR A		 ; Put carry bit back in place

	TYA		 ; A = $00 or $FF as appropriate

	ADC Vs_PlayerYHi,X
	STA Vs_PlayerYHi,X	 ; Set Player/Object Y Hi

PRG009_B8CF:
	RTS		 ; Return

	; Updates random number pool for 2P Vs
Vs_Randomize:
	LDA Vs_Random	 
	ASL A
	ASL A
	SEC
	ADC Vs_Random
	STA Vs_Random

	ASL Vs_Random+1
	LDA #$20
	BIT Vs_Random+1
	BCC PRG009_B8EA
	BEQ PRG009_B8EF
	BNE PRG009_B8EC
PRG009_B8EA:
	BNE PRG009_B8EF
PRG009_B8EC:
	INC Vs_Random+1
PRG009_B8EF:
	LDA Vs_Random+1
	EOR Vs_Random
	STA Vs_Random+2

	RTS		 ; Return

PRG009_B8F9:
	.byte $80, $B7, $85, $00, $A5, $AB, $A4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; AutoScroll_Do
;
; Performs all "auto scroll" movements.  This is the
; most obvious effect of levels like 1-4, but more subtle
; as the effect in floating water levels levels like 3-8.
; Any time parts of the playfield are moving and you're
; not doing it, likely it's here...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
AutoScroll_Do:
	LDA Player_SuitLost	; If Player is NOT losing their power up ...
	ORA Player_Grow		; ... and Player is NOT growing from a mushroom ...
	ORA <Player_HaltGame	; ... and the gameplay is NOT halted ...
	BEQ PRG009_B917	 ; ... then jump to PRG009_B917

	; Gameplay is stopped for some reason

	LDA Level_AScrlLimitSel
	CMP #$13
	BLT PRG009_B916	 ; If Level_AScrlLimitSel < $13, jump to PRG009_B916 (RTS)

	; Otherwise, halt timer
	LDA #$80
	STA Level_TimerEn

PRG009_B916:
	RTS		 ; Return

PRG009_B917:

	; Ensure clock is not stopped (?)
	STA Level_TimerEn

	LDA Level_AScrlTimer
	BEQ PRG009_B922	 ; If Level_AScrlTimer = 0, jump to PRG009_B922

	DEC Level_AScrlTimer	 ; Level_AScrlTimer--

PRG009_B922:
	LDA Level_AScrlSelect
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word AutoScroll_Horizontal	; 0 Generally for non-stop horizontal levels, uses movement commands; most complex type
	.word AutoScroll_Horizontal	; 1 Same as type zero, except accesses $1x Level_AScrlVar
	.word AutoScroll_URDiagonal	; 2 Up-right diagonal used in 5-9
	.word AutoScroll_SpikeCeiling	; 3 Falling spiked ceilings (e.g. World 1 and 2 Mini Fortresses)
	.word AutoScroll_BooRoom	; 4 Used in the last World 6 Fortress, a room of Boos, scrolls up to meet a door
	.word AutoScroll_Floating	; 5 Sinking/rising over water world (e.g. in 3-8)

	; This table is what value (if any) will go into Level_AScrlLoopSel
	; when horizontal auto scroll reaches the end.  A value of $00
	; indicates that no movement loop is desired.  The common use of this
	; value is when you come to the end of an Airship/Battleship/Coin Ship
	; and the screen continues to bob.
AScroll_MoveEndLoopSelect:
	.byte $00	;  0 World 3-6 / 1-4
	.byte $04	;  1 World 3 Airship
	.byte $00	;  2 World 6-2
	.byte $04	;  3 World 5 Airship
	.byte $04	;  4 World 2 Airship
	.byte $04	;  5 World 4 Airship
	.byte $04	;  6 World 6 Airship
	.byte $00	;  7 World 5-6
	.byte $00	;  8
	.byte $00	;  9 
	.byte $00	;  A World 6-7
	.byte $04	;  B World 1 Airship
	.byte $04	;  C World 7 Airship
	.byte $04	;  D World 8 Airship
	.byte $03	;  E World 8 Battleship
	.byte $00	;  F World 7-4
	.byte $00	; 10 World 1 Coin Heaven
	.byte $04	; 11 Coin Ship
	.byte $00	; 12
	.byte $00	; 13 World 8 Tank 1
	.byte $00	; 14 World 8 Tank 2

	; Movement command selected by "Level_AScrlVar" 
	; Bits 0-1: (0 to 3) Acceleration selection (from AScroll_VelAccel) for vertical auto scroll velocity
	; Bits 2-3: (0 to 3) Acceleration selection (from AScroll_VelAccel) for horizontal auto scroll velocity
	; Bits 4-7: -> Level_AScrlLoopSel
AScroll_Movement:
ASM_World_36_14:	.byte $04, $10, $00
ASM_W3_Airship:		.byte $04, $00, $01, $00, $02, $00, $01, $00, $02, $00, $01, $00, $00, $02, $00, $01, $00
ASM_World_62:		.byte $70
ASM_W5_Airship:		.byte $04, $00, $01, $00, $02, $00, $01, $00, $01, $00, $02, $00, $01, $00, $02, $00, $01, $00
ASM_UNK4:		.byte $04, $00, $01, $00, $02, $00, $01, $00, $02, $00, $01, $00
ASM_W4Airship:		.byte $05, $04, $00, $02, $00, $01, $00, $02, $00, $01, $00, $02, $00, $01, $00, $02, $00, $01, $00, $02, $00, $01, $00, $00, $02, $00, $01
ASM_W6Airship:		.byte $04, $00, $01, $00, $02, $00, $01, $00, $02, $00, $0A, $02, $00, $05, $01, $00, $02, $00, $01
ASM_World_56:		.byte $04, $10
ASM_UNK8:		.byte $04, $00, $01, $00, $02, $00, $00, $02, $00, $01, $00, $01, $00, $02, $00
ASM_UNK9:		.byte $01, $00, $06, $00, $01, $00, $02, $00, $02, $00, $01, $00, $02, $00, $01, $00, $01, $00, $02, $00
ASM_World_67:		.byte $04, $00, $01, $00, $02, $00, $00, $02, $00, $01, $00
ASM_W1Airship:		.byte $04, $00, $00, $01, $00, $02, $00, $01, $00, $02, $00, $02, $00, $01, $00, $02, $00, $02, $00, $01, $00
ASM_W7Airship:		.byte $05, $00, $20, $00, $02, $30, $00, $30, $02, $00, $01, $00, $30, $00, $02, $00, $01, $00, $20, $02, $00, $01, $00, $02, $00, $01, $00, $30, $02, $00, $01, $00, $01
ASM_W8Airship:		.byte $04, $10, $00
ASM_W8Battleship:	.byte $06, $04, $00, $01, $00, $30
ASM_World_74:		.byte $04, $00, $00, $0A, $00, $04, $00, $01, $00, $02, $00, $01, $50, $01, $00, $08, $00, $06, $02, $00, $00
ASM_W1CoinHeaven:	.byte $60
ASM_CoinShip:		.byte $80
ASM_UNK12:		.byte $04, $00
ASM_World8Tank1:	.byte $04, $10, $00
ASM_World8Tank2:	.byte $04, $10
ASM_Terminator


	; How many times to repeat the above command
AScroll_MovementRepeat:
ASMR_World_36_14:	.byte $08, $03, $80
ASMR_W3_Airship:	.byte $08, $40, $08, $3C, $10, $1E, $08, $87, $08, $19, $08, $FF, $88, $08, $45, $08, $35
ASMR_World_62:		.byte $01
ASMR_W5_Airship:	.byte $08, $62, $06, $6E, $10, $62, $0A, $60, $06, $4C, $08, $6C, $06, $2C, $08, $31, $04, $93
ASMR_UNK4:		.byte $08, $FF, $08, $2E, $0E, $68, $10, $6A, $16, $56, $0C, $DF
ASMR_W4Airship:		.byte $01, $03, $60, $03, $80, $04, $80, $04, $80, $04, $80, $04, $80, $04, $80, $04, $80, $06, $32, $08, $32, $06, $77, $FF, $05, $FF, $03
ASMR_W6Airship:		.byte $08, $67, $01, $80, $03, $82, $0A, $87, $08, $9F, $08, $08, $63, $08, $0C, $40, $06, $78
ASMR_World_56:		.byte $02, $08
ASMR_UNK8:		.byte $03, $08, $EE, $10, $67, $10, $FF, $48, $10, $67, $10, $34, $10, $67, $10
ASMR_UNK9:		.byte $78, $08, $48, $08, $38, $10, $26, $10, $1C, $08, $36, $08, $90, $0A, $68, $0A, $BF, $0D, $60, $0D
ASMR_World_67:		.byte $56, $08, $7A, $11, $5F, $11, $FF, $94, $15, $45, $15
ASMR_W1Airship:		.byte $80, $08, $71, $47, $06, $20, $0E, $18, $0E, $23, $06, $31, $06, $25, $14, $27, $0E, $35, $0A, $2C, $0A
ASMR_W7Airship:		.byte $27, $08, $20, $02, $0E, $03, $01, $18, $02, $0C, $28, $0C, $20, $01, $2C, $0D, $10, $10, $20, $02, $10, $20, $12, $18, $17, $16, $12, $20, $03, $0C, $28, $06, $42
ASMR_W8Airship:		.byte $01, $0F, $02
ASMR_W8Battleship:	.byte $E6, $05, $03, $27, $0A, $27
ASMR_World_74:		.byte $0B, $08, $FF, $79, $08, $48, $08, $0E, $0C, $0E, $10, $0E, $04, $04, $18, $10, $08, $18, $08, $08, $FF
ASMR_W1CoinHeaven:	.byte $8A
ASMR_CoinShip:		.byte $01
ASMR_UNK12:		.byte $01, $08
ASMR_World8Tank1:	.byte $F9, $08, $05
ASMR_World8Tank2:	.byte $E8, $08
ASMR_Terminator:	.byte $04

	; Accelerates horizontal or vertical velocity
AScroll_VelAccel:	.byte $00, $01, -$01, -$01

	; "Movement Loops" are perpetual auto scroll movements e.g. for the Airship scroll termination
	; It just continually feeds movement commands on loop forever (see AScroll_MovementLoop and AScroll_MovementLoopTicks)

	; This points to the starting offset into AScroll_MovementLoop
	; Indexed by (Level_AScrlLoopSel - 2), next value up is terminating value
ASML	.func \1 - AScroll_MovementLoop
AScroll_MovementLoopStart:
	.byte ASML(ASML_0)		; 0 (Level_AScrlLoopSel = 2)
	.byte ASML(ASML_Battleship)	; 1 (Level_AScrlLoopSel = 3) Battleship uses as the "idle" at the end of its scrolling
	.byte ASML(ASML_Airship)	; 2 (Level_AScrlLoopSel = 4) Airship/Coin Ship uses this as the "idle" at the end of its scrolling
	.byte ASML(ASML_3)		; 3 (Level_AScrlLoopSel = 5)
	.byte ASML(ASML_4)		; 4 (Level_AScrlLoopSel = 6)
	.byte ASML(ASML_5)		; 5 (Level_AScrlLoopSel = 7)
	.byte ASML(ASML_6)		; 6 (Level_AScrlLoopSel = 8)
	.byte ASML(ASML_Terminator)	; Terminator

	.byte $00

	; Supplies a AScroll_Movement value, unless negative (but that never happens here apparently)
AScroll_MovementLoop:
ASML_0:		.byte $02, $00, $01, $00
ASML_Battleship:.byte $02, $00, $01, $00	; Battleship
ASML_Airship:	.byte $02, $00, $01, $00, $02	; Airship/Coin Ship
ASML_3:		.byte $01, $00, $02, $00
ASML_4:		.byte $04, $00, $00
ASML_5:		.byte $04, $00, $00, $02, $00, $01, $00, $01, $00, $02, $00
ASML_6:		.byte $05, $04, $00, $02, $00, $01, $00, $02, $00, $01, $00, $02, $00, $01
ASML_Terminator

	.byte $FF

	; Supplies a AScroll_MovementLoopTicks value (ticks to perform current looping command)
AScroll_MovementLoopTicks:
ASMLT_0:	.byte $10, $20, $10, $20
ASMLT_Battleship:.byte $0A, $26, $0A, $26
ASMLT_Airship:	.byte $04, $08, $08, $08, $04
ASMLT_3:	.byte $10, $0E, $10, $0E
ASMLT_4:	.byte $08, $FF, $68
ASMLT_5:	.byte $08, $F0, $F4, $10, $66, $10, $76, $10, $66, $10, $95
ASMLT_6:	.byte $02, $02, $90, $04, $78, $04, $78, $04, $78, $04, $78, $04, $78, $02
ASMLT_Terminator

	; Glowing coin palette colors
AScroll_CoinShipCoinGlowPal:
	.byte $27, $27, $27, $17, $07, $17

CoinShip_CoinGlow:
	DEC CoinShip_CoinGlowCnt
	BPL PRG009_BBB3	 ; If CoinShip_CoinGlowCnt >= 0, jump to PRG009_BBB3

	; Reload CoinShip_CoinGlowCnt = 5
	LDA #$05
	STA CoinShip_CoinGlowCnt

	INC CoinShip_CoinGlowIdx	 ; CoinShip_CoinGlowIdx++ (next palette color index)

	LDA CoinShip_CoinGlowIdx
	CMP #(CoinShip_CoinGlow - AScroll_CoinShipCoinGlowPal)
	BLT PRG009_BBAC	 ; If we haven't hit the end of the palette array yet, jump to PRG009_BBAC

	; CoinShip_CoinGlowIdx = 0
	LDA #$00
	STA CoinShip_CoinGlowIdx

PRG009_BBAC:
	TAY		 ; -> 'Y'

	; Get color index, pump into palette buffer
	LDA AScroll_CoinShipCoinGlowPal,Y
	STA Palette_Buffer+7

PRG009_BBB3:
	RTS		 ; Return


AutoScroll_Horizontal:
	LDX #$00	; X = 0 
	JSR AutoScroll_ApplyHVel	 ; Apply auto scroll horizontal velocity

	LDA Level_AScrlLimitSel
	CMP #$11
	BNE PRG009_BBC5	 ; If Level_AScrlLimitSel <> $11 (Coin Ship), jump to PRG009_BBC5

	PHA		 ; Save Level_AScrlLimitSel 

	JSR CoinShip_CoinGlow	 ; Do the glowing coin effect on the Coin Ship

	PLA		 ; Restore Level_AScrlLimitSel

PRG009_BBC5:
	CMP #$0e	 
	BNE PRG009_BBCC	 ; If Level_AScrlLimitSel <> $0E (World 8 Battleship), jump to PRG009_BBCC

	JSR Setup32PixPartWater	 ; World 8 Battleship needs its muddy water

PRG009_BBCC:
	JSR AScroll_MovePlayer	 ; Moves Player as necessary with auto scroll

	LDA Level_AScrlTimer
	LSR A		 
	BCS PRG009_BC0B	 ; Every other tick, jump to PRG009_BC0B (RTS)

	PHA		 ; Save timer / 2 value

	JSR AutoScroll_ApplyVVel	 ; Apply auto scroll vertical velocity

	PLA		 ; Restore timer / 2 value

	BNE PRG009_BC0B	 ; If timer > 1, jump to PRG009_BC0B

	LDA Level_AScrlMoveTicks
	BEQ PRG009_BBE4	 ; If Level_AScrlMoveTicks = 0, jump to PRG009_BBE4

	JMP PRG009_BC66	 ; Otherwise, jump to PRG009_BC66

PRG009_BBE4:
	LDA Level_AScrlMoveRepeat
	BNE PRG009_BC3A	 ; If move is to be repeated, jump to PRG009_BC3A

PRG009_BBE9:
	LDY Level_AScrlLimitSel	 ; Y = Level_AScrlLimitSel

	LDA Level_AScrlVar
	CMP AScroll_HorizontalInitMove+1,Y
	BNE PRG009_BC16	 ; If we're not yet at the last command index, jump to PRG009_BC16

	CPY #$13
	BLT PRG009_BBFB	 ; If Level_AScrlLimitSel < $13 (i.e. NOT a World 8 Tank level), jump to PRG009_BBFB

	; (Carry is set by the CPY)
	; Set bit 7 on Level_TimerEn, which disables level animations (specifically, the tank treads)
	ROR Level_TimerEn

PRG009_BBFB:

	; Halt the horizontal auto scroll velocity
	LDA #$00
	STA Level_AScrlHVel

	LDA AScroll_MoveEndLoopSelect,Y
	BNE PRG009_BC0C		; If there's a loop select value to load, jump to PRG009_BC0C

	; Otherwise, also halt vertical auto scroll velocity and clear the horizontal fractional accumulator (just in case)
	STA Level_AScrlVVel
	STA Level_AScrlHVelFrac

PRG009_BC0B:
	RTS		 ; Return

PRG009_BC0C:

	; Load the loop select value!
	STA Level_AScrlLoopSel

	; Level_AScrlMoveRepeat = $FF (do movement loop)
	LDA #$ff
	STA Level_AScrlMoveRepeat

	BNE PRG009_BC31	 ; Jump (technically always) to PRG009_BC60

PRG009_BC16:
	INC Level_AScrlVar	 ; Level_AScrlVar++

	LDY Level_AScrlVar	 ; Y = Level_AScrlVar

	LDA AScroll_Movement,Y	 ; Select next movement command

	LSR A
	LSR A
	LSR A
	LSR A		 ; Shift upper 4 bits to the right; sets Level_AScrlLoopSel (if not zero)
	BEQ PRG009_BC60	 ; If it is zero, jump to PRG009_BC60

	STA Level_AScrlLoopSel	 ; -> Level_AScrlLoopSel

	LDY Level_AScrlVar	 ; Y = Level_AScrlVar

	; Set repeat count
	LDA AScroll_MovementRepeat,Y
	STA Level_AScrlMoveRepeat

PRG009_BC31:
	LDY Level_AScrlLoopSel	 ; Y = Level_AScrlLoopSel (current looping movement index)

	; Set Level_AScrlLoopCurMove
	LDA AScroll_MovementLoopStart-2,Y
	STA Level_AScrlLoopCurMove

PRG009_BC3A:
	LDY Level_AScrlLoopSel	 ; Y = Level_AScrlLoopSel

	LDA Level_AScrlLoopCurMove	 
	CMP AScroll_MovementLoopStart-1,Y
	BNE PRG009_BC55	 ; If Level_AScrlLoopCurMove <> terminating index, jump to PRG009_BC55

	; End index for the looping movement

	; Restart at the beginning of the looping movement!
	LDA AScroll_MovementLoopStart-2,Y
	STA Level_AScrlLoopCurMove

	LDA Level_AScrlMoveRepeat
	BMI PRG009_BC55	 ; If bit 7 is set on Level_AScrlMoveRepeat, jump to PRG009_BC55

	DEC Level_AScrlMoveRepeat	 ; Level_AScrlMoveRepeat-- (one less repeat)
	BEQ PRG009_BBE9	 ; If Level_AScrlMoveRepeat = 0, jump to PRG009_BBE9

PRG009_BC55:
	INC Level_AScrlLoopCurMove	 ; Level_AScrlLoopCurMove++

	LDY Level_AScrlLoopCurMove	 ; Y = Level_AScrlLoopCurMove

	LDA AScroll_MovementLoopTicks-1,Y
	BNE PRG009_BC63	 ; If loop tick value is non-zero, jump to PRG009_BC63

PRG009_BC60:
	LDA AScroll_MovementRepeat,Y	 ; Get movement repeat value

PRG009_BC63:
	STA Level_AScrlMoveTicks	 ; Update ticks value

PRG009_BC66:
	DEC Level_AScrlMoveTicks	 ; Level_AScrlMoveTicks--

	LDA Level_AScrlMoveRepeat
	BEQ PRG009_BC76	 ; If Level_AScrlMoveRepeat = 0, jump to PRG009_BC76

	LDY Level_AScrlLoopCurMove	 ; Y = Level_AScrlLoopCurMove

	LDA AScroll_MovementLoop-1,Y
	BPL PRG009_BC7C	 ; If value not negative, jump to PRG009_BC7C

PRG009_BC76:
	LDY Level_AScrlVar ; Y = Level_AScrlVar

	LDA AScroll_Movement,Y

PRG009_BC7C:
	PHA		 ; Save AScroll_Movement[Y]

	LSR A		 
	LSR A		 ; Get bits 3,2 -> 1,0
	AND #$03
	TAY		 ; Y = 0 to 3

	; Accelerate horizontal auto scroll velocity
	LDA AScroll_VelAccel,Y
	ADD Level_AScrlHVel
	STA Level_AScrlHVel

	PLA		 ; Restore movement

	AND #$03	 
	TAY		 ; Y = 0 to 3

	; Accelerate vertical auto scroll velocity
	LDA AScroll_VelAccel,Y
	ADD Level_AScrlVVel
	STA Level_AScrlVVel

	; Level_AScrlTimer = 4
	LDA #$04
	STA Level_AScrlTimer

	RTS		 ; Return


	; Player movements based on auto scroll
AScroll_MovePlayer:
	; Enable auto scroll effects (vertical and horizontal)
	LDA #ASCONFIG_ENABLE
	STA Level_AScrlConfig

	LDY <Player_InAir
	BNE PRG009_BCC0	 ; If Player is mid air, jump to PRG009_BCC0

	LDA Level_AScrlLimitSel
	CMP #$13
	BLT PRG009_BCBC	 ; If Level_AScrlLimitSel < $13 (Not a World 8 Tank), jump to PRG009_BCBC

	; World 8 tanks only...

	LDA <Player_YHi
	CMP #$01
	BNE PRG009_BCBC	 ; If Player is not low, jump to PRG009_BCBC

	LDA <Player_Y
	CMP #112
	BGE PRG009_BCBD	 ; If Player Y >= 112, jump to PRG009_BCBD

PRG009_BCBC:
	INY		 ; Y = 1 (World 8 Tank with low Player Y < 112)

PRG009_BCBD:
	STY World8Tank_OnTank	 ; Player is standing on the tank (as opposed to the ground)

PRG009_BCC0:
	LDA <Player_SpriteX
	CMP #16
	BLT PRG009_BCCA	 ; If Player is pressed against the left, jump to PRG009_BCCA

	CMP #224
	BLT PRG009_BCE0	 ; If Player is not pressed against the right, jump to PRG009_BCE0

PRG009_BCCA:

	; Player is pressing against either horizontal edge

	LDA Level_AScrlHVel	; Get the horizontal scroll velocity
	CLC		
	SBC <Player_XVel	; Difference against Player's X velocity
	EOR <Player_SpriteX	; Check sign of difference against Player's Sprite X
	BMI PRG009_BCF1	 	; Basically determines if Player should be pushed by the scroll; if not, jump to PRG009_BCF1

	; Set Player's X velocity same as auto scroll horizontal velocity
	LDA Level_AScrlHVel
	STA <Player_XVel

	; Player_XVelFrac = 0
	LDA #$00
	STA Player_XVelFrac

	BEQ PRG009_BCF1	 ; Jump (technically always) to PRG009_BCF1

PRG009_BCE0:

	; Player is not against the left or right edge of the screen...

	LDA World8Tank_OnTank
	BNE PRG009_BCF1	 ; If World8Tank_OnTank is not set, jump to PRG009_BCF1

	; World8Tank_OnTank is set....

	; Move Player along as scroll occurs; simulates that the tank is rolling at the Player
	LDA <Player_X
	ADD Level_AScrlHVelCarry
	STA <Player_X

	BCC PRG009_BCF1	 ; If no carry, jump to PRG009_BCF1

	INC <Player_XHi	 ; Apply carry

PRG009_BCF1:

	; Set Level_AScrlSclLastDir based on sign of Level_AScrlHVel
	LDA Level_AScrlHVel
	ASL A		; Bit 7 -> carry
	ROL A		; Carry -> Bit 0
	AND #$01	; Masks 0/1
	STA Level_AScrlSclLastDir	; -> Level_AScrlSclLastDir

	LDA <Player_XVel
	BEQ PRG009_BD1D	 ; If Player is not moving horizontally, jump to PRG009_BD1D (RTS)

	EOR Level_AScrlHVel
	BMI PRG009_BD1D	 ; If Player's X velocity is the moving the opposite way than auto scroll, jump to PRG009_BD1D (RTS)

	LDY #$00	 ; Y = $00 (16-bit sign extension)

	LDA Level_AScrlHVelCarry
	BEQ PRG009_BD1D	 ; If auto scroll has not carried, jump to PRG009_BD1D (RTS)
	BPL PRG009_BD0E	 ; If positive, jump to PRG009_BD0E

	DEY		 ; Y = $FF (16-bit sign extension)

PRG009_BD0E:

	; Apply carry to Player's X
	ADD <Player_X
	STA <Player_X
	TYA	
	ADC <Player_XHi
	STA <Player_XHi

	; Player_XVelFrac = 0
	LDA #$00
	STA Player_XVelFrac

PRG009_BD1D:
	RTS		 ; Return

	; In levels that "float" on water, this determines the lowest
	; point of the water along the bottom for small/ducking or big
Float_WaterBottomLimitY:	.byte 140, 144

AutoScroll_BooRoom:
	LDA Level_AScrlLoopSel
	BNE PRG009_BD37	 ; If Level_AScrlLoopSel <> 0, jump to PRG009_BD37

	LDA <Vert_Scroll
	CMP #$ef
	BNE PRG009_BD1D	 ; If vertical scroll <> $EF (bottom), jump to PRG009_BD1D (RTS)

	; Auto scroll and vertical scroll set together
	LDA <Vert_Scroll
	STA Level_AScrlPosV

	INC Level_AScrlLoopSel	 ; Level_AScrlLoopSel++

	LDA #$20
	BNE PRG009_BD54	 ; Jump (technically always) to PRG009_BD54

PRG009_BD37:
	LDA Level_AScrlTimer
	BEQ PRG009_BD3F	 ; If timer expired, jump to PRG009_BD3F
	JMP PRG009_BDC1	 ; Jump to PRG009_BDC1

PRG009_BD3F:
	LDA Level_AScrlPosV
	CMP #$0d
	BEQ PRG009_BD6A	 ; If vertical scroll position = $0D, jump to PRG009_BD6A

	CMP #$0f
	BNE PRG009_BD57	 ; If vertical scroll position <> $0F, jump to PRG009_BD57

	; Play Ba-boom sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA #$20	 ; A = $20

PRG009_BD54:
	STA Level_AScrlTimer	 ; Set the scroll timer

PRG009_BD57:
	JSR AutoScroll_ApplyVVel	 ; Apply auto scroll vertical velocity

	LDA <Counter_1
	AND #$07
	BNE PRG009_BD6A	 ; 1:8 ticks proceed, otherwise jump to PRG009_BD6A

	LDA Level_AScrlVVel
	CMP #-$08
	BEQ PRG009_BD6A	 ; If vertical scroll velocity = -$08, jump to PRG009_BD6A

	DEC Level_AScrlVVel	 ; Otherwise, accelerate upwards...

PRG009_BD6A:
	JMP PRG009_BDC9	 ; Jump to PRG009_BDC9


ASFloat_VelAccel:	.byte -$01, $01

AScroll_SpikeCeilVVelLimit:	.byte -$08, $08

AScroll_SpikeCeilVLimits:
	.byte $7C, $EF	; Spike Ceiling 0 Upper/Lower limit
	.byte $CF, $EF	; Spike Ceiling 1 Upper/Lower limit


AutoScroll_SpikeCeiling:
	LDA Level_AScrlTimer
	BNE PRG009_BDC1	 ; If timer not expired, jump to PRG009_BDC1

	JSR AutoScroll_ApplyVVel	 ; Apply auto scroll vertical velocity

	LDA <Counter_1
	AND #$07
	BNE PRG009_BD95	 ; 1:8 ticks proceed, otherwise jump to PRG009_BD95

	LDY Level_AScrlVar	 ; Y = Level_AScrlVar (0/1, direction of movement in spiked ceiling)

	LDA Level_AScrlVVel
	CMP AScroll_SpikeCeilVVelLimit,Y
	BEQ PRG009_BD95	 ; If auto scroll vertical velocity is at its limit, jump to PRG009_BD95

	; Accelerate spiked ceiling!
	ADD ASFloat_VelAccel,Y
	STA Level_AScrlVVel

PRG009_BD95:
	LDA Level_AScrlLimitSel
	ASL A		 	; Level_AScrlLimitSel * 2
	ORA Level_AScrlVar	; OR'd with Level_AScrlVar (0/1)
	TAY		 	; -> 'Y'

	LDA Level_AScrlPosV
	CMP AScroll_SpikeCeilVLimits,Y
	BNE PRG009_BDC9	 ; If Spiked ceiling is not at its upper/lower limit, jump to PRG009_BDC9

	; Halt ceiling!
	LDA #$00
	STA Level_AScrlVVel

	; Change direction!
	LDA Level_AScrlVar
	EOR #$01
	STA Level_AScrlVar

	BEQ PRG009_BDBC	 ; If spikes just went to the top, jump to PRG009_BDBC (no sound)

	; Spike limit hit sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

PRG009_BDBC:
	; Reset timer
	LDA #$20
	STA Level_AScrlTimer

PRG009_BDC1:

	; Spike ceiling at its high/low limit; "shake"

	; Invert bit 0 on Level_AScrlPosV, giving a +/-1 pixel shake
	AND #$01
	EOR Level_AScrlPosV
	STA Level_AScrlPosV

PRG009_BDC9:

	; Set Player_PartDetEn (detect bottom 2 rows of tiles when Player Y >= 160)
	LDA #$01
	STA Player_PartDetEn

	; Enable display of 32 pixel partition and show sprites beneath the partition
	LDA #(UPDATERASTER_32PIXPART | UPDATERASTER_32PIXSHOWSPR)


PRG009_BDD0:
	STA Update_Request	; Set Update_Request

	LDA #6	 ; A = 6

	LDY <Player_Suit
	BNE PRG009_BDDB	 ; If Player is not small, jump to PRG009_BDDB

	LDA #18	 ; A = 18

PRG009_BDDB:
	ADC <Player_Y	; Offset to Player's feet
	AND #$f0	; Align to tile grid
	STA <Temp_Var9  ; -> Temp_Var9

	LDA <Player_YHi
	ADC #$00	; Apply carry
	AND #$01	; 0/1 only valid values in non-vertical level
	STA <Temp_Var3	; -> Temp_Var3

	; Temp_Var10 = Player X + 8
	LDA <Player_X
	ADD #$08
	STA <Temp_Var10

	LDA <Player_XHi
	ADC #$00	 ; Apply carry
	ASL A		 ; Multiply by 2 for Tile_Mem_Addr index
	TAY		 ; -> 'Y'

	; Set Temp_Var1/2 to point to tile
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1
	LDA Tile_Mem_Addr+1,Y
	ADD <Temp_Var3	
	STA <Temp_Var2	

	; Compute row/column offset
	LDA <Temp_Var10
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var9
	TAY	; -> 'Y'

	LDA [Temp_Var1],Y	; Get tile
	STA <Temp_Var1		; -> Temp_Var1

	LDY Level_TilesetIdx		; Y = level tileset index
	LDA MuncherJelectroSet,Y	; Get Muncher/Jelectro tile
	CMP <Temp_Var1
	BEQ PRG009_BE28	 	; If this is the Muncher/Jelectro, jump to PRG009_BE28

	LDA SpikesEnable,Y
	CMP #$ff
	BEQ PRG009_BE2B	 	; If there's no spikes here, jump to PRG009_BE2B

	SUB <Temp_Var1
	CMP #$02
	BGE PRG009_BE2B	 	; If this is not the spike tile, jump to PRG009_BE2B

PRG009_BE28:
	JSR Player_GetHurt	; Player touched hurtful tile!

PRG009_BE2B: 

	; Auto scroll effects enabled, but no horizontal auto scroll
	LDA #(ASCONFIG_ENABLE | ASCONFIG_HDISABLE)
	STA Level_AScrlConfig

	RTS		 ; Return

ASFloat_VVelLimit:	.byte -$04, $04


	; Based on value in Level_AScrlLimitSel (Level_AScrlVar = 0 for left value, 1 for right)
ASFloat_VertLimit:
	.byte $C4, $EA	; 0 -- Until 4, sprites will NOT be shown beneath the 32 pixel partition
	.byte $94, $EA	; 1
	.byte $C4, $EA	; 2
	.byte $D4, $EA	; 3
	.byte $90, $EA	; 4 -- NOTE, starting here, sprites WILL be shown beneath the 32 pixel partition
	.byte $B4, $EA	; 5
	.byte $CF, $EA	; 6

AutoScroll_Floating:
	JSR AutoScroll_ApplyVVel	 ; Apply auto scroll vertical velocity

	LDA <Counter_1
	AND #$07
	BNE PRG009_BE5C	 ; 1:8 ticks proceed, otherwise jump to  PRG009_BE5C

	LDY Level_AScrlVar	 ; Y = Level_AScrlVar

	LDA Level_AScrlVVel
	CMP ASFloat_VVelLimit,Y
	BEQ PRG009_BE5C	 ; If auto scroll vertical velocity is at its limit, jump to PRG009_BE5C

	ADD ASFloat_VelAccel,Y	 ; Add to vertical velocity
	STA Level_AScrlVVel	 ; Update vertical velocity

PRG009_BE5C:
	LDA Level_AScrlLimitSel
	ASL A		 	; A = Level_AScrlLimitSel * 2
	ORA Level_AScrlVar	; OR the direction flag
	TAY		 	; -> 'Y'

	LDA Level_AScrlPosV
	CMP ASFloat_VertLimit,Y
	BNE PRG009_BE74	 ; If vertical position is not at vertical limit, jump to PRG009_BE74

	; Reverse direction
	LDA Level_AScrlVar
	EOR #$01
	STA Level_AScrlVar

PRG009_BE74:
	LDA Level_AScrlLimitSel
	CMP #$04
	BLT Setup32PixPartWater	 ; If the limit select < 4, jump to Setup32PixPartWater

	JMP PRG009_BDC9	 ; Otherwise, jump to PRG009_BDC9

Setup32PixPartWater:
	LDA #UPDATERASTER_32PIXPART	; For Update_Select; use the "32 pixel partition" style (water along the bottom)
	JSR PRG009_BDD0	  

	LDA Player_AboveTop
	BNE PRG009_BEA0	 ; If Player is above the top of screen, jump to PRG009_BEA0 (RTS)

	TAY		 ; Y = 0

	LDA Player_IsDucking
	BNE PRG009_BE93	 ; If Player is ducking, jump to PRG009_BE93

	LDA <Player_Suit
	BEQ PRG009_BE93	 ; If Player is small, jump to PRG009_BE93

	INY		 ; Y = 1

PRG009_BE93:
	LDA <Player_SpriteY
	CMP Float_WaterBottomLimitY,Y	; Sets carry if greater-equal
	TAY			; Y = Player_SpriteY
	ROR A			; Will rotate carry bit into bit 7
	CPY #128		; Carry set if Player_SpriteY >= 128
	ROR A			; Will rotate carry bit into bit 7

	; FloatLevel_PlayerWaterStat:
	;	Bit 6: Set if Player_SpriteY >= Float_WaterBottomLimitY[Y] (player is beneath bottom of water)
	;	Bit 7: Set if Player_SpriteY >= 128 (i.e. Player is beneath top of water)
	STA FloatLevel_PlayerWaterStat

PRG009_BEA0:
	RTS		 ; Return

AutoScroll_URDiagonalLimits:
	.byte $70, $D0, $60, $C0, $90, $30, $F0, $00

AutoScroll_URDiagonal:
	INC Level_AScrlVVelCarry

	LDA #$00
	STA Level_AScrlHVel
	STA Level_AScrlHVelCarry

	LDA Level_AScrlLoopSel
	CMP #$05
	BGE PRG009_BF18	 ; If Level_AScrlLoopSel >= 5, jump to PRG009_BF18

	; Scroll diagonally
	LDA #$08
	STA Level_AScrlHVel
	LDA #-$08
	STA Level_AScrlVVel

	LDA Level_AScrlVVelCarry
	LSR A
	BCC PRG009_BECE	 ; If vertical velocity didn't carry, jump to PRG009_BECE

	INC Level_AScrlHVelCarry	 ; Carry horizontal velocity with it

PRG009_BECE:
	LDA AScrlURDiag_WrapState
	BNE PRG009_BEEC	 ; If AScrlURDiag_WrapState <> 0, jump to PRG009_BEEC
	BCC PRG009_BF1D	 ; If no horizontal/vertical carry occurred, jump to PRG009_BF1D

	; Horizontal carry occurred...

	INC Level_AScrlPosH	; Level_AScrlPosH++ (horizontal move +1)
	BNE PRG009_BEDD	 	; As long as no overflow occurred, jump to PRG009_BEDD

	INC Level_AScrlPosHHi	 ; Otherwise, apply carry

PRG009_BEDD:
	LDA Level_AScrlPosV
	BNE PRG009_BEE7	 ; If Level_AScrlPosV <> 0, jump to PRG009_BEE7

	; Level_AScrlPosV = 0 (we're at the top...)

	INC Level_AScrlLoopSel	; Level_AScrlLoopSel++
	BNE PRG009_BF10	 ; If Level_AScrlLoopSel <> 0, jump to PRG009_BF10

PRG009_BEE7:
	DEC Level_AScrlPosV	; Level_AScrlPosV--

	BCS PRG009_BF1D	 	; Jump (technically always) to PRG009_BF1D

PRG009_BEEC:

	; AScrlURDiag_WrapState <> 0...

	LSR A
	LSR A	; AScrlURDiag_WrapState bit 1 --> carry

	LDA Level_AScrlLoopSel
	ROL A
	TAY		 ; Y = (Level_AScrlLoopSel << 1) | carry
 
	; Level_AScrlPosH += 4
	LDA Level_AScrlPosH
	ADD #$04
	STA Level_AScrlPosH

	BCC PRG009_BF01	 ; If no carry, jump to PRG009_BF01

	INC Level_AScrlPosHHi	 ; Otherwise, apply carry

PRG009_BF01: 
	AND #$f0	 ; Align horizontal auto scroll coordinate to grid

	CMP AutoScroll_URDiagonalLimits-2,Y
	BNE PRG009_BF1D	 ; If limit not hit, jump to PRG009_BF1D

	; Lock horizontal scroll to limit
	STA Level_AScrlPosH

	; Set scroll to bottom
	LDA #$ef
	STA Level_AScrlPosV

PRG009_BF10:
	LDY AScrlURDiag_WrapState	 ; Y = AScrlURDiag_WrapState
	INY		 ; Y++
	CPY #$04	 
	BLT PRG009_BF1A	 ; If Y < 4, jump to PRG009_BF1A

PRG009_BF18:
	LDY #$00	 ; Y = 0

PRG009_BF1A:
	STY AScrlURDiag_WrapState	 ; Update AScrlURDiag_WrapState 

PRG009_BF1D:
	JMP AScroll_MovePlayer	 ; Move Player with the scroll and don't come back!


AutoScroll_ApplyVVel:
	LDX #$01	; X = 1	; Vertical instead of horizontal

AutoScroll_ApplyHVel:
	LDA Level_AScrlHVel,X	; Get auto scroll velocity
	ASL A
	ASL A
	ASL A
	ASL A		 	; Fractional part shifted up
	ADD Level_AScrlHVelFrac,X
	STA Level_AScrlHVelFrac,X	; Add to auto scroll's velocity fractional accumulator

	PHP		 ; Save CPU state
	PHP		 ; Save CPU state

	LDY #$00	 ; Y = 0 (positive high part)

	LDA Level_AScrlHVel,X	; Get auto scroll Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PRG009_BF42	 ; If the value was not negatively signed, jump to PRG009_BF42
	ORA #%11110000	 ; Otherwise, apply a sign extension
	DEY		 ; Y = $FF (negative high part)
PRG009_BF42:
	PLP		 ; Restore CPU state


	PHA		 ; Save integer of velocity

	ADC Level_AScrlPosH,X 
	STA Level_AScrlPosH,X ; Add with carry

	TYA		 ; A = $00 or $FF as appropriate

	ADC Level_AScrlPosHHi,X
	STA Level_AScrlPosHHi,X ; Add to the high part

	PLA		 ; Restore integer of X Velocity

	PLP		 ; Restore CPU state

	ADC #$00
	STA Level_AScrlHVelCarry	 ; Set to '1' if fractional part rolled over

	RTS		 ; Return

; Rest of ROM bank was empty

