; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-12 22:48:24.881635889 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

; FIXME: Appears to be unused Video_Upd_Table format data??
	.byte $20, $E6, $05, $F1, $FC, $9D, $9C, $9E, $21, $26, $05, $F2, $FC, $9D, $9C, $9E ; $0000 - $000F
	.byte $21, $66, $05, $F3, $FC, $9D, $9C, $9E, $21, $A6, $05, $F4, $FC, $9D, $9C, $9E ; $0010 - $001F
	.byte $21, $E6, $05, $F5, $FC, $9D, $9C, $9E, $22, $26, $05, $F6, $FC, $9D, $9C, $9E ; $0020 - $002F
	.byte $22, $66, $05, $F7, $FC, $9D, $9C, $9E, $22, $A6, $05, $F8, $FC, $9D, $9C, $9E ; $0030 - $003F
	.byte $21, $14, $02, $F0, $F3, $22, $14, $03, $F1, $FC, $F2, $3F, $00, $20, $0F, $0F ; $0040 - $004F
	.byte $30, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $16 ; $0050 - $005F
	.byte $30, $0F, $0F, $0F, $30, $0F, $0F, $0F, $30, $0F, $0F, $0F, $30, $0F, $00, $00 ; $0060 - $006F


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DoInventory_And_PoofFX
;
; This is a super major function which entirely handles the
; inventory flip and usage on the map (opening, closing,
; using items, cycling items, etc.) and also manages the 
; "poof" effect that occurs when a power-up is used or a
; special item takes effect (e.g. hammer breaking lock)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_DoInventory_And_PoofFX:
	LDA Map_Powerup_Poof
	BEQ PRG026_A078	 ; If Map_Powerup_Poof = 0 (no powerup being applied), jump to PRG026_A078
	JSR Map_Poof_Update	 ; If "poof" is active, update it!

PRG026_A078:
	LDA Inventory_Open
	BEQ PRG026_A082	 	; If Inventory_Open = 0, jump to PRG026_A082

	; If Inventory_Open >= 1, set "2" into Player_HaltTick (???)
	; This actually isn't used on the map... perhaps there was
	; to be in-level inventory usage once?
	LDA #$02	 
	STA Player_HaltTick	 ; Player_HaltTick = 2

PRG026_A082:
	LDA InvFlip_Counter	; Call a subroutine based on the value in InvFlip_Counter
	JSR DynJump	 	; Dynamic jump based on LUT below...

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	; Jump destinations based on InvFlip_Counter:
	.word Inventory_DoHilites	; 0: When inventory panel is open, highlight items
	.word Inventory_Close		; 1: Updates video to close panel down during flip
	.word Inventory_DoFlipPalChange	; 2: Change colors
	.word Inventory_DoFlipVideoUpd	; 3: Performs video updates as panel flips open or closed (includes displaying inventory items!)
	.word Inventory_DoPowerupUse	; 4: Does the "poof" effect from using a power-up item (and closing the Inventory)

Inventory_DoHilites:
	LDA #$2b	 
	STA InvFlip_VAddrHi	; VRAM Hi-byte is $2B

	LDA #$00	 
	STA InvHilite_Item 	; Hilite on first column

	LDX Level_Tileset	; X = Level_Tileset
	CPX #$07	 
	BEQ PRG026_A0A6	 	; If Level_Tileset = $07 (Toad House), jump to PRG026_A0A6

	STA InvStart_Item	; If not Toad House, Start on first row, first item

PRG026_A0A6:
	LDA #$48	 
	STA InvHilite_X	 	; First item hilited

	LDX #$00	 
	STX InvFlip_Frame	; InvFlip_Frame = 0

	INC InvFlip_Counter	; InvFlip_Counter = 1
	LDA Inventory_Open	 
	BEQ PRG026_A0CA	 	; If Inventory_Open = 0 (it's not), jump to PRG026_A0CA (RTS)

	; Inventory is open...
	LDA InvStart_Item	; A = InvStart_Item
	LDX Player_Current	; X = Player_Current
	BEQ PRG026_A0C3	 	; If Player_Current = 0 (Mario), jump to PRG026_A0C3

	ADD #(Inventory_Items2 - Inventory_Items)	 ; Offset for Luigi's items

PRG026_A0C3:
	TAX		 	; X = A (InvStart_Item + offset)
	LDA Inventory_Items,X	; Get this item -> A
	JMP InvItem_SetColor 	; Jump to InvItem_SetColor

PRG026_A0CA:
	RTS		 ; Return

InvFlip_VAddrLo_LUT:
	.byte $00, $60, $20, $40

Inventory_Close:
	LDX Graphics_BufCnt		; X = current position in graphics buffer
	LDA InvFlip_VAddrHi		; A = VRAM High Address
	STA Graphics_Buffer,X		; Store into the buffer
	LDY InvFlip_Frame	 	; Y = InvFlip_Frame
	LDA InvFlip_VAddrLo_LUT,Y	; Get appropriate low byte for video address
	STA Graphics_Buffer+1,X	 	; Store into the buffer

	; This is data in the style of the Video_Upd_Table; see "Video_Upd_Table" in PRG030 for format.
	LDA #VU_REPEAT | 32 	
	STA Graphics_Buffer+2,X		; Repeat 32 times
	LDA #$fc	 	
	STA Graphics_Buffer+3,X		; Tile $FC
	LDA #$00	 	
	STA Graphics_Buffer+4,X		; Terminator

	LDA Graphics_BufCnt
	ADD #$04	 
	STA Graphics_BufCnt	; Graphics_BufCnt += 4

	INY			; Y++
	TYA			; A = Y
	AND #$03		; A is 0 to 3 
	STA InvFlip_Frame	; Next indexed low byte
	BNE PRG026_A10F	 	; If A <> 0, jump to PRG026_A10F
	LDX Inventory_Open	; X = Inventory_Open
	BEQ PRG026_A109	 	; If Inventory_Open = 0, jump to PRG026_A109
	LDA #$08	 	; Otherwise, A = 8 (?)

PRG026_A109:
	STA InvFlip_Frame	; Update the lo index
	INC InvFlip_Counter	; InvFlip_Counter = 2

PRG026_A10F:
	RTS		 ; Return

	; Palette changes for opening the Inventory
	; This is data in the style of the Video_Upd_Table; see "Video_Upd_Table" in PRG030 for format.
Inv_OpenPal_Changes:
	vaddr $3F00			; Palette
	.byte $04, $0F, $0F, $30, $3C	; Palette set
	.byte $00			; Terminator

Inventory_DoFlipPalChange:
	LDX Graphics_BufCnt	; X = Graphics_BufCnt
	LDY #$00	 	; Y = 0

	; Copy in the palette changes
PRG026_A11D:
	LDA Inv_OpenPal_Changes,Y	; Get next byte
	STA Graphics_Buffer,X	; Store into the buffer
	INX		 	; X++
	INY		 	; Y++
	CPY #$08	 
	BNE PRG026_A11D	 	; While Y < 8, loop!

	LDY #$3c	 	; Y = $3C (Closed cyan color)
	LDX Graphics_BufCnt	; X = Graphics_BufCnt
	LDA Inventory_Open	; A = Inventory_Open
	BEQ PRG026_A135	 	; If Inventory_Open = 0, jump to PRG026_A135

	; Inventory_Open...
	LDY #$36	 	; Y = $36 (Inventory_Open salmon color)

PRG026_A135:
	TYA		 	; A = Y
	STA Graphics_Buffer+6,X	; Store the color into the graphics buffer
	STA Palette_Buffer+3 	; And also the CURRENT palette buffer
	STA Pal_Data+3	 	; And also the MASTER palette buffer

	LDA Graphics_BufCnt
	ADD #$07		
	STA Graphics_BufCnt	; Pal_Data += 7

	INC InvFlip_Counter	; InvFlip_Counter = 3
	RTS		 	; Return...

; This is data in the style of the Video_Upd_Table; see "Video_Upd_Table" in PRG030 for format.
Flip_Video_Data_Opening:	; Inventory_Open = 1

Flip_TopBarInv:	
	vaddr $2B00
	.byte $02, $FC, $A0

	vaddr $2B02
	.byte VU_REPEAT | $1C, $A1

	vaddr $2B1E
	.byte $02, $A2, $FC

	.byte $00


	; If editing this, check out note under PRG026_A2E4, "MAGIC 12 OFFSET"
Flip_MidTItems:	
	vaddr $2B20

	;                 |    W    O   R   LD   [x]
	.byte  32, $FC, $A6, $70, $71, $72, $73, $FE, $FE, $FE

	; Top of items start rendering here (replaced at runtime)
	;      Item 1         Item 2         Item 3         Item 4         Item 5         Item 6         Item 7
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;       |
	.byte $A7, $FC

	.byte $00

	; If editing this, check out note under PRG026_A2E4, "MAGIC 12 OFFSET"
Flip_MidBItems:	
	vaddr $2B40

	;                 |    < M >     x  [ Lives]
	.byte  32, $FC, $A6, $74, $75, $FB, $FE, $F3, $FE, $FE

	; Bottom of items start rendering here (replaced at runtime)
	;      Item 1         Item 2         Item 3         Item 4         Item 5         Item 6         Item 7
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;       |
	.byte $A7, $FC

	.byte $00

Flip_BottomBarInv:	
	vaddr $2B60
	.byte   2, $FC, $A8
	
	vaddr $2B62
	.byte VU_REPEAT | 28, $A4

	vaddr $2B7E
	.byte 2, $A5, $FC

	.byte $00

; ******************************************************************


; This is data in the style of the Video_Upd_Table; see "Video_Upd_Table" in PRG030 for format.
Flip_Video_Data_Closing:	; Inventory_Open = 0

Flip_TopBarMid:
	vaddr $2B20
	.byte 2, $FC, $A0

	vaddr $2B22
	.byte VU_REPEAT | 28, $A1

	vaddr $2B3E
	.byte 2, $A2, $FC

	.byte $00

Flip_BotBarMid:
	; Lower left corner
	vaddr $2B40
	.byte 2, $FC, $A8

	; Bottom bar
	vaddr $2B42
	.byte VU_REPEAT | 28, $A4

	; Upper right corner
	vaddr $2B5E
	.byte 2, $A5, $FC

	.byte $00

Flip_EraseTopBarMid:	
	vaddr $2B20
	.byte VU_REPEAT | 32, $FC

	.byte $00

Flip_EraseBotBarMid:	
	vaddr $2B40
	.byte VU_REPEAT | 32, $FC
	
	.byte $00

	; Sync with PRG030 "StatusBar" macro
Flip_TopBarCards:
	vaddr $2B00
	.byte 2, $FC, $A0

	vaddr $2B02
	.byte VU_REPEAT | 18, $A1	; Bar across the top

	vaddr $2B14
	.byte 12, $A2, $A0, $A1, $A1, $A3, $A1, $A1, $A3, $A1, $A1, $A2, $FC	; top of card slots

	.byte $00

	; Sync with PRG030 "StatusBar" macro
	; If editing this, check out note under PRG026_A2E4, "MAGIC 12 OFFSET"
Flip_MidTStatCards:	
	vaddr $2B20

	.byte $20, $FC, $A6, $70, $71, $72, $73, $FE, $FE, $EF, $EF, $EF, $EF, $EF, $EF, $3C	; |WORLD  >>>>>>[P] $  | |  | |  | |  | |
	.byte $3D, $FE, $EC, $FE, $F0, $A7, $A6, $FE, $FE, $AA, $FE, $FE, $AA, $FE, $FE, $A7, $FC
	; Discrepency --------^  (Pattern is ... $F0, $F0 ... in PRG030 status bar graphics)

	.byte $00

	; Sync with PRG030 "StatusBar" macro
	; If editing this, check out note under PRG026_A2E4, "MAGIC 12 OFFSET"
Flip_MidBStatCards:	
	vaddr $2B40

	; Discrepency --------v  (Pattern is ... $FE, $FE ... in PRG030 status bar)  Unimportant; inserts <M> which is replaced anyway
	.byte  32, $FC, $A6, $74, $75, $FB, $FE, $F3, $FE, $F0, $F0, $F0, $F0, $F0, $F0	; [M/L]x  000000 c000| etc.
	.byte $F0, $FE, $ED, $F0, $F0, $F0, $A7, $A6, $FE, $FE, $AA, $FE, $FE, $AA, $FE
	.byte $FE, $A7, $FC
	; Discrepency --------^  (Pattern is ... $F4, $F0 ... in PRG030 status bar graphics)

	.byte $00

	; Sync with PRG030 "StatusBar" macro
Flip_BottomBarCards:	
	vaddr $2B60
	.byte $02, $FC, $A8	; Lower corner

	vaddr $2B62
	.byte VU_REPEAT | 18, $A4	; Bottom bar

	vaddr $2B74
	.byte $0C, $A5, $A8, $A4, $A4, $A9, $A4, $A4, $A9, $A4, $A4, $A5, $FC	; lower corner and card bottoms

	.byte $00

Flip_END:
; ******************************************************************

InvGBuf_By_Open:	; Points to two different graphics buffer data blocks depending on Inventory_Open
	.word Flip_Video_Data_Closing, Flip_Video_Data_Opening

FVDC .func \1-Flip_Video_Data_Closing
FVDO .func \1-Flip_Video_Data_Opening

Flip_Video_Offsets:
	; Offsets into Flip_Video_Data_Closing
	.byte FVDC(Flip_TopBarMid)	;  0: Draw top bar (at middle)
	.byte FVDC(Flip_BotBarMid)	;  1: Draw bottom bar (at middle)
	.byte FVDC(Flip_EraseTopBarMid)	;  2: Erase top bar (at middle)
	.byte FVDC(Flip_EraseBotBarMid)	;  3: Erase bottom bar (at middle)
	.byte FVDC(Flip_MidTStatCards)	;  4: Draw top middle row of normal status bar/cards
	.byte FVDC(Flip_MidBStatCards)	;  5: Draw bottom middle row of normal status bar/cards
	.byte FVDC(Flip_TopBarCards)	;  6: Draw top bar (at top)
	.byte FVDC(Flip_BottomBarCards)	;  7: Draw bottom bar (at bottom)

	; Offsets into Flip_Video_Data_Opening (note reuse of Closing data)
	.byte FVDO(Flip_TopBarMid)	;  8: Draw top bar (at middle)
	.byte FVDO(Flip_BotBarMid)	;  9: Draw bottom bar (at middle)
	.byte FVDO(Flip_EraseTopBarMid)	; 10: Erase top bar (at middle)
	.byte FVDO(Flip_EraseBotBarMid)	; 11: Erase bottom bar (at middle)
	.byte FVDO(Flip_MidTItems)	; 12: Draw top middle row of inventory
	.byte FVDO(Flip_MidBItems)	; 13: Draw bottom middle row of inventory
	.byte FVDO(Flip_TopBarInv)	; 14: Draw top bar (at top)
	.byte FVDO(Flip_BottomBarInv)	; 15: Draw bottom bar (at bottom)

Flip_Video_Ends:
	; Ending data addresses per offset into Flip_Video_Data_Closing (when to stop copying!)
	.byte FVDC(Flip_BotBarMid)	; 0
	.byte FVDC(Flip_EraseTopBarMid)	; 1
	.byte FVDC(Flip_EraseBotBarMid)	; 2
	.byte FVDC(Flip_TopBarCards)	; 3
	.byte FVDC(Flip_MidBStatCards)	; 4
	.byte FVDC(Flip_BottomBarCards)	; 5
	.byte FVDC(Flip_MidTStatCards)	; 6
	.byte FVDC(Flip_END)		; 7

	; Ending data addresses per offset into Flip_Video_Data_Opening (when to stop copying!)
	.byte FVDO(Flip_BotBarMid)	; 8
	.byte FVDO(Flip_EraseTopBarMid)	; 9
	.byte FVDO(Flip_EraseBotBarMid)	; 10
	.byte FVDO(Flip_TopBarCards)	; 11
	.byte FVDO(Flip_MidBItems)	; 12
	.byte FVDO(Flip_BottomBarInv)	; 13
	.byte FVDO(Flip_MidTItems)	; 14
	.byte FVDO(Flip_TopBarMid)	; 15

InvFlip_TileLayout_Sel:
	; Based on Inventory_Open
	.word InvCard_Tile_Layout	; When inventory closing, render cards
	.word InvItem_Tile_Layout	; When inventory opening, render items

InvItem_Tile_Layout:
	; Item tiles layout when closing/unselected
	; NOTE: See also InvItem_Hilite_Layout
	.byte $FE, $FE, $FE, $FE	; Empty
	.byte $20, $21, $30, $31	; Super Mushroom
	.byte $22, $23, $32, $33	; Fire Flower
	.byte $0E, $0F, $1E, $1F	; Leaf
	.byte $0A, $0B, $1A, $1B	; Frog Suit
	.byte $00, $01, $10, $11	; Tanooki Suit
	.byte $28, $29, $38, $39	; Hammer Suit
	.byte $08, $09, $18, $19	; Judgems Cloud
	.byte $2A, $2B, $3A, $3B	; P-Wing
	.byte $24, $25, $34, $35	; Starman
	.byte $02, $03, $12, $13	; Anchor
	.byte $06, $07, $16, $17	; Hammer
	.byte $04, $05, $14, $15	; Warp Whistle
	.byte $0C, $0D, $1C, $1D	; Music Box

InvCard_Tile_Layout:
	.byte $FE, $FE, $FE, $FE	; No card
	.byte $E0, $E1, $E2, $E3	; Mushroom
	.byte $E4, $E6, $E7, $E8	; Flower
	.byte $AC, $AD, $AE, $AF	; Star


Inventory_DoFlipVideoUpd:
	LDA Inventory_Open
	ASL A
	TAX		 	; X = Inventory_Open << 1

	; Store address to video data into Temp_Var15 based on Inventory_Open status
	LDA InvGBuf_By_Open,X
	STA <Temp_Var15	
	LDA InvGBuf_By_Open+1,X
	STA <Temp_Var16

	; InvFlip_Frame indexes which block of video data we'll be using...

	LDY InvFlip_Frame		; Y = InvFlip_Frame
	LDA Flip_Video_Ends,Y		; Get offset value that is the END of the video data
	STA <Temp_Var13			; Store into Temp_Var13

	LDA Flip_Video_Offsets,Y	; Get offset value that is the BEGINNING of the video data
	TAY		 		; Y = A

	LDX Graphics_BufCnt	
	STX <Temp_Var9			; Temp_Var9 = Graphics_BufCnt (where in Graphics_Buffer we begin)

	; Copy all of the video update data into the Graphics_Buffer
PRG026_A2E4:
	LDA [Temp_Var15],Y	; Get next byte 
	STA Graphics_Buffer,X	; Store it into the buffer
	INX		 	; X++
	INY		 	; Y++
	CPY <Temp_Var13		
	BNE PRG026_A2E4	 	; While Y <> end of update data, loop!

	LDA Graphics_BufCnt
	ADD #12
	STA <Temp_Var13		; Temp_Var13 = Offset to 12 bytes in from where we started the graphics buffer
	DEX		 
	STX Graphics_BufCnt	; Update Graphics_BufCnt with where the buffer actually is

	LDA InvFlip_Frame
	AND #$07
	TAX
	DEX		 	; X = (InvFlip_Frame & 7) - 1
	SUB #$04	 	; A = (InvFlip_Frame & 7) - 4
	CMP #$02	 
	BGE PRG026_A30C	 	; If A >= 2, jump to PRG026_A30C
	JSR Inventory_DrawItemsOrCards	 	; Otherwise, JSR to Inventory_DrawItemsOrCards

PRG026_A30C:
	JSR InvFlipFrame_UpdateStatusBar ; Update status bar as needed for flip frame
	INC InvFlip_Frame	; InvFlip_Frame++
	LDA InvFlip_Frame	 
	AND #$07	 
	BNE PRG026_A327	 	; If InvFlip_Frame & 7 <> 0, jump to PRG026_A327 (RTS)

	; We've reached fully open or closed!
	LDA Inventory_Open
	BNE PRG026_A324		; If fully open, jump to PRG026_A324

	; Fully closed!
	LDA #$00	 	
	STA InvFlip_Counter	; InvFlip_Counter = 0
	RTS		 	; Return!

PRG026_A324:
	; Fully open...
	INC InvFlip_Counter	; InvFlip_Counter = 4

PRG026_A327:
	RTS		 	; Return

Inventory_DrawItemsOrCards:
	LDA Inventory_Open
	BNE PRG026_A344		; If Inventory_Open <> 0, jump to PRG026_A344


	; Inventory is closing!  Set up for cards
	LDA #(Inventory_Cards - Inventory_Items)	; Mario's cards
	LDX Player_Current	; X = Player_Current
	BEQ PRG026_A336	 	; If Player_Current = 0 (Mario), jump to PRG026_A336
	LDA #(Inventory_Cards2 - Inventory_Items)	; Luigi's cards

PRG026_A336:
	STA <Temp_Var14		; Store this into Temp_Var14 (offset to first pattern in card layout)

	LDA <Temp_Var13		; A = 12 bytes into the graphics buffer we just did
	ADD #$0d	 	
	STA <Temp_Var13		; Temp_Var13 += $D

	LDA #$02	 	; A = 2
	JMP PRG026_A355	 	; Jump to PRG026_A355...

PRG026_A344:
	; Inventory is opening!  Set up for inventory items!

	LDA #(Inventory_Items - Inventory_Items)	; Mario's inventory
	LDX Player_Current				; X = Player_Current
	BEQ PRG026_A34D					; If Player_Current = 0 (Mario), jump to PRG026_A34D
	LDA #(Inventory_Items2 - Inventory_Items)	; Luigi's inventory

PRG026_A34D:
	ADD InvStart_Item	; Offset to the starting item
	STA <Temp_Var14		; Store this into Temp_Var14 (offset to first pattern in item layout)
	LDA #$06	 	; Number of items to display minus one

PRG026_A355:
	STA <Temp_Var11		; Store number of items to display...

	; Set pointer to proper render items
	LDA Inventory_Open
	ASL A		 
	TAX		 ; X = Inventory_Open * 2 (2 byte index)
	LDA InvFlip_TileLayout_Sel,X
	STA <Temp_Var15	
	LDA InvFlip_TileLayout_Sel+1,X
	STA <Temp_Var16		; Temp_Var15/16 point to start of pattern data for inventory items / cards

PRG026_A366:
	LDY <Temp_Var14	; Starting item/card offset

	LDA Inventory_Items,Y	; Get this item
	BEQ PRG026_A38B	 	; If it's an empty slot, jump to PRG026_A38B

	; Item/card to process...
	ASL A		
	ASL A		
	TAY		 	; Y = item << 2

	LDA InvFlip_Frame
	AND #$07
	CMP #$04	 
	BEQ PRG026_A37D	 	; If currently on InvFlip_Frame = 4 or 12 (drawing the top half of items/cards), jump to PRG026_A37D

	; On frame 5, the bottom half of the object/card is drawn in
	TYA		 
	ORA #$02	 
	TAY		 	; Y (item offset) OR'd with 2 (do the bottom half of the object!)

PRG026_A37D:

	; This loop copies two bytes of the item/card
	; into the buffer; the graphic is made up of 4 bytes,
	; but in a single row of 8x8s, it's two at a time :)
	LDX <Temp_Var13		; X = Temp_Var13 (offset into the graphics buffer)
PRG026_A37F:
	LDA [Temp_Var15],Y	; Get next tile for this power-up
	STA Graphics_Buffer,X	; Store it into the graphics buffer
	INX		 	; X++
	INY		 	; Y++
	TYA		 	
	AND #$01	 	; A = Y & 1
	BNE PRG026_A37F	 	; If A <> 0, loop (loops for two bytes)

PRG026_A38B:
	LDA <Temp_Var13		; X = Temp_Var13 (offset into the graphics buffer)
	ADD #$03
	STA <Temp_Var13		; Temp_Var13 += 3 (2 for the power-up, 1 for spacing)
	INC <Temp_Var14	; Next item!
	DEC <Temp_Var11		; One less item left to display...
	BPL PRG026_A366	 	; While Temp_Var11 >= 0, loop!

PRG026_A398:

InvFlipFrame_DoNothing:
	RTS		 	; Return...


InvFlipFrame_UpdateStatusBar:
	LDA InvFlip_Frame
	AND #$07
	JSR DynJump

	; THESE MUST BE HERE FOR DynJump TO WORK!
	.word InvFlipFrame_DoNothing		; 0
	.word InvFlipFrame_DoNothing		; 1
	.word InvFlipFrame_DoNothing		; 2
	.word InvFlipFrame_DoNothing		; 3
	.word InvFlipFrame_DrawWorldCoins	; 4
	.word InvFlipFrame_DrawMLLivesScore	; 5
	.word InvFlipFrame_DoNothing		; 6
	.word InvFlipFrame_DoNothing		; 7

InvFlipFrame_DrawWorldCoins:
	JSR StatusBar_Fill_World ; Put world number in status bar

	LDA InvFlip_Frame
	AND #$08
	BNE PRG026_A3CC	 ; If we're doing the opening, jump to PRG026_A3CC

	JSR StatusBar_Fill_Coins ; Put coins in status bar

	LDX <Temp_Var9		 ; X = Temp_Var9

	LDA StatusBar_CoinH
	STA Graphics_Buffer+$15,X
	LDA StatusBar_CoinL
	STA Graphics_Buffer+$16,X

PRG026_A3CC:
	RTS		 ; Return

InvFlipFrame_DrawMLLivesScore:
	JSR StatusBar_Fill_MorL	 ; Put <M> or <L> in status bar
	JSR StatusBar_Fill_Lives ; Put lives in status bar

	LDX <Temp_Var9		 ; X = Temp_Var9

	LDA StatusBar_LivesH
	STA Graphics_Buffer+8,X
	LDA StatusBar_LivesL
	STA Graphics_Buffer+9,X

	LDA InvFlip_Frame
	AND #$08
	BNE PRG026_A3FB	 ; If we're doing the opening, jump to PRG026_A3FB (RTS)

	JSR StatusBar_Fill_Score ; Put score in status bar

	; Patch in all of the digits of score
	LDX <Temp_Var9	 ; X = Temp_Var9
	LDY #$00	 ; Y = 0
PRG026_A3EF:
	LDA StatusBar_Score,Y
	STA Graphics_Buffer+11,X

	INX		 ; X++ (next graphics buffer byte)
	INY		 ; Y++ (next digit of score)

	CPY #$06
	BNE PRG026_A3EF	 ; While 'Y' <> $06, loop

PRG026_A3FB:
	RTS		 ; Return

; These tables really define a lot of behavior for the inventory item menu
InvItem_AddSub:		.byte 7, -7	; Press down to go forward 7 items, up to go back 7 items
InvItem_IndexOOR:	.byte 28, -7	; Out-of-range index values for wrap-around when pressing down/up
InvItem_Wrap:		.byte 0, 21	; Wrap-around values for Inventory start
InvItem_NextPrior:	.byte 24, -24	; Whether left or right was pressed, how to add/sub the highlight X position
InvItem_HiliteOORX:	.byte 240, 48	; Highlight out-of-range X position to tell when at ends, for right/left
InvItem_HiliteMinMax:	.byte 72, 216	; Highlight left min and right max for right/left overflows
InvItem_RightLeft:	.byte 1, -1	; Whether right or left was pressed, how to inc/dec the highlight index
InvItem_RightLeftMinMax:.byte 0, 6	; Right/left overflows wrap-around index value
InvItem_PerPlayerOff:	.byte $00, (Inventory_Items2 - Inventory_Items)	; Offset per player
Inventory_DoPowerupUse:
	LDA Map_Powerup_Poof
	BNE PRG026_A398	 	; If no power-up "poof" effect occurring, jump to PRG026_A398 (RTS)

	LDA <Map_UseItem
	BEQ PRG026_A41A	 	; If Map_UseItem = 0 (not using item), jump to PRG026_A41A
	JMP PRG026_A4FC	 	; Otherwise, jump to PRG026_A4FC

PRG026_A41A:
	; Not using item
	LDA Pad_Input	 ; Get Player 
	AND #(PAD_B | PAD_START)	; B or START close the Inventory panel
	BEQ PRG026_A436	 ; If neither B nor START are pressed, jump to PRG026_A436

	; Need to close the panel
	LDA #SND_MAPINVENTORYFLIP	 
	STA Sound_QMap	 	; Play inventory flip sound
Inventory_ForceFlip:
	LDA Inventory_Open	
	EOR #$01	 
	STA Inventory_Open	; Inventory_Open ^= 1 (set to opposite)
	LDA #$00	 
	STA InvFlip_Counter	; Reset Inventory_Open
	JMP Inventory_DoHilites	; Jump to Inventory_DoHilites

PRG026_A436:
	; Neither B nor START pressed
	LDA Pad_Input
	AND #(PAD_DOWN | PAD_UP)
	BEQ PRG026_A491	 	; If neither up nor down pressed, jump to PRG026_A491

	; Up or Down pressed...
	LSR A
	LSR A
	LSR A
	TAY		 	; Y = Pad_Input >> 3 (will be 0 if down, 1 if up)
	LDA #SND_LEVELBLIP	 
	STA Sound_QLevel1	; Play item select sound

	LDA InvStart_Item	; A = InvStart_Item
	ADD InvItem_AddSub,Y	; +/- 7 based on up/down

	STA InvStart_Item	; Update InvStart_Item
	CMP InvItem_IndexOOR,Y
	BNE PRG026_A45B	 	; If we haven't hit the max or min, jump to PRG026_A45B

	; We've hit a limit!
	LDA InvItem_Wrap,Y
	STA InvStart_Item	; Wrap-around

PRG026_A45B:
	LDX InvStart_Item	; X = InvStart_Item
	LDA Player_Current	; A = Player_Current
	BEQ PRG026_A468	 	; If Player_Current = 0 (Mario), jump to PRG026_A468
	TXA			; A = InvStart_Item
	ADD #(Inventory_Items2 - Inventory_Items)	 ; Offset to Luigi's items
	TAX			; X = offset to item

PRG026_A468:
	LDY Player_Current		; Y = Player_Current
	TXA		 		; A = starting of the row Inventory item
	CMP InvItem_PerPlayerOff,Y	; If it's the very first item of this player (just wrapped around)
	BEQ PRG026_A476	 		; If so, jump to PRG026_A476

	LDA Inventory_Items,X	 	; A = next item
	BEQ PRG026_A436	 		; Jump to PRG026_A436 if row is not empty

PRG026_A476:
	LDA Inventory_Items,X	 	; A = next item
	JSR InvItem_SetColor	 	; Properly set colors for this item

Inventory_ForceUpdate_AndFlip:
	LDA #$0c	 		
	STA InvFlip_Frame	 	; InvFlip_Frame = $0C
	LDA #$03	 	
	STA InvFlip_Counter	 	; InvFlip_Counter = 3
	LDA #$00	 
	STA InvHilite_Item	 	; InvHilite_Item = 0 (first item highlighted on new row)
	LDA #$48	 
	STA InvHilite_X			; InvHilite_X = $48 (first item highlighted on new row)
	RTS		 	; Return...

PRG026_A491:
	; Neither B nor START nor Up nor Down pressed...
	LDA Level_Tileset
	CMP #$07	 
	BEQ PRG026_A4A6	 	; If Level_Tileset = 7 (Toad House), jump to PRG026_A4A6 (RTS)
	LDY #$00		; Y = 0
	LDX Player_Current	; X = Player_Current
	BEQ PRG026_A4A1		; If Player_Current = 0 (Mario), jump to PRG026_A4A1
	LDY #(Inventory_Items2 - Inventory_Items)	 ; Offset to Luigi's items

PRG026_A4A1:
	LDA Inventory_Items,Y
	BNE PRG026_A4A7		; If first item is not empty, jump to PRG026_A4A7

PRG026_A4A6:
	RTS		 	; Otherwise, just return...

PRG026_A4A7:
	LDA <Pad_Input	 
	AND #(PAD_LEFT | PAD_RIGHT)	 
	BEQ PRG026_A4F6	 	; If neither left nor right is pressed, jump to PRG026_A4F6

	LSR A		 	; Diminish to 0/1 condition (right = 0, left = 1)
	TAX		 	; Move result to X

	LDA #SND_LEVELBLIP	 
	STA Sound_QLevel1	; Play item selection sound

PRG026_A4B4:
	LDA InvHilite_Item
	ADD InvItem_RightLeft,X	; Inc/Dec InvHilite_Item appropriately
	STA InvHilite_Item	; Update InvHilite_Item

	LDA InvHilite_X	
	ADD InvItem_NextPrior,X	; Add/Sub to highlight X as appropriate
	STA InvHilite_X	  	; Update InvHilite_X

	CMP InvItem_HiliteOORX,X	
	BNE PRG026_A4D9	 	; If we have NOT hit an item limit, jump to PRG026_A4D9

	; Properly wrap the item selection around to the left or right side
	LDA InvItem_RightLeftMinMax,X
	STA InvHilite_Item	
	LDA InvItem_HiliteMinMax,X
	STA InvHilite_X	 	

PRG026_A4D9:
	LDA InvHilite_Item
	ADD InvStart_Item
	TAY		 	; Y = InvHilite_Item + InvStart_Item
	LDA Player_Current	; A = Player_Current
	BEQ PRG026_A4EB	 	; If Player_Current = 0 (Mario), jump to PRG026_A4EB

	; Luigi...
	TYA		 	
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y = InvHilite_Item + InvStart_Item + Luigi offset

PRG026_A4EB:
	LDA Inventory_Items,Y	; Get the selected item
	BEQ PRG026_A4B4	 	; If item is zero (empty slot), jump to PRG026_A4B4 (moves inventory slot back)
	JSR InvItem_SetColor 	; Otherwise, set the color...
	JMP PRG026_A511	 	; Then jump to PRG026_A511

PRG026_A4F6:
	LDA <Pad_Input		
	AND #PAD_A
	BEQ PRG026_A511	 	; If Player is NOT pressing A, jump to PRG026_A511

PRG026_A4FC:
	LDA InvHilite_Item
	ADD InvStart_Item
	TAY		 	; Y = InvHilite_Item + InvStart_Item

	LDA Player_Current
	BEQ PRG026_A50E	 	; If Player_Current = 0 (Mario), jump to PRG026_A50E
	TYA		 	
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y += Luigi offset

PRG026_A50E:
	JMP Inv_UseItem	 ; Use item and don't come back!

PRG026_A511:
	JMP Inv_Display_Hilite	 ; Highlight item and don't come back!

InvItem_Pal:
	; Per-Item LUT
	;	0    1    2    3    4    5    6    7    8    9   10   11   12   13
	.byte $16, $16, $2A, $2A, $2A, $17, $27, $16, $27, $16, $07, $17, $27, $27

InvItem_SetColor:
	; Inventory is open ... assign proper color for item that is highlighted
	LDX Level_Tileset	; X = Level_Tileset
	CPX #$07	 	
	BEQ PRG026_A539	 	; If Level_Tileset = 7 (Toad House), jump to PRG026_A539 (RTS)

	TAX		 	; A = Current inventory item selected
	LDA InvItem_Pal,X	; Get the color that will be used for this item
	STA Palette_Buffer+30	; Store it into the palette buffer
 
	LDA #$36
	STA Palette_Buffer+3	; Ensure status bar color in there!

	LDA #$06		
	STA <Graphics_Queue	; Update the palette when capable

PRG026_A539:
	RTS		 ; Return


Inv_UseItem:
	LDA Inventory_Items,Y		; Get which item to use
	JSR DynJump	 		; Dynamic jump based on item used

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	; Inventory per-item jump table!
	.word PRG026_A4A6		; Empty slot (shouldn't ever happen, but it will just RTS)
	.word Inv_UseItem_Powerup	; Super Mushroom
	.word Inv_UseItem_Powerup	; Fire Flower
	.word Inv_UseItem_Powerup	; Leaf
	.word Inv_UseItem_Powerup	; Frog Suit
	.word Inv_UseItem_Powerup	; Tanooki Suit
	.word Inv_UseItem_Powerup	; Hammer Suit
	.word Inv_UseItem_Powerup	; Judgems Cloud
	.word Inv_UseItem_Powerup	; P-Wing
	.word Inv_UseItem_Starman	; Starman
	.word Inv_UseItem_Anchor	; Anchor
	.word Inv_UseItem_Hammer	; Hammer
	.word Inv_UseItem_WarpWhistle	; Warp Whistle
	.word Inv_UseItem_MusicBox	; Music Box

InvItem_PerPowerUp_L1Sound:
	; Sound to play for each Power Up item when used...
	.byte $00		; Empty slot (shouldn't ever happen)
	.byte SND_LEVELPOWER	; Super Mushroom
	.byte SND_LEVELPOWER	; Fire Flower
	.byte SND_LEVELPOOF	; Leaf
	.byte SND_LEVELPOWER	; Frog Suit
	.byte SND_LEVELPOOF	; Tanooki Suit
	.byte SND_LEVELPOWER	; Hammer Suit
	.byte SND_LEVELPOWER	; Judgems Cloud
	.byte SND_LEVELPOWER	; P-Wing

InvItem_PerPowerUp_Disp:
	; Powerup to display on map per powerup used
	;      ES   SM   FF   L    FS   TS   HS   JC   PW 
	.byte $00, $01, $02, $03, $04, $05, $06, $07, $08

	.byte $FF

	; These define the colors set per use of a power-up item.  Note that only the first three
	; bytes are actually used.  "Power-up zero" (which I guess would be small Mario) is 
	; present here, likely for simplicity, but it is also not used (there is no "power down")
	; See also PRG027 InitPals_Per_MapPUp
InvItem_PerPowerUp_Palette:
	; Mario
	.byte $16, $36, $0F, $FF	; "Empty Slot" (shouldn't ever be used)
	.byte $16, $36, $0F, $FF	; Super Mushroom 
	.byte $27, $36, $16, $FF	; Fire Flower
	.byte $16, $36, $0F, $FF	; Leaf
	.byte $2A, $36, $0F, $FF	; Frog Suit
	.byte $17, $36, $0F, $FF	; Tanooki Suit
	.byte $30, $36, $0F, $FF	; Hammer Suit
	.byte $30, $36, $0F, $FF	; Judgems Cloud
	.byte $16, $36, $0F, $FF	; P-Wing

InvItem_PerPowerUp_Palette2:
	; Luigi
	.byte $1A, $36, $0F, $FF	; "Empty Slot" (shouldn't ever be used)
	.byte $1A, $36, $0F, $FF	; Super Mushroom
	.byte $27, $36, $16, $FF	; Fire Flower
	.byte $1A, $36, $0F, $FF	; Leaf
	.byte $2A, $36, $0F, $FF	; Frog Suit
	.byte $17, $36, $0F, $FF	; Tanooki Suit
	.byte $30, $36, $0F, $FF	; Hammer Suit
	.byte $30, $36, $0F, $FF	; Judgems Cloud
	.byte $1A, $36, $0F		; P-Wing (note lack of 4th byte)


Inv_UseItem_Powerup:
	LDA InvHilite_Item
	ADD InvStart_Item
	TAY		 	; Y = InvHilite_Item + InvStart_Item (currently highlighted item)

	LDA Player_Current	
	BEQ PRG026_A5C8	 	; If Player_Current = 0 (Mario), jump to PRG026_A5C8
	TYA		 
	ADD #(Inventory_Items2 - Inventory_Items)	 ; Offset to Luigi's items
	TAY		 	; Y, offset to Luigi

PRG026_A5C8:
	LDX Inventory_Items,Y	; Get the item (should be a POWER-UP item, Super Mushroom to P-Wing only)
	TXA		 	
	ASL A		 
	ASL A		 
	TAY		 	; Y = X << 2

	LDA Player_Current
	BEQ PRG026_A5D9	 	; If Player_Current = 0 (Mario), jump to PRG026_A5D9
	TYA		 
	ADD #(InvItem_PerPowerUp_Palette2-InvItem_PerPowerUp_Palette)	 	; Offset for Luigi
	TAY		 

PRG026_A5D9:
	; Load the colors for this power-up into the palette buffer
	LDA InvItem_PerPowerUp_Palette,Y
	STA Palette_Buffer+17
	LDA InvItem_PerPowerUp_Palette+1,Y
	STA Palette_Buffer+18
	LDA InvItem_PerPowerUp_Palette+2,Y
	STA Palette_Buffer+19

	; Queue palette update
	LDA #$06
	STA <Graphics_Queue

	; Play the correct sound for this power up item
	LDA InvItem_PerPowerUp_L1Sound,X
	STA Sound_QLevel1

	LDA InvItem_PerPowerUp_Disp,X	; Store proper power-up to display -> A
	LDX Player_Current	 	; X = Player_Current
	STA Map_Power_Disp	 	; Power-up to display -> Map_Power_Disp

	CMP #$07
	BEQ PRG026_A60B	 		; If Map_Power_Disp = $07 (Judgem's Cloud), jump to PRG026_A60B (does NOT update Player's map power!)

	CMP #$08	 
	BNE PRG026_A608	 		; If Map_Power_Disp <> $08 (P-Wing), jump to PRG026_A608
	LDA #$03	 		; For P-Wing, "Map Power Up" is set as Leaf

PRG026_A608:
	STA World_Map_Power,X	 	; Update appropriate player's "Map Power Up"

PRG026_A60B:
	LDA #$14	 
	STA Map_Powerup_Poof	 	; Map_Powerup_Poof = $14
	LDX Player_Current	 	; X = Player_Current

	; Target "Map Poof" on active Player
	LDA <World_Map_Y,X
	STA <MapPoof_Y	
	LDA <World_Map_X,X
	STA <MapPoof_X	

Inv_UseItem_ShiftOver:
	LDA #27
	STA <Temp_Var15	 	; Temp_Var15 = 27 (last index of items to shift)

	LDA InvHilite_Item
	ADD InvStart_Item
	TAY			; Y = InvHilite_Item + InvStart_Item

	LDA Player_Current	
	BEQ PRG026_A638	 	; If Player_Current = 0 (Mario), jump to PRG026_A638

	LDA #27
	ADD #(Inventory_Items2 - Inventory_Items)	; This could've been done as a constant, but oh well!
	STA <Temp_Var15		; Temp_Var15 += Luigi items offset (last index of Luigi items to shift)

	TYA		 
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y += Luigi items offset

	; This loop "removes" the used item by backing the other items over it
PRG026_A638:
	CPY <Temp_Var15
	BEQ PRG026_A646
	LDA Inventory_Items+1,Y
	STA Inventory_Items,Y	
	INY		
	JMP PRG026_A638	
PRG026_A646:
	LDA #$00	
	STA Inventory_Items,Y	 ; This clears the very last item

PRG026_A64B:
	LDY InvStart_Item	; Y = InvStart_Item
	BEQ PRG026_A66B	 	; If InvStart_Item = 0, jump to PRG025_A66B

	LDA Player_Current
	BEQ PRG026_A65A	 	; If Player_Current = 0, jump to PRG026_A65A
	TYA
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y is Offset to Luigi's items

PRG026_A65A:
	LDA Inventory_Items,Y	; Get item
	BNE PRG026_A66B	 	; If Y <> 0, jump to PRG026_A66B

	; If Player used first item on row, this backs it up one row
	LDA InvStart_Item
	SUB #$07
	STA InvStart_Item	; InvStart_Item -= 7
	JMP PRG026_A64B		; Jump to PRG026_A64B

PRG026_A66B:
	JSR Inventory_ForceUpdate_AndFlip	; Forces Inventory to flip back over
	JMP Inv_Display_Hilite	 	; Jump to Inv_Display_Hilite...

Inv_UseItem_Starman:
	INC Map_Starman	 		; Set Starman active (Nintendo's betting you never would have more than 255 on the map!)
	LDA Sound_QLevel1	 
	ORA #SND_LEVELPOWER	 	
	STA Sound_QLevel1		; Player "Power-up" noise
	JSR Inv_UseItem_ShiftOver	; Shift over all items over top of the Starman
	JMP Inventory_ForceFlip		; Force inventory to flip over

Inv_UseItem_Anchor: 
	LDA Map_Anchored
	BEQ PRG026_A690	 ; If Map_Anchored = 0, jump to PRG026_A690

Inv_UseItem_Denial:
	; Otherwise, play denial sound; prevents multiple usage
	LDA Sound_QMap
	ORA #SND_MAPDENY	
	STA Sound_QMap	 ; Denial sound
	RTS		 ; Return

PRG026_A690: 
	INC Map_Anchored 		; Set map as anchored
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF	 
	STA Sound_QLevel1		; Player powerup sound
	JSR Inv_UseItem_ShiftOver	; Shift over all items over top of the Anchor
	JMP Inventory_ForceFlip	 	; Force inventory to flip over

Inv_UseItem_MusicBox:
	LDA #$02
	STA Map_MusicBox_Cnt	 ; Map_MusicBox_Cnt = 2

	LDA #MUS2A_MUSICBOX
	STA Sound_QMusic2	 ; Play Music Box song

	JSR Inv_UseItem_ShiftOver	 ; Shift over all items over top of the Music Box
	JMP Inventory_ForceFlip	 ; Force inventory to flip and don't come back! 

RockBreak_Replace:	.byte TILE_HORZPATH, TILE_VERTPATH	; The path replacement tiles (NOTE: see also PRG012 Map_RemoveTo_Tiles)

RockBreak_TileFix:
	; These specify the tiles that replace the tiles of the rock.
	; Note for some reason these are interleved, meaning the first,
	; third, fifth, and seventh bytes are for rock $51, and the others
	; for rock $52...
	.byte $FE, $FE, $E1, $FE, $FE, $C0, $E1, $C0

Inv_UseItem_Hammer: 
	LDA #$03
	STA <Temp_Var1	 ; Temp_Var1 = 3 (checking all 4 directions around Player)

PRG026_A6BF:
	LDY <Temp_Var1	 		; Y = LDY <Temp_Var1
	JSR MapTile_Get_By_Offset	; Get map tile nearby player (on page 10)

	; Rock tiles:
	SUB #TILE_ROCKBREAKH	 ; Offset to rock tiles
	CMP #$02	 ; See if value is less than 2 (rock to break)
	BLT PRG026_A6D2	 ; If rock, jump to PRG026_A6D2

	DEC <Temp_Var1		; Temp_Var1--
	BPL PRG026_A6BF	 	; While directions to search, loop!

	JMP Inv_UseItem_Denial	; No way to use hammer; deny!

PRG026_A6D2:
	; Rock to break...

	STX <Temp_Var2		; Store screen high byte -> Temp_Var2
	LSR <Temp_Var2		; Temp_Var2 >>= 1 (previously used as index into Map_Tile_Addr, now back to just a screen index)
	PHA		 	; Save 'A' (map tile minus TILE_ROCKBREAKH, either 0 or 1)
	TAX		 	; X = A
	LDA RockBreak_Replace,X	; Get the tile number that replaces this rock
	STA [Map_Tile_AddrL],Y	; Store it in place!

	; "Poof" where the rock sits
	TYA
	ASL A
	ASL A
	ASL A
	ASL A		; Multiply by 16 for X
	STA <MapPoof_X
	STA <Temp_Var3	; Temp_Var3 = MapPoof_X

	TYA		
	AND #$f0	
	ADD #$10	; Decouple a Y
	STA <MapPoof_Y
	STA <Temp_Var1	; Temp_Var1 = MapPoof_Y

	JSR Map_SetCompletion_By_Poof	 ; Set completion bit based on location of map "poof"

	; Rock removal sets completion bit for BOTH Players!
	; The following will set it for whatever Player didn't get the 
	; completion bit set... pretty neat.
	TYA		 ; A = offset to map completion byte for this Player
	EOR #$40	 ; Flip to the OTHER Player
	TAY	
	LDA Map_Completions,Y
	ORA Map_Completion_Bit,X
	STA Map_Completions,Y

	; Take the Map poof coordinates and calculate what address in
	; Nametable 2 we need to modify to remove the rock...
	LDX <MapPoof_X		 ; X = MapPoof_X
	LDA <MapPoof_Y		 ; A = MapPoof_Y
	JSR Map_Calc_NT2Addr_By_XY

	PLA		 	; Retore 'A' (0 or 1, depending on which rock was busted)
	TAX		 	; X = A

	; Buffer in the rock replacement tiles
	LDY Graphics_BufCnt
	LDA <Temp_Var15	
	STA Graphics_Buffer,Y
	STA Graphics_Buffer+5,Y
	LDA <Temp_Var16	
	STA Graphics_Buffer+1,Y	
	ADD #$01
	STA Graphics_Buffer+6,Y
	LDA #$82
	STA Graphics_Buffer+2,Y
	STA Graphics_Buffer+7,Y
	LDA RockBreak_TileFix,X
	STA Graphics_Buffer+3,Y
	LDA RockBreak_TileFix+2,X
	STA Graphics_Buffer+4,Y	
	LDA RockBreak_TileFix+4,X
	STA Graphics_Buffer+8,Y
	LDA RockBreak_TileFix+6,X
	STA Graphics_Buffer+9,Y	

	; Terminator
	LDA #$00
	STA Graphics_Buffer+10,Y

	TYA		 
	ADD #10	 		
	STA Graphics_BufCnt	; Graphics_BufCnt += 10 (bytes added to buffer)

	; Play rock crumbling sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	; Do the poof!
	LDA #$14	
	STA Map_Powerup_Poof
	JSR Map_Poof_Update

	JMP Inv_UseItem_ShiftOver	 ; Shift all items over and don't come back 

Map_WWOrHT_StartX:
	; For the wind coming from the left or the right...
	.byte 0, 240

Inv_UseItem_WarpWhistle:
	LDY Player_Current	; Y = Player_Current
	LDX #$00	 	; X = 0 (Wind comes from the left)
	LDA World_Map_X,Y	; Get Player's X position on Map
	SUB <Horz_Scroll	; Offset it by the horizontal scroll
	CMP #$80	
	BGE PRG026_A771	 	
	LDX #$01		; Wind comes from the right
PRG026_A771:
	STX <Map_WWOrHT_Dir		; Store travel direction

	LDA Map_WWOrHT_StartX,X	; Get proper start position for the wind
	STA <Map_WWOrHT_X		; Set it as the wind's X
	LDA World_Map_Y,Y		; Get Player's Y position on map
	STA <Map_WWOrHT_Y		; Set it as the wind's Y
	STA Map_PlyrSprOvrY		; Clear the map sprite override Y

	; Back up the Player's map positioning (why??)
	LDA World_Map_Y,Y
	STA Map_WW_Backup_Y	; Store Player's map Y position

	LDA World_Map_X,Y	
	STA Map_WW_Backup_X	; Store Player's map X position

	LDA World_Map_XHi,Y	
	STA Map_WW_Backup_XH	; Store Player's map X Hi position

	LDA Map_UnusedPlayerVal2,Y	
	STA Map_WW_Backup_UPV2	; Store Player's Map_WW_Backup_UPV2


	LDX #$01	 ; X = 1

	LDA #$00
	; Clear all of the following:
	STA Map_Prev_XOff,Y
	STA Map_Prev_XHi,Y
	STA <Scroll_LastDir
	STA Map_InCanoe_Flag		; Not in a canoe

	STX <Map_WarpWind_FX		 ; Map_WarpWind_FX = 1 (Warp Whistle begin!)
	JSR Inv_UseItem_ShiftOver	 ; Shift out the Warp Whistle

	LDA #MUS2A_WARPWHISTLE	 
	STA Sound_QMusic2	 ; Play the Warp Whistle tune
	JMP Inventory_ForceFlip	 ; Flip over the inventory

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Poof_Update
;
; Updates map "poof" effect, including decrementing
; Map_Powerup_Poof and inserting the sprites to be
; displayed based on the current count...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Poof_Tiles:
	; "Outer" and "Inner" tiles for the map poof sprites
	.byte $49, $41
	.byte $49, $39
	.byte $49, $35
	.byte $49, $31
	.byte $45, $47
	.byte $45, $47

Map_Poof_Update:
	LDA <MapPoof_Y	
	SUB #$08	 	; Center Map Poof

	; Four pieces with identical Y
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64
	STA Sprite_RAM+$68
	STA Sprite_RAM+$6C

	; Four pieces with identical Y (offset 16 from the above)
	ADD #16			
	STA Sprite_RAM+$70
	STA Sprite_RAM+$74
	STA Sprite_RAM+$78
	STA Sprite_RAM+$7C

	LDY #$00	 	; Y = 0
	LDA <MapPoof_X	
	SUB <Horz_Scroll	; Offset poof effect based on horizontal scroll
	SUB #$08	 	; Center horizontally

	; This will loop through to position each piece of the poof sprite
	; horizontally, spaced 8 pixels apart.
PRG026_A7EA:
	STA Sprite_RAM+$63,Y	; Upper and...
	STA Sprite_RAM+$73,Y	; ... lower sprites with same X coordinate
	ADD #$08	 	; X coordinate += 8 (next poof sprite over)
	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)
	CPY #16
	BNE PRG026_A7EA	 ; Loop while Y < 16 (8 sprites total, doing 2 at a time)

	; The four "corners" of the poof, pieces of the sprite
	; flipped as appropriate...
	LDA #$03
	STA Sprite_RAM+$62
	STA Sprite_RAM+$66

	LDA #$43
	STA Sprite_RAM+$6A
	STA Sprite_RAM+$6E

	LDA #$83
	STA Sprite_RAM+$72
	STA Sprite_RAM+$76

	LDA #$c3
	STA Sprite_RAM+$7A
	STA Sprite_RAM+$7E

	LDA Map_Powerup_Poof
	AND #$1c	 	; Constrain the value of Map_Powerup_Poof, only change every 4 units
	LSR A		 	; A >> 1 (2 tiles per valid change in Map_Powerup_Poof)
	TAY		 	; Y = A

	; Tile for "outer" poof sprites
	LDA Map_Poof_Tiles,Y
	STA Sprite_RAM+$61
	STA Sprite_RAM+$6D
	STA Sprite_RAM+$71
	STA Sprite_RAM+$7D

	; Tile for "inner" poof sprites
	LDA Map_Poof_Tiles+1,Y
	STA Sprite_RAM+$65
	STA Sprite_RAM+$69
	STA Sprite_RAM+$75
	STA Sprite_RAM+$79

	DEC Map_Powerup_Poof	; Decrease "poof" effect
	LDA Map_Powerup_Poof	
	BNE PRG026_A84B	 	; If Map_Powerup_Poof <> 0, jump to PRG026_A84B (RTS)

	JMP Inventory_ForceFlip	; When poof has completed, inventory is closed

PRG026_A84B:
	RTS		 ; Return

InvItem_Hilite_Layout:
	; Item sprite tiles layout when highlighted
	; NOTE: See also InvItem_Tile_Layout
	; NOTE: If both tile values are equal, the right
	;        half is horizontally flipped
	.byte $01, $01		; Empty
	.byte $85, $85		; Super Mushroom
	.byte $87, $87		; Fire Flower
	.byte $9D, $9F		; Leaf
	.byte $81, $81		; Frog Suit
	.byte $83, $83		; Tanooki Suit
	.byte $8B, $8B		; Hammer Suit
	.byte $B5, $B7		; Judgems Cloud
	.byte $91, $93		; P-Wing
	.byte $A9, $A9		; Starman
	.byte $95, $97		; Anchor
	.byte $99, $9B		; Hammer
	.byte $A1, $A3		; Warp Whistle
	.byte $89, $8D		; Music Box

Inv_Display_Hilite:
	; Displays the hilited item
	LDY #$c8	 ; Y = $C8
	LDA <Map_UseItem 
	BEQ PRG026_A876	 ; If not using an item, jump to PRG026_A876

	LDA <Counter_1
	AND #$18
	BNE PRG026_A876	 ; Periodically jump to PRG026_A876

	LDY #$f8	 ; Y = $F8 (hilite is pushed off bottom of screen during item use)

PRG026_A876:
	STY Sprite_RAM+$00	; Store 'Y' position into left half
	STY Sprite_RAM+$04	; Store 'Y' position into right half
	LDA InvStart_Item
	ADD InvHilite_Item	; A = InvStart_Item + InvHilite_Item
	TAY		 	; Y = A

	LDA Player_Current
	BEQ PRG026_A88E		; If Player_Current = 0 (Mario), jump to PRG026_A88E
	TYA		 
	ADD #(Inventory_Items2 - Inventory_Items)
	TAY		 	; Y += Luigi items offset

PRG026_A88E:
	LDX Inventory_Items,Y	; X = currently highlighted item

	; Use palette 3 for both
	LDA #$03
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06

	TXA
	ASL A
	TAX		 ; X << 1 (index into InvItem_Hilite_Layout)

	; Index highlight tiles
	LDA InvItem_Hilite_Layout,X
	STA Sprite_RAM+$01
	LDA InvItem_Hilite_Layout+1,X
	STA Sprite_RAM+$05

	LDA Sprite_RAM+$01
	CMP Sprite_RAM+$05
	BNE PRG026_A8B8	 	; If left half / right half tiles differ, jump to PRG026_A8B8

	; Otherwise, a horizontal flip is applied to the right half
	LDA Sprite_RAM+$06
	ORA #$40	 	; H-Flip
	STA Sprite_RAM+$06	

PRG026_A8B8:
	LDA InvHilite_X	 
	STA Sprite_RAM+$03	; Highlight X for left
	ADD #$08	 	; +8
	STA Sprite_RAM+$07	; Highlight X for right
	RTS		 	; Return...

Map_Poof_To_Row:
	; Convert a Map Poof Y coordinate to a row LUT
	.byte $20, $30, $40, $50, $60, $70, $80

Map_Completion_Bit:
	; Set proper map "completion" bit based on row
	.byte $80, $40, $20, $10, $08, $04, $02, $01

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_SetCompletion_By_Poof
;
; Set completion bit on map for the CURRENT Player based on the location
; of the map "poof" effect (from using a hammer); does not actually do 
; graphics or RAM alteration to map, however.  Just marks completion bit 
; for future reloads of the map...
;
; 'X' is set to the row where the rock existed
; 'Y' is set to the offset for the map completion for the CURRENT Player
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_SetCompletion_By_Poof:	; $A8D4

	; This loop will determine what row to mark completion on based on
	; the Y coordinate of the "map poof"
	LDY #6	
	LDA <Temp_Var1		; A = Temp_Var1 (Map Poof Y)
PRG026_A8D8:
	CMP Map_Poof_To_Row,Y	; Compare Map Poof Y to this value
	BEQ PRG026_A8E2		; If it matches, jump to PRG026_A8E2
	DEY			; Y--
	BPL PRG026_A8D8		; While Y >= 0, loop!

	; If it doesn't match, use Y = 7 (which amounts to the last row anyway, but SHOULDN'T HAPPEN)
	LDY #7
PRG026_A8E2:
	STY <Temp_Var5		; Temp_Var5 = Y
	LDA <Temp_Var2		; A = current screen (map X Hi byte)
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var4		; Temp_Var4 = Temp_Var2 << 4
	LDA <Temp_Var3		
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var4	 	; A = Temp_Var3 >> 3 (Map Poof X, div 16) OR'd with Temp_Var4 (row is upper 4 bits, column is lower 4 bits)
	TAY		 	; Y = A
	LDX Player_Current	; X = Player_Current
	BEQ PRG026_A8FF	 	; If Player_Current = 0 (Mario), jump to PRG026_A8FF
	TYA		 	; 
	ADD #$40	 	; 
	TAY		 	; Y += $40 for Luigi (Luigi's clear bits are 64 ahead of Mario's)

PRG026_A8FF:
	LDX <Temp_Var5		; X = row on which the rock existed
	LDA Map_Completions,Y	; Get current "completion" byte for this spot
	ORA Map_Completion_Bit,X; Set appropriate "completion" bit for this row
	STA Map_Completions,Y	; Store it back
	RTS		 	; Return!

	; Per-world Big [?] block areas
LevelJctBQ_Layout:	.word BigQBlock1L, BigQBlock2L, BigQBlock3L, BigQBlock4L, BigQBlock5L, BigQBlock6L, BigQBlock7L, BigQBlock8L
LevelJctBQ_Objects:	.word BigQBlock1O, BigQBlock2O, BigQBlock3O, BigQBlock4O, BigQBlock5O, BigQBlock6O, BigQBlock7O, BigQBlock8O
LevelJctBQ_Tileset:	.byte 14, 14, 14, 14, 14, 14, 14, 14	; All use "Underground (14)" style


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HandleLevelJunction
;
; Fades out the screen, sets up the pointers, and loads a new
; area!  And some other tedious things as required to swap out
; to a different level and potentially swap back in later...
;
; Used for all bonus areas, alternate exits, whatever!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HandleLevelJunction:
	; Fades out the screen
	JSR Palette_PrepareFadeOut	 ; Prepare
PRG026_A936:
	JSR GraphicsBuf_Prep_And_WaitVSync	; Wait VSync
	JSR Palette_DoFadeOut	; Fade
	LDA Fade_Level
	BNE PRG026_A936	 ; While Fade_Level > 0, loop

	LDA #%00011000	 	; Show sprites + BG
	STA <PPU_CTL2_Copy

	JSR GraphicsBuf_Prep_And_WaitVSync	; Wait VSync

	LDA #$00
	STA PPU_CTL2	 	; Disable display
	STA Level_AScrlConfig	; Level_AScrlConfig = 0

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	JSR Level_JctCtl_Do	 ; Do what's appropriate for the Level Junction!

	LDA <Horz_Scroll
	STA Level_Jct_HS	 ; Level_Jct_HS = Horz_Scroll

	LDA <Horz_Scroll_Hi
	STA Level_Jct_HSHi	 ; Level_Jct_HSHi = Horz_Scroll_Hi

	LDA <Vert_Scroll
	STA Level_Jct_VS	 ; Level_Jct_VS = Vert_Scroll

	LDA <Vert_Scroll_Hi
	STA Level_Jct_VSHi	 ; Level_Jct_VSHi = Vert_Scroll_Hi

	LDA #$01
	STA Map_ReturnStatus	; Map_ReturnStatus = 1 (??)

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd


	; For this next part, the appropriate scroll column counter 
	; (based on which way the system last scrolled) is faked out
	; to think it is behind a whole screen (how mean!) to force
	; a "dirty" update after we transition...

	LDX <Scroll_LastDir
	BNE PRG026_A982	 	; If screen last moved left (1), jump to PRG026_A982

	; X = Scroll_LastDir = 0 (Screen last moved right)

	LDA <Scroll_ColumnR
	SUB #16
	STA <Scroll_ColumnR	; Scroll_ColumnR -= 16 (pretend we have a whole screen to the right to update)

	JMP PRG026_A989	 ; Jump to PRG026_A989

PRG026_A982:

	; X = Scroll_LastDir = 1 (Screen last moved left)

	LDA <Scroll_ColumnL
	ADD #16
	STA <Scroll_ColumnL	; Scroll_ColumnL += 16 (pretend we have a whole screen to the left to update)

PRG026_A989:
	LDA Level_JctCtl
	CMP #$02
	BEQ PRG026_A995	 ; If Level_JctCtl = 2 (Big Question Block bonus area), jump to PRG026_A995

	; The Big Question Block bonus area locks horizontal scrolling,
	; but everyone else is free to set it correctly!
	LDA Level_Jct_HS
	STA <Horz_Scroll	 ; Horz_Scroll = Level_Jct_HS

PRG026_A995:
	JMP PRG030_897B	 ; Jump to PRG026_897B (continue preparation of display!)


Level_JctCtl_Do:
	LDA Level_JctCtl
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word $0000			; 0 - Not used (Level_JctCtl = 0 does not call here)
	.word Level_JctInit		; 1 - Initialize junction
	.word LevelJct_BigQuestionBlock	; 2 - Big Question Block bonus area (they're special for some reason!)
	.word LevelJct_General		; 3 - General purpose
	.word LevelJct_GenericExit	; 4 - Generic level exit (comes up from pipe)
	.word LevelJct_SpecialToadHouse	; 5 - Special Toad House (used for the 1-3 warp whistle)

Level_JctInit:
	; Grab level header's "alternate layout" pointer and put into Level_LayPtr/H_AddrL/H
	LDA Level_AltLayout
	STA <Level_LayPtr_AddrL
	STA Level_LayPtrOrig_AddrL

	LDA Level_AltLayout+1
	STA <Level_LayPtr_AddrH
	STA Level_LayPtrOrig_AddrH

	; Grab level header's "alternate objects" pointer and put into Level_ObjPtrL/H_AddrL/H
	LDA Level_AltObjects
	STA <Level_ObjPtr_AddrL
	STA Level_ObjPtrOrig_AddrL

	LDA Level_AltObjects+1
	STA <Level_ObjPtr_AddrH
	STA Level_ObjPtrOrig_AddrH

	; Set the alternate tileset
	LDA Level_AltTileset
	STA Level_Tileset	; Level_Tileset = Level_AltTileset

	; Toggle Level_JctFlag
	LDA Level_JctFlag
	EOR #$01
	STA Level_JctFlag

	RTS		 ; Return


LevelJct_BigQuestionBlock:

	; LevelJctBQ_Flag: When you enter a Big Question block area,
	;  sets it; when you leave, clears it!
	LDA LevelJctBQ_Flag
	EOR #$01
	STA LevelJctBQ_Flag

	BEQ PRG026_AA5A	 ; If we're leaving, time to restore from backups

	; Backup Level_Tileset
	LDA Level_Tileset
	STA Level_JctBackupTileset ; Level_JctBackupTileset = Level_Tileset

	; Load tileset by world (always 14 Underground?)
	LDY World_Num	 
	LDA LevelJctBQ_Tileset,Y
	STA Level_Tileset

	; Turn world index into 2-byte index
	TYA
	ASL A
	TAY

	; Big Question block layout
	LDA LevelJctBQ_Layout,Y
	STA <Level_LayPtr_AddrL
	LDA LevelJctBQ_Layout+1,Y
	STA <Level_LayPtr_AddrH

	; Big Question block objects
	LDA LevelJctBQ_Objects,Y
	STA <Level_ObjPtr_AddrL
	LDA LevelJctBQ_Objects+1,Y
	STA <Level_ObjPtr_AddrH

	LDX <Player_XHi	 	; X = Player_XHi
	LDA Level_JctXLHStart,X	; Get value from Level_JctXLHStart based on Player's X Hi

	; A = X start position in the format of high byte in lower 4 bits 
	; and low in the upper 4 bits

	PHA		 	; Save it

	; Cap XHi 0-15 and match the scroll position
	AND #$0f
	STA <Player_XHi
	STA <Horz_Scroll_Hi

	PLA		 ; Restore UserData2 value

	AND #$f0	 ; Get the X low start component
	ORA #$08	 ; Center it up (better for coming out of pipe)
	STA <Player_X	 ; Store it into Player_X

	LDA Level_JctYLHStart,X

	; A = a few things:
	;	Bits 0 - 3: Go into Level_PipeExitDir
	;	Bits 4 - 6: Starting position index
	;	Bits     7: Set for vertical level (and also sets Level_7VertCopy)

	PHA		 ; Push Level_JctYLHStart
	PHA		 ; Push Level_JctYLHStart

	AND #$0f	 ; Lower 4 bits of Level_JctYLHStart
	STA Level_PipeExitDir	 ; Store into Level_PipeExitDir

	CMP #$03
	BLT PRG026_AA30	 ; If Level_PipeExitDir < 3, jump to PRG026_AA30

	; Otherwise, don't center Player (better for starting on block)
	LDA <Player_X
	AND #$f0
	STA <Player_X

PRG026_AA30:
	PLA		 ; Restore Level_JctYLHStart
	AND #$80
	STA Level_7VertCopy
	STA Level_7Vertical	 ; Set vertical mode

	PLA		 ; Restore Level_JctYLHStart

	; Get start index 0 - 7
	AND #%01110000
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAY
	LDA LevelJct_YLHStarts,Y	 ; Get appropriate Y start info

	; 'A' is similar format byte to the X start; 
	; Y is defined as "high" part in the lower 4 bits and
	; the "low" part is the upper 4 bits

	PHA		 ; Push 'A'

	AND #$0f	
	STA <Player_YHi	 ; Lower 4 bits are the "High" byte

	PLA		 ; Restore 'A'
	AND #$f0	
	STA <Player_Y	 ; Upper 4 bits are the "low" byte

	LDA LevelJct_VertStarts,Y	 ; Get appropriate vertical start position
	STA <Vert_Scroll		 ; Store into Vert_Scroll

	LDA #$00
	STA <Horz_Scroll ; Horz_Scroll = 0

	JMP PRG026_AB0E	 ; Jump to PRG026_AB0E

PRG026_AA5A:
	; Restore from all backups

	LDA Level_JctBackupTileset
	STA Level_Tileset

	LDA Level_LayPtrOrig_AddrL
	STA <Level_LayPtr_AddrL

	LDA Level_LayPtrOrig_AddrH
	STA <Level_LayPtr_AddrH

	LDA Level_ObjPtrOrig_AddrL
	STA <Level_ObjPtr_AddrL

	LDA Level_ObjPtrOrig_AddrH
	STA <Level_ObjPtr_AddrH

	JMP PRG026_AA8A	 	; Jump to PRG026_AA8A (perform switch)

	; For Level Junction start position:	
	; Defines start positions in the format of the lower 4 bits 
	; being the "high" part, and upper 4 bits are the low part
LevelJct_YLHStarts:	.byte $00, $40, $70, $B0, $F0, $41, $71, $81

	; These define the Vert_Scroll init value
LevelJct_VertStarts:	.byte $00, $00, $30, $70, $B0, $EF, $EF, $EF


LevelJct_General:
	JSR Level_JctInit	 ; Initialize level junction

PRG026_AA8A:
	; Actual switch code:

	LDX <Player_XHi		 ; X = Player_XHi

	LDA Level_7Vertical
	BEQ PRG026_AA9A	 	; If level is not vertical, jump to PRG026_AA9A

	LDY <Player_YHi	; Y = Player_YHi
	LDA <Player_Y	; A = Player_Y
	JSR LevelJct_GetVScreenH	 ; Possibly advances 'Y'
	TYA		
	TAX		 ; X = Y

PRG026_AA9A:

	; Get Level_JctXLHStart, based on Player's X Hi or a possibly modded
	; Player's Y Hi in Vertical levels, essentially determining 
	; where to go based on the Player's "progress" through an area...
	LDA Level_JctXLHStart,X	

	; A = X start position in the format of high byte in lower 4 bits 
	; and low in the upper 4 bits
 
	PHA		 ; Save read byte
	AND #$0f	 ; Get the "X Hi" part of it
	STA <Player_XHi	 ; Store it!

	PLA		 ; Restore read byte
	AND #$f0	 ; Get the X low part
	ORA #$08	 ; Center it
	STA <Player_X	 ; Store it!

	LDA Level_JctYLHStart,X	

	; A = a few things:
	;	Bits 0 - 3: Go into Level_PipeExitDir
	;	Bits 4 - 6: 0 to 7, selects start position from LevelJct_YLHStarts and sets proper vertical with LevelJct_VertStarts
	;	Bits     7: Set for vertical level (and also sets Level_7VertCopy)


	PHA		 ; Push Level_JctYLHStart
	PHA		 ; Push Level_JctYLHStart

	AND #$0f	 ; Lower 4 bits of Level_JctYLHStart
	STA Level_PipeExitDir	 ; Store into Level_PipeExitDir

	CMP #$03
	BLT PRG026_AABD	 ; If Level_PipeExitDir < 3, jump to PRG026_AABD

	; Otherwise, don't center Player (better for starting on block)
	LDA <Player_X
	AND #$f0
	STA <Player_X

PRG026_AABD:
	PLA		 ; Restore Level_JctYLHStart
	AND #$80
	STA Level_7VertCopy
	STA Level_7Vertical	 ; Set vertical mode

	PLA		 ; Restore Level_JctYLHStart

	; Get start index 0 - 7
	AND #%01110000
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAY
	LDA LevelJct_YLHStarts,Y	 ; Get appropriate Y start info

	; 'A' is similar format byte to the X start; 
	; Y is defined as "high" part in the lower 4 bits and
	; the "low" part is the upper 4 bits

	PHA		 ; Push 'A'

	AND #$0f	
	STA <Player_YHi	 ; Lower 4 bits are the "High" byte

	PLA		 ; Restore 'A'
	AND #$f0	
	STA <Player_Y	 ; Upper 4 bits are the "low" byte

	LDA LevelJct_VertStarts,Y	 ; Get appropriate vertical start position
	STA <Vert_Scroll		 ; Store into Vert_Scroll

	LDA #$00
	STA <Horz_Scroll 	; Horz_Scroll = 0
	STA <Horz_Scroll_Hi	; Horz_Scroll_Hi = 0
	STA <Vert_Scroll_Hi	; Vert_Scroll_Hi = 0

	LDA Level_7VertCopy
	BNE PRG026_AB0E	 	; If switching to vertical, jump to PRG026_AB0E

	; Non-vertical level...

	; As long as the Player's X is >= $80, we can subtract $80 from
	; it to properly center the horizontal scroll on the Player!
	; Obviously if Player_XHi > 0, then we can do that REGARDLESS
	; of the Player X low position because we have space to the left

	LDA <Player_XHi
	STA <Horz_Scroll_Hi	 ; Horz_Scroll_Hi = Horz_Scroll_Hi
	BNE PRG026_AAF9	 	; Jump if Player_XHi <> 0 to PRG026_AAF9

	; If Player X Hi is zero, we may not have enough room to center
	; left of the Player, so let's check...
	LDA <Player_X
	CMP #$80	
	BLT PRG026_AB06	 ; If Player_X < $80, jump to PRG026_AB06

PRG026_AAF9:

	; Enough room to center horizontally left of the Player!
	LDA <Player_X
	SUB #$80
	STA <Horz_Scroll

	; Carried into Horz_Scroll_Hi if need be
	LDA <Horz_Scroll_Hi
	SBC #$00
	STA <Horz_Scroll_Hi

PRG026_AB06:
	LDA <Player_YHi
	BEQ PRG026_AB0E	; If Player_YHi = 0, jump to PRG026_AB0E

	; Otherwise, Player needs screen scrolled as low as it can go
	LDA #$ef	 
	STA <Vert_Scroll ; Vert_Scroll = $EF

PRG026_AB0E:
	; Common (regular and vertical level) continue point...

	LDA <Horz_Scroll
	STA <Scroll_Temp	; Scroll_Temp = Horz_Scroll
	LDA <Horz_Scroll_Hi	; A = Horz_Scroll_Hi

	JMP Scroll_Update_Ranges ; Set scrolling appropriately!

	; For levels which employ the "generic exit" pipe at the end
	; Only World 4 has a special one though...
LevelJctGE_Layout:	.word W503_EndL, W503_EndL, W503_EndL, GenericW4L, W503_EndL, W503_EndL, W503_EndL, W503_EndL
LevelJctGE_Objects:	.word W503_EndO, W503_EndO, W503_EndO, W503_EndO, W503_EndO, W503_EndO, W503_EndO, W503_EndO
LevelJctGE_Tileset:	.byte 1, 1, 1, 1, 1, 1, 1, 1	; All use "Plains" style

LevelJct_GenericExit:
	; Load tileset by world (always Plains style)
	LDY World_Num
	LDA LevelJctGE_Tileset,Y
	STA Level_Tileset

	; Turn world index into 2-byte index
	TYA
	ASL A
	TAY

	; Generic Exit block layout
	LDA LevelJctGE_Layout,Y
	STA <Level_LayPtr_AddrL
	LDA LevelJctGE_Layout+1,Y
	STA <Level_LayPtr_AddrH

	; Generic Exit objects
	LDA LevelJctGE_Objects,Y
	STA <Level_ObjPtr_AddrL
	LDA LevelJctGE_Objects+1,Y
	STA <Level_ObjPtr_AddrH

	; Generic exit uses a predictable start position
	LDA #$00
	STA <Player_XHi
	STA <Horz_Scroll
	STA <Vert_Scroll_Hi
	STA <Horz_Scroll_Hi

	; ... and is never vertical
	STA Level_7Vertical	; Level_7Vertical = 0

	; And several other constants:
	LDA #$ef
	STA <Vert_Scroll ; Level_7Vertical = $EF

	LDA #$28
	STA <Player_X	 ; Player_X = $28

	LDA #$01
	STA <Player_YHi	 ; Player_YHi = 1

	STA Level_PipeExitDir	 ; Level_PipeExitDir = 1

	LDA #$80
	STA <Player_Y	 ; Player_Y = $80

	JMP PRG026_AB0E	 ; Jump to PRG026_AB0E


LevelJct_SpecialToadHouse:
	; NOTE: This does NOT set the layout / object pointers!!
	; These MUST be set prior to using this Level Junction!

	; (FIXME: Is this done by the hidden object of 1-3?)

	; The special warp whistle Toad House uses a predictable start position
	LDA #$00
	STA <Horz_Scroll
	STA <Horz_Scroll_Hi
	STA <Vert_Scroll_Hi
	STA <Player_XHi

	; ... and is never vertical
	STA Level_7Vertical	; Level_7Vertical = 0

	; And several other constants:
	LDA #32
	STA <Player_X	 ; Player_X = 32

	LDA #$01
	STA <Player_YHi	 ; Player_YHi = 1

	LDA #64
	STA <Player_Y	 ; Player_Y = 64

	LDA #$07
	STA Level_Tileset	 ; Level_Tileset = 7 (Toad House)

	JMP PRG026_AB0E	 ; Jump to PRG026_AB0E

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Palette_PrepareFadeIn
;
; This subroutine is called prior to performing a palette
; fade-in.  It configures the initial version of the buffer
; with all of the darkest shades of colors.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Palette_PrepareFadeIn:
	CLC			; signals to use "fade in" prep code 

Palette_PrepareFadeOut_Entry:	; entry point when preparing to fade out!

	; Set the palette address to the beginning of palettes, $3F00
	LDA #$3f	 
	STA Palette_AddrHi
	LDA #$00	 
	STA Palette_AddrLo

	STA Palette_Term	 ; Palette_Term = 0, Terminate the palette data

	LDA #32
	STA Palette_BufCnt	 ; Loading 32 colors

	; Prepare all 31 colors in their darkest shades!
	LDY #31		 ; Y = 31
PRG026_ABB8:
	PHP		 ; Save processor status

	LDA Pal_Data,Y	 ; Get next byte of target palette data

	BCS PRG026_ABC5	 ; If carry is set (fade out), jump to PRG026_ABC5 (fade out needs the colors as they're to be targeted!)

	SUB #$30	 ; Otherwise, A -= $30 (darkest shade of this color)
	BCS PRG026_ABC5	 ; If we didn't go "less than black", jump to PRG026_ABC5
	LDA #$0f	 ; Otherwise, A = $F (black)

PRG026_ABC5:
	PLP		 ; Restore processor status

	STA Palette_Buffer,Y	; Copy this byte of palette data to the buffer
	DEY		 	; Y--
	BPL PRG026_ABB8	 	; While Y >= 0, loop!

	LDA #$04
	STA Fade_Level	 ; Fade_Level = 4
	STA Fade_Tick	 ; Fade_Tick = 0
	INC Fade_State	 ; Fade_State = 1 (Fade in)

	LDA #$06	 
	STA <Graphics_Queue	 ; Reset the graphics buffer
	RTS		 ; Return

Palette_DoFadeIn:
	LDA Fade_Tick	 
	BEQ PRG026_ABE4	 ; If Fade_Tick = 0, jump to PRG026_ABE4
	DEC Fade_Tick	 ; Otherwise, Fade_Tick--

PRG026_ABE4:
	LDA Fade_Level	 
	BEQ PRG026_AC1A	 ; If Fade_Level = 0, jump to PRG026_AC1A

	LDA Fade_Tick	 
	BNE PRG026_AC19	 ; If Fade_Tick <> 0, jump to PRG026_AC19

	LDA #$04	
	STA Fade_Tick	 ; Fade_Tick = 4 (reload) 

	DEC Fade_Level	 ; Fade_Level--

	LDY #31		 ; Y = 31
PRG026_ABF8:
	LDA Palette_Buffer,Y	; Get next byte of palette data 
	CMP #$0f	 	; Is this color black?
	BNE PRG026_AC07	 	; If not, jump to PRG026_AC07

	LDA Pal_Data,Y	 ; Get the target byte
	AND #$0f	 ; Gets the darkest shade of this color
	JMP PRG026_AC0F	 ; Jump to PRG026_AC0F

PRG026_AC07:
	CMP Pal_Data,Y	 ; Compare this against the target palette byte
	BEQ PRG026_AC12	 ; If we reached the target, jump to PRG026_AC12
	ADD #$10	 ; Otherwise, add $10 (brighter)

PRG026_AC0F:
	STA Palette_Buffer,Y	 ; Update the buffer!

PRG026_AC12:
	DEY		 ; Y--
	BPL PRG026_ABF8	 ; While Y >= 0, loop!

	LDA #$06	 
	STA <Graphics_Queue	 ; Queue graphics routine 6

PRG026_AC19:
	RTS		 ; Return


PRG026_AC1A:
	LDA #$00	 
	STA Fade_State	 ; Fade_State = 0
	RTS		 ; Return


Palette_PrepareFadeOut:
	LDA FadeOut_Cancel
	BNE PRG026_AC29	 	; If FadeOut_Cancel <> 0, jump to PRG026_AC29 (RTS)

	SEC			; signals to use "fade out" prep code		 
	JMP Palette_PrepareFadeOut_Entry

PRG026_AC29:
	RTS		 ; Return

Palette_DoFadeOut:
	LDA FadeOut_Cancel
	BNE PRG026_AC60	 ; If FadeOut_Cancel <> 0, jump to PRG026_AC60

	LDA Fade_Tick
	BEQ PRG026_AC37	 ; If Fade_Tick = 0, jump to PRG026_AC37

	DEC Fade_Tick	 ; Fade_Tick--

PRG026_AC37:
	LDA Fade_Level
	BEQ PRG026_AC60	 ; If Fade_Level = 0, jump to PRG026_AC60

	LDA Fade_Tick
	BNE PRG026_AC5F	 ; If Fade_Tick <> 0, jump to PRG026_AC5F

	LDA #$04
	STA Fade_Tick	 ; Fade_Tick = 4

	DEC Fade_Level	 ; Fade_Level--

	; For all palette colors...
	LDY #31
PRG026_AC4B:
	LDA Palette_Buffer,Y	; Get this color
	SUB #16		 	; Subtract 16 from it
	BPL PRG026_AC55	 	; If we didn't go below zero, jump to PRG026_AC55

	LDA #$0f	 	; Otherwise, set it to safe minimum

PRG026_AC55:
	STA Palette_Buffer,Y	; Update palette color
	DEY		 	; Y--
	BPL PRG026_AC4B	 	; While Y >= 0, loop!

	; Update palette
	LDA #$06
	STA <Graphics_Queue

PRG026_AC5F:
	RTS		 ; Return

PRG026_AC60:
	; Fade out cancellation request

	LDA #$00
	STA Fade_State
	STA FadeOut_Cancel
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Palette_FadeIn
;
; This performs the palette fade-in routine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Palette_FadeIn:		; AC69
	JSR Palette_PrepareFadeIn	 ; Prepare to fade in!

	; Some kind of hardware thing??
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR

PRG026_AC8C:
	LDA PPU_STAT	 ; Get PPU_STAT
	AND #$80	 
	BNE PRG026_AC8C	 ; If VBlank is NOT occurring, loop!

	LDA #%10101000	 ; PT2 is sprites, use 8x16 sprites, generate VBlanks

	; Update PPU_CTL1 and local copy
	STA PPU_CTL1	 
	STA <PPU_CTL1_Copy

	LDA #%00011000	 	; Show sprites + BG
	STA <PPU_CTL2_Copy

PRG026_AC9E:
	; Update the palette based on the buffer
	JSR GraphicsBuf_Prep_And_WaitVSync

	JSR Palette_DoFadeIn	; Do the fade in
	LDA Fade_Level	 
	BNE PRG026_AC9E	 	; If fade-in not complete, go around again!

	RTS		 	; Return...


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Palette_FadeOut
;
; This performs the palette fade-out routine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Palette_FadeOut:
	JSR Palette_PrepareFadeOut	; Prepare to fade out!

	; Wait for V-Blank
PRG026_ACAD:
	LDA PPU_STAT
	AND #$80	
	BNE PRG026_ACAD	

	LDA #%10101000	 ; PT2 is sprites, use 8x16 sprites, generate VBlanks
	; Update PPU_CTL1 and local copy
	STA PPU_CTL1	 
	STA <PPU_CTL1_Copy

	LDA #%00011000	 	; Show sprites + BG
	STA <PPU_CTL2_Copy

PRG026_ACBF:
	; Update the palette based on the buffer
	JSR GraphicsBuf_Prep_And_WaitVSync

	JSR Palette_DoFadeOut	; Do the fade out
	LDA Fade_Level	 	
	BNE PRG026_ACBF	 	; If fade-out not complete, go around again!

	RTS		 ; Return
 

PRG026_ACCB:	.byte $40, $40, $20, $00, $00, $00

Map_EnterLevel_Effect:		; routine called while entering a level
	LDA PPU_STAT
	LDX Map_EntTran_BorderLoop	; X = current border index (0-3: Top 0, bottom 1, right 2, left 3)

	; Copy this border's VRAM addresses to Map_EntTran_VAddrH/L
	LDA Map_EntTran_BVAddrH,X
	STA Map_EntTran_VAddrH	 
	LDA Map_EntTran_BVAddrL,X
	STA Map_EntTran_VAddrL	 

	LDA Map_EntTran_BorderLoop	; Get current border loop index
	AND #$02	 
	BEQ PRG026_ACF6	 		; If not updating left/right (i.e. doing top/bottom), jump to PRG026_ACF6

	LDY Map_EntTran_LRCnt	 	; Y = Map_EntTran_LRCnt

	; Set vertical update mode (left/right edges benefit from this)
	LDA <PPU_CTL1_Copy
	ORA #$04	 
	STA <PPU_CTL1_Copy

	JMP PRG026_ACFF	 ; Jump to PRG026_ACFF

PRG026_ACF6:
	LDY Map_EntTran_TBCnt	 	; Y = Map_EntTran_TBCnt

	; Set horizontal update mode (top/bottom edges benefit from this)
	LDA <PPU_CTL1_Copy
	AND #$fb	 
	STA <PPU_CTL1_Copy

PRG026_ACFF:
	LDA <PPU_CTL1_Copy
	STA PPU_CTL1	 	; Commit changes to PPU_CTL1

	; Set this border's VRAM addresses
	LDA Map_EntTran_VAddrH
	STA PPU_VRAM_ADDR	
	LDA Map_EntTran_VAddrL
	STA PPU_VRAM_ADDR	

PRG026_AD10:
	LDA #$ff		; black pattern	
	STA PPU_VRAM_DATA	; Store into VRAM

	LDA Map_EntTran_BorderLoop
	AND #$02
	BNE PRG026_AD26	 	; If updating left/right, jump to PRG026_AD26

	; top/bottom update...
	INC Map_EntTran_VAddrL	; Map_EntTran_VAddrL++

	LDA Map_EntTran_VAddrL
	AND #$1f
	BEQ PRG026_AD2B	 	; If Map_EntTran_VAddrL has covered 32 bytes, jump to PRG026_AD2B

PRG026_AD26:
	DEY		 	; Y--
	BPL PRG026_AD10	 	; While Y >= 0, loop!
	BMI PRG026_AD37	 	; If loop has ended, jump to PRG026_AD37

PRG026_AD2B:
	; After covering 32 bytes, reset
	LDA Map_EntTran_VAddrL
	SUB #32
	STA Map_EntTran_VAddrL	; Map_EntTran_VAddrL -= 32
	DEY		 	; Y--
	BPL PRG026_ACFF	 	; While Y >= 0, loop! (and reset VRAM address, since autoincrement needs reset too)

PRG026_AD37:
	JSR Border_Do	 ; Update this edge of the border

	INC Map_EntTran_BorderLoop
	LDA Map_EntTran_BorderLoop
	AND #$03	 
	STA Map_EntTran_BorderLoop	; Map_EntTran_BorderLoop = (Map_EntTran_BorderLoop + 1) & 3

	LDY Map_EntTran_Cnt		; Y = Map_EntTran_Cnt
	CPY #$06
	BGE PRG026_AD67	 		; If Map_EntTran_Cnt >= 6, jump to PRG026_AD67

	LDA <PPU_CTL1_Copy
	AND #$04	 
	BNE PRG026_AD67	 		; If vertical update bit is set (?), jump to PRG026_AD67 (RTS)

	; Pump in final black tiles
	LDX #31

	; Set VRAM address to [$2B][PRG026_ACCB[Y]]
	LDA #$2b
	STA PPU_VRAM_ADDR
	LDA PRG026_ACCB,Y
	STA PPU_VRAM_ADDR
PRG026_AD5F:
	LDA #$ff	 
	STA PPU_VRAM_DATA
	DEX		 ; X--
	BPL PRG026_AD5F	 ; While X >= 0, loop!

PRG026_AD67:
	RTS		 ; Return


Border_Do:
	LDA Map_EntTran_BorderLoop
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Border_Top
	.word Border_Bottom
	.word Border_Right
	.word Border_Left

Border_Top:
	LDX Map_EntTran_BorderLoop	; X = current border index
	LDA Map_EntTran_BVAddrL,X
	AND #$1f
	CMP #$1f
	BEQ PRG026_AD94	 		; If Map_EntTran_BVAddrL is at the 31st byte, jump to PRG026_AD94

	; Otherwise... Map_EntTran_BVAddrH/L += 33 (causes it to shift over, creating the diagonals)
	LDA Map_EntTran_BVAddrL,X
	ADD #33
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	 
	STA Map_EntTran_BVAddrH,X
	RTS		 ; Return

PRG026_AD94:
	; 31st byte, top
	; Map_EntTran_BVAddrH/L += 1
	LDA Map_EntTran_BVAddrL,X
	ADD #$01	
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	 
	STA Map_EntTran_BVAddrH,X
	RTS		 ; Return

Border_Right:
	LDX Map_EntTran_BorderLoop	; X = current border index

	; Map_EntTran_BVAddrH/L += 31
	LDA Map_EntTran_BVAddrL,X
	ADD #31
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	
	STA Map_EntTran_BVAddrH,X
	RTS		 ; Return

Border_Bottom:
	LDX Map_EntTran_BorderLoop	; X = current border index

	; Map_EntTran_BVAddrH/L -= 31 (causes it to shift over, creating the diagonals)
	LDA Map_EntTran_BVAddrL,X
	SUB #31
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	SBC #$00	 
	STA Map_EntTran_BVAddrH,X

	DEC Map_EntTran_TBCnt
	DEC Map_EntTran_TBCnt	 ; Map_EntTran_TBCnt -= 2
	RTS		 ; Return

Border_Left:
	LDX Map_EntTran_BorderLoop	; X = current border index

	; Map_EntTran_BVAddrH/L += 33
	LDA Map_EntTran_BVAddrL,X
	ADD #33
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	
	STA Map_EntTran_BVAddrH,X
	DEC Map_EntTran_LRCnt	 
	DEC Map_EntTran_LRCnt	 ; Map_EntTran_LRCnt -= 2
	RTS		 ; Return

Level_Opening_Effect:	; Unused in the US release; this is the reverse effect of the map entry

	LDA PPU_STAT
	LDA Map_EntTran_BorderLoop	; A = current border index (0-3: Top 0, bottom 1, right 2, left 3)
	AND #$02
	BEQ PRG026_AE07	 		; If updating top/bottom, jump to PRG026_AE07

	; left/right update..
	LDY Map_EntTran_LRCnt

	; Set vertical update mode (left/right edges benefit from this)
	LDA <PPU_CTL1_Copy
	ORA #$04	 
	STA <PPU_CTL1_Copy
	JMP PRG026_AE10	 		; Jump to PRG026_AE10

PRG026_AE07:
	LDY Map_EntTran_TBCnt	 	; Y = Map_EntTran_TBCnt

	; Set horizontal update mode (top/bottom edges benefit from this)
	LDA <PPU_CTL1_Copy
	AND #$fb	 
	STA <PPU_CTL1_Copy

PRG026_AE10:
	LDA <PPU_CTL1_Copy
	STA PPU_CTL1	 	; Commit changes to PPU_CTL1
	LDX Map_EntTran_BorderLoop	; X = current border index 

	; Set VRAM address for this border
	LDA Map_EntTran_BVAddrH,X
	STA PPU_VRAM_ADDR	 
	LDA Map_EntTran_BVAddrL,X
	STA PPU_VRAM_ADDR	 

PRG026_AE24:
	LDA Scroll_ColorStrip,Y	 
	STA PPU_VRAM_DATA	 ; Store attribute data to VRAM

	CPY Map_EntTran_Temp
	BEQ PRG026_AE35	 	; If Y = Map_EntTran_Temp, jump to PRG026_AE35

	DEY		 	; Y--
	BPL PRG026_AE24	 	; While Y >= 0, loop
	JMP PRG026_AE51	 	; Jump to PRG026_AE51

PRG026_AE35:
	LDA #$ff	 
	STA Map_EntTran_Temp	; Map_EntTran_Temp = $FF

	; Set VRAM address to [$28][Map_EntTran_BVAddrL & $1f]
	LDA #$28	 
	STA PPU_VRAM_ADDR
	LDA Map_EntTran_BVAddrL,X
	AND #$1f	 
	STA PPU_VRAM_ADDR	

	DEY		 	; Y--

PRG026_AE48:
	LDA Scroll_ColorStrip,Y	 
	STA PPU_VRAM_DATA	 ; Store attribute data to VRAM
	DEY		 	; Y--
	BPL PRG026_AE48	 ; While Y >= 0, loop

PRG026_AE51:
	JSR BorderOut_Do	 ; Update this edge of the border!

	INC Map_EntTran_BorderLoop
	LDA Map_EntTran_BorderLoop
	AND #$03	
	STA Map_EntTran_BorderLoop	; Map_EntTran_BorderLoop = (Map_EntTran_BorderLoop + 1) & 3

	INC Map_EntTran_Cnt		; Map_EntTran_Cnt++
	RTS		 ; Return

BorderOut_VHLimitTRL:	.byte $20, $00, $00, $00, $28
BorderOut_VHLimitB:	.byte $23, $00, $00, $00, $2A

BorderOut_Do:
	LDA Map_EntTran_BorderLoop
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BorderOut_Top
	.word BorderOut_Bottom
	.word BorderOut_Right
	.word BorderOut_Left

BorderOut_Top:
	LDX Map_EntTran_InitValIdx
	LDA BorderOut_VHLimitTRL,X

	LDX Map_EntTran_BorderLoop
	CMP Map_EntTran_BVAddrH,X
	BNE PRG026_AE92	 		; If Map_EntTran_BVAddrH[Map_EntTran_BorderLoop] <> BorderOut_VHLimitTRL[Map_EntTran_InitValIdx], jump to PRG026_AE92

	; Otherwise...
	LDA Map_EntTran_BVAddrL,X
	CMP #$20
	BGE PRG026_AE92	 ; If Map_EntTran_BVAddrL >= $20, jump to PRG026_AE92
	BLT PRG026_AEA6	 ; Otherwise, jump to PRG026_AEA6

PRG026_AE92:
	; Map_EntTran_BVAddrL >= $20

	LDX Map_EntTran_BorderLoop	; X = border index

	; Map_EntTran_BVAddrH/L -= 33
	LDA Map_EntTran_BVAddrL,X
	SUB #33
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	SBC #$00	
	STA Map_EntTran_BVAddrH,X

PRG026_AEA6:
	LDA Map_EntTran_BVAddrH,X
	CMP #$27
	BNE PRG026_AEBB			; If Map_EntTran_BVAddrH <> $27, jump to PRG026_AEBB (RTS)

	; Map_EntTran_BVAddrH = $23
	LDA #$23
	STA Map_EntTran_BVAddrH,X

	; Map_EntTran_BVAddrL -= $40
	LDA Map_EntTran_BVAddrL,X
	SUB #$40	
	STA Map_EntTran_BVAddrL,X

PRG026_AEBB:
	RTS

BorderOut_Right:
	LDX Map_EntTran_InitValIdx
	LDA BorderOut_VHLimitTRL,X

	LDX Map_EntTran_BorderLoop
	CMP Map_EntTran_BVAddrH,X
	BNE PRG026_AED7 		; If Map_EntTran_BVAddrH[Map_EntTran_BorderLoop] <> BorderOut_VHLimitTRL[Map_EntTran_InitValIdx], jump to PRG026_AED7

	LDA Map_EntTran_BVAddrL,X
	CMP #$1e
	BNE PRG026_AED7			; If Map_EntTran_BVAddrL <> $1e, jump to PRG026_AED7

	INC Map_EntTran_BVAddrL,X	; Map_EntTran_BVAddrL++
	JMP PRG026_AEE8	 		; Jump to PRG026_AEE8

PRG026_AED7:

	; Map_EntTran_BVAddrH/L -= 31
	LDA Map_EntTran_BVAddrL,X
	SUB #31
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	SBC #$00	 
	STA Map_EntTran_BVAddrH,X

PRG026_AEE8:
	LDA Map_EntTran_BVAddrH,X
	CMP #$27	 
	BNE PRG026_AEFD	 		; If Map_EntTran_BVAddrH <> $27, jump to PRG026_AEFD (RTS)

	LDA #$23
	STA Map_EntTran_BVAddrH,X

	; Map_EntTran_BVAddrL -= $40
	LDA Map_EntTran_BVAddrL,X
	SUB #$40	
	STA Map_EntTran_BVAddrL,X

PRG026_AEFD:
	RTS		 ; Return

BorderOut_Bottom:
	LDX Map_EntTran_InitValIdx
	LDA BorderOut_VHLimitB,X

	LDX Map_EntTran_BorderLoop
	CMP Map_EntTran_BVAddrH,X
	BNE PRG026_AF1C 		; If Map_EntTran_BVAddrH[Map_EntTran_BorderLoop] <> BorderOut_VHLimitB[Map_EntTran_InitValIdx], jump to PRG026_AF1C

	LDA Map_EntTran_InitValIdx
	CMP #$04	 
	BLT PRG026_AF33	 		; If Map_EntTran_InitValIdx < 4, jump to PRG026_AF33

	LDA Map_EntTran_BVAddrL,X
	CMP #$e0	 
	BLT PRG026_AF1C	 		; If Map_EntTran_BVAddrL < $e0, jump to PRG026_AF1C
	BGE PRG026_AF33	 		; Otherwise, jump to PRG026_AF33

PRG026_AF1C:
	; Map_EntTran_BVAddrH/L += 31
	LDA Map_EntTran_BVAddrL,X
	ADD #31
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	ADC #$00	
	STA Map_EntTran_BVAddrH,X

	INC Map_EntTran_TBCnt	
	INC Map_EntTran_TBCnt		; Map_EntTran_TBCnt += 2

PRG026_AF33:
	LDA Map_EntTran_BVAddrH,X
	CMP #$23
	BNE PRG026_AF4E	 		; If Map_EntTran_BVAddrH <> $23, jump to PRG026_AF4E (RTS)

	LDA Map_EntTran_BVAddrL,X
	CMP #$c0	
	BLT PRG026_AF4E	 		; If Map_EntTran_BVAddrL < $c0, jump to PRG026_AF4E (RTS)

	LDA #$28	 
	STA Map_EntTran_BVAddrH,X	; Map_EntTran_BVAddrH = $28

	LDA Map_EntTran_BVAddrL,X
	AND #$1f	
	STA Map_EntTran_BVAddrL,X	; Map_EntTran_BVAddrL &= $31

PRG026_AF4E:
	RTS		 ; Return

BorderOut_Left:
	LDX Map_EntTran_InitValIdx
	LDA BorderOut_VHLimitTRL,X

	LDX Map_EntTran_BorderLoop
	CMP Map_EntTran_BVAddrH,X
	BNE PRG026_AF70 		; If Map_EntTran_BVAddrH[Map_EntTran_BorderLoop] <> BorderOut_VHLimitTRL[Map_EntTran_InitValIdx], jump to PRG026_AF70

	LDA Map_EntTran_BVAddrL,X
	CMP #$02
	BNE PRG026_AF70	 		; If Map_EntTran_BVAddrL <> 2, jump to PRG026_AF70

	DEC Map_EntTran_BVAddrL,X	; PRG026_AF70--

	LDA Map_EntTran_InitValIdx	 
	CMP #$04	
	BLT PRG026_AF84	 		; If Map_EntTran_InitValIdx < 4, jump to PRG026_AF84
	BEQ PRG026_AF87	 		; If Map_EntTran_InitValIdx = 4, jump to PRG026_AF87

PRG026_AF70:

	; Map_EntTran_BVAddrH/L -= 33
	LDA Map_EntTran_BVAddrL,X
	SUB #33
	STA Map_EntTran_BVAddrL,X
	LDA Map_EntTran_BVAddrH,X
	SBC #$00
	STA Map_EntTran_BVAddrH,X

	INC Map_EntTran_LRCnt	 ; Map_EntTran_LRCnt++

PRG026_AF84:
	INC Map_EntTran_LRCnt	 ; Map_EntTran_LRCnt++

PRG026_AF87:
	LDA Map_EntTran_BVAddrH,X
	CMP #$27
	BNE PRG026_AF9C		; If Map_EntTran_BVAddrH <> $27, jump to PRG026_AF9C

	LDA #$23	 
	STA Map_EntTran_BVAddrH,X	; Map_EntTran_BVAddrH = $23

	LDA Map_EntTran_BVAddrL,X
	SUB #$40
	STA Map_EntTran_BVAddrL,X	; Map_EntTran_BVAddrL -= $40

PRG026_AF9C:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_Time
;
; Fills the StatusBar_Time array with tiles representing
; the current time remaining; also updates the clock
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Fill_Time:
	LDA Level_Tileset
	BEQ Timer_NoChange	 ; If Level_Tileset = 0, jump to Timer_NoChange (no timer on map EVER)
	CMP #15	 
	BGE Timer_NoChange	 ; If Level_Tileset >= 15, jump to Timer_NoChange
	LDA Level_TimerEn
	AND #$7f	 	; Only checking the timer disable here
	ORA Player_InPipe 	; ... or if Player is in pipe
	BNE Timer_NoChange 	; If set, timer is disabled!  Jump to Timer_NoChange

	DEC Level_TimerTick	; Level_TimerTick--
	BPL Timer_NoChange	; If Level_TimerTick >= 0, jump to Timer_NoChange

	; Reload Level_TimerTick
	LDA #$28
	STA Level_TimerTick	 ; Level_TimerTick = $28

	DEC Level_TimerLSD	; Level_TimerLSD--
	BPL PRG026_AFDC	 	; If it hasn't rolled over, jump to PRG026_AFDC

	; LSD rolled over!
	LDA #$09	 	
	STA Level_TimerLSD	; Level_TimerLSD = 9
	DEC Level_TimerMid	; Level_TimerMid--
	BPL PRG026_AFDC	 	; If it hasn't rolled over, jump to PRG026_AFDC

	; Mid rolled over!
	STA Level_TimerMid	; Level_TimerMid = 9
	DEC Level_TimerMSD	; Level_TimerMSD--
	BPL PRG026_AFDC	 	; If it hasn't rolled over, jump to PRG026_AFDC

	; At expiration of MSD, we're out of time!  Zero everybody!
	LDA #$00	 	
	STA Level_TimerMSD
	STA Level_TimerMid
	STA Level_TimerLSD

PRG026_AFDC:
	LDA Level_TimerMSD	
	CMP #$01	 	
	BNE Timer_NoChange	; If Level_TimerMSD <> 1, jump to Timer_NoChange

	; MSD is 1...
	LDA Level_TimerMid
	ORA Level_TimerLSD
	BNE Timer_NoChange	; If !(Level_TimerMid == 0 && Level_TimerLSD == 0), jump to Timer_NoChange

	; Time is running out!
	LDA #MUS1_TIMEWARNING	 
	STA Sound_QMusic1	; Queue low-time warning music!
Timer_NoChange:
	; For all 3 digits of time, write their tiles...
	LDX #$02	 	; X = 2
PRG026_AFF2:
	LDA Level_TimerMSD,X	; Get digit
	ORA #$f0	 	; Offset as tile
	STA StatusBar_Time,X	; Store it into StatusBar_Time
	DEX		 	; X--
	BPL PRG026_AFF2	 	; While X >= 0, loop!
	RTS		 ; Return


; FIXME: Anybody want to claim this?
; Uses graphics buffer to push out the 3 digits of timer unlike the special buffers used by status bar
; $AFFE 
	LDX Graphics_BufCnt	; X = graphics buffer count

	LDA #$2b	; VRAM High in non-vertical level

	LDY Level_7Vertical
	BEQ PRG026_B00A

	LDA #$27	; VRAM High in vertical level

PRG026_B00A:
	; VRAM High address
	STA Graphics_Buffer,X

	; VRAM Low address
	LDA #$51
	STA Graphics_Buffer+1,X

	; Run length of 3
	LDA #$03
	STA Graphics_Buffer+2,X

	; 3 timer digits
	LDA Level_TimerMSD
	ORA #$f0
	STA Graphics_Buffer+3,X
	LDA Level_TimerMid
	ORA #$f0
	STA Graphics_Buffer+4,X
	LDA Level_TimerLSD
	ORA #$f0
	STA Graphics_Buffer+5,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+6,X

	; Add to graphics buffer count
	TXA
	ADD #$06
	STA Graphics_BufCnt

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_Lives
;
; Fills the StatusBar_LivesL/H values with tiles representing
; the current lives held by the player
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Fill_Lives:
	LDX Player_Current	; X = Player_Current
	LDY #$00	 	; Y = 0
	LDA Player_Lives,X	; Get current player's lives count -> A
	CMP #$ff	 	
	BNE PRG026_B04D	 	; If lives <> $FF, jump to PRG026_B04D

	; Lives are $FF (last death at zero lives)
	LDA #$0E	 ; A = $E (this will appear as a blank tile)
	JMP PRG026_B061	 ; Jump to PRG026_B061

PRG026_B04D:
	CMP #100
	BLS PRG026_B056	 ; If Player's lives are under 100, jump to PRG026_B056

	LDA #99	
	STA Player_Lives,X	 ; Otherwise, force Player's lives to cap at 99
PRG026_B056:

	; Loop while A > 10, basically a rudimentary modulus for the
	; LSD; 'Y' will count the loops, and thus be the MSD
	CMP #10	 
	BMI PRG026_B061	 ; When A is under 10, jump to PRG026_B061
	SUB #10		 ; A -= 10 (find the LSD)
	INY		 ; Y++ (form the MSD)
	JMP PRG026_B056	 ; Loop again...

PRG026_B061:
	ADD #$f0	 	; Offset the LSD to the appropriate tile
	STA StatusBar_LivesL	; Store into StatusBar_LivesL
	TYA		 	; Most significant digit -> A
	BNE PRG026_B06C		; Anything but zero, jump to PRG026_B06C
	LDA #$0E	 	; Otherwise, use blank tile instead of leading zero
PRG026_B06C:
	ADD #$f0	 	; Offset to appropriate tile
	STA StatusBar_LivesH	; Store into StatusBar_LivesH
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_Coins
;
; Fills the StatusBar_CoinsL/H values with tiles representing
; the current coins held by the player; also applies the
; Coins_Earned value to the active total and issues 1-ups
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Fill_Coins:
	LDA #Inventory_Coins-Inventory_Items	 	; A = $22 (offset to Mario's coins)
	LDX Player_Current	; X = Player_Current
	BEQ PRG026_B07D	 	; If Player_Current = 0 (Mario), jump to PRG026_B07D
	ADD #(Inventory_Coins2-Inventory_Items)-(Inventory_Coins-Inventory_Items) 	; Otherwise, A = $45 (offset to Luigi's coins)
PRG026_B07D:
	LDY #$00	 	; Y = 0 (for loop at PRG026_B09F)
	TAX		 	; X = $22 / $45
	LDA Inventory_Items,X	; Getting this player's coins, not items, but Nintendo used this offset, so...
	ADD Coins_Earned 	; Add in any coins earned
	STA Inventory_Items,X	; Store total
	CMP #100	 	
	BLT PRG026_B09F	 	; If coin total is < 100, jump to PRG026_B09F

	SUB #100	 	; Take 100 away
	STA Inventory_Items,X	; Store new total

	LDX Player_Current	; X = Player_Current
	INC Player_Lives,X	; Extra life!

	LDA #SND_LEVEL1UP	 	
	STA Sound_QLevel1	; Play 1-up extra life sound

	;LDA #MUS2A_WORLD8	 	
	;STA Sound_QMusic2	; Now it's Sonic 2 Beta!

	; This continually subtracts 10 as long you have more than 10
	; coins, sort of a rudimentary modulus operation...
PRG026_B09F:
	CMP #10		
	BMI PRG026_B0AA	
	SUB #10	 	
	INY		; Y will be the most significant digit by virtue of loop counting
	JMP PRG026_B09F	

PRG026_B0AA:
	LDX Graphics_BufCnt	; X = Graphics_BufCnt
	ADD #$f0	 	; With 'A' as the lower coin digit, this adds $F0 to it to make the respective 0-9 tile 
	STA StatusBar_CoinL	; Store into StatusBar_CoinL
	TYA		 	; A = Y (most significant digit)
	BNE PRG026_B0B8	 	; If it's anything but zero, jump to PRG026_B0B8
	LDA #Temp_Var15	 	; Otherwise, we're going to use a blank, instead of a leading zero
PRG026_B0B8:
	ADD #$f0	 	; Offset to proper MSD tile
	STA StatusBar_CoinH	; Store into StatusBar_CoinH

	LDA #$00
	STA Coins_Earned ; Coins_Earned has been applied, remove

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_World
;
; Simply puts the correct world number in the status bar
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Fill_World:
	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	LDX World_Num	 	
	INX		 	; X = World_Num+1
	TXA		 	; A = X
	ORA #$f0	 	; Mark it up as a tile
	STA Graphics_Buffer+3,Y

	; Terminate prior graphic data
	LDA #$00
	STA Graphics_Buffer+4,Y

	LDX #$27	 	; X = $27 (VRAM High if vertical)
	LDA Level_7Vertical	
	BNE PRG026_B0EC	 	; If level is vertical, jump to PRG026_B0EC

	LDX #$2b	 	; X = $2B (VRAM High if non-vertical)

	LDA Level_Tileset
	CMP #16	 
	BEQ PRG026_B0EA	 	; If tileset = 16 (Spade game), jump to PRG026_B0EA

	CMP #17	 
	BNE PRG026_B0EC	 	; If tileset = 17 (N-Spade game), jump to PRG026_B0EC

PRG026_B0EA:
	LDX #$23		; X = $23 (VRAM High in Spade/N-Spade bonus games only)

PRG026_B0EC:
	TXA		 

	; VRAM Address High
	STA Graphics_Buffer,Y

	; VRAM Address Low
	LDA #$26
	STA Graphics_Buffer+1,Y

	; Run length of 1
	LDA #$01
	STA Graphics_Buffer+2,Y

	; Update Graphics_BufCnt
	LDA Graphics_BufCnt
	ADD #$04	 
	STA Graphics_BufCnt

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_MorL
;
; Simply puts the correct <M> or <L> in the status bar
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG026_B104:
	.byte $74, $75, $76, $77  ; Two tiles each, for <M> or <L>, respectively

StatusBar_Fill_MorL:
	LDA Player_Current
	ASL A		 	; A = Player_Current << 1
	TAX		 	; X = A
	LDA #$01	 	; A = 1
	STA <Temp_Var15		; Temp_Var15 = 1
	LDY Graphics_BufCnt	; Y = Graphics_BufCnt

	; Loop to copy the two tiles
PRG026_B114:
	LDA PRG026_B104,X	; Get player-relevant tile
	STA Graphics_Buffer+3,Y ; -> graphics buffer
 
	INX		 	; X++
	INY		 	; Y++
	DEC <Temp_Var15		; Temp_Var15--
	BPL PRG026_B114	 	; While Temp_Var15 > 0, loop!

	LDA #$00	 	
	STA Graphics_Buffer+3,Y	; Add a terminator

	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	LDX #$27	 	; X = $27 (VRAM address high if vertical)

	LDA Level_7Vertical
	BNE PRG026_B13E	 	; If level is vertical, jump to PRG026_B13E

	LDX #$2b	 	; X = $2B (VRAM address high if non-vertical)

	LDA Level_Tileset	

	CMP #16	 
	BEQ PRG026_B13C	 	; If Level_Tileset = 16 (Spade game), jump to PRG026_B13C

	CMP #17
	BNE PRG026_B13E	 	; If Level_Tileset = 17 (N-Spade game), jump to PRG026_B13E

PRG026_B13C:
	LDX #$23	 ; X = $23 (VRAM Address high for Spade/N-Spade bonus games only)

PRG026_B13E:

	; VRAM Address High
	TXA
	STA Graphics_Buffer,Y

	; VRAM Address low
	LDA #$42
	STA Graphics_Buffer+1,Y

	; Run length of 2
	LDA #$02
	STA Graphics_Buffer+2,Y

	; Update buffer count appropriately
	LDA Graphics_BufCnt	
	ADD #$05	 
	STA Graphics_BufCnt	
	RTS		 ; Return


PRG026_B156:
	.byte $2B, $48, $06, $00, $00, $00, $00, $00, $00, $00 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_Score
;
; Fills the StatusBar_PMT array with tiles representing
; the current score; also applies the
; Score_Earned value to the active total
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG026_B160:	.byte $00, $00, $00, $00, $00, $01
PRG026_B166:	.byte $00, $00, $00, $03, $27, $86
PRG026_B16C:	.byte $01, $0A, $64, $E8, $10, $A0
PRG026_B172:	.byte $0F, $42, $3F 

StatusBar_Fill_Score:
	LDA Player_Score+2	; Get least significant byte of score
	ADD Score_Earned	; Add in any earned points 
	STA Player_Score+2	; Store into least significant digit
	STA <Temp_Var1		; Keep LSD in Temp_Var1	 

	LDA Player_Score+1	; Get next higher byte
	ADC Score_Earned+1 	; Add score and carry to of earned high byte to middle score byte
	STA Player_Score+1	; Store result
	STA <Temp_Var2		; Keep middle digit in Temp_Var2

	LDA Player_Score	; Get most significant byte of score
	ADC #$00	 	; Add in any carry
	STA Player_Score	; Store result
	STA <Temp_Var3		; Keep MSD in Temp_Var3

	; This giant loop is how you use an 8-bit CPU to display
	; 6* digits of score from a 3-byte integer :)
	; * - The rightmost/least significant 0 is a placeholder, and 
	; will always be zero, thus score is always a multiple of 10
	LDY #$00	 ; Y = 0
	LDX #$05	 ; X = 5	0-5, 6 digits
PRG026_B19A:
	LDA <Temp_Var1	 ; Get LSD -> A

	; I haven't taken time yet to discern this magic yet
	SUB PRG026_B16C,X
	STA <Temp_Var1	
	LDA <Temp_Var2	
	SBC PRG026_B166,X
	STA <Temp_Var2	
	LDA <Temp_Var3	
	SBC PRG026_B160,X
	STA <Temp_Var3	

	BCC PRG026_B1B8	 	; If the subtraction didn't go negative, jump to PRG026_B1B8

	INC Score_Temp	 ; Score_Temp++

	JMP PRG026_B19A	 ; Jump to PRG026_B19A

PRG026_B1B8:
	LDA <Temp_Var1

	; I haven't taken time yet to discern this magic yet
	ADD PRG026_B16C,X
	STA <Temp_Var1	
	LDA <Temp_Var2	
	ADC PRG026_B166,X
	STA <Temp_Var2	
	LDA <Temp_Var3	
	ADC PRG026_B160,X
	STA <Temp_Var3	

	LDA Score_Temp	 
	ADD #$f0	 	; A = Score_Temp + $F0 (tile to display)
	STA StatusBar_Score,Y	; Store it as next digit

	LDA #$00	 	; A = 0
	STA Score_Temp	 	; Score_Temp = 0

	INY		 	; Y++
	DEX		 	; X--
	BPL PRG026_B19A	 	; While digits remain, loop!

	LDA StatusBar_Score	; First byte of status bar's score
	CMP #$fa	 
	BLT PRG026_B1FC	 	; If tile is less than $FA (overflow occurred!), jump to PRG026_B1FC

	; Tile is greater than $FA...
	LDX #$02	 	; X = 2
PRG026_B1E9:
	LDA PRG026_B172,X
	STA Player_Score,X

	DEX		 ; X--
	BPL PRG026_B1E9	 ; While X >= 0, loop!

	; All 9s across score when overflowed
	LDX #$05	 ; X = 5
	LDA #$f9	 ; A = $F9
PRG026_B1F6:
	STA StatusBar_Score,X	 
	DEX		 ; X--
	BPL PRG026_B1F6	 ; While X >= 0, loop 

PRG026_B1FC:
	; Clear Score_Earned
	LDA #$00	 
	STA Score_Earned	
	STA Score_Earned+1	
	RTS		 ; Return



; FIXME: Anybody want to claim this?
; Uses graphics buffer to push out the score unlike the special buffers used by status bar
; $B205
	LDX Graphics_BufCnt	 ; X = graphics buffer count

	LDY #$00	 ; Y = 0
PRG026_B20A:
	LDA PRG026_B156,Y
	STA Graphics_Buffer,X

	INX		 ; X++
	INY		 ; Y++

	CPY #$0a
	BNE PRG026_B20A	 ; While Y <> $0A, loop

	LDX Graphics_BufCnt	 ; X = graphics buffer count

	; Put score in buffer
	LDY #$00	 ; Y = 0
PRG026_B21B:
	LDA StatusBar_Score,Y
	STA Graphics_Buffer+3,X

	INX		 ; X++
	INY		 ; Y++

	CPY #$06
	BNE PRG026_B21B	 ; While Y <> $06, loop

	LDY Graphics_BufCnt	; Y = graphics buffer count

	LDX #$27	 ; X = $27 (VRAM High address if vertical)

	LDA Level_7Vertical
	BNE PRG026_B23E	 ; If level is vertical, jump to PRG026_B23E

	LDA Level_Tileset

	CMP #16
	BEQ PRG026_B23C	 ; If Level_Tileset = 16 (Spade game), jump to PRG026_B23C

	CMP #17
	BNE PRG026_B242	 ; If Level_Tileset <> 17 (N-Spade game), jump to PRG026_B242

PRG026_B23C:
	LDX #$23	; X = $23 (VRAM High address for Spade/N-Spade bonus games ONLY)

PRG026_B23E:

	; Set VRAM high address
	TXA
	STA Graphics_Buffer,Y

PRG026_B242:

	; Update graphics buffer count
	TYA
	ADD #$09
	STA Graphics_BufCnt

	RTS		 ; Return

; FIXME: Anybody want to claim this?
; $B24A
	.byte $2B, $28, $08, $EF, $EF, $EF, $EF, $EF, $EF, $3C, $3D, $00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Fill_PowerMT
;
; Fills the StatusBar_PMT array with tiles representing
; the current "charge" of the power meter in the status bar
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Fill_PowerMT:
	LDY #$00		; Y = 0
	LDA #$01		; A = 1
	STA <Temp_Var15		; <Temp_Var15 = 1

	; This checks each bit of Player_Power to see if it's set or not,
	; and produces the proper state of the '>' in the array StatusBar_PMT
PRG026_B25C:
	LDX #$ef		; X = $EF (dark '>')
	LDA Player_Power	; Player's current "Power" charge (each "unit" of power sets one more bit in this field)
	AND <Temp_Var15		; A = Player_Power & Temp_Var15
	BEQ PRG026_B267	 	; If Player_Power bit not set, jump to PRG026_B267
	LDX #$ee		; Otherwise, X = $EE (glowing '>')
PRG026_B267:
	TXA		 	; A = X ($EF dark or $EE glowing)
	STA StatusBar_PMT,Y	; Store this tile into the buffer
	INY		 	; Y++
	ASL <Temp_Var15		; Shift up to next power bit
	LDA <Temp_Var15		; A = Temp_Var15
	CMP #$40	 	
	BNE PRG026_B25C	 	; If Temp_Var15 <> $40, loop!

	; Temp_Var15 is $40...
	LDX #$3c	 	; X = $3C (dark [P])
	LDA Player_Power	; A = Player_Power
	AND <Temp_Var15		; Checking bit 7 or 8...
	BEQ PRG026_B289	 	; Not set, jump to PRG026_B289

	; Player is at max power!  Set [P] flash state
	DEC MaxPower_Tick	; PRG026_B289--
	LDA MaxPower_Tick	; A = PRG026_B289
	AND #$08	 	
	BNE PRG026_B289	 	; If bit 3 not set, jump to PRG026_B289
	LDX #$2c	 	; X = $2C (light [P])

PRG026_B289:
	TXA		 	; A = X
	STA StatusBar_PMT,Y	; Store left half [P] tile as decided
	INX		 	; X++
	TXA		 	; A =X
	STA StatusBar_PMT+1,Y	; And the right half

PRG026_B292:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; Video_Misc_Updates
;
; This routine appears to be responsible for all video updates
; OTHER than scrolling, which includes palettes, clearing the
; "WORLD x" thing from a world map introduction, updating the
; status bar, printing "COURSE CLEAR!", etc...
;
; Loads data as specified from table Video_Upd_Table in PRG030 (see there for format and data source!)
; Cloned in its entirety in PRG024 (i.e. Video_Misc_Updates2)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Video_Misc_Updates:

	LDY #$00	 	; Y = 0
	LDA [Video_Upd_AddrL],Y	; Get byte
	BEQ PRG026_B292	 	; If 0, jump to PRG026_B292 (RTS)

	LDX PPU_STAT	 	; Flush video

	STA PPU_VRAM_ADDR	; Store byte into video address high
	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_ADDR	; Store byte into video address low

	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte...

	ASL A		 	; Its uppermost bit dictates whether to use horizontal (1B) or vertical (32B) advancement
	PHA		 	; Save A

	LDA <PPU_CTL1_Copy	; Get PPU_CTL1 settings
	ORA #$04	 	; Set PPU update vertical (each write advances by 32)
	BCS PRG026_B2B2		; If bit 7 was set, jump to PRG026_B2B2
	AND #$fb		; Otherwise, use horizontal updates! (clears vertical bit)

PRG026_B2B2:
	STA PPU_CTL1		; Update PPU_CTL1
	STA <PPU_CTL1_Copy	; Update PPU_CTL1_Copy

	PLA		; Restore A

	ASL A		 ; Check next bit...
	BCC PRG026_B2BE	 ; If not set, jump to PRG026_B2BE
	ORA #$02	 ; Otherwise, remaining value gets bit 1 set (forces skip of first increment)
	INY		 ; Y++ 

PRG026_B2BE:
	; Restore remainder of byte read (6-bits for value)
	LSR A
	LSR A
	TAX		 ; Keep it in X

	; The following will continuously write bytes from the stream
	; directly into the PPU 'X+1' times
PRG026_B2C1:
	BCS PRG026_B2C4	 ; If carry set, jump to PRG026_B2C4
	INY		 ; Y++
PRG026_B2C4:
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_DATA	; Store into PPU
	DEX		 	; X--
	BNE PRG026_B2C1	 	; While X <> 0, loop! 

	; This advances the current position of the pointer so 'Y' can go
	; back to zero and we begin again...
	INY		 ; Y++
	TYA		 ; A = Y
	ADD <Video_Upd_AddrL
	STA <Video_Upd_AddrL
	LDA <Video_Upd_AddrH
	ADC #$00	 
	STA <Video_Upd_AddrH	; Entire video address value has 'Y' added to it
	JMP Video_Misc_Updates	; Jump back to start to process next command or terminate!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Commit_Column
;
; This subroutine takes the buffered set of tiles in Scroll_PatStrip
; and commits them to actual VRAM, OR it takes the buffer attribute
; bytes and commits those.
; Used by both the world map and a standard horizontally scrolling level
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Commit_Column:
	LDA PPU_STAT

	LDA Scroll_ToVRAMHi	; A = Scroll_ToVRAMHi
	BEQ PRG026_B354	 	; If Scroll_ToVRAMHi = 0, jump to PRG030_B354
	LDX #$00	 	; X = 0
	LDA Scroll_ToVRAMHi	; A = Scroll_ToVRAMHi
	STA PPU_VRAM_ADDR	; Write as high byte to VRAM address
	LDA Scroll_LastCol8	
	STA PPU_VRAM_ADDR	; Low byte is Scroll_LastCol8
	LDA <PPU_CTL1_Copy	; Get the PPU_CTL1
	ORA #$04	 	; Use vertical update mode
	STA PPU_CTL1	 	; Set PPU_CTL1

PRG026_B2F9:

	; Push 5 blocks in
	LDA Scroll_PatStrip,X	 
	STA PPU_VRAM_DATA	 
	LDA Scroll_PatStrip+1,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+2,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+3,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+4,X
	STA PPU_VRAM_DATA	

	INX
	INX
	INX
	INX
	INX		; X += 5

	CPX #30	
	BNE PRG026_B2F9	; While X < 30, loop!

	; Begin update on Nametable 2
	LDA Scroll_ToVRAMHi	
	ORA #$08	 	
	STA PPU_VRAM_ADDR	
	LDA Scroll_LastCol8	
	STA PPU_VRAM_ADDR	

PRG026_B32E:
	; Push another 4
	LDA Scroll_PatStrip,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+1,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+2,X
	STA PPU_VRAM_DATA	
	LDA Scroll_PatStrip+3,X
	STA PPU_VRAM_DATA	 

	INX		
	INX		
	INX		
	INX		 ; X += 4

	CPX #30+24	 ; 24 more rows...!
	BNE PRG026_B32E	 ; While X < 54, loop! (54 rows of 8 gets down to the status bar in the NTSC model)

	LDA #$00	 
	STA Scroll_ToVRAMHi	 ; Scroll_ToVRAMHi = 0
	RTS		 ; Return

PRG026_B354:
	; If Scroll_ToVRAMHi = 0 ... do we need to commit any attribute updates??
	LDA Scroll_ToVRAMHA
	BEQ PRG026_B38E	 ; If Scroll_ToVRAMHA = 0, jump to PRG026_B38E (RTS)

	; Commiting attribute updates...
	LDA <PPU_CTL1_Copy
	STA PPU_CTL1	 	; Update PPU_CTL1

	LDX #$00	 	; X = 0
	LDY Scroll_LastAttr	; Y = Scroll_LastAttr (low part)
PRG026_B363:
	LDA Scroll_ToVRAMHA	; A = Scroll_ToVRAMHA (high part)
	STA PPU_VRAM_ADDR	; Set high address
	STY PPU_VRAM_ADDR	; Set low address
	LDA Scroll_AttrStrip,X	; Get next attribute byte
	STA PPU_VRAM_DATA	; Commit it!
	TYA		 
	ADD #$08	 
	TAY		 	; Y += 8
	BCC PRG026_B384	 	; If we haven't overflowed, jump to PRG026_B384

	; Update high byte 
	LDA Scroll_ToVRAMHA
	EOR #$08	 	; Flips to attribute table 2
	STA Scroll_ToVRAMHA
	LDY Scroll_LastAttr	; Get low byte
PRG026_B384:
	INX		 	; X++
	CPX #14
	BNE PRG026_B363	 	; If X <> 14, loop!

	LDA #$00	 
	STA Scroll_ToVRAMHA	 ; Scroll_ToVRAMHA = 0 (update complete!)

PRG026_B38E:
	RTS		 ; Return


Scroll_ToVRAM_Apply:
	LDA PPU_STAT

	LDA Scroll_ToVRAMHi
	BEQ PRG026_B3BD	 ; If Scroll_ToVRAMHi = 0 (no scrolled pattern update required), jump to PRG026_B3BD

	LDX #$00	 ; X = 0

	; Set high byte of VRAM address
	LDA Scroll_ToVRAMHi
	STA PPU_VRAM_ADDR

	; Set low byte of VRAM address
	LDA Scroll_LastCol8
	STA PPU_VRAM_ADDR

	; Do increment by 1
	LDA <PPU_CTL1_Copy
	AND #~$04
	STA PPU_CTL1

PRG026_B3AC:
	LDA Scroll_PatStrip,X	; Get next block
	STA PPU_VRAM_DATA	; Write to VRAM
	INX		 	; X++
	CPX #32			
	BNE PRG026_B3AC		; While X < 32, loop!

	; Scroll_ToVRAMHi = 0 (update complete)
	LDA #$00	 
	STA Scroll_ToVRAMHi	 ; Scroll_ToVRAMHi = 0

	RTS		 ; Return


PRG026_B3BD:
	LDA Scroll_ToVRAMHA
	BEQ PRG026_B3E5	  ; If Scroll_ToVRAMHA = 0 (no scrolled attribute update required), jump to PRG026_B3E5 (RTS)

	; Reset PPU_CTL1
	LDA <PPU_CTL1_Copy
	STA PPU_CTL1

	LDX #$00	 ; X = 0
	; Set high byte of VRAM address
	LDA Scroll_ToVRAMHA
	STA PPU_VRAM_ADDR

	; Set low byte of VRAM address
	LDA Scroll_LastAttr
	STA PPU_VRAM_ADDR

PRG026_B3D5:
	; Set next byte of attribute data
	LDA Scroll_AttrStrip,X
	STA PPU_VRAM_DATA

	INX		 ; X++ (next attribute byte)
	CPX #$08
	BLT PRG026_B3D5	 ; While X < 8, loop!

	; Scroll_ToVRAMHA = 0 (update complete)
	LDA #$00
	STA Scroll_ToVRAMHA

PRG026_B3E5:
	RTS		 ; Return

TileChng_VRAMCommit:
	LDY TileChng_VRAM_H
	BEQ PRG026_B38E	 ; If TileChng_VRAM_H = 0 (no tile change to do), jump to PRG026_B38E (RTS)

	LDA PPU_STAT

	; Switch to +1 increment mode
	LDA <PPU_CTL1_Copy
	AND #~$04
	STA PPU_CTL1

	LDA TileChng_VRAM_L	; Get VRAM low address
	STY PPU_VRAM_ADDR	; Set VRAM high address
	STA PPU_VRAM_ADDR	; Set VRAM low address

	; Commit the top two patterns
	LDA TileChng_Pats
	STA PPU_VRAM_DATA
	LDA TileChng_Pats+1
	STA PPU_VRAM_DATA

	; Set VRAM address at base +32
	LDA TileChng_VRAM_L
	ADD #32		; +32 to jump to next line
	STY PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR

	; Commit the lower two patterns
	LDA TileChng_Pats+2
	STA PPU_VRAM_DATA
	LDA TileChng_Pats+3
	STA PPU_VRAM_DATA

	; TileChng_VRAM_H = 0 (Tile update commit completed!)
	LDA #$00
	STA TileChng_VRAM_H

	RTS		 ; Return

; Same format as data from Video_Upd_Table in PRG030, check there for details
; This is used as a template, but actual values will be overwritten below...
StatusBar_UpdTemplate:
	vaddr $2B28
	.byte $0C, $EF, $EF, $EF, $EF, $EF, $EF, $AE, $AF, $FE, $EC, $F0, $F0
	vaddr $2B45
	.byte $0F, $FE, $F0, $FE, $F0, $F0, $F0, $F0, $F0, $F0, $F0, $FE, $ED, $F0, $F0, $F0
	.byte $00 ; Terminator

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_UpdateValues
;
; This subroutine basically handles all of the status bar updates
; besides cards; it inserts all of the following data:
; Power meter, coins, lives, score, time
; ... and performs updates where relevant, and even pushes it to the
; graphics buffer for commitment later on!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_UpdateValues:
	JSR StatusBar_Fill_PowerMT	; Fill in StatusBar_PMT with tiles of current Power Meter state
	JSR StatusBar_Fill_Coins	; Fill in StatusBar_CoinsL/H with tiles for coins held; also applies Coins_Earned
	JSR StatusBar_Fill_Lives	; Fill in StatusBar_LivesL/H with tiles for lives held
	JSR StatusBar_Fill_Score 	; Fill in StatusBar_Score with tiles for score; also applies Score_Earned
	JSR StatusBar_Fill_Time	 	; Fill in StatusBar_Time with tiles for time; also updates clock

	LDX #$00	 	; X = 0
	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	BEQ PRG026_B466	 	; If graphics buffer is empty, jump to PRG026_B466

	; Graphics buffer has content... skips delay functionality:
	STX StatusBar_UpdFl	; StatusBar_UpdFl = 0
	JMP PRG026_B47A	 	; Jump to PRG026_B47A

PRG026_B466:
	; No data in graphics buffer, adds delay functionality

	; Basically, only one of two frames update the status
	; bar if the buffer is otherwise empty... I guess the
	; contrary is "well, they'll be processing update data
	; anyway, so we might as well get in there..."

	INC StatusBar_UpdFl	; StatusBar_UpdFl++
	LDA StatusBar_UpdFl	; A = StatusBar_UpdFl
	AND #$01	 	; going for a toggle
	BNE PRG026_B47A	 	; If set, jump to PRG026_B47A

	LDA #$00	 	
	STA StatusBar_UpdFl	; StatusBar_UpdFl = 0
	LDA #$06	 	;
	STA <Graphics_Queue	; Set Graphics_Queue = 6 (6?? Does it matter?)
	RTS		 ; Return

	; Arriving, X = 0, Y = Graphics_BufCnt
	; Copy StatusBar_UpdTemplate into the graphics buffer, which makes
	; room for everything to be done to the status bar, and includes
	; things like the video addresses and whatnot...
PRG026_B47A:
	LDA StatusBar_UpdTemplate,X	; Get next byte from StatusBar_UpdTemplate
	STA Graphics_Buffer,Y		; Store it into the graphics buffer
	INY				; Y++
	INX				; X++
	CPX #$22	 	
	BNE PRG026_B47A	 		; If X <> $22, loop!

	; *** Power meter copy loop
	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	LDX #$00	 	; X = 0
PRG026_B48B:
	LDA StatusBar_PMT,X	 
	STA Graphics_Buffer+3,Y	 
	INY		 	; Y++
	INX		 	; X++
	CPX #$08	 	
	BNE PRG026_B48B	 	; While X <> 8, loop!

	; *** Coins copy
	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	LDA StatusBar_CoinH	 
	STA Graphics_Buffer+13,Y
	LDA StatusBar_CoinL	
	STA Graphics_Buffer+14,Y

	; *** Lives copy
	LDY Graphics_BufCnt	 ; Y = Graphics_BufCnt
	LDA StatusBar_LivesH	
	STA Graphics_Buffer+18,Y
	LDA StatusBar_LivesL	
	STA Graphics_Buffer+19,Y

	; *** Score copy loop
	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	LDX #$00	 	; X = 0
PRG026_B4BA:
	LDA StatusBar_Score,X
	STA Graphics_Buffer+21,Y
	INY		 ; Y++
	INX		 ; X++
	CPX #$06	 
	BNE PRG026_B4BA	 ; If X <> 6, loop!

	; *** Time copy loop
	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	LDX #$00	 	; X = 0
PRG026_B4CB:
	LDA StatusBar_Time,X	
	STA Graphics_Buffer+30,Y
	INY		 ; Y++
	INX		 ; X++
	CPX #$03	 
	BNE PRG026_B4CB	 ; If X <> 3, loop!

	LDY Graphics_BufCnt	; Y = Graphics_BufCnt

	LDX #$27	 	; X = $27 (VRAM High address if vertical)

	LDA Level_7Vertical	
	BNE PRG026_B4EE	 	; If level is vertical, jump to PRG026_B4EE

	LDA Level_Tileset

	CMP #16	
	BEQ PRG026_B4EC	 	; If Level_Tileset = 16 (Spade game), jump to PRG026_B4EC

	CMP #17
	BNE PRG026_B4F5	 	; If Level_Tileset = 17 (N-Spade game), jump to PRG026_B4F5

PRG026_B4EC:
	LDX #$23	; X = $23 (VRAM High address for Spade/N-Spade bonus games ONLY)
PRG026_B4EE:

	; VRAM High address
	TXA
	STA Graphics_Buffer,Y
	STA Graphics_Buffer+15,Y

PRG026_B4F5:
	; Update graphics buffer count
	LDA Graphics_BufCnt
	ADD #$21	 
	STA Graphics_BufCnt	 

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_CopyObjectList
;
; Copies the level's object list in from ROM to RAM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_CopyObjectList:
	LDY #$00	 ; Y = 0

	LDA [Level_ObjPtr_AddrL],Y	; Get first byte from object layout data
	STA Level_Objects,Y	 	; Copy to beginning of Level_Objects array

PRG026_B506:

	; Next byte is ID of object (or $FF to terminate the list)
	INY
	LDA [Level_ObjPtr_AddrL],Y
	STA Level_Objects,Y

	CMP #$ff	 
	BEQ PRG026_B51F	 	; If terminator hit, jump to PRG026_B51F (RTS)

	; Copy in start column of object
	INY		 
	LDA [Level_ObjPtr_AddrL],Y
	STA Level_Objects,Y

	; Copy in start row of object
	INY
	LDA [Level_ObjPtr_AddrL],Y
	STA Level_Objects,Y

	JMP PRG026_B506		; Loop!

PRG026_B51F:
	RTS		 ; Return

; Rest of ROM bank was empty...
