; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-01-05 18:11:17.050297840 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
Tile_Layout_TS18:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $FC, $3B, $FF, $CC, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $BC, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DC, $EC, $EC, $EC, $FF, $FF, $FF, $FF, $FF, $29, $28, $2D, $29, $FF, $2B, $2D ; Tiles $40 - $4F
	.byte $00, $14, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $50, $40, $52, $42, $BC, $B0, $BE, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2 ; Tiles $80 - $8F
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2 ; Tiles $90 - $9F
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $8C, $8E, $8C ; Tiles $A0 - $AF
	.byte $8E, $8C, $8E, $8C, $8E, $52, $52, $50, $40, $42, $AC, $AE, $98, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $18, $02, $02, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $FC, $3A, $FF, $CD, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $BD, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DD, $ED, $ED, $ED, $24, $28, $25, $FF, $28, $26, $28, $28, $27, $FF, $28, $28 ; Tiles $40 - $4F
	.byte $10, $15, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $51, $41, $53, $43, $BD, $B1, $BF, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3 ; Tiles $80 - $8F
	.byte $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3 ; Tiles $90 - $9F
	.byte $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $9C, $9E, $9C ; Tiles $A0 - $AF
	.byte $9E, $9C, $9E, $9C, $9E, $53, $53, $51, $41, $43, $AC, $AE, $99, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $18, $12, $12, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $FC, $FC, $FF, $CE, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $BE, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DE, $EE, $EE, $EE, $FF, $FF, $FF, $FF, $FF, $2A, $2D, $2D, $FF, $29, $28, $29 ; Tiles $40 - $4F
	.byte $01, $16, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $70, $40, $72, $42, $E8, $B0, $EA, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2 ; Tiles $80 - $8F
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2 ; Tiles $90 - $9F
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $B2, $8D, $8F, $8D ; Tiles $A0 - $AF
	.byte $8F, $8D, $8F, $8D, $8F, $72, $72, $70, $40, $42, $AD, $AF, $9A, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $19, $03, $03, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $FC, $FC, $FF, $CF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $BF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DF, $EF, $EF, $EF, $28, $28, $FF, $24, $25, $28, $28, $28, $FF, $26, $28, $27 ; Tiles $40 - $4F
	.byte $11, $17, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $71, $41, $73, $43, $E9, $B1, $EB, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3 ; Tiles $80 - $8F
	.byte $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3 ; Tiles $90 - $9F
	.byte $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $B3, $9D, $9F, $9D ; Tiles $A0 - $AF
	.byte $9F, $9D, $9F, $9D, $9F, $73, $73, $71, $41, $43, $AD, $AF, $9B, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $19, $13, $13, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

Tile_Attributes_TS18:
	.byte $32, $50, $AD, $C1, $32, $50, $AD, $C1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS18
;
; Entry point for loading level layout data for Level_Tileset = 18
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS18:
	; Clear tiles to black
	LDY #$00	 ; Y = 0
PRG014_C40A:
	LDA #TILE18_BLACK
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA

	CPY #$f0
	BNE PRG014_C40A

	; Set the brick foor
	LDY #$d0	 ; Y = $D0
PRG014_C418:
	LDA #TILE18_BRICKFLOOR
	JSR Tile_Mem_ClearA

	CPY #$f0
	BNE PRG014_C418

	JMP LevelLoad	; Begin actual level loading!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS18
;
; Based on the values in Temp_Var15 and LL_ShapeDef, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG014_C424:
	.byte 0, 15, 30, 45, 60, 75, 90, 105

LoadLevel_Generator_TS18:
	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = upper 3 bits of Temp_Var15 (0-7) (selects a multiple of 15 as the base)

	LDA LL_ShapeDef
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = upper 4 bits of LL_ShapeDef shifted down
	ADD PRG014_C424,X	; Add multiple of 15
	TAX
	DEX
	TXA		 ; A = ((LL_ShapeDef >> 4) + PRG023_A419[X]) - 1

	; PRG014_C424 provides values reserved for expansion...

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_VsBrickTiles	;  0 - Place a run of brick tiles
	.word LoadLevel_VsBounceBlocks	;  1 - Place a run of bounce block tiles
	.word LoadLevel_VsDiamondBlocks	;  2 - Place a run of [UNUSED] SMB1-ish diamond tiles
	.word LoadLevel_VsCoins		;  3 - UNUSED; Places regular SMB3 coins and employs the coin tracking (Level_BlockGrabHitMem)
	.word LoadLevel_VsLadder	;  4 - Place a vertical run of ladder tiles
	.word $0000	;  5 - N/A
	.word $0000	;  6 - N/A
	.word $0000	;  7 - N/A
	.word $0000	;  8 - N/A
	.word $0000	;  9 - N/A
	.word $0000	; 10 - N/A
	.word $0000	; 11 - N/A
	.word $0000	; 12 - N/A
	.word $0000	; 13 - N/A
	.word $0000	; 14 - N/A
	.word $0000	; 15 - N/A
	.word $0000	; 16 - N/A
	.word $0000	; 17 - N/A
	.word $0000	; 18 - N/A
	.word $0000	; 19 - N/A
	.word $0000	; 20 - N/A
	.word $0000	; 21 - N/A
	.word $0000	; 22 - N/A
	.word $0000	; 23 - N/A

	; NOTE: These are stock, I'm not sure which are used or which work correctly.
	; Of course, little 2P Vs Mario/Luigi don't have code to actually use these
	; like the pipes they represent...
	.word LoadLevel_VGroundPipeRun		; 24 - Vertical ground pipe 1 (alt level)
	.word LoadLevel_VGroundPipeRun		; 25 - Vertical ground pipe 2 (Big [?] area)
	.word LoadLevel_VGroundPipeRun		; 26 - Vertical ground pipe 3 (no entrance)
	.word LoadLevel_VCeilingPipeRun		; 27 - Vertical ceiling pipe 1 (alt level)
	.word LoadLevel_VCeilingPipeRun		; 28 - Vertical ceiling pipe 2 (no entrance)
	.word LoadLevel_HRightWallPipeRun	; 29 - Horizontal right-hand wall pipe (alt level)
	.word LoadLevel_HRightWallPipeRun	; 30 - Horizontal right-hand wall pipe (no entrance)
	.word LoadLevel_HLeftWallPipeRun	; 31 - Horizontal left-hand wall pipe (alt level)
	.word LoadLevel_HLeftWallPipeRun	; 32 - Horizontal left-hand wall pipe (no entrance)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS18
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS18:
	; It is verified before calling this function that all of
	; the upper 4 bits of LL_ShapeDef are ZERO

	; So the upper 3 bits of Temp_Var15 serve as the most significant bits
	; to a value where LL_ShapeDef provide the 4 least significant bits

	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	ADD LL_ShapeDef	
	TAX		 	; Resultant index is put into 'X'
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_VsLeftPipes	;  0 - Left side of screen pipes that appear in the "typical" levels
	.word LoadLevel_VsRightPipes	;  1 - Right side of screen pipes that appear in the "typical" levels
	.word LoadLevel_VsQBlock	;  2 - [?] block from the ladder climbing game
	.word LoadLevel_VsStatusBar	;  3 - Tiles that make up the status bar

Vs_Battlefields:
	.word Vs_BattlefieldTypical	;  0: Spiny Only
	.word Vs_BattlefieldTypical	;  1: Fighter Fly Only
	.word Vs_BattlefieldTypical	;  2: Spiny and Fighter Fly
	.word Vs_BattlefieldTypical	;  3: Static coins
	.word Vs_BattlefieldTypical	;  4: Spiny and Sidestepper
	.word Vs_BattlefieldTypical	;  5: Fighter Fly and Sidestepper
	.word Vs_BattlefieldTypical	;  6: Sidestepper Only
	.word Vs_BattlefieldFountain	;  7: Coin Fountain
	.word Vs_BattlefieldTypical	;  8: Spiny Only
	.word Vs_BattlefieldTypical	;  9: Fighter Fly Only 
	.word Vs_BattlefieldTypical	; 10: Sidestepper Only
	.word Vs_BattlefieldLadders	; 11: Ladder and [?] blocks


	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/2PVs.asm"


LoadLevel_VsBrickTiles:
	LDX #$00	; X = 0 (place brick tiles)
	JMP PRG014_C580	 ; Jump to PRG014_C580

LoadLevel_VsBounceBlocks:
	LDX #$01	; X = 1 (place bounce block tiles)
	JMP PRG014_C580	 ; Jump to PRG014_C580

PRG014_C57B:
	.byte TILE18_BRICKFLOOR, TILE18_BOUNCEBLOCK, TILE18_DIAMOND

LoadLevel_VsDiamondBlocks:
	LDX #$02	; X = 2 (place SMB1-ish diamond tiles)

PRG014_C580:

	; Temp_Var1 = run length of tiles
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var1

	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_C58A:
	LDA PRG014_C57B,X	 ; Get tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 ; Y++ (next column)

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG014_C58A	 ; While Temp_Var1 >= 0, loop

	RTS		 ; Return


LoadLevel_VsLadder:
	; Run -> 'X'
	LDA LL_ShapeDef
	AND #$0f
	TAX

	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_C59E:
	LDA #TILE18_LADDER
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; +16 bytes to next row
	TYA
	ADD #16
	TAY

	DEX		 ; X--
	BPL PRG014_C59E	 ; While X >= 0, loop

	RTS		 ; Return

LoadLevel_VsLeftPipes:
	LDX #$00	 ; X = 0 (left pipe offset)
	JMP PRG014_C5BA	 ; Jump to PRG014_C5BA

PRG014_C5B0:
	; Left pipe
	.byte $81, $80
	.byte $83, $82

	; Right pipe
	.byte $80, $81
	.byte $82, $83

LoadLevel_VsRightPipes:
	LDX #$04	 ; X = 4 (right pipe offset)

PRG014_C5BA:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_C5BD:
	LDA PRG014_C5B0,X	 ; PRG014_C5BD 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 ; Y++ (next column)
	INX		 ; X++ (next tile)

	TXA
	AND #$01
	BNE PRG014_C5BD	 ; Every other tile, jump to PRG014_C5BD

	LDA TileAddr_Off
	ADD #16		; +16 to next row
	TAY		 ; -> 'Y'

	TXA
	AND #$03
	BNE PRG014_C5BD	 ; If haven't done 4 tiles yet, jump to PRG014_C5BD

	RTS		 ; Return

LoadLevel_VsQBlock:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE18_QBLOCK
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return

Vs_StatusBarTiles:
	.byte TILE18_MSTATUS_UL, TILE18_STATUS_UM, TILE18_STATUS_UM, TILE18_STATUS_UM, TILE18_MSTATUS_UR, TILE18_LSTATUS_UL, TILE18_STATUS_UM, TILE18_STATUS_UM, TILE18_STATUS_UM, TILE18_LSTATUS_UR
	.byte TILE18_MSTATUS_LL, TILE18_MSTATUS_LML, TILE18_STATUS_LM, TILE18_STATUS_LM, TILE18_MSTATUS_LR, TILE18_LSTATUS_LL, TILE18_LSTATUS_LML, TILE18_STATUS_LM, TILE18_STATUS_LM, TILE18_LSTATUS_LR
Vs_StatusBarTiles_End

LoadLevel_VsStatusBar:
	LDX #$00		; X = 0

PRG014_C5F4:
	LDY TileAddr_Off	; Y = TileAddr_Off

	; Temp_Var1 = tiles per row - 1
	LDA #(((Vs_StatusBarTiles_End - Vs_StatusBarTiles) / 2) - 1)
	STA <Temp_Var1

PRG014_C5FB:
	LDA Vs_StatusBarTiles,X
	STA [Map_Tile_AddrL],Y

	INY		 ; Y++
	INX		 ; X++

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG014_C5FB	 ; While Temp_Var1 >= 0, loop

	; Go to next row
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off

	CPX #(Vs_StatusBarTiles_End - Vs_StatusBarTiles)
	BNE PRG014_C5F4	 ; If we have another row to do, loop!

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Door1
;
; Puts 2 TILEA_DOOR1 tiles, stacked vertically
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Door1:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA #TILEA_DOOR1	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Move to next row by adding 16 to tile offset
	TYA		 
	ADD #16
	TAY		 
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA #TILEA_DOOR1	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Door2
;
; Puts 2 TILEA_DOOR2 tiles, stacked vertically
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Door2:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA #TILEA_DOOR2	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Move to next row by adding 16 to tile offset
	TYA		 
	ADD #16
	TAY		 
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA #TILEA_DOOR2	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VGroundPipeRun
;
; Generates a vertical pipe which runs into the ground (i.e. 
; no visible bottom is applied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_VertPipe:
	.byte TILE1_PIPETB1_L, TILE1_PIPETB1_R	; alt level
	.byte TILE1_PIPETB3_L, TILE1_PIPETB3_R	; Big [?] area
	.byte TILE1_PIPETB2_L, TILE1_PIPETB2_R	; not enterable

LL_VertPipeTransit:
	.byte TILE1_PIPETB4_L, TILE1_PIPETB4_R	; within level transit

LL_VertPipe4:
	.byte TILE3_PIPETB5_L, TILE3_PIPETB5_R	; exits to common end area
	
LoadLevel_VGroundPipeRun:

	; Backup original Map_Tile_AddrL/H to Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	SUB #$90	
	AND #$f0	
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = index to pipe (so relative index * 2 I think)

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of run)

	LDY TileAddr_Off	; Y = TileAddr_Off

	LDA LL_VertPipe,X	 ; Get this pipe tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	LDA LL_VertPipe+1,X	 ; Get pipe's right-hand tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_C688	 	 ; Jump to PRG014_C688

PRG014_C67A:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE1_PIPEVL
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	LDA #TILE1_PIPEVR
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_C688:

	; Restore backup Map_Tile_Addr
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 bytes
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update backup Map_Tile_AddrH

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_C67A	 	 ; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VCeilingPipeRun
;
; Generates a vertical pipe which runs into the ceiling (i.e. 
; no visible top is applied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VCeilingPipeRun:
	LDA LL_ShapeDef
	PHA		; Save LL_ShapeDef
	SUB #$c0	
	AND #$f0	
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = index to pipe (so relative index * 2 I think)

	PLA		 	; Restore LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (length of run)

PRG014_C6B8:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

PRG014_C6C0:
	LDY TileAddr_Off	; Y = TileAddr_off

	; Store left/right top of pipe into tile mem
	LDA #TILE1_PIPEVL
	STA [Map_Tile_AddrL],Y
	JSR LoadLevel_NextColumn ; Next column
	LDA #TILE1_PIPEVR	 
	STA [Map_Tile_AddrL],Y	 

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Move to next row by adding 16 bytes to Map_Tile_Addr
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	DEC <Temp_Var3		; Temp_Var3--
	BNE PRG014_C6C0	 	; While Temp_Var3 > 0, loop!

	; Bottom of pipe
	LDY TileAddr_Off	
	LDA LL_VertPipe,X	
	STA [Map_Tile_AddrL],Y	
	JSR LoadLevel_NextColumn ; Next column
	LDA LL_VertPipe+1,X	
	STA [Map_Tile_AddrL],Y	

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VTransitPipeRun
;
; Generates a vertical in-level transit style pipe
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VTransitPipeRun:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDX #(LL_VertPipeTransit - LL_VertPipe)	; X is set to index of in-level transit pipe tile

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of run)

	LDY TileAddr_Off	; Y = TileAddr_Off
	LDA [Map_Tile_AddrL],Y	; Get tile here
	CMP LL_VertPipe,X	; Is the in-level transit pipe tile?
	BEQ PRG014_C727	 	; If so, jump to PRG014_C735

	; The current tile is NOT an in-level transit pipe tile
	; ... but it is now!
	LDA LL_VertPipe,X	 
	STA [Map_Tile_AddrL],Y	 
	JSR LoadLevel_NextColumn
	LDA LL_VertPipe+1,X	
	STA [Map_Tile_AddrL],Y	
	JMP PRG014_C735	 	; Jump to PRG014_C735

PRG014_C727:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; Place center column of pipe here
	LDA #TILE1_PIPEVL
	STA [Map_Tile_AddrL],Y
	JSR LoadLevel_NextColumn
	LDA #TILE1_PIPEVR	
	STA [Map_Tile_AddrL],Y	

PRG014_C735:
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to Map_Tile_Addr
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update backup of Map_Tile_AddrH

	DEC <Temp_Var3		; Temp_Var3--
	BNE PRG014_C727	 	; While Temp_Var3 > 0, loop!

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; Store other end of in-level transit vertical pipe here
	LDA LL_VertPipe,X	
	STA [Map_Tile_AddrL],Y	
	JSR LoadLevel_NextColumn
	LDA LL_VertPipe+1,X	
	STA [Map_Tile_AddrL],Y	

	RTS		 ; Return

LoadLevel_VGroundPipe5Run:
	LDX #(LL_VertPipe4 - LL_VertPipe)	; Level_Tileset 3 or 14 (Hills or underground styles) have a fourth pipe

	LDA LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of pipe)
	JMP PRG014_C6B8	 ; Jump to PRG014_C6B8, which continues with the rest of LoadLevel_VCeilingPipeRun


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_HRightWallPipeRun
;
; Generates a horizontal pipe which runs into a righthand wall
; (i.e. no visible right edge is applied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_HorzPipe:
	.byte TILE1_PIPEH_T, TILE1_PIPEH_T, TILE1_PIPEH_T
	.byte TILE1_PIPEH1_B, TILE1_PIPEH2_B, TILE5_PIPEH3_B

LoadLevel_HRightWallPipeRun:
	LDA LL_ShapeDef
	SUB #$e0	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		; X = relative index by pipe type (0-2)

PRG014_C780:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3	; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	; Y = TileAddr_Off

	; Do top of horizontal pipe
	LDA LL_HorzPipe,X	 ; Get top left edge of pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG014_C79E	 	; Jump to PRG014_C79E

PRG014_C79A:
	LDA #TILE1_PIPEHT	 ; Pipe horizontal middle top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_C79E:
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3		; Temp_Var3--
	BPL PRG014_C79A	 	; While Temp_Var3 >= 0, loop!

	; Restore Map_Tile_Addr backup
	LDA <Temp_Var1		
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update Map_Tile_AddrH backup

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	; Do bottom of horizontal pipe
	LDA LL_HorzPipe+3,X	 ; Get bottom left edge of pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_C7D2	 	; Jump to PRG014_C7D2

PRG014_C7CE:
	LDA #TILE1_PIPEHB	 ; Pipe horizontal middle bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_C7D2:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_C7CE	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_HLeftWallPipeRun
;
; Generates a horizontal pipe which runs into a lefthand wall
; (i.e. no visible left edge is applied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_HLeftWallPipeRun:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	SUB #$10	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 ; X = relative index by pipe type (0-2)

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3	; Temp_Var3 = lower 4 bits of LL_ShapeDef (length of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG014_C7F7:
	; Do top of horizontal pipe
	LDA #TILE1_PIPEHT	 ; Pipe horizontal middle top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3		 ; Temp_Var3--
	BNE PRG014_C7F7	 	; While Temp_Var3 > 0, loop!

	LDA LL_HorzPipe,X	 ; Get right top edge of pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update Map_Tile_AddrH backup

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

PRG014_C828:
	; Do bottom of horizontal pipe
	LDA #TILE1_PIPEHB	; Pipe horizontal middle bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BNE PRG014_C828		 ; While Temp_Var3 > 0, loop!

	LDA LL_HorzPipe+3,X	 ; Get right bottom edge of pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_HLeftWallPipeRun3
;
; A bypass that forces horizontal pipe 3 to be used and otherwise
; runs the LoadLevel_HLeftWallPipeRun code...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_HRightWallPipeRun3:	; $C839
	LDX #$02	 ; Force Horizontal Pipe 3
	JMP PRG014_C780	 ; Jump to PRG014_C780


	; UNUSED: 2P Vs doesn't use regular SMB3 coins and certainly doesn't need to track them
	; But, of note, the coins DO display correctly (face forward only) but the "removed"
	; coin tile displays as the base of a Bullet Bill cannon; weird, huh?
LoadLevel_VsCoins:
	; Temp_Var3 = run length
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3

	LDY TileAddr_Off ; Y = TileAddr_Off
PRG014_C848:
	LDX #TILEA_COINREMOVED	 ; X = TILEA_COINREMOVED

	JSR LoadLevel_CheckBGHMem

	CMP #$00
	BNE PRG014_C853	 	; If this coin was grabbed already, jump to PRG014_C853

	LDX #TILEA_COIN	 ; Otherwise, X = TILEA_COIN

PRG014_C853:
	TXA		 ; Coin/removed tile -> 'A'
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INC <Temp_Var16		 ; Temp_Var16++

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG014_C848	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_EndGoal
;
; The end goal!  Takes up a little more than one screen...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG014_C860:
	.byte TILE1_GOALEDGE, TILE1_GOALBLACK

LoadLevel_EndGoal:
	; Backup Map_Tile_Addr into Tem_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDX #$00	; do the edges
	STX <Temp_Var4	 ; Temp_Var4 = 0
 
PRG014_C86E:
	LDA #25
	STA <Temp_Var3	 ; Temp_Var3 = 25 (almost full vertical height)

	LDY TileAddr_Off ; Y = TileAddr_Off

PRG014_C875:
	LDA PRG014_C860,X	 ; Get proper goal tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset
	TYA		 
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_C875		 ; While Temp_Var3 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	INY		 ; Y++
	TYA		 ; A = Y

	AND #$0f
	BNE PRG014_C8DB	 ; If we haven't reached the start of the next column (or start of a new row?), jump to PRG014_C8DB

	LDA Level_Tileset

	; NOTE: This should probably be sync'ed with LL_Goal_TSetList!!
	; If Level_Tileset = 1 (Plains style), 4 (High-Up style), 12 (ice level)
	; 9 (desert), 3 (Hills style), 14 (underground style), jump to PRG014_C8B9
	CMP #1
	BEQ PRG014_C8B9
	CMP #4
	BEQ PRG014_C8B9	
	CMP #12
	BEQ PRG014_C8B9	
	CMP #9
	BEQ PRG014_C8B9	 
	CMP #3
	BEQ PRG014_C8B9	 
	CMP #14
	BEQ PRG014_C8B9	 

	CMP #13	 
	BNE PRG014_C8C2	 ; If Level_Tileset <> 13 (coin heaven / sky level), jump to PRG014_C8C2


PRG014_C8B9:
	; All the above and 13 too, fall into here...

	LDA <Temp_Var4
	CMP #$01
	BNE PRG014_C8C2	 ; If Temp_Var4 <> 1 (doing the filler part), jump to PRG014_C8C2

	; Otherwise, add the goal square and relevant decoration!
	JSR LoadLevel_EndGoalDecoSquare	 

PRG014_C8C2:
	; Add $1B0 to the offset (move over an entire screen)
	; and update the backup values!
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2	

	INC <Temp_Var4		; Temp_Var4++ (0 = edge, 1 = filler, 2 = done!)

	LDA TileAddr_Off
	AND #$f0	
	TAY		

PRG014_C8DB:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y

	LDX #$01	 ; X = 1 (do the black filler)
	LDA <Temp_Var4	 
	CMP #$02	 
	BNE PRG014_C86E	 ; If Temp_Var4 <> 2, loop back up...

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_EndGoalDecoSquare
;
; As part of LoadLevel_EndGoal, adds the decoration and square
; which contains the "card", as appropriate to the Level_TileSet
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; End goal decoration and square (which contains the goal 'card')
; for different Level_Tilesets...

; These are 16 tiles wide, the goal is assumed to occupy the last
; screen and be aligned to it on the left edge!

; NOTE: These values are tiles, but since they're mixed, 
; I'm not translating them to TILEx_... constants!

	; Used by Level_Tileset 1, 3, 14
PRG014_C8E7:
	.byte $00, $00, $13, $14, $00, $00, $00, $17, $18, $19, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $15, $16, $00, $00, $00, $1A, $00, $1B, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $15, $13, $14, $00, $00, $1C, $1D, $1E, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $15, $00, $16, $00, $00, $00, $00, $00, $00, $00, $00, $13, $14, $00
	.byte $00, $00, $15, $00, $13, $14, $00, $00, $00, $00, $00, $00, $00, $15, $16, $00
	.byte $00, $13, $14, $00, $00, $16, $00, $00, $00, $00, $00, $00, $13, $14, $16, $00

	; Used by Level_Tileset 4, 12
PRG014_C947:
	.byte $00, $11, $12, $12, $13, $00, $00, $17, $18, $19, $00, $00, $00, $00, $00, $00
	.byte $00, $14, $15, $15, $16, $00, $00, $1A, $00, $1B, $00, $00, $00, $11, $12, $13
	.byte $00, $14, $15, $15, $16, $00, $00, $1C, $1D, $1E, $00, $00, $00, $14, $15, $16
	.byte $00, $14, $15, $15, $16, $00, $00, $00, $00, $00, $00, $11, $12, $13, $15, $16
	.byte $00, $14, $15, $11, $12, $12, $13, $00, $00, $00, $00, $14, $15, $16, $15, $16
	.byte $00, $14, $15, $14, $15, $15, $16, $00, $00, $00, $00, $14, $15, $16, $15, $16

	; Used by Level_Tileset 9
PRG014_C9A7:
	.byte $00, $00, $00, $00, $00, $00, $00, $17, $18, $19, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $1A, $00, $1B, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $1C, $1D, $1E, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $14, $15, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $14, $00, $00, $15, $14, $15, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $14, $00, $00, $00, $14, $00, $00, $15, $00, $00, $14, $15, $00, $00

	; Used by Level_Tileset 13
PRG014_CA07:
	.byte $00, $00, $00, $00, $00, $00, $00, $17, $18, $19, $00, $00, $00, $15, $16, $00
	.byte $00, $00, $15, $16, $00, $00, $00, $1A, $00, $1B, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $1C, $1D, $1E, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $15, $16, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00


; Matched indexes to LL_Goal_TSetList...
LL_Goal_TSetAddr:	; by tileset...
	.word PRG014_C8E7	; 1
	.word PRG014_C947	; 4
	.word PRG014_C9A7	; 9
	.word PRG014_CA07	; 13
	.word PRG014_C947	; 12
	.word PRG014_C8E7	; 3
	.word PRG014_C8E7	; 14

	; Same list of recognized tilesets as hardcoded in PRG014_C862
LL_Goal_TSetList:
	.byte 1, 4, 9, 13, 12, 3, 14
LL_Goal_TSetListEnd


LoadLevel_EndGoalDecoSquare:
	INC <Map_Tile_AddrH	; Move ahead to next 16 rows

	; Add 64 to tile offset and advance 4 more rows
	LDA <Map_Tile_AddrL
	ADD #64
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDY #$00
	STY <Temp_Var7	 ; Temp_Var7 = 0

	LDX #(LL_Goal_TSetListEnd - LL_Goal_TSetList - 1)
	LDA Level_Tileset	 ; A = Level_Tileset

	; Searching for an index into LL_Goal_TSetList which matches
	; the current tileset (0, which indexes 1, Plains style, is 
	; assumed if otherwise invalid...)
PRG014_CA94: 
	CMP LL_Goal_TSetList,X	
	BEQ PRG014_CA9C
	DEX		 ; X--
	BNE PRG014_CA94	 ; While X <> 0, loop!

PRG014_CA9C:
	; 'X' holds an index within LL_Goal_TSetList matched to the current tileset
	TXA	
	ASL A	
	TAX	; X <<= 1 (2 byte index)

	; Pull address from LL_Goal_TSetAddr, store into Temp_Var13/14
	LDA LL_Goal_TSetAddr,X	 
	STA <Temp_Var13		 
	LDA LL_Goal_TSetAddr+1,X
	STA <Temp_Var14		

PRG014_CAA9:
	LDX #$0f	 ; X = $F (width)

PRG014_CAAB:
	LDA [Temp_Var13],Y	 ; Get this goal deco tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	INY		 	 ; Y++ (next column)
	DEX		 	 ; X-- (width decrement)
	BPL PRG014_CAAB		 ; While X >= 0, loop!

	INC <Temp_Var7		 ; Temp_Var7++
	LDA <Temp_Var7		 
	CMP #$06	 
	BNE PRG014_CAA9	 	; While Temp_Var7 <> 6 (need to do 6 rows of this!), loop!

	; Restore Map_Tile_Addr backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PowerBlock
;
; Adds one of many types of "power" blocks -- different containers
; for power ups, P-Switches, vines, and the muncher plant (?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PowerBlocks:
	.byte TILEA_QBLOCKFLOWER, TILEA_QBLOCKLEAF, TILEA_QBLOCKSTAR, TILEA_QBLOCKCOINSTAR ; 0 - 3
	.byte TILEA_QBLOCKCOIN2, TILEA_MUNCHER, TILEA_BRICKFLOWER, TILEA_BRICKLEAF ; 4 - 7
	.byte TILEA_BRICKSTAR, TILEA_BRICKCOINSTAR, TILEA_BRICK10COIN, TILEA_BRICK1UP ; 8 - 11
	.byte TILEA_BRICKVINE, TILEA_BRICKPSWITCH, TILEA_INVISCOIN, TILEA_INVIS1UP ; 12 - 15
	.byte TILEA_NOTEINVIS, TILEA_NOTEFLOWER, TILEA_NOTELEAF, TILEA_NOTESTAR ; 16 - 19
	.byte TILEA_WOODBLOCKFLOWER, TILEA_WOODBLOCKLEAF, TILEA_WOODBLOCKSTAR, TILEA_NOTECOINHEAVEN ; 20 - 23
	.byte TILEA_PSWITCH ; 24


LoadLevel_PowerBlock:
	; The index we came in on is in 'X', which starts at 16
	TXA	
	SUB #16
	TAX		 ; Now 'X' is relative index, 0 - 24

	LDY TileAddr_Off ; Y = TileAddr_Off

	CPX #11	 
	BEQ PRG014_CAED	 ; If this is a brick with a 1-up, jump to PRG014_CAED

	CPX #15	 
	BNE PRG014_CAFD	 ; If this is NOT a brick with an invisible 1-up, jump to PRG014_CAFD

PRG014_CAED:
	JSR LoadLevel_CheckBGHMem

	CMP #$00	 
	BEQ PRG014_CAFD	 	; If check OK, jump to PRG014_CAFD

	; Otherwise, stamp it out as an empty!  (Prevent 1-up from reappearing)
	LDA #TILEA_BLOCKEMPTY

	CPX #11	 
	BEQ PRG014_CB00	 ; Technically jump always to PRG014_CB00 (because we only get to this code if X = 11 in the first place!)

	; Unreachable?
	JMP PRG014_CB15	 ; Jump to PRG014_CB15 (RTS)

PRG014_CAFD:
	LDA LL_PowerBlocks,X	 ; Get the correct power block

PRG014_CB00:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	CMP #TILEA_BRICKPSWITCH
	BNE PRG014_CB15	 ; If this is not a brick with a P-Switch inside of it, jump to PRG014_CB15

	; Y -= 16 (go to previous row)
	TYA
	SUB #16
	TAY
	LDA <Map_Tile_AddrH
	SBC #$00
	STA <Map_Tile_AddrH

	; On reload, blank out the used up P-Switch
	LDA #TILEA_PSWITCH_BLANK
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_CB15:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BlockRun
;
; Puts down 1-16 of one of the blocks from LoadLevel_Blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Blocks:
	.byte TILEA_BRICK, TILEA_QBLOCKCOIN, TILEA_BRICKCOIN, TILEA_WOODBLOCK
	.byte TILEA_GNOTE, TILEA_NOTE, TILEA_WOODBLOCKBOUNCE, TILEA_COIN
	.byte TILEA_ICEBRICK	; This one is accessed by LoadLevel_IceBricks

LoadLevel_BlockRun:
	LDA LL_ShapeDef
	SUB #16
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 ; X = relative index we were called in on

PRG014_CB2A:
	LDA LL_ShapeDef	
	AND #$0f	
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off ; Y = TileAddr_Off

PRG014_CB34:
	CPX #$07	
	BNE PRG014_CB3F	 ; If X <> 7 (coins), jump to PRG014_CB3F

	; Only coins need to do this check...
	JSR LoadLevel_CheckBGHMem	 ; Check if this coin was collected already
	CMP #$00
	BNE PRG014_CB44	 	; If coin was collected already, jump to PRG014_CB44 (skip putting a coin here)

PRG014_CB3F:
	LDA LoadLevel_Blocks,X	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_CB44:
	JSR LoadLevel_NextColumn ; Next column...
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CB34	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_IceBricks
;
; Puts down 1-16 icebricks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_IceBricks:
	LDX #$08	 ; Iceblock in LoadLevel_BlockRun
	JMP PRG014_CB2A	 ; Jump to PRG014_CB2A


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_(Small/Mid/Big)Bush
;
; Inserts 1 of 3 pre-fab large green bush designs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Each bush design is as wide as LL_Bush_Width defines it to be!
LL_Bush1:
	.byte TILE1_SKY,      TILE1_BUSH_UL,  TILE1_BUSH_UR,  TILE1_SKY,      TILE1_SKY
	.byte TILE1_BUSH_UL,  TILE1_BUSH_FUR, TILE1_BUSH_BR,  TILE1_BUSH_UL,  TILE1_BUSH_UR
	.byte TILE1_BUSH_BL,  TILE1_BUSH_FUL, TILE1_BUSH_FUR, TILE1_BUSH_MID, TILE1_BUSH_BR
	.byte TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_BR
	.byte $FF	; Terminator

LL_Bush2:
	.byte TILE1_SKY,      TILE1_BUSH_UL,  TILE1_BUSH_UR,  TILE1_SKY
	.byte TILE1_SKY,      TILE1_BUSH_BL,  TILE1_BUSH_FUL, TILE1_BUSH_UR
	.byte TILE1_BUSH_UL,  TILE1_BUSH_FUR, TILE1_BUSH_MID, TILE1_BUSH_BR
	.byte $FF	; Terminator

LL_Bush3:
	.byte TILE1_SKY,      TILE1_SKY,      TILE1_BUSH_UL,  TILE1_BUSH_UR,  TILE1_SKY,      TILE1_SKY
	.byte TILE1_SKY,      TILE1_SKY,      TILE1_BUSH_BL,  TILE1_BUSH_FUL, TILE1_BUSH_UR,  TILE1_SKY
	.byte TILE1_SKY,      TILE1_SKY,      TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_BR,  TILE1_SKY
	.byte TILE1_SKY,      TILE1_BUSH_UL,  TILE1_BUSH_FUR, TILE1_BUSH_MID, TILE1_BUSH_BR,  TILE1_SKY
	.byte TILE1_BUSH_UL,  TILE1_BUSH_FUR, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_BR,  TILE1_SKY
	.byte TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_BR,  TILE1_SKY
	.byte TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_FUL, TILE1_BUSH_UR
	.byte TILE1_BUSH_BL,  TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_MID, TILE1_BUSH_BR
	.byte $FF	; Terminator


	; Width of each bush; because of "from X to 0" type loops,
	; these are one less than the actual tile width of the bush!
LL_Bush_Width:
	.byte 4, 3, 5

LoadLevel_MidSizeBush:
	LDX #0				; Starting index from LL_Bush1
	LDY #0		 		; Bush width index
	JMP PRG014_CBB9	 		; Jump to PRG014_CBB9

LoadLevel_SmallSizeBush:
	LDX #(LL_Bush2 - LL_Bush1)	; Starting index from LL_Bush1
	LDY #1		 		; Bush width index
	JMP PRG014_CBB9	 		; Jump to PRG014_CBB9

LoadLevel_BigSizeBush:
	LDX #(LL_Bush3 - LL_Bush1)	; Starting index in LL_Bush1
	LDY #2		 		; Bush width index

PRG014_CBB9:

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	STY <Temp_Var13		; Temp_Var13 = 0, 1, or 2

PRG014_CBC3:
	LDY <Temp_Var13		; Y = Temp_Var13
	LDA LL_Bush_Width,Y	
	STA <Temp_Var3		; Temp_Var3 = LL_Bush_Width[Y]

	LDY TileAddr_Off	; Y = TileAddr_Off

PRG014_CBCD:
	LDA LL_Bush1,X		; Get this tile from the bush layout
	CMP #TILE1_SKY
	BEQ PRG014_CC04	 	; If tile = TILE1_SKY, jump to PRG014_CC04 (skip placing it)

	STA <Temp_Var4		; Temp_Var4 = bush tile

	; If this tile belongs in the front of another bush, jump to PRG014_CC00 (place the bush tile)
	CMP #TILE1_BUSH_FUL
	BEQ PRG014_CC00
	CMP #TILE1_BUSH_FUR	 
	BEQ PRG014_CC00	


	LDA [Map_Tile_AddrL],Y	; Get the tile here

	; If tile < TILE1_BUSH_UL or tile >= TILE1_BUSH_SBR (out of bush range), jump to PRG014_CC00 (place the bush tile)
	CMP #TILE1_BUSH_UL	
	BLT PRG014_CC00
	CMP #TILE1_BUSH_SBR	
	BGE PRG014_CC00	

	; Tile we grabbed is in bush range...

	CMP <Temp_Var4	
	BEQ PRG014_CC04		; If the tile we grabbed is the same as the tile we were going to place, jump to PRG014_CC04 (don't place the bush tile)

	LDA <Temp_Var4		; Get tile we were going to place
	CMP #TILE1_BUSH_BL
	BGE PRG014_CBFC	 	; If tile is >= TILE1_BUSH_BL (i.e. not top of a bush), jump to PRG014_CBFC (change to generic middle-of-bush tile)

	; Otherwise, Temp_Var4 += 2 (changes bush tops to "front" tops, or changes "front" tops to the lower part?)
	LDA <Temp_Var4	
	ADD #$02	
	STA <Temp_Var4	

	JMP PRG014_CC00	 	; Jump to PRG014_CC00 (place the bush tile)

PRG014_CBFC:
	LDA #TILE1_BUSH_MID
	STA <Temp_Var4		 ; Temp_Var4 = TILE1_BUSH_MID

PRG014_CC00:
	LDA <Temp_Var4		 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_CC04:
	JSR LoadLevel_NextColumn	; Next column
	INX		 		; X++ (next tile of bush layout)
	DEC <Temp_Var3		 	; Temp_Var3--
	BPL PRG014_CBCD	 		; If Temp_Var3 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	; Go to next row by adding 16 to address
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	LDA LL_Bush1,X
	CMP #$ff	 	
	BNE PRG014_CBC3	 	; If next byte from bush is NOT $FF, loop around again...

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PathHorizontal
;
; Adds a run of 1-16 horizontal moving platform path tiles
; Automatically moves RIGHT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PathHorz:
	.byte TILEA_PATH_HORZ, TILE2_PATH_HORZ

LoadLevel_PathHorizontal:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CC32:
	LDA LL_PathHorz,X	 ; Get appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CC32	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return

	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PathVertical
;
; Adds a run of 1-16 vertical moving platform path tiles
; Automatically moves DOWN with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PathVert:
	.byte TILEA_PATH_VERT, TILE2_PATH_VERT

LoadLevel_PathVertical:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CC44:
	LDA LL_PathVert,X	 ; Get appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Next row by adding 16
	TYA		 
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CC44	 	; While Temp_Var3 >= 0, loop
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Path45T2B
;
; Adds a run of 1-16 45 degree top-to-bottom moving platform path
; tiles.  Automatically moves DOWN and RIGHT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Path45T2B:
	.byte TILEA_PATH_45T2B, TILE2_PATH_45T2B

LoadLevel_Path45T2B:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CC5E:
	LDA LL_Path45T2B,X	 ; Get appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Next row by adding 16, to the right 1 via LoadLevel_NextColumn
	TYA
	ADD #16
	TAY	
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	JSR LoadLevel_NextColumn

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CC5E	 	; While Temp_Var3 >= 0, loop
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Path45B2T
;
; Adds a run of 1-16 45 degree bottom-to-top moving platform path
; tiles.  Automatically moves UP and RIGHT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Path45B2T:
	.byte TILEA_PATH_45B2T, TILE2_PATH_45B2T

LoadLevel_Path45B2T:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CC7E:
	LDA LL_Path45B2T,X	 ; Load appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Move up and to the right
	TYA
	SUB #16
	TAY	
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	SBC #$00	 
	STA <Map_Tile_AddrH
	JSR LoadLevel_NextColumn

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CC7E	 	; While Temp_Var3 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Path625T2B
;
; Adds a run of 1-16 62.5 degree top-to-bottom moving platform path
; tiles.  Automatically moves DOWN TWICE and RIGHT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Path625T2B:
	.byte TILEA_PATH_625T2B_U, TILE2_PATH_625T2B_U
	.byte TILEA_PATH_625T2B_L, TILE2_PATH_625T2B_L

LoadLevel_Path625T2B:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)

PRG014_CCA0:
	LDA LL_Path625T2B,X	 ; Get appropriate tile (upper 62.5)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Down one row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA LL_Path625T2B+2,X	 ; Get appropriate tile (lower 62.5)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Down one row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CCA0	 	 ; While Temp_Var3 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Path625T2B
;
; Adds a run of 1-16 62.5 degree top-to-bottom moving platform path
; tiles.  Automatically moves DOWN TWICE and LEFT with every iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Path625B2T:
	.byte TILEA_PATH_625B2T_U, TILE2_PATH_625B2T_U
	.byte TILEA_PATH_625B2T_L, TILE2_PATH_625B2T_L

LoadLevel_Path625B2T:
	JSR LL_PathInit	 ; Set Temp_Var3 to width and X = 0 or 1 (latter if Level_Tileset = 2)
PRG014_CCD2:
	LDA LL_Path625B2T,X	 	; Get appropriate tile (upper 62.5)
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Down one row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA LL_Path625B2T+2,X	 	; Get appropriate tile (lower 62.5)
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Down one row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEY		 ; Y--
	TYA	
	AND #$0f
	CMP #$0f
	BNE PRG014_CD0E		; If we haven't left the left edge of this screen, jump to PRG014_CD0E

	; Move back one screen by subtracting $1B0 from Map_Tile_Addr
	LDA <Map_Tile_AddrL
	SUB #$b0	 
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	SBC #$01	 
	STA <Map_Tile_AddrH

	; Transfer 'Y' to the other side
	INY	
	TYA	
	AND #$f0
	ORA #$0f
	TAY	

PRG014_CD0E:
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_CCD2	 	; While Temp_Var3 >= 0, loop!
	RTS		 ; Return


	; Setup for the path routines
LL_PathInit:
	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; X = 0 UNLESS Level_Tileset = 2 (Fortress style), in which case X = 1
	LDX #$00
	LDA Level_Tileset
	CMP #$02	 
	BNE PRG014_CD28	 
	LDX #$01	 

PRG014_CD28:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Lava
;
; Puts down a 1-256 width stretch of lava!  Puts the bubbly on
; top and the red beneath it (i.e. 2 rows)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Lava:
	.byte TILE2_LAVATOP, TILE2_LAVABOTTOM

LoadLevel_Lava:
	LDY #$00	 ; Y = 0

	LDA [Level_LayPtr_AddrL],Y	 ; Get another byte from layout
	STA <Temp_Var3			 ; Store it into Temp_Var3

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01	
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef

	LDX #$00	 	; X = 0 (top of lava first)
PRG014_CD4F:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3		 
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3 (restore width)
 
PRG014_CD56:
	LDA LL_Lava,X	 	 ; Get appropriate lava tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	LDA <Temp_Var5		 
	CMP #$ff	 
	BNE PRG014_CD56	 	; While Temp_Var5 >= 0, loop!


	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	LDX #$01	 	; X = 1 (bottom of lava)
	DEC <Temp_Var4		; Temp_Var4--
	BPL PRG014_CD4F	 ; While Temp_Var4 >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Pillar
;
; Puts down 1-16 pillars, which are created downward from their
; starting position for as long as the appropriate BGBRICK tile
; continues downward.  Also generates the shadow, which follows
; the same pattern.  So, word of warning: Don't have a pillar
; generate over top of anything except those tiles!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Pillar:
	LDX #$00	 ; X = 0 (foreground pillar)
	BEQ PRG014_CD98	 ; (Technically always) jump to PRG014_CD98

LL_Pillar:
	.byte TILE2_PILLARSHADOW_T, TILE2_PILLAR_T	; Top
	.byte TILE2_PILLARSHADOW_M, TILE2_PILLAR_M	; Middle
	.byte TILE2_PILLARSHADOW_B, TILE2_PILLAR_B	; Bottom

	; These are the shadow tiles which appear to the right of the pillar
LL_PillarShadow:
	.byte TILE2_BGBRICK_ULDSHADOW, TILE2_BGBRICK_SHADOW	; Top
	.byte TILE2_BGBRICK_LDSHADOW, TILE2_BGBRICK_LSHADOW	; Middle/bottom

	; BGBRICK tile check for different pillar types
	; The pillar will build downward as long as it sees this tile
LL_PillarBrickChk:
	.byte TILE2_BGBRICK_SHADOW2, TILE2_BGBRICK_NOSHADOW
	
LoadLevel_Pillar_BG:
	LDX #$01	 ; X = 1 (background pillar)

PRG014_CD98:
	STX <Temp_Var3		; Temp_Var3 = X

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	AND #$0f	 
	STA <Temp_Var4	 	; Temp_Var4 = lower 4 bits of LL_ShapeDef (number of pillars)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG014_CDAC:
	LDX <Temp_Var3		 ; X = Temp_Var3

	LDA LL_Pillar,X	 	; Get top pillar tile
	STA [Map_Tile_AddrL],Y	; Store into tile mem

	; Loop builds pillar while it hits a TILE2_BGBRICK_SHADOW2 tile 
	; (shadowed pillar) or a TILE2_BGBRICK_NOSHADOW tile (nonshadowed)
PRG014_CDB3:
	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA [Map_Tile_AddrL],Y	; Get tile here
	CMP LL_PillarBrickChk,X	 
	BNE PRG014_CDCD	 	; If NOT the appropriate shadow tile, jump to PRG014_CDCD

	; Otherwise, replace tile with shadowing tile
	LDA LL_Pillar+2,X	 ; Get middle pillar tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_CDB3	 	; Jump to PRG014_CDB3


PRG014_CDCD:

	; Back up one row by subtracting 16 (because we're sitting on
	; the non BGBRICK tile that we hit!)
	TYA	
	SUB #16
	TAY	
	LDA <Map_Tile_AddrH
	SBC #$00	 
	STA <Map_Tile_AddrH

	LDA LL_Pillar+4,X	 ; Get bottom of pillar tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDY TileAddr_Off	 ; Y = TileAddr_Off


	; The following (down to PRG014_CE05) is ALMOST the same as LoadLevel_NextColumn,
	; except it also backs up the new address (kind of pointless, but sure...)

	INY		 ; Y++
	TYA		 ; A = Y
	AND #$0f	 ; Check column
	BNE PRG014_CE05	 ; If on column 1-15, jump to PRG014_CE05

	; Otherwise, need to move over to the next screen (+$1B0)
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var1		 ; Update Map_Tile_AddrL backup
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	; Get TileAddr_Off and only keep the row, but clear 'Y' lower bits since
	; we're going to column 0 on the same row, new screen...
	LDA TileAddr_Off
	AND #$f0
	TAY	
PRG014_CE05:


	STY TileAddr_Off	 ; Tile_Addr_Off = Y

	; We moved over one column from the top of the pillar...

	LDA LL_PillarShadow,X	 ; Get the appropriate ceiling shadow for this pillar
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Loop builds pillar shadow while it hits a TILE2_BGBRICK_SHADOW2 tile 
	; (shadowed pillar) or a TILE2_BGBRICK_NOSHADOW tile (nonshadowed)
PRG014_CE0D:
	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA [Map_Tile_AddrL],Y	 ; Check for the BGBRICK like before...
	CMP LL_PillarBrickChk,X	 
	BNE PRG014_CE27	 	; If NOT the appropriate shadow tile, jump to PRG014_CE27

	LDA LL_PillarShadow+2,X	 ; Get pillar shadow tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_CE0D	 	; Loop back around...

PRG014_CE27:
	DEC <Temp_Var4		; Temp_Var4--
	BMI PRG014_CE5E	 	; If Temp_Var4 < 0, jump to PRG014_CE5E

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	LDX #$02	 ; X = 2
	LDY TileAddr_Off ; Y = TileAddr_Off

PRG014_CE38:
	; The following (down to PRG014_CE05) is ALMOST the same as LoadLevel_NextColumn,
	; except it also backs up the new address (kind of pointless, but sure...)
	INY		 ; Y++
	TYA		 ; A = Y
	AND #$0f	 ; Check column
	BNE PRG014_CE55	 ; If on column 1-15, jump to PRG014_CE05

	; Otherwise, need to move over to the next screen (+$1B0)
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var1		 ; Update Map_Tile_AddrL backup
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	; Get TileAddr_Off and only keep the row, but clear 'Y' lower bits since
	; we're going to column 0 on the same row, new screen...
	LDA TileAddr_Off
	AND #$f0
	TAY	
PRG014_CE55:

	DEX		 ; X--
	BPL PRG014_CE38	 ; While PRG014_CE38 >= 0, loop!

	STY TileAddr_Off ; TileAddr_Off = Y
	JMP PRG014_CDAC	 ; Loop back around...

PRG014_CE5E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BrickAndShadow
;
; Puts down 1-16 solid brick blocks with automatically added
; shadow background brickwork blocks beneath it
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BrickAndShadow:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_ShapeDef
	AND #$0f	
	TAX		 	; X = lower 4 bits of LL_ShapeDef

PRG014_CE70:
	LDA #TILE2_SOLIDBRICK		; Solid brick pattern
	STA [Map_Tile_AddrL],Y		; Store into tile mem
	JSR LoadLevel_NextColumn	; Go to next column
	DEX		 		; X--
	BPL PRG014_CE70	 		; While X >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	LDA LL_ShapeDef
	AND #$0f	
	TAX		 	; X = lower 4 bits of LL_ShapeDef

	LDA #TILE2_BGBRICK_UNDBRICK 	; BGBRICK as appears under the solid brick edge
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JMP PRG014_CEA3	 		; Jump to PRG014_CEA3

PRG014_CE9F:
	LDA #TILE2_BGBRICK_TOPSHADOW	; Rest of bricks get shadow BGBRICK under it...
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

PRG014_CEA3:
	JSR LoadLevel_NextColumn	 ; Next column
	DEX		 ; X--
	BPL PRG014_CE9F	 ; While X >= 0, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Cannon
;
; Generates a Bullet Bill cannon.  The specified height includes
; the very top of the cannon (height = 0), the mount beneath
; (height = 1), and then the body extending downward (height > 1)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Cannon:
	LDA LL_ShapeDef	 
	AND #$0f	 
	TAX		 	; X = lower 4 bits of LL_ShapeDef (height of cannon)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE1_CANNONTOP1	 ; Top of cannon
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height decrement)
	BMI PRG014_CEE9	 ; If X < 0, jump to PRG014_CEE9 (RTS)

	LDA #TILE1_CANNONTOP2	 ; Top beneath cannon
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height decrement)
	BMI PRG014_CEE9	 ; If X < 0, jump to PRG014_CEE9 (RTS)

PRG014_CED7:
	LDA #TILE1_CANNONMID	 ; Middle part of cannon and continued
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height decrement)
	BPL PRG014_CED7	 ; While X >= 0, loop!

PRG014_CEE9:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_CCBridge
;
; Generates a Cheep-cheep style 'oo' bridge, with fence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Bridge:
	.byte TILE1_LITTLEFENCE, TILEA_PSWITCHCOIN, TILE1_CCBRIDGE, TILE1_BLOCK_SHUL ; <-- TILE1_BLOCK_SHUL is used as early terminator!

LoadLevel_CCBridge:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	SUB #$40
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	PLA		 ; Restore LL_ShapeDef
	AND #$0f
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)
	STA <Temp_Var4	 ; Temp_Var4 = Temp_Var3 (save original width)

	LDY TileAddr_Off	; Y = TileAddr_Off

	; Top of bridge
PRG014_CF0C:
	LDA LL_Bridge,X	 	; Get fence tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BPL PRG014_CF0C	 	; While Temp_Var4 >= 0, loop!

	; Restore the backup of Map_Tile_Addr
	LDA <Temp_Var1		 
	STA <Map_Tile_AddrL	
	LDA <Temp_Var2		
	STA <Map_Tile_AddrH	

	; Go to next offset row by adding 16, carry to Map_Tile_AddrH if needed...
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update the backup Temp_Var2

	LDA <Temp_Var3	
	STA <Temp_Var4		; Temp_Var4 = Temp_Var3 (restore original width)

PRG014_CF36:
	LDA LL_Bridge+2,X	; Get bridge tile
	CMP #TILE1_BLOCK_SHUL	
	BEQ PRG014_CF46	 	; If the tile is TILE1_BLOCK_SHUL, jump to PRG014_CF46 (RTS)

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BPL PRG014_CF36	 	; While Temp_Var4 >= 0, loop!

PRG014_CF46:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_TopDecoBlocks
;
; Generates a rectangle (width 1-256 / height 1-16) of "top 
; decorated" blocks, like a block of water with waves at the top,
; or sandy ground with its special "top" sandy floor, etc.
;
; In this case, the lower 4 bits of LL_ShapeDef specify the 
; HEIGHT of the following blocks, while a byte pulled from the
; level data stream contains the WIDTH (so large 1-256 widths
; are supported by this routine.)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; This array specifies the block which will appear on top
LL_TopBlock:
	.byte TILE1_WFALLTOP,     TILE1_WATERWAVEL, TILE1_WATERWAVE, TILE1_WATERWAVER
	.byte TILE1_WATERBUMPS1,  TILE1_DIAMOND,    TILE1_SANDTOP,   TILE3_QUICKSAND_TOP

	; This array specifies what blocks will follow
LL_FollowBlock:
	.byte TILE1_WFALLMID,     TILE1_WATER,      TILE1_WATER,     TILE1_WATER
	.byte TILE1_WATERBUMPSSH, TILE1_DIAMOND,    TILE1_SANDMID,   TILE3_QUICKSAND_MID

LoadLevel_TopDecoBlocks:
	LDY #$00	 		; Y = 0
	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	STA <Temp_Var3		 	; Store into Temp_Var3

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01	 
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	PHA		 ; Push LL_ShapeDef

	SUB #$60
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		; X = relative index

	PLA		; Restore LL_ShapeDef
	AND #$0f	
	STA <Temp_Var4	; Temp_Var4 = lower 4 bits of LL_ShapeDef (height of the run)

	LDA <Temp_Var3	
	STA <Temp_Var5	; Temp_Var5 = Temp_Var3 (the value we pulled in)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG014_CF8A:
	LDA LL_TopBlock,X	 ; Get block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5--
	LDA <Temp_Var5
	CMP #-1
	BNE PRG014_CF8A	 	; While Temp_Var5 <> -1, loop!

	; After loop...

PRG014_CF9A:
	DEC <Temp_Var4		; Temp_Var4--
	BPL PRG014_CF9F	 	; While Temp_Var4 >= 0, jump to PRG014_CF9F

	RTS		 ; Return


PRG014_CF9F:
	; Restore from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next offset row by adding 16, carry to Map_Tile_AddrH if needed...
	LDA TileAddr_Off	
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update backup of Map_Tile_AddrH

	LDA <Temp_Var3		
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 (reload starting width)

PRG014_CFBD:
	LDA LL_FollowBlock,X	; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5--
	LDA <Temp_Var5
	CMP #-1
	BNE PRG014_CFBD	 	; While Temp_Var5 <> -1, loop!

	JMP PRG014_CF9A	 ; Jump to PRG014_CF9A


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LittleCloudRun and LoadLevel_LittleCloudSolidRun
;
; Puts down 1-16 of those little smiling Judgem's like clouds
;
; WARNING: LoadLevel_LittleCloudSolidRun is broken!  Read below!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LittleCloudSolidRun:
	LDX #$01	 	; X = 1 (use TILE1_JCLOUDSOLID)

	; BUG!! This jump will always fail, dropping into the table below!!
	; The table is misinterpreted as a BIT xxxx instruction followed by
	; a BRK, which triggers the NMI but ultimately is MOSTLY harmless...
	; The return is in the middle of the LDA LL_ShapeDef which is now
	; misinterpreted as an "ASL <$07"... in one trial, I got $CF as
	; the run length!  Big oops there Nintendo...
	BEQ PRG014_CFD8		; <-- MISTAKE!! This is never true!  They wanted a BNE!!

PRG014_CFD4:
	.byte TILE1_JCLOUD, TILE1_JCLOUDSOLID

LoadLevel_LittleCloudRun:
	LDX #$00	 ; X = 0 (use TILE1_JCLOUD)

PRG014_CFD8:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_CFE2:
	LDA PRG014_CFD4,X	 ; Get this block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Go to next column
	DEC <Temp_Var3		; Temp_Var3--
	BPL PRG014_CFE2	 	; If Temp_Var3 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Jelectro
;
; Puts down 1-16 Jelectros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Jelectro:
	LDX #$02	 ; X = 2 (use TILE4_JELECTRO)
	LDA LL_ShapeDef	 
	JMP PRG014_D007	 ; PRG014_D007

LL_Conveyor:
	.byte TILE2_CONVEYORL, TILE2_CONVEYORR, TILE4_JELECTRO

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Conveyor
;
; Puts down 1-16 left/right conveyor tiles
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Conveyor:
	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef

	SUB #$50	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	TAX		 ; X = relative index

	PLA		 ; Restore LL_ShapeDef

PRG014_D007:
	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_D00E:
	LDA LL_Conveyor,X	 ; Get appropriate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3-- (width decrement)
	BPL PRG014_D00E	 	; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PutLittleBGCloud
;
; Places a single little BG cloud tile
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_PutLittleBGCloud:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE1_LILBGCLOUD	 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DonutLifts
;
; Places 1-16 donut lifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_DonutLifts:
	LDA LL_ShapeDef	 
	AND #$0f	 
	TAX		 ; X = lower 4 bits of LL_ShapeDef (with of run)
	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_D02C:
	LDA #TILE2_DONUTLIFT	; Donut lift
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column
	DEX		 ; X--
	BPL PRG014_D02C	 ; While X >= 0, loop!
	RTS		 ; Return


	; Defines the tile lookup to construct the "big blocks" seen in 
	; Plains style levels, top/middle/bottom, in each of the 4 colors.
LL_BigBlock_Top:
	; Top
	.byte TILE1_WBLOCKUL, TILE1_WBLOCKTH, TILE1_WBLOCKUR
	.byte TILE1_OBLOCKUL, TILE1_OBLOCKTH, TILE1_OBLOCKUR 
	.byte TILE1_GBLOCKUL, TILE1_GBLOCKTH, TILE1_GBLOCKUR
	.byte TILE1_BBLOCKUL, TILE1_BBLOCKTH, TILE1_BBLOCKUR

LL_BigBlock_Mid:
	; Middle
	.byte TILE1_WBLOCKLV, TILE1_WBLOCKM,  TILE1_WBLOCKRV
	.byte TILE1_OBLOCKLV, TILE1_OBLOCKM,  TILE1_OBLOCKRV
	.byte TILE1_GBLOCKLV, TILE1_GBLOCKM,  TILE1_GBLOCKRV
	.byte TILE1_BBLOCKLV, TILE1_BBLOCKM,  TILE1_BBLOCKRV

LL_BigBlock_Bot:
	; Bottom
	.byte TILE1_WBLOCKLL, TILE1_WBLOCKBH, TILE1_WBLOCKLR
	.byte TILE1_OBLOCKLL, TILE1_OBLOCKBH, TILE1_OBLOCKLR
	.byte TILE1_GBLOCKLL, TILE1_GBLOCKBH, TILE1_GBLOCKLR
	.byte TILE1_BBLOCKLL, TILE1_BBLOCKBH, TILE1_BBLOCKLR

	; Array of values used for determining an index of an appropriate shadow;
	; that is, for each of these, they are paired with a result in the same
	; sized LL_BigBlock_ApprShadow array to provide a shadow tile...
LL_BigBlock_ShadowChks:
	; |*	Defines "big block" in just lower-left corner blocks
	; L-	<-- like this
	.byte TILE1_WBLOCKLV, TILE1_WBLOCKM, TILE1_WBLOCKBH, TILE1_WBLOCKLL
	.byte TILE1_OBLOCKLV, TILE1_OBLOCKM, TILE1_OBLOCKBH, TILE1_OBLOCKLL
	.byte TILE1_GBLOCKLV, TILE1_GBLOCKM, TILE1_GBLOCKBH, TILE1_GBLOCKLL
	.byte TILE1_BBLOCKLV, TILE1_BBLOCKM, TILE1_BBLOCKBH, TILE1_BBLOCKLL

	; Big green bush pieces
	.byte TILE1_BUSH_UL,  TILE1_BUSH_BL,  TILE1_BUSH_UR,  TILE1_BUSH_BR
	.byte TILE1_BUSH_FUL, TILE1_BUSH_FBL, TILE1_BUSH_FUR, TILE1_BUSH_FBR

	.byte TILE1_BUSH_MID
LL_BigBlock_EndShadowChks


	; Array of values (matching array above) for correct shadow
LL_BigBlock_ApprShadow:
	; Shadowed middle and bottom of big blocks
	.byte TILE1_WBLOCKSM, TILE1_WBLOCKSM, TILE1_WBLOCKSB, TILE1_WBLOCKSB
	.byte TILE1_OBLOCKSM, TILE1_OBLOCKSM, TILE1_OBLOCKSB, TILE1_OBLOCKSB
	.byte TILE1_GBLOCKSM, TILE1_GBLOCKSM, TILE1_GBLOCKSB, TILE1_GBLOCKSB
	.byte TILE1_BBLOCKSM, TILE1_BBLOCKSM, TILE1_BBLOCKSB, TILE1_BBLOCKSB

	; Shadowed big green bush
	.byte TILE1_BUSH_SUL,  TILE1_BUSH_SBL, TILE1_BUSH_SUR,  TILE1_BUSH_SBR
	.byte TILE1_BUSH_SFUL, TILE1_BUSH_SBL, TILE1_BUSH_SFUR, TILE1_BUSH_SBL	; Did they perhaps mean for TILE1_BUSH_SBR at the end there?

	.byte TILE1_BUSH_SBL

	;;;;;;;;;;;;;;;;;;

	.byte $00, $40, $80, $C0


	; This selects an offset to a particular color of block from LL_BigBlock_Top
LL_BigBlock_Top_ColorOff:	.byte 0, 3, 6, 9	; White, Orange, Green, Blue


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GenerateBigBlock
;
; This rather elaborate function is responsible for the 
; generation of the "big block" blocks seen in a Plains style
; level.  At the current 'cursor' position, and with a given
; width, it automatically generates the block down to the floor
; (so note that there must be a floor there!) and even adds
; an appropriate shadow, shading against the sky, bushes, or
; other big blocks.  Very clever and elaborate, but why not just
; store a tile grid instead of complex generator functions? :P
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_GenerateBigBlock:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data
	; * Map_Tile_AddrL/H points to starting block of Tile_Mem_Addr(V)
	; * Temp_Var5 = Map_Tile_AddrH + 0/1 (if not vertical, otherwise unassigned)
	; * Temp_Var6 = Map_Tile_AddrH
	; * TileAddr_Off = (Temp_Var15 << 4) | (Temp_Var16 & $f), offset within screen

	; Function is also input 'X', which is the index this arrived via, which in
	; this case is a value of 0 - 3

	STX <Temp_Var12		; Temp_Var12 = X

	; Backup the current Map_Tile_AddrL/H values into Temp_Var3/4
	LDA <Map_Tile_AddrL
	STA <Temp_Var3		; Temp_Var3 = Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	STA <Temp_Var4		; Temp_Var4 = Map_Tile_AddrH

	; Lower 4 bits of LL_ShapeDef specify the "width" of the block
	LDA LL_ShapeDef
	AND #%00001111
	STA <Temp_Var1		; Temp_Var1 = lower 4 bits of LL_ShapeDef

	LDX #$00		; X = 0 (left edge to start)
PRG014_D0A8:
	TXA		 	; A = X (0, 1, 2 for left, middle, right)

	; Temp_Var12: 0-3 (entrance index), selects a root color offset from LL_BigBlock_Top_ColorOff
	; Temp_Var13: Gets root color, so we get 0, 3, 6, 9
	LDX <Temp_Var12	 		
	ADD LL_BigBlock_Top_ColorOff,X	; Offset to specified color
	STA <Temp_Var13			; Temp_Var13 = LL_BigBlock_Top_ColorOff[X] --> 0, 3, 6, 9
	TAX		 		; X = Temp_Var13 

	LDA LL_ShapeDef
	AND #%11000000	 
	STA <Temp_Var2			; Temp_Var2 = just the upper 2 bits of LL_ShapeDef ($00, $40, $80, $C0)

	LDY TileAddr_Off		; Y = TileAddr_Off

	; This applies the top of a big block
	LDA LL_BigBlock_Top,X		; Get tile for this 'X' (X = 0, 4, 8, 12)
	STA [Map_Tile_AddrL],Y		; Store into the level

	; This loops middle blocks until it hits ground
PRG014_D0C1:
	JSR LoadLevel_TileMemNextRow	; Go to next row of tiles, directly beneath this one
	LDA [Map_Tile_AddrL],Y		; Get this tile from existing memory

	; If grabbed tile is TILE1_GROUNDTM (ground top middle) or TILE1_GROUNDTL (ground top left), jump to PRG014_D0D8
	CMP #TILE1_GROUNDTM
	BEQ PRG014_D0D8
	CMP #TILE1_GROUNDTL	
	BEQ PRG014_D0D8

	; Otherwise, there's no ground here; get middle block
	LDX <Temp_Var13		 	; X = Temp_Var13 (0, 3, 6, 9)
	LDA LL_BigBlock_Mid,X	 	; Get appropriate middle block
	STA [Map_Tile_AddrL],Y	 	; Store into TileMem
	JMP PRG014_D0C1	 		; Loop for more ground

PRG014_D0D8:

	; Move back one row of tiles
	; Subtracts 16 from 'Y', updating Map_Tile_AddrH if needed
	TYA	
	SUB #16	
	TAY	
	LDA <Map_Tile_AddrH
	SBC #$00	 
	STA <Map_Tile_AddrH

	; And put the bottom here!
	LDX <Temp_Var13		 
	LDA LL_BigBlock_Bot,X	 
	STA [Map_Tile_AddrL],Y	 

	; Restore the original Map_Tile_AddrL/H values
	LDA <Temp_Var3		 
	STA <Map_Tile_AddrL
	LDA <Temp_Var4		
	STA <Map_Tile_AddrH	

	LDY TileAddr_Off	; Y = TileAddr_Off
	INY		 	; Y++ (next column over)
	TYA		 	; A = Y
	AND #$0f	 	; Keep just the lower 4 bits (specific column)
	BNE PRG014_D11C	 	; If column 1-15, jump to PRG014_D11C

	; Otherwise, we've just crossed over into the next screen...
	LDA TileAddr_Off	
	AND #$f0	 
	TAY		 	; Y = TileAddr_Off & $F0 -- the specific "row" of tiles on this screen

	; Add $1B0 to address (go to next screen) and update Temp_Var3/4 backup
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var3	
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var4	

	STA <Temp_Var5		; Temp_Var5 = Map_Tile_AddrH

	LDA <Temp_Var15
	AND #$10	
	BNE PRG014_D11C		; If bit 4 of Temp_Var15 is set, jump to PRG014_D11C

	INC <Temp_Var5		; Otherwise, Temp_Var5 = Map_Tile_AddrH + 1

PRG014_D11C:
	STY TileAddr_Off	; Update TileAddr_Off

	DEC <Temp_Var1		; Temp_Var1-- (the width value)

	LDX #$01		; X = 1 (middle blocks)

	LDA <Temp_Var1
	CMP #$01	
	BGS PRG014_D12E	 	; If Temp_Var1 >= 1, jump to PRG014_D12E

	; Otherwise...
	INX			; X = 2 (right-edge blocks)

	; 6502 assembler-ism: we used a BGS (signed) comparison above, so
	; don't think we get here only when Temp_Var1 is 0; we also get
	; here when Temp_Var1 has fallen below zero, which makes it
	; "not zero" (it'd be clearer as a BMI, but whatever)
	CMP #$00	 
	BNE PRG014_D133	 	; If Temp_Var1 <> 0, jump to PRG014_D133

PRG014_D12E:
	STX <Temp_Var13		; Update Temp_Var13 with new edge value
	JMP PRG014_D0A8	 	; Loop around...


	; We're done forming the block!  Left/right/middle, top to bottom!  Whew!


	; Now the shadow...


	; ** Determine proper upper-right corner shadow!

PRG014_D133:
	LDA [Map_Tile_AddrL],Y	; Get tile at our current location

	CMP #TILE1_SKY
	BNE PRG014_D13E	 ; If tile is not sky, jump to PRG014_D13E

	; If there's sky here, plant the corner shadow
	LDA #TILE1_BLOCK_SHUR
	JMP PRG014_D14F	 ; Jump to PRG014_D14F

PRG014_D13E:
	; If not a bush tile, jump to PRG014_D14B
	CMP #TILE1_BUSH_UL
	BLT PRG014_D14B
	CMP #TILE1_BUSH_SBR
	BGE PRG014_D14B	 

	; Otherwise, put shadow on bush
	LDA #TILE1_BUSH_SHUR
	JMP PRG014_D14F	 ; Jump to PRG014_D14F

PRG014_D14B:
	; Not sky, not bush; assume we're shadowing another big block
	AND #$c0	 ; Keep color quadrant
	ORA #$0b	 ; Set to the shaded block tile

PRG014_D14F:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem


	; ** Generate right side shadow...

PRG014_D151:
	JSR LoadLevel_TileMemNextRow	; Go to next row

	LDA [Map_Tile_AddrL],Y	 ; Check this tile

	CMP #TILE1_GROUNDTM
	BEQ PRG014_D15E	 	; If tile is top-middle ground, jump to PRG014_D15E (RTS)

	CMP #TILE1_GROUNDTR
	BNE PRG014_D15F	 	; If tile is NOT top-right ground, jump to PRG014_D15F

PRG014_D15E:
	RTS		 ; Return


PRG014_D15F:
	LDX #(LL_BigBlock_EndShadowChks-LL_BigBlock_ShadowChks-1)

	; Searching for block corners to terminate shadow
	LDA [Map_Tile_AddrL],Y	 	; Get this tile
PRG014_D163:
	CMP LL_BigBlock_ShadowChks,X
	BEQ PRG014_D170	 		; If this tile equals a shadow stopper, jump to PRG014_D170
	DEX		 	; X--
	BPL PRG014_D163		; While X >= 0, loop!

	LDA #TILE1_BLOCK_SHADOW
	JMP PRG014_D173	

PRG014_D170:
	LDA LL_BigBlock_ApprShadow,X	; Get appropriate shading tile

PRG014_D173:
	STA [Map_Tile_AddrL],Y	 	; Store this shadow tile!
	JMP PRG014_D151	 		; Loop!

	; The LL_BigBlockSky arrays define, per color, the large
	; colored blocks that float in the sky, with predetermined
	; shadow effects and whatnot...

LL_BigBlockSky_Left:
	.byte TILE1_WBLOCKUL, TILE1_WBLOCKLL, TILE1_BLOCK_SHLL
	.byte TILE1_OBLOCKUL, TILE1_OBLOCKLL, TILE1_BLOCK_SHLL
	.byte TILE1_GBLOCKUL, TILE1_GBLOCKLL, TILE1_BLOCK_SHLL
	.byte TILE1_BBLOCKUL, TILE1_BBLOCKLL, TILE1_BLOCK_SHLL

LL_BigBlockSky_Middle:
	.byte TILE1_WBLOCKTH, TILE1_WBLOCKBH, TILE1_BLOCK_SHADOWB
	.byte TILE1_OBLOCKTH, TILE1_OBLOCKBH, TILE1_BLOCK_SHADOWB
	.byte TILE1_GBLOCKTH, TILE1_GBLOCKBH, TILE1_BLOCK_SHADOWB
	.byte TILE1_BBLOCKTH, TILE1_BBLOCKBH, TILE1_BLOCK_SHADOWB

LL_BigBlockSky_Right:
	.byte TILE1_WBLOCKUR, TILE1_WBLOCKLR, TILE1_BLOCK_SHADOWB
	.byte TILE1_OBLOCKUR, TILE1_OBLOCKLR, TILE1_BLOCK_SHADOWB
	.byte TILE1_GBLOCKUR, TILE1_GBLOCKLR, TILE1_BLOCK_SHADOWB
	.byte TILE1_BBLOCKUR, TILE1_BBLOCKLR, TILE1_BLOCK_SHADOWB

LL_BigBlockSky_Shadow:
	.byte TILE1_BLOCK_SHUR, TILE1_BLOCK_SHADOW, TILE1_BLOCK_SHLR
	.byte TILE1_BLOCK_SHUR, TILE1_BLOCK_SHADOW, TILE1_BLOCK_SHLR
	.byte TILE1_BLOCK_SHUR, TILE1_BLOCK_SHADOW, TILE1_BLOCK_SHLR
	.byte TILE1_BLOCK_SHUR, TILE1_BLOCK_SHADOW, TILE1_BLOCK_SHLR


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_FloatingBigBlock
;
; Not nearly as elaborate as its "big brother" above, this
; function generates a simple rectangular block that floats
; and has a shadow.  Still generated, though...
;
; Always of a constant height (2 x W) with shadow, no clever 
; shadow detection code.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_FloatingBigBlock:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data
	; * Map_Tile_AddrL/H points to starting block of Tile_Mem_Addr(V)
	; * TileAddr_Off = (Temp_Var15 << 4) | (Temp_Var16 & $f), offset within screen

	; Back up current Map_Tile_Addr into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	; LL_ShapeDef actually determines the color of the block... a slightly
	; uglier way to do this than just take the index we came in with,
	; like the "big brother" generator function did!
	LDA LL_ShapeDef
	SUB #$50
	PHA		; Push LL_ShapeDef - $50
	
	AND #$f0
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	STA <Temp_Var3	; Store upper 4 bits of result, shifted down by 4, into Temp_Var3

	; Temp_Var3 is now a value like the following, depending on what range 
	; LL_ShapeDef started at (the left number):
	; 00 = $B, 10 = $C, 20 = $D, 30 = $E, 40 = $F, 50 = $0, 60 = $1, 70 = $2,
	; 80 = $3, 90 = $4, A0 = $5, B0 = $6, C0 = $7, D0 = $8, E0 = $9, F0 = $A

	PLA		; Restore LL_ShapeDef - $50

	AND #$0f	; Previous subtraction makes no difference here; keeps the lower 4 bits of LL_ShapeDef
	STA <Temp_Var4	; ... into Temp_Var4 (stores original width)
	STA <Temp_Var6	; ... and Temp_Var6 (active decrementing width counter)

	LDA #$00	
	STA <Temp_Var5	; Temp_Var5 = 0 (loop counter)
PRG014_D1CA:
	LDX <Temp_Var3	; X = Temp_Var3

	; Offset loop counter with color value
	LDA <Temp_Var5	
	ADD LL_BigBlock_Top_ColorOff,X

	TAX		 	; X = A (colorized block)

	LDY TileAddr_Off		; Y = TileAddr_Off
	LDA LL_BigBlockSky_Left,X	; Get this block
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Move to next column

	DEC <Temp_Var6		 	; Temp_Var6--

PRG014_D1E0:
	LDA LL_BigBlockSky_Middle,X	; Get this block
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Move to next column

	DEC <Temp_Var6		 	; Temp_Var6--
	LDA <Temp_Var6		 
	CMP #$01
	BNE PRG014_D1E0	 		; If Temp_Var6 <> 1, loop!

	LDA LL_BigBlockSky_Right,X	; Get this block
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Move to next column

	LDA LL_BigBlockSky_Shadow,X	; Get this shadow block
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Restore original Map_Tile_AddrL/H
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go down to next row (+16 to TileAddr_Off with carry to Map_Tile_AddrH, if needed)
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	LDA <Temp_Var4
	STA <Temp_Var6		 ; Temp_Var6 = Temp_Var4 (restore original width value)

	INC <Temp_Var5		 ; Temp_Var5++
	LDA <Temp_Var5		 
	CMP #$03	 
	BNE PRG014_D1CA	 	 ; If Temp_Var5 <> 3, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_RandomPUpClouds
;
; Generates 60 random "power up" clouds in Plains style levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_PUPClouds:
	.byte TILE1_PUPCLOUD_M, TILE1_PUPCLOUD_F, TILE1_PUPCLOUD_S

LoadLevel_RandomPUpClouds:
	LDA #59
	STA Misc_Counter ; Generate 60 random power up clouds!

PRG014_D22B:
	JSR Randomize	 ; Seed the randomizer
	LDA RandomN	 ; Get a random number
	AND #$0f	 
	CMP #10 
	BLT PRG014_D23A	 ; If random number < 10, jump to PRG014_D23A (mod 9 essentially)

	SUB #9	 	; If random number was 10, subtract 9 

PRG014_D23A:
	STA <Temp_Var15	 ; Random number 0-9

	LDA RandomN+1	 ; Get another random number
	TAX		 ; -> 'X'

	AND #$f0
	CMP #$f0
	BNE PRG014_D24B	 ; If the upper 4 bits are not all set, jump to PRG014_D24B

	; Otherwise, X += $20 (random 0 to $EF)
	TXA
	ADD #$20
	TAX	

PRG014_D24B:
	STX <Temp_Var16	 ; Temp_Var16 = 'X'

	TXA		 
	AND #$03	 
	CMP #$03	 
	BNE PRG014_D257	 ; If this random value is not 3, jump to PRG014_D257 (mod 3 essentially)

	; Otherwise, if 3, subtract 2 (make 0)
	SUB #2

PRG014_D257:
	PHA		 ; Save 'A' (Random value of 0-2)
	JSR LoadLevel_Set_TileMemAddr	 ; Set tile address
	PLA		 ; Restore 'A'

	TAX		 ; Get random 0-2 value

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_PUPClouds,X	 ; Get random power up cloud!
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	DEC Misc_Counter	 ; Misc_Counter--
	BPL PRG014_D22B	 	; While Misc_Counter >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VineToGround
;
; Constructs a vine from its starting point continuing downward
; until it hits any "not sky" tile
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VineToGround:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG014_D26E:
	LDA [Map_Tile_AddrL],Y	; Grab this tile
	CMP #TILE1_SKY	
	BEQ PRG014_D278	 	; If this is a sky tile jump to PRG014_D278

	CMP #TILE1_SKY
	BNE PRG014_D282	 	; If this is NOT a sky tile, jump to PRG014_D282 (RTS)

PRG014_D278:
	LDA #TILE1_VINE	 
	STA [Map_Tile_AddrL],Y		; Put a vine tile here
	JSR LoadLevel_TileMemNextRow	; Go to next row
	JMP PRG014_D26E	 ; Jump to PRG014_D26E

PRG014_D282:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LittleBushRun
;
; Puts down 1-16 of those cute little bushes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LittleBushRun:
	LDA LL_ShapeDef
	AND #$0f	 
	TAX		 ; X = lower 4 bits of LL_ShapeDef
	LDY TileAddr_Off ; Y = TileAddr_Off

PRG014_D28C:
	LDA #TILE1_LITTLE_BUSH
	STA [Map_Tile_AddrL],Y	 	; Put the little bush here
	JSR LoadLevel_NextColumn	; Next column
	DEX		 		; X--
	BPL PRG014_D28C	 		; While X >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Pitfall / LoadLevel_PitfallW
;
; Generates a pitfall along the ground, automatically adding
; the appropriate edge tiles on each side...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Pitfall:
	LDX #$00	 ; X = 0 (above ground tiles)
	BEQ PRG014_D2A9	 ; Jump (technically always) to PRG014_D2A9

LL_RightEdge:
	.byte TILE1_GROUNDTR,  TILE1_GROUNDMR	; Top and middle of ground, right edge
	.byte TILE1_WGROUNDTR, TILE1_WGROUNDMR	; Top and middle of underwater ground, right edge

LL_PitTile:
	.byte TILE1_SKY,       TILE1_SKY	; Associated pit tile for the ground (sky)
	.byte TILE1_WATER,     TILE1_WATER	; Associated pit tile for the underwater ground (water)

LL_LeftEdge:
	.byte TILE1_GROUNDTL,  TILE1_GROUNDML	; Top and middle of ground, left edge
	.byte TILE1_WGROUNDTL, TILE1_WGROUNDML	; Top and middle of underwater ground, left edge

LoadLevel_PitfallW:
	LDX #$02		; X = 2 (underwater tiles instead)

PRG014_D2A9:

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = the lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	; Y = TileAddr_Off

PRG014_D2BB:
	LDA <Temp_Var3
	STA <Temp_Var4		; Temp_Var4 = Temp_Var3 (store original width)

	; Right edge of the ground, beginning of pitfall
	LDA LL_RightEdge,X	; Get this tile
	STA [Map_Tile_AddrL],Y	; Store in tile mem
	JMP PRG014_D2CC		; Jump to PRG014_D2CC

	; Process run of tiles appropriate to the surface (sky or water)
PRG014_D2C7:
	LDA LL_PitTile,X	; Get this pit tile
	STA [Map_Tile_AddrL],Y	; Store in tile mem

PRG014_D2CC:
	JSR LoadLevel_NextColumn ; Go to next column
	DEC <Temp_Var4		 ; Temp_Var4-- (active width counter
	BNE PRG014_D2C7	 	 ; If Temp_Var4 <> 0, loop!

	; Left edge of ground, end of pitfall
	LDA LL_LeftEdge,X	 
	STA [Map_Tile_AddrL],Y	 

	; Restore Map_Tile_AddrL/H from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next offset row by adding 16, carry to Map_Tile_AddrH if needed...
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		; Update the backup Temp_Var2

	INX		 ; X++ (next do mid-ground)

	CPY #$b0	 
	BLT PRG014_D2BB	 ; If Y < $B0, loop!  ($B0 would be the beyond end of screen)

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GroundRun
;
; Puts down 1-255 tiles worth of ground.  Unlike other run
; functions, this does not use the limited lower 4 bits of
; LL_ShapeDef (in fact, does not use it at all), but instead
; grabs another byte from the layout stream and uses that as
; the width value, so this can stretch pretty far!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Ground top left/middle/right or underwater ground left/middle/right
LL_RunGroundTop:	
	.byte TILE1_GROUNDTL,  TILE1_GROUNDTM,  TILE1_GROUNDTR
	.byte TILE1_WGROUNDTL, TILE1_WGROUNDTM, TILE1_WGROUNDTR

	; Ground middle left/middle/right or underwater ground middle left/middle/right
LL_RunGroundMid:
	.byte TILE1_GROUNDML,  TILE1_GROUNDMM,  TILE1_GROUNDMR
	.byte TILE1_WGROUNDML, TILE1_WGROUNDMM, TILE1_WGROUNDMR

LL_RunGround_Offset:
	.byte 0, 3	; Solid ground, solid underwater ground

LoadLevel_GroundRun:
	LDY #$00	 ; Y = 0

	LDA [Level_LayPtr_AddrL],Y
	STA <Temp_Var3		 ; Get next byte from layout -> Temp_Var3 (width of run)

	; Level_LayPtr_Addr += 1
	LDA <Level_LayPtr_AddrL
	ADD #$01	 
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	PHA		 ; Push LL_ShapeDef

	; In short, Y = 0 or 1, depending on whether we were called by index 11 or 12
	SUB #$c0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAY		

	LDX LL_RunGround_Offset,Y	; X = 0 or 3 (solid or underwater solid)
	PLA		 	; Restore LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var4		; Temp_Var4 = lower 4 bits of LL_ShapeDef (width of run)

	LDA <Temp_Var3		; Byte retrieved from stream 
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 (save original width)

	LDY TileAddr_Off	; Y = TileAddr_Off

	; Left edge of ground
	LDA LL_RunGroundTop,X	; Get next ground tile
	STA [Map_Tile_AddrL],Y	; Store into tile mem

	JSR LoadLevel_NextColumn ; Go to next column

	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BEQ PRG014_D354	 	 ; If Temp_Var5 = 0, jump to PRG014_D354

	; Middle ground
PRG014_D348:
	LDA LL_RunGroundTop+1,X	 ; Get middle of ground
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Go to next column

	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG014_D348	 	 ; While Temp_Var5 <> 0, loop!

PRG014_D354:

	; Right edge of ground
	LDA LL_RunGroundTop+2,X	 ; Get right edge
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 and updating Map_Tile_AddrH if carried
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	DEC <Temp_Var4		 ; Temp_Var4--
	BMI PRG014_D398	 	 ; If Temp_Var4 < 0, jump to PRG014_D398 (RTS)

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3 (restore original width)

	; Left middle edge
	LDA LL_RunGroundMid,X	 ; Get left edge
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Go to next column
	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BEQ PRG014_D393	 	; If Temp_Var5 = 0, jump to PRG014_D393

PRG014_D387:
	; Middle middle 
	LDA LL_RunGroundMid+1,X	 ; Get middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Go to next column
	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BNE PRG014_D387	 	; While Temp_Var5 <> 0, loop!

PRG014_D393:
	; Right middle edge
	LDA LL_RunGroundMid+2,X	 ; Get right edge
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_D398:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_CloudRun
;
; Puts down a run of the big clouds, repeating the middle for
; the run in a strange fashion...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Cloud:
	.byte TILE1_CLOUD_UL, TILE1_CLOUD_LL, TILE1_CLOUD_UM, TILE1_CLOUD_LM, TILE1_CLOUD_UR, TILE1_CLOUD_LR

LoadLevel_CloudRun:

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	; Y = TileAddr_Off
	LDX #$00	 	; X = 0

PRG014_D3B3:
	LDA <Temp_Var3
	STA <Temp_Var4		; Temp_Var4 = Temp_Var3 (backup original width)

	LDA LL_Cloud,X	 	; Get left edge of cloud
	JMP PRG014_D3C0	 	; Jump to PRG014_D3C0

PRG014_D3BD:
	LDA LL_Cloud+2,X	; Get middle of cloud

PRG014_D3C0:
	STA [Map_Tile_AddrL],Y	; Store this into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4--
	BNE PRG014_D3BD	 	; If Temp_Var4 <> 0, loop!

	LDA LL_Cloud+4,X	 ; Get right edge of cloud
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Next row by adding 16 and updating Map_Tile_AddrH if carry
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2	 ; Update Map_Tile_AddrH backup

	INX		 ; X++
	CPX #$02	 
	BNE PRG014_D3B3	 ; If X <> 2, loop!

	RTS		 ; Return


LoadLevel_TileMemNextRow:
	; Y = TileAddr_Off

	TYA	
	ADD #16
	TAY		 ; Y += 16

	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	RTS		 ; Return

; FIXME: Anybody want to claim this??
; $D3FA 
	LDA <Temp_Var6		 ; A = Temp_Var6 (row offset into tile memory)
	STA <Map_Tile_AddrH	; -> Map_Tile_AddrH

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	INY		; next column
	TYA
	AND #$0f
	BNE PRG014_D438	 ; If we have not stepped into the end of this row, jump to PRG014_D438

	LDY #$00	 ; Y = 0

	LDA <Temp_Var15
	AND #$10
	BEQ PRG014_D410	 ; If bit 4 of Temp_Var15 is not set, jump to PRG014_D410

	INY		 ; Y = 1

PRG014_D410:
	STY <Temp_Var10		 ; Temp_Var10 = 0 or 1

	; Move forward half screen or one screen by adding $B0 / $1B0
	LDA <Map_Tile_AddrL
	ADD #$b0	
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	ADC <Temp_Var10
	STA <Map_Tile_AddrH
	STA <Temp_Var6		 ; Tile_AddrH -> Temp_Var6

	; "Map_Tile_Addr" is formed Tile_Mem_Addr[ (Temp_Var16 & $F0) >> 3 ]
	;	- The upper 4 bits of Temp_Var16 select the starting screen
	LDA <Temp_Var16
	AND #%11110000
	LSR A
	LSR A
	LSR A
	TAY		 ; -> 'Y'

	; Two screens over??
	INY
	INY
	LDA Tile_Mem_Addr+1,Y

	STA <Temp_Var5
	INC <Temp_Var5
	LDA TileAddr_Off
	AND #$f0
	TAY

PRG014_D438: 
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Corner
;
; Places a single corner tile in sloped levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_Corners:
	.byte TILE14_ABOVE_CORNER_UL, TILE3_ULCORNERGROUND, TILE3_WCORNER_UL	; Upper left
	.byte TILE14_ABOVE_CORNER_UR, TILE3_URCORNERGROUND, TILE3_WCORNER_UR	; Upper right
	.byte $FF, TILE3_LLCORNERGROUND, TILE3_WCORNER_LL	; Lower left (not avail AG) 
	.byte $FF, TILE3_LRCORNERGROUND, TILE3_WCORNER_LR	; Lower right (not avail AG) 

LoadLevel_Corner:
	LDX LL_ShapeDef	 	; LL_ShapeDef is limited 0-15 because of fixed size gen mode, so it's perfect! 
	LDY TileAddr_Off	; Y = TileAddr_Off
	LDA LL_Corners,X	 ; Get corner tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope45T2B
;
; Adds a 1-16 length 45 degree top-to-bottom slope.  With each
; iteration, it adds one more "midground" tile to the left of the
; slope.  So it looks like this:
; \
; M\
; MM\
; MMM\  ... and so on
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_SlopeMidGround:	.byte TILE14_ABOVE_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND		; Middle ground
LL_45SlopesT2B:		.byte TILE14_ABOVE_SLOPE45T2B, TILE3_SLOPE45T2B,  TILE3_WSLOPE45T2B	; 45 degree ground slopes top-to-bottom
LL_45SlopesB2T:		.byte TILE14_ABOVE_SLOPE45B2T, TILE3_SLOPE45B2T,  TILE3_WSLOPE45B2T	; 45 degree ground slopes bottom-to-top
LL_45SlopesT2BCeiling:	.byte $FF, TILE14_SLOPE45T2B_CEIL, TILE14_WSLOPE45T2B_CEIL		; 45 degree ceiling slopes top-to-bottom (not avail Above Ground)
LL_45SlopesB2TCeiling:	.byte $FF, TILE14_SLOPE45B2T_CEIL, TILE14_WSLOPE45B2T_CEIL		; 45 degree ceiling sloeps bottom-to-top (not avail Above Ground)


LoadLevel_Slope45T2B:	
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3	; Temp_Var3 = 0 (each additional slope tile we add is followed by +1 midground tiles behind it)

	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef	

	AND #$0f	 
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of slope)

	PLA		 ; Restore LL_ShapeDef
	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = Relative index 

PRG014_D482:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 
	BEQ PRG014_D497	 	; If Temp_Var3 is zero, we skip the middle ground addition

PRG014_D48B:
	LDA LL_SlopeMidGround,X	 ; Get middle ground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG014_D48B	 	 ; While Temp_Var5 > 0, loop! 

PRG014_D497:
	LDA LL_45SlopesT2B,X	 ; Get the 45 degree slope
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	INC <Temp_Var3		 ; Temp_Var3++ (one more midground behind the slope)
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG014_D482	 	; While Temp_Var4 >= 0, loop!

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope45B2T
;
; Adds a 1-16 length 45 degree bottom-to-top slope.  With each
; iteration, it adds one more "midground" tile to the right of
; the slope.  So it looks like this:
;    /
;   /M
;  /MM
; /MMM  ... and so on
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Slope45B2T:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3	; Temp_Var3 = 0 (each additional slope tile we add is followed by +1 midground tiles behind it)

	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef	

	AND #$0f	 
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of slope)

	PLA		 ; Restore LL_ShapeDef
	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = Relative index 

PRG014_D4DB:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 

	LDA LL_45SlopesB2T,X	 ; Get slope tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_D4EF	 	; Jump to PRG014_D4EF

PRG014_D4EA:
	LDA LL_SlopeMidGround,X	 ; Get mid-ground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_D4EF:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5--
	BPL PRG014_D4EA	 	 ; While Temp_Var5 >= 0, loop!

	INC <Temp_Var3		 ; Temp_Var3++ (one more midground behind the slope)


	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 15 to tile offset (we're always one column too far..)
	LDA TileAddr_Off
	ADD #15
	TAY		 
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	TYA
	AND #$0f
	CMP #$0f	
	BNE PRG014_D534	 	; If we haven't wrapped the screen, jump to PRG014_D534

	; Move back one screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0	
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	SBC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	; Jump to the right side
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

PRG014_D534:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG014_D4DB	 	; While Temp_Var4 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope45T2BCeiling
;
; Adds a 1-16 length 45 degree bottom-to-top slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
; \MMM
;  \MM
;   \M
;    \
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Slope45T2BCeiling:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	


	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef	

	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (diagonal length of slope)

	PLA		 ; Restore LL_ShapeDef
	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = Relative index 

PRG014_D557:
	LDY TileAddr_Off	 	; Y = TileAddr_Off
	LDA <Temp_Var3		 	
	STA <Temp_Var5		 	; Temp_Var3 = Temp_Var5 (next padding length)

	LDA LL_45SlopesT2BCeiling,X	; Get ceiling slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JMP PRG014_D56B	 		; Jump to PRG014_D56B

PRG014_D566:
	LDA LL_SlopeMidGround,X	 	; Get midground tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

PRG014_D56B:
	JSR LoadLevel_NextColumn	; Next column
	DEC <Temp_Var5		 	; Temp_Var5--
	BPL PRG014_D566	 		; While Temp_Var5 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH


	INY
	TYA
	AND #$0f
	BNE PRG014_D5A5	 	; If we haven't wrapped the screen, jump to PRG014_D534

	; Move forward one screen by adding $1B0
	LDA <Map_Tile_AddrL
	ADD #$b0	
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	DEY
	TYA
	AND #$f0
	TAY	

PRG014_D5A5:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	DEC <Temp_Var3		 ; Temp_Var3-- (diagonal length decrement, decreasing padding)
	BPL PRG014_D557	 	; While Temp_Var3 >= 0, loop!
	RTS		 ; Return




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope45B2TCeiling
;
; Adds a 1-16 length 45 degree bottom-to-top slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
; MMM/
; MM/ 
; M/  
; /   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Slope45B2TCeiling:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	


	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef	

	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (diagonal length of slope)

	PLA		 ; Restore LL_ShapeDef
	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = Relative index 

PRG014_D5C8:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3 
	BEQ PRG014_D5DD	 	; If Temp_Var3 is zero, we skip the middle ground addition

PRG041_D5D1:
	LDA LL_SlopeMidGround,X	 ; Get midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG041_D5D1	 	; While Temp_Var5 > 0, loop!

PRG014_D5DD:
	LDA LL_45SlopesB2TCeiling,X	; Get ceiling slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup
	DEC <Temp_Var3		 ; Temp_Var3-- (diagonal length decrement)
	BPL PRG014_D5C8	 	; While Temp_Var3 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope225T2B
;
; Adds a 1-16 length 22.5 degree top-to-bottom slope.  With each
; iteration, it adds two more "midground" tile to the left of the
; slope.  So it looks like this:
; --
; MM--
; MMMM--
; MMMMMM--
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_225SlopesT2B_Upper:	.byte TILE14_ABOVE_SLOPE225T2B_U, TILE3_SLOPE225T2B_U, TILE3_WSLOPE225T2B_U
LL_225SlopesT2B_Lower:	.byte TILE14_ABOVE_SLOPE225T2B_L, TILE3_SLOPE225T2B_L, TILE3_WSLOPE225T2B_L

LoadLevel_Slope225T2B:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3		; Temp_Var3 = 0

	LDA LL_ShapeDef	 
	PHA		 	; Save LL_ShapeDef

	AND #$0f	 
	STA <Temp_Var4		; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of run)

	PLA		 	; Restore LL_ShapeDef

	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = relative index

PRG014_D625:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		; Temp_Var5 = Temp_Var3
	BEQ PRG014_D642	 	; If Temp_Var3 is currently zero, skip the midground tiles

	; Midground tiles behind slope
PRG014_D62E:
	LDA LL_SlopeMidGround,X	 ; Get midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	LDA LL_SlopeMidGround,X	 ; Get midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG014_D62E	 	; While Temp_Var5

PRG014_D642:
	LDA LL_225SlopesT2B_Upper,X 	; Get proper slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Next column

	LDA LL_225SlopesT2B_Lower,X	; Get proper slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	INC <Temp_Var3		 ; Temp_Var3++ (midground tile increment)
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG014_D625	 	; While Temp_Var4 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope225B2T
;
; Adds a 1-16 length 22.5 degree top-to-bottom slope.  With each
; iteration, it adds two more "midground" tile to the right of the
; slope.  So it looks like this:
;       --
;     --MM
;   --MMMM
; --MMMMMM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_225SlopesB2T_Upper:	.byte TILE14_ABOVE_SLOPE225B2T_L, TILE3_SLOPE225B2T_L, TILE3_WSLOPE225B2T_L
LL_225SlopesB2T_Lower:	.byte TILE14_ABOVE_SLOPE225B2T_U, TILE3_SLOPE225B2T_U, TILE3_WSLOPE225B2T_U

LoadLevel_Slope225B2T:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA #$00
	STA <Temp_Var3		; Temp_Var3 = 0

	LDA LL_ShapeDef	 
	PHA		 	; Save LL_ShapeDef

	AND #$0f	 
	STA <Temp_Var4		; Temp_Var4 = lower 4 bits of LL_ShapeDef (diagonal length of run)

	PLA		 	; Restore LL_ShapeDef

	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = relative index

PRG014_D694:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3

	LDA LL_225SlopesB2T_Upper,X	; Get slope tile
	STA [Map_Tile_AddrL],Y		; Store into tile mem
	JSR LoadLevel_NextColumn	; Next column
	LDA LL_225SlopesB2T_Lower,X	; Get slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JMP PRG014_D6B8	 		; Jump to PRG014_D6B8

PRG014_D6AB:
	LDA LL_SlopeMidGround,X	 	; Get midground tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JSR LoadLevel_NextColumn	; Next column
	LDA LL_SlopeMidGround,X	 	; Get midground tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

PRG014_D6B8:
	JSR LoadLevel_NextColumn	; Next column
	DEC <Temp_Var5		 	; Temp_Var5--
	BPL PRG014_D6AB	 		; While Temp_Var5 >= 0, loop!


	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 14 to tile offset (always over by 2)
	LDA TileAddr_Off
	ADD #14
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	TYA		
	AND #$0f	
	CMP #14
	BLT PRG014_D6F9	 	; If we haven't crossed the screen, jump to PRG014_D6F9

	; Move back one screen by subtracting $1B0
	LDA <Map_Tile_AddrL
	SUB #$b0	 
	STA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	SBC #$01	
	STA <Map_Tile_AddrH

	; Jump to the right side
	TYA	
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2	

PRG014_D6F9:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	INC <Temp_Var3		 ; Temp_Var3++ (midground padding increment)
	DEC <Temp_Var4		 ; Temp_Var4-- (diagonal length decrement)
	BPL PRG014_D694	 	; While Temp_Var4 >= 0, loop!
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope225T2BCeiling
;
; Adds a 1-16 length 22.5 degree top-to-bottom slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
; --MMMMMM
;   --MMMM
;     --MM
;       --
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
	; This ceiling is not available Above Ground
LL_225SlopesT2B_LowerCeiling:	.byte $FF, TILE14_SLOPE225T2B_L_CEIL, TILE14_WSLOPE225T2B_L_CEIL
LL_225SlopesT2B_UpperCeiling:	.byte $FF, TILE14_SLOPE225T2B_U_CEIL, TILE14_WSLOPE225T2B_U_CEIL

LoadLevel_Slope225T2BCeiling:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	PHA		 	; Save LL_ShapeDef

	AND #$0f	 
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (diagonal length of run)

	PLA		 	; Restore LL_ShapeDef

	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = relative index


PRG014_D724:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3

	LDA LL_225SlopesT2B_LowerCeiling,X	; Get slope tile
	STA [Map_Tile_AddrL],Y		; Store into tile mem
	JSR LoadLevel_NextColumn	; Next column
	LDA LL_225SlopesT2B_UpperCeiling,X	; Get slope tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem
	JMP PRG014_D748	 		; Jump to PRG014_D748

PRG014_D73B:
	LDA LL_SlopeMidGround,X	 ; Get proper midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	LDA LL_SlopeMidGround,X	 ; Get proper midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_D748:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5--
	BPL PRG014_D73B	 ; While Temp_Var5 >= 0, loop

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDA TileAddr_Off

	; Go to next row
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	INY		 
	INY		 
	TYA		 
	AND #$0f	 
	CMP #$02	 
	BGE PRG014_D786	 ; If not crossing screen edge, jump to PRG014_D786

	; Go to next screen by adding $1B0 
	LDA <Map_Tile_AddrL
	ADD #$b0
	STA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	ADC #$01
	STA <Map_Tile_AddrH
	STA <Temp_Var2	

	DEY	
	DEY	
	TYA	
	AND #$f1
	TAY	

PRG014_D786:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_D724	 	; While Temp_Var3 >= 0, loop
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Slope225B2TCeiling
;
; Adds a 1-16 length 22.5 degree bottom-to-top slope along the 
; ceiling.  Each row packs midground tiles along the length.
; So it looks like this:
; MMMMMM--
; MMMM--
; MM--
; --
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
	; This ceiling is not available Above Ground
LL_225SlopesB2T_UpperCeiling:	.byte $FF, TILE14_SLOPE225B2T_U_CEIL, TILE14_WSLOPE225B2T_U_CEIL
LL_225SlopesB2T_LowerCeiling:	.byte $FF, TILE14_SLOPE225B2T_L_CEIL, TILE14_WSLOPE225B2T_L_CEIL

LoadLevel_Slope225B2TCeiling:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	 
	PHA		 	; Save LL_ShapeDef

	AND #$0f	 
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (diagonal length of run)

	PLA		 	; Restore LL_ShapeDef

	SUB #$10
	AND #$c0
	CLC	
	ROL A	
	ROL A	
	ROL A	
	TAX		 ; X = relative index

PRG014_D7AF:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3
	BEQ PRG014_D7CC	 ; If Temp_Var3 = 0, jump to  PRG014_D7CC

PRG014_D7B8:
	LDA LL_SlopeMidGround,X	 ; Get proper midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	LDA LL_SlopeMidGround,X	 ; Get proper midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5--
	BNE PRG014_D7B8	 	; While Temp_Var5 >= 0, loop!

PRG014_D7CC:
	LDA LL_225SlopesB2T_UpperCeiling,X	; Get ceiling slope tile
	STA [Map_Tile_AddrL],Y	 		; Store into tile mem
	JSR LoadLevel_NextColumn 		; Next column
	LDA LL_225SlopesB2T_LowerCeiling,X	; Get ceiling slope tile
	STA [Map_Tile_AddrL],Y	 		; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_D7AF	 	; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VertGroundL
;
; Adds a vertical 1-16 run of left vertical edge tiles for sloped levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_VertGroundL:	.byte TILE14_ABOVE_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL
LL_VertGroundR:	.byte TILE14_ABOVE_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR

LoadLevel_VertGroundL:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var1	 ; Temp_Var1 = lower 4 bits of LL_ShapeDef

	PLA		 ; Restore LL_ShapeDef

	SUB #$d0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	LDY TileAddr_Off 	; Y = TileAddr_Off
PRG014_D811:
	LDA LL_VertGroundL,X	; Get vertical ground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEC <Temp_Var1		 ; Temp_Var1--
	BPL PRG014_D811	 	; While Temp_Var1 >= 0, loop!
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VertGroundR
;
; Adds a vertical 1-16 run of right vertical edge tiles for sloped levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VertGroundR:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var1	 ; Temp_Var1 = lower 4 bits of LL_ShapeDef

	PLA		 ; Restore LL_ShapeDef

	SUB #$d0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ADD #3		; switches to the left edge tiles
	TAX		 ; X = relative index
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	JMP PRG014_D811	 ; Jump to PRG014_D811


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DecoGround
;
; Adds a rectangle (width 1-256 / height 1-16) of "deocrated
; ground" (in sloped levels) which can be the horizontal top
; applied with middle ground beneath it, or it's all just 
; middle ground (depending on index supplied)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Shared in Hills and Underground styles
	; Column order is Above Ground (UG only), Underground/Hills normal, Underwater
LL_DecoGroundTop:
	.byte TILE14_ABOVE_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND		; All midground
	.byte TILE14_ABOVE_HORZGROUND, TILE3_HORZGROUND, TILE3_WHORZGROUND	; Topped by horizontal ground

LL_DecoGroundMid:
	.byte TILE14_ABOVE_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND		; All midground
	.byte TILE14_ABOVE_MIDGROUND, TILE3_MIDGROUND, TILE3_WMIDGROUND		; Topped by horizontal ground

LoadLevel_DecoGround:
	LDY #$00	 ; Y = 0
	LDA [Level_LayPtr_AddrL],Y	 ; Get another byte from the layout stream
	STA <Temp_Var3		 	; Store into Temp_Var3 (width of rectangle)

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	AND #$0f
	STA <Temp_Var5	; Temp_Var5 = lower 4 bits of LL_ShapeDef (height of rectangle)

	PLA		 ; Restore LL_ShapeDef

	SUB #$40
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

PRG014_D87F:
	LDA LL_DecoGroundTop,X	 ; Get top ground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	LDA <Temp_Var4		 
	CMP #$ff	 
	BNE PRG014_D87F	 	; While Temp_Var4 >= 0, loop

	JMP PRG014_D8A2	 	; Jump to PRG014_D8A2

PRG014_D892:
	LDA LL_DecoGroundMid,X	 ; Get midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	LDA <Temp_Var4	
	CMP #$ff
	BNE PRG014_D892	 	; While Temp_Var4 >= 0, loop!

PRG014_D8A2:

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	LDA <Temp_Var3		 
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

	DEC <Temp_Var5		 ; Temp_Var5-- (height decrement)
	BPL PRG014_D892	 	; While Temp_Var5 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DecoCeiling
;
; Adds a rectangle (width 1-256 / height 1-16) of "deocrated
; ceiling" (in sloped levels) which is the ceiling
; applied with middle ground above it
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_DecoCeilingMid:	.byte $FF, TILE3_MIDGROUND, TILE3_MIDGROUND
LL_DecoCeiling:		.byte $FF, TILE3_CEILING, TILE3_WCEILING

LoadLevel_DecoCeiling:
	LDY #$00	 		; Y = 0
	LDA [Level_LayPtr_AddrL],Y	; Get byte from layout stream
	STA <Temp_Var3		 	; Store it into Temp_Var3 (width of rectangle)

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef	
	SUB #$a0	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 ; X = relative index

	LDA LL_ShapeDef	 
	AND #$0f	 
	STA <Temp_Var5		; Temp_Var5 = lower 4 bits of LL_ShapeDef (height of rectangle)

PRG014_D8F8:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA <Temp_Var5
	BEQ PRG014_D937	 	; If Temp_Var5 = 0, jump to PRG014_D937 (skip the middle ground portion)

PRG014_D903:
	LDA LL_DecoCeilingMid,X	 ; Get the midground tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	LDA <Temp_Var4		 
	CMP #$ff	
	BNE PRG014_D903	 	; While Temp_Var4 >= 0, loop!

	; Restore Map_Tile_Addr from backup 
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Move ahead one row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	DEC <Temp_Var5		; Temp_Var5-- (height decrement)
	BNE PRG014_D8F8	 	; While Temp_Var5 >= 0, loop

	LDA <Temp_Var3
	STA <Temp_Var4		; Temp_Var4 = Temp_Var3 (width copy)
	LDY TileAddr_Off	; Y = TileAddr_Off

PRG014_D937:
	LDA LL_DecoCeiling,X	 ; Get ceiling tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	LDA <Temp_Var4
	CMP #$ff	
	BNE PRG014_D937	 	; While Temp_Var4 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGOrWater
;
; Adds a rectangle (width 1-256 / height 1-16) of "background or 
; water" (depending on entry  index); this function seems a little 
; backwards in that does the "top" tile loop several times (by the 
; height value) until the last iteration when it does the "mid" 
; tiles; it seems like it should only do one top and the rest mid?
;
; TTTTTTTTTTTTT
; TTTTTTTTTTTTT  <-- which doesn't work for water, doesn't matter to the other ones...
; MMMMMMMMMMMMM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; Column order is Above Ground (this one's OK in non-UG), Underground/Hills normal, Underwater
LL_BGTop:	.byte TILE3_SKY, TILE3_UNDERGROUND, TILE3_WATERTOP
LL_BGMid:	.byte TILE3_SKY, TILE3_UNDERGROUND, TILE3_WATER


LoadLevel_BGOrWater:
	LDY #$00	 ; Y = 0
	LDA [Level_LayPtr_AddrL],Y	 ; Get another byte from the layout stream
	STA <Temp_Var3		 	; Store into Temp_Var3 (width of rectangle)

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	SUB #$10	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 ; Relative index

	PLA		 ; Restore LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var4	 ; Temp_Var4 = lower 4 bits of LL_ShapeDef (height of rectangle)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3	
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3 (width copy)

	LDA <Temp_Var4		
	BEQ PRG014_D99F	 	; If Temp_Var4 (height) = 0, jump to PRG014_D99F (does NOT use "Top" tile)

PRG014_D985:
	LDA LL_BGTop,X	 	; Get top tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	LDA <Temp_Var5		
	CMP #$ff
	BNE PRG014_D985	 	; While Temp_Var5 >= 0, loop!

	JMP PRG014_D9AB	 	; Jump to PRG014_D9AB (skip mid tiles)

PRG014_D998:
	LDA <Temp_Var3
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var3
	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG014_D99F:
	LDA LL_BGMid,X	 	; Get mid tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var5		 ; Temp_Var5-- (height decrement)
	BPL PRG014_D99F	 	; While Temp_Var5 >= 0, loop!

PRG014_D9AB:

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 to tile offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup

	DEC <Temp_Var4		 ; Temp_Var4-- (height decrement)
	BPL PRG014_D998	 	; While Temp_Var4 >= 0, loop!

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Nothing
;
; Fixed size generator in sloped level that does ... nothing!
; Probably something removed, dunno what it was...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Nothing:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_FillBackground
;
; Fills a large area of the background with sky, underground
; speckle and (FIXME? TILE3_UNK), e.g. used in 1-5
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG014_D9CA:
	.byte TILE3_SKY, TILE3_UNDERGROUND, TILE3_UNK

LoadLevel_FillBackground:
	LDA LL_ShapeDef	 
	SUB #$0d	 
	TAX		 ; X = relative index

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; The lower 5 bits of Temp_Var15 are whatever in fixed size gen...

	LDA <Temp_Var15	 
	AND #$10	 
	BNE PRG014_D9E1	 ; If bit 4 of Temp_Var15 is set, jump to PRG014_D9E1

	; Otherwise...
	CPY #$c0	  
	BLT PRG014_D9E9	 ; If Y < $C0 (end of screen), jump to PRG014_D9E9

PRG014_D9E1:
	TYA	
	SUB #$c0
	TAY	
	JMP PRG014_D9F3	 ; Jump to PRG014_D9F3

PRG014_D9E9:
	LDA PRG014_D9CA,X
	JSR Tile_Mem_ClearA
	CPY #$00	 
	BNE PRG014_D9E9	 

PRG014_D9F3:
	LDA PRG014_D9CA,X
	JSR Tile_Mem_ClearB
	INY		 
	CPY #$f0	 
	BNE PRG014_D9F3	 

	RTS		 ; Return


; FIXME: Anybody want to claim this??
; $D9FF 
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A		; Shift upper 4 bits down
	STA <Temp_Var4	; -> Temp_Var4

PRG014_DA16:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
PRG014_DA19:
	LDA #$47	; What tile?
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; +16 to next line
	TYA
	ADD #16
	TAY
	BCC PRG014_DA2A
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

PRG014_DA2A:
	LDA <Temp_Var5
	CMP <Map_Tile_AddrH
	BNE PRG014_DA19	 ; While Temp_Var5 <> Map_Tile_AddrH, loop

	CPY #$b0
	BLT PRG014_DA19	 ; If Y < $B0, loop!  ($B0 would be the beyond end of screen)

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	INY		 ; Y++
	TYA		 ; A = Y
	AND #$0f	 ; Check column
	BNE PRG014_DA6D	 ; If on column 1-15, jump to PRG014_DA6D

	LDA TileAddr_Off
	AND #$f0
	TAY		 ; current row offset -> 'Y'

	INC <Temp_Var4		 ; Temp_Var4++

	LDA <Temp_Var4
	ASL A	
	TAX		 ; X = Temp_Var4 << 1 (2 byte index for Tile_Mem_Addr)

	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	STA <Temp_Var1		 ; Update Map_Tile_AddrL backup
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup
	STA <Temp_Var5		 ; -> Temp_Var5

	INC <Temp_Var5		 ; Temp_Var5++

	LDA <Temp_Var15
	AND #$10	
	BEQ PRG014_DA6D		; If bit 4 of Temp_Var15 is not set, jump to PRG014_DA6D

	INC <Map_Tile_AddrH	; Move ahead to next 16 rows
	INC <Temp_Var2		; Temp_Var2++ (

PRG014_DA6D:
	STY TileAddr_Off	 ; Tile_Addr_Off = Y

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG014_DA16	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGBush
;
; Adds a 1-16 run of the little "background bushes" (left, run in
; the middle, right edge)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGBush:
	LDA LL_ShapeDef	 
	AND #$0f	 
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA #TILE3_BGBUSH_L	 ; Left edge of background bush
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_DA8A	 	; Jump to PRG014_DA8A

PRG014_DA86:
	LDA #TILE3_BGBUSH_M	 ; Middle bush
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_DA8A:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BNE PRG014_DA86	 	 ; While Temp_Var3 >= 0, loop!

	LDA #TILE3_BGBUSH_R	 ; Right edge of bush
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_CloudRun3
;
; Same functionality as LoadLevel_CloudRun but uses alternate tiles
; available in Level_Tileset 3 (1-2) / 14 (Underground)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Cloud3:
	.byte TILE3_CLOUD_UL, TILE3_CLOUD_LL, TILE3_CLOUD_UM, TILE3_CLOUD_LM, TILE3_CLOUD_UR, TILE3_CLOUD_LR

LoadLevel_CloudRun3:

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f	
	STA <Temp_Var3		; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	; Y = TileAddr_Off
	LDX #$00	 	; X = 0

PRG014_DAB0:
	LDA <Temp_Var3
	STA <Temp_Var4		; Temp_Var4 = Temp_Var3 (backup original width)

	LDA LL_Cloud3,X	 	; Get left edge of cloud
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG014_DAC1	 	; Jump to PRG014_DAC1

PRG014_DABC:
	LDA LL_Cloud3+2,X	 ; Get middle tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG014_DAC1:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BNE PRG014_DABC	 	 ; While Temp_Var4 >= 0, loop

	LDA LL_Cloud3+4,X	 ; Get right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2		 ; Update Map_Tile_AddrH backup
	INX		 	; X++
	CPX #$02	
	BNE PRG014_DAB0	 	; If we still have to do the bottom, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Tunnel
;
; Adds a 1-16 run of the "tunnel" tiles that appear beneath some
; grassy hills in a Hills style level.
;
; Note: Apparently at one time, the alternate diamond block seen
; in some W3 levels was to be an option, but for some reason they
; explicitly disabled it... wonder why?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Tunnel:
	.byte TILE3_TUNNEL
	.byte TILE3_ALTDIAMOND	; listed but not actually usable!

LoadLevel_Tunnel:
	LDA LL_ShapeDef	 
	PHA		 ; Save LL_ShapeDef

	SUB #$10
	AND #$f0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index
	BNE PRG014_DB13	 ; If X <> 0 (the alt diamond block), jump to PRG014_DB13 (RTS; I guess they didn't want to use it here?)

	PLA		 ; Restore LL_ShapeDef
	AND #$0f
	STA <Temp_Var4	 ; Temp_Var4

	LDY TileAddr_Off 	 ; Y = TileAddr_Off
PRG014_DB07:
	LDA LL_Tunnel,X	 	 ; Get tunnel tile (would've been also the diamond block, phooey)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var4		 ; Temp_Var4--
	BPL PRG014_DB07	 	; While Temp_Var4 >= 0, loop!

PRG014_DB13:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_MiscBG
;
; Miscellaneous background tile insert
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_MiscBG:
	.byte TILE3_LILCLOUD, TILE3_UNK2, TILE3_UNK3

LoadLevel_MiscBG:
	LDX LL_ShapeDef	 	; X = LL_ShapeDef (0-15)
	LDY TileAddr_Off	; Y = TileAddr_Off
	LDA LL_MiscBG,X	 	; Get misc BG tile
	STA [Map_Tile_AddrL],Y	; Store into tile mem
	RTS		 	; Return
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PrefabBlock
;
; Produces large, pre-defined 8x7 blocks.  I'm guessing this was
; just for the sake of pre-fabricating certain types of geometry
; that the typical generators were just not efficient for, but it
; really seems like an inconsistent waste!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PRG014_DB23:	.byte TILE14_ABOVE_CORNER_UR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB29:	.byte TILE3_SKY
PRG014_DB2A:	.byte TILE3_UNDERGROUND
PRG014_DB2B:	.byte TILE3_UNDERGROUND
PRG014_DB2C:	.byte TILE3_UNDERGROUND
PRG014_DB2D:	.byte TILE3_SLOPE45T2B
PRG014_DB2E:	.byte TILE3_MIDGROUND
PRG014_DB2F:	.byte TILE14_SLOPE45T2B_CEIL
PRG014_DB30:	.byte TILE3_SKY
PRG014_DB31:	.byte TILE3_UNDERGROUND
PRG014_DB32:	.byte TILE3_UNDERGROUND
PRG014_DB33:	.byte TILE3_UNDERGROUND
PRG014_DB34:	.byte TILE3_UNDERGROUND
PRG014_DB35:	.byte TILE3_UNDERGROUND
PRG014_DB36:	.byte TILE3_URCORNERGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB3C:	.byte TILE14_ABOVE_CORNER_UL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE14_SLOPE45T2B_CEIL
PRG014_DB40: 	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_HORZGROUND, TILE3_CEILING
PRG014_DB44:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_ULCORNERGROUND, TILE3_LLCORNERGROUND
PRG014_DB48:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_URCORNERGROUND, TILE3_LRCORNERGROUND, TILE3_UNDERGROUND
PRG014_DB4D:	.byte TILE3_UNDERGROUND, TILE3_SLOPE225B2T_L, TILE3_VERTGROUNDL, TILE3_WVERTGROUND_L, TILE3_WVERTGROUND_L, TILE3_MIDGROUND
PRG014_DB53:	.byte TILE3_SKY, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE45T2B
PRG014_DB59:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE14_SLOPE45T2B_CEIL
PRG014_DB5E:	.byte TILE3_UNDERGROUND, TILE3_SLOPE225B2T_U, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB64:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE14_SLOPE45T2B_CEIL
PRG014_DB6A:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB70:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE14_SLOPE45B2T_CEIL
PRG014_DB76:	.byte TILE14_ABOVE_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE14_SLOPE45B2T_CEIL
PRG014_DB7B:	.byte TILE3_UNDERGROUND, TILE3_SLOPE225T2B_U, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB81:	.byte TILE14_ABOVE_CORNER_UR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE14_SLOPE45B2T_CEIL, TILE3_UNDERGROUND
PRG014_DB86:	.byte TILE3_UNDERGROUND, TILE3_SLOPE225T2B_L, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB8C:	.byte TILE3_SKY, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE45B2T
PRG014_DB92:	.byte TILE14_ABOVE_CORNER_UL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DB98:	.byte TILE3_SKY
PRG014_DB99:	.byte TILE3_UNDERGROUND
PRG014_DB9A:	.byte TILE3_UNDERGROUND
PRG014_DB9B:	.byte TILE3_UNDERGROUND
PRG014_DB9C:	.byte TILE3_SLOPE45B2T
PRG014_DB9D:	.byte TILE3_MIDGROUND
PRG014_DB9E:	.byte TILE14_SLOPE45B2T_CEIL
PRG014_DB9F:	.byte TILE3_UNDERGROUND
PRG014_DBA0:	.byte TILE3_UNDERGROUND
PRG014_DBA1:	.byte TILE3_UNDERGROUND
PRG014_DBA2:	.byte TILE3_UNDERGROUND
PRG014_DBA3:	.byte TILE3_UNDERGROUND
PRG014_DBA4:	.byte TILE3_UNDERGROUND
PRG014_DBA5:	.byte TILE3_ULCORNERGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DBAB:	.byte TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL, TILE3_VERTGROUNDL
PRG014_DBB1:	.byte TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR, TILE3_VERTGROUNDR
PRG014_DBB7:	.byte TILE3_UNDERGROUND
PRG014_DBB8:	.byte TILE3_UNDERGROUND
PRG014_DBB9:	.byte TILE3_UNDERGROUND
PRG014_DBBA:	.byte TILE3_SLOPE225B2T_L, TILE3_MIDGROUND, TILE14_SLOPE225B2T_U_CEIL
PRG014_DBBD:	.byte TILE3_UNDERGROUND
PRG014_DBBE:	.byte TILE3_UNDERGROUND
PRG014_DBBF:	.byte TILE3_UNDERGROUND
PRG014_DBC0:	.byte TILE3_SLOPE225B2T_U, TILE3_MIDGROUND, TILE14_SLOPE225B2T_L_CEIL
PRG014_DBC3:	.byte TILE3_UNDERGROUND
PRG014_DBC4:	.byte TILE3_UNDERGROUND
PRG014_DBC5:	.byte TILE3_UNDERGROUND
PRG014_DBC6:	.byte TILE3_SLOPE225T2B_L, TILE3_MIDGROUND, TILE14_SLOPE225T2B_U_CEIL
PRG014_DBC9:	.byte TILE3_UNDERGROUND
PRG014_DBCA:	.byte TILE3_UNDERGROUND
PRG014_DBCB:	.byte TILE3_UNDERGROUND
PRG014_DBCC:	.byte TILE3_SLOPE225T2B_U, TILE3_MIDGROUND, TILE14_SLOPE225T2B_L_CEIL
PRG014_DBCF:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND
PRG014_DBD2:	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DBD8:	.byte TILE3_ULCORNERGROUND, TILE14_SLOPE225T2B_L_CEIL
PRG014_DBDA:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225B2T_L, TILE3_LLCORNERGROUND
PRG014_DBE0:	.byte TILE3_HORZGROUND, TILE14_SLOPE225T2B_U_CEIL
PRG014_DBE2:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225B2T_U, TILE3_CEILING
PRG014_DBE8:	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE14_SLOPE225T2B_L_CEIL
PRG014_DBEB:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225B2T_L, TILE3_MIDGROUND, TILE3_CEILING
PRG014_DBF1:	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE14_SLOPE225T2B_U_CEIL
PRG014_DBF4:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225B2T_U, TILE3_MIDGROUND, TILE3_CEILING
PRG014_DBFA:	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE14_SLOPE225B2T_U_CEIL
PRG014_DBFD:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225T2B_U, TILE3_MIDGROUND, TILE3_CEILING
PRG014_DC03: 	.byte TILE3_HORZGROUND, TILE3_MIDGROUND, TILE14_SLOPE225B2T_L_CEIL
PRG014_DC06:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225T2B_L, TILE3_MIDGROUND, TILE3_CEILING
PRG014_DC0C:	.byte TILE3_HORZGROUND, TILE14_SLOPE225B2T_U_CEIL
PRG014_DC0E:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225T2B_U, TILE3_CEILING
PRG014_DC14:	.byte TILE3_URCORNERGROUND, TILE14_SLOPE225B2T_L_CEIL
PRG014_DC16:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_UNDERGROUND, TILE3_SLOPE225T2B_L, TILE3_LRCORNERGROUND
PRG014_DC1C:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND
PRG014_DC1E:	.byte TILE3_UNDERGROUND, TILE3_WCORNER_UR, TILE3_WVERTGROUND_R, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DC24:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND
PRG014_DC26:	.byte TILE3_UNDERGROUND, TILE3_WATERTOP, TILE3_WATER, TILE3_WHORZGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DC2C:	.byte TILE3_UNDERGROUND, TILE3_UNDERGROUND
PRG014_DC2E:	.byte TILE3_UNDERGROUND, TILE3_WCORNER_UL, TILE3_WVERTGROUND_L, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DC34:	.byte TILE3_ULCORNERGROUND, TILE3_WVERTGROUND_L, TILE3_WVERTGROUND_L, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND
PRG014_DC3A:	.byte TILE3_URCORNERGROUND, TILE3_WVERTGROUND_R, TILE3_WVERTGROUND_R, TILE3_MIDGROUND, TILE3_MIDGROUND, TILE3_MIDGROUND


PRG014_DC40:
	; Each row defines one of the "entry indexes" -- from where that point, we pull 7 tiles
	; Each address in one row is the next column, pointing to the next 7 tiles to pull
	.word PRG014_DB23, PRG014_DB29, PRG014_DB53, PRG014_DB30, PRG014_DB3C, PRG014_DB59, PRG014_DB64, PRG014_DB6A	; Entry 0
	.word PRG014_DB6A, PRG014_DB70, PRG014_DB76, PRG014_DB81, PRG014_DB30, PRG014_DB8C, PRG014_DB98, PRG014_DB92	; Entry 1
	.word PRG014_DB99, PRG014_DB9A, PRG014_DB9B, PRG014_DB9C, PRG014_DB9D, PRG014_DB9E, PRG014_DB9F, PRG014_DB9F	; Entry 2
	.word PRG014_DB9F, PRG014_DB9F, PRG014_DB2F, PRG014_DB2E, PRG014_DB2D, PRG014_DB2C, PRG014_DB2B, PRG014_DB2A	; Entry 3
	.word PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40, PRG014_DB40	; Entry 4
	.word PRG014_DB9F, PRG014_DB9F, PRG014_DB9F, PRG014_DBAB, PRG014_DBB1, PRG014_DB9F, PRG014_DB9F, PRG014_DB9F	; Entry 5
	.word PRG014_DBB7, PRG014_DBBD, PRG014_DBB8, PRG014_DBBE, PRG014_DBB9, PRG014_DBBF, PRG014_DBBA, PRG014_DBC0	; Entry 6
	.word PRG014_DBCC, PRG014_DBC6, PRG014_DBCB, PRG014_DBC5, PRG014_DBCA, PRG014_DBC4, PRG014_DBC9, PRG014_DBC3	; Entry 7
	.word PRG014_DBD8, PRG014_DBE0, PRG014_DBE8, PRG014_DBF1, PRG014_DBFA, PRG014_DC03, PRG014_DC0C, PRG014_DC14	; Entry 8
	.word PRG014_DBDA, PRG014_DBE2, PRG014_DBEB, PRG014_DBF4, PRG014_DBFD, PRG014_DC06, PRG014_DC0E, PRG014_DC16	; Entry 9
	.word PRG014_DB9F, PRG014_DBA0, PRG014_DBA1, PRG014_DBA2, PRG014_DBA3, PRG014_DBA4, PRG014_DBA5, PRG014_DBD2	; Entry 10
	.word PRG014_DBD2, PRG014_DB36, PRG014_DB35, PRG014_DB34, PRG014_DB33, PRG014_DB32, PRG014_DB31, PRG014_DB9F	; Entry 11
	.word PRG014_DB9F, PRG014_DB9F, PRG014_DB9F, PRG014_DB44, PRG014_DB48, PRG014_DB9F, PRG014_DB9F, PRG014_DB9F	; Entry 12
	.word PRG014_DC1C, PRG014_DC24, PRG014_DC2C, PRG014_DBCF, PRG014_DC1C, PRG014_DC24, PRG014_DC2C, PRG014_DBCF	; Entry 13
	.word PRG014_DC1C, PRG014_DC24, PRG014_DB4D, PRG014_DB5E, PRG014_DC1E, PRG014_DC26, PRG014_DC34, PRG014_DBD2	; Entry 14
	.word PRG014_DC3A, PRG014_DC26, PRG014_DC2E, PRG014_DB7B, PRG014_DB86, PRG014_DC24, PRG014_DC2C, PRG014_DBCF	; Entry 15

LoadLevel_PrefabBlock:
	; Backup Map_Tile_Addr into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef	; LL_ShapeDef is a value 0 - 15 in fixed size gens
	ASL A		
	ASL A	
	ASL A	
	STA <Temp_Var5	 ; Temp_Var5 = 0, 8, 16, 24, ...

	; This loops for 8 columns
PRG014_DD50:
	LDA TileAddr_Off
	STA <Temp_Var6	 ; Temp_Var6 = TileAddr_Off

	LDA #$00
	STA <Temp_Var7	 ; Temp_Var7 = 0

	LDA <Temp_Var5
	ASL A		 
	TAX		 ; X = Temp_Var5 << 1 (0, 16, 32, 48, ...)

	; Get address from one row of PRG014_DC40 array above, store into Temp_Var3/4
	LDA PRG014_DC40,X
	STA <Temp_Var3	
	LDA PRG014_DC40+1,X
	STA <Temp_Var4	

	; This copies in 7 tiles vertically
PRG014_DD67:
	LDY <Temp_Var7		 ; Y = Temp_Var7 (row offset into pointer)
	LDA [Temp_Var3],Y	 ; Get byte from pointer for this row

	LDY <Temp_Var6		 ; Y = Temp_Var6 (row offset into tile memory)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16 to tile offset and also the TileAddr_Off
	TYA	
	ADD #16
	STA <Temp_Var6
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	INC <Temp_Var7		 ; Temp_Var7++ (row increment)

	LDA <Temp_Var7	
	CMP #$06	 
	BNE PRG014_DD67	 	; If Temp_Var6 <> 6, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1	
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	JSR LoadLevel_NextColumn ; Next column

	STY TileAddr_Off	 ; Tile_Addr_Off = Y
	
	; Update backup
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	INC <Temp_Var5		 ; Temp_Var5++ (column increment, get next address in same row)
	LDA <Temp_Var5
	AND #$07	
	BNE PRG014_DD50	 	; If Temp_Var5 < 8, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ThroneRoom
;
; Builds the end-of-world Throne Room (completely prefabricated!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; The end world castle throne room
LL_ThroneRoom:
; The princess's letter is actually here (at Vert_Scroll = 0)
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $47, $48, $48, $48, $48, $48, $48, $48, $48, $48, $48, $49, $02, $02
	.byte $02, $02, $4A, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $4A, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $4A, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $4A, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $4A, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $4A, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4C, $02, $02
	.byte $02, $02, $4A, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4B, $4F, $02, $02
	.byte $02, $02, $4D, $4E, $4E, $4E, $4E, $4E, $4E, $4E, $4E, $4E, $50, $51, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02

; You only see from here though... (at Vert_Scroll = $EF)
	.byte $9C, $9C, $9C, $9C, $9C, $9C, $9C, $9C, $9C, $9C, $9C, $9C, $9C, $9C, $9C, $9C
	.byte $C0, $96, $C2, $C4, $C4, $C4, $C4, $C4, $C4, $C4, $C4, $C4, $C4, $C4, $C4, $96
	.byte $C7, $82, $C3, $C9, $CB, $CB, $CB, $CB, $CB, $CB, $CB, $CB, $CB, $CB, $CB, $82
	.byte $C7, $82, $C6, $C8, $C9, $CB, $CB, $CB, $CB, $CB, $CB, $CB, $CB, $CB, $CB, $82
	.byte $C7, $82, $C6, $C7, $C8, $CE, $CF, $D0, $CE, $CF, $D0, $CE, $CF, $D0, $CE, $82
	.byte $C7, $82, $C6, $C7, $C7, $D3, $D4, $C7, $D3, $D4, $C7, $D3, $D4, $C7, $D3, $82
	.byte $C7, $82, $C6, $C7, $C7, $C7, $C7, $C7, $C7, $C7, $C7, $D6, $52, $53, $E7, $82
	.byte $C7, $82, $C6, $C7, $C7, $C7, $C7, $C7, $C7, $C7, $C7, $D6, $54, $55, $E7, $82
	.byte $C7, $82, $C6, $C7, $C7, $C7, $C7, $C7, $C7, $C7, $C7, $D6, $56, $57, $E7, $82
	.byte $C7, $83, $C6, $C7, $C7, $C7, $C7, $D6, $58, $59, $59, $59, $59, $59, $59, $83
	.byte $FF	; Terminator

LoadLevel_ThroneRoom:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	; Temp_Var1/2 point to LL_ThroneRoom
	LDA #(LL_ThroneRoom & $FF)
	STA <Temp_Var1		
	LDA #(LL_ThroneRoom >> 8)
	STA <Temp_Var2		

PRG014_DF41:
	LDA [Temp_Var1],Y	 ; Get next tile
	CMP #$ff	 
	BEQ PRG014_DF60	 	; If we hit the terminator, jump to PRG014_DF60

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	INY		 	; Y++ next tile
	CPY #$00	 	; Check if we overflowed
	BNE PRG014_DF5C	 	; If not, jump to PRG014_DF5C

	; Map_Tile_AddrH++
	LDA <Map_Tile_AddrH
	ADD #$01	 
	STA <Map_Tile_AddrH

	; Temp_Var2++ (move ahead 256 bytes)
	LDA <Temp_Var2
	ADD #$01	
	STA <Temp_Var2	

PRG014_DF5C:
	INX		 ; X++	; um, actually I don't think this serves a purpose!  Old version of loop idea I guess?
	JMP PRG014_DF41	; Jump to PRG014_DF41

PRG014_DF60:
	RTS		 ; Return



LBGHM_BitMasks:
	.byte $80, $40, $20, $10, $08, $04, $02, $01

	; Prevents collected coins or discovered hidden power ups from
	; reappearing if you switch areas
	; Returns non-zero if this coin was grabbed or 1-up was found already
LoadLevel_CheckBGHMem:

	; Backup X and Y
	STX <Temp_Var12
	STY <Temp_Var13

	LDA <Temp_Var15		; A = Temp_Var15 (first byte read from layout)
	AND #$10	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA <Temp_Var14		; Temp_Var14 = 0/1, depending on if Temp_Var15's bit 4 was set

	LDY <Temp_Var16		; Y = Temp_Var16 (second byte read from layout)

	LDA LL_ShapeDef	 	; A = LL_ShapeDef
	AND #$f0	 
	BEQ PRG014_DF8C	 	; If upper 4 bits of LL_ShapeDef are not set, jump to PRG014_DF8C

	; Otherwise...
	LDA LL_ShapeDef
	AND #$0f		; Take lower 4 bits of ShapeDef (the original width)
	SUB <Temp_Var3		; Subtract Temp_Var3 (the remaining width)
	ADD <Temp_Var16		; Add in the second value read
	TAY			; Y = original width - remaining width + Temp_Var16

PRG014_DF8C
	TYA		 	; A = Y
	AND #%11111000
	LSR A		 
	LSR A		 	; A = upper 5 bits of 'Y', shifted down twice (has a trailing zero bit)
	ORA <Temp_Var14		; 'Or' the 0/1 determined by Temp_Var15's bit 4
	STA <Temp_Var14		; Temp_Var14 holds the result

	LDA Level_JctFlag	 
	BEQ PRG014_DFA1	 	; If Level_JctFlag = 0 (no junction occurring), jump to PRG014_DFA1

	; Otherwise, Temp_Var14 += $40 (use second set for "alternate" level)
	LDA <Temp_Var14
	ADD #$40	 
	STA <Temp_Var14

PRG014_DFA1:
	LDA <Temp_Var13		; A = Temp_Var13 (the tile offset we came in with)
	AND #$07	 	; Keeping only the first 3 bits (0-7)
	TAX		 	; X = A (0-3)

	LDY <Temp_Var14			; Y = Temp_Var14 from above
	LDA Level_BlockGrabHitMem,Y	; Pull data from Level_BlockGrabHitMem

	; This sets the result of the check
	AND LBGHM_BitMasks,X	; Check if appropriate bit is set (means this coin was grabbed or hidden block hit or whatever)

	; Restore X/Y
	LDX <Temp_Var12
	LDY <Temp_Var13
	RTS		 	; Return

LoadLevel_NextColumn:
	INY		 ; Y++
	TYA		 ; A = Y
	AND #$0f	 ; Check column
	BNE PRG014_DFCC	 ; If on column 1-15, jump to PRG014_DFCC (RTS)

	; Otherwise, need to move over to the next screen (+$1B0)
	LDA <Map_Tile_AddrL
	ADD #$b0	 
	STA <Map_Tile_AddrL
	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH

	; Get TileAddr_Off and only keep the row, but clear 'Y' lower bits since
	; we're going to column 0 on the same row, new screen...
	LDA TileAddr_Off
	AND #$f0
	TAY	

PRG014_DFCC:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_StoreJctStart
;
; Temp_Var16 and LL_ShapeDef become bytes that fill in Level_JctYLHStart 
; and Level_JctXLHStart arrays, based on lower 4-bits of Temp_Var15
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_StoreJctStart:
	; Temp_Var15, Temp_Var16, and LL_ShapeDef are 3 input bytes from the loader routine

	; Lower 4 bits of Temp_Var15 define the index into Level_JctY/XLHStart
	LDA <Temp_Var15
	AND #$0f	
	TAY		; Y = Temp_Var15 & $f

	LDA <Temp_Var16	
	STA Level_JctYLHStart,Y		; Temp_Var16 is stored at Level_JctYLHStart[Y]

	LDA LL_ShapeDef	 
	STA Level_JctXLHStart,Y		; LL_ShapeDef is stored at Level_JctXLHStart[Y]

	RTS		 ; Return

; Rest of ROM bank was empty...

