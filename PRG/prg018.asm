; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-01-04 18:56:24.850111672 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
Tile_Layout_TS6_TS7_TS8:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $FF, $FF, $FF, $05, $05, $E8, $FF, $99, $99, $FF, $62, $63, $7C, $7E, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $B8, $B8 ; Tiles $20 - $2F
	.byte $B8, $B8, $BC, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DC, $05, $FC, $FC, $05, $05, $05, $05, $99, $FF, $FF, $99, $1A, $4A, $4C, $FE ; Tiles $40 - $4F
	.byte $1E, $4A, $4C, $FE, $44, $46, $44, $79, $44, $21, $44, $5C, $31, $09, $4A, $D8 ; Tiles $50 - $5F
	.byte $98, $98, $98, $98, $98, $98, $92, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4 ; Tiles $60 - $6F
	.byte $B4, $B8, $C0, $C0, $C0, $C0, $A4, $EC, $E4, $C0, $D5, $B2, $4A, $4C, $FE, $FE ; Tiles $70 - $7F
	.byte $05, $40, $42, $48, $4A, $C4, $50, $52, $6C, $60, $FE, $84, $05, $F0, $F2, $80 ; Tiles $80 - $8F
	.byte $82, $8C, $8E, $4E, $04, $04, $48, $49, $49, $40, $50, $50, $50, $42, $52, $52 ; Tiles $90 - $9F
	.byte $52, $3C, $AE, $60, $AE, $68, $6A, $38, $62, $AE, $42, $42, $42, $8C, $8E, $8C ; Tiles $A0 - $AF
	.byte $8E, $8C, $8E, $8C, $8E, $52, $52, $50, $40, $42, $AC, $AE, $B8, $8C, $8E, $52 ; Tiles $B0 - $BF
	.byte $40, $05, $50, $42, $52, $8C, $8E, $AC, $AE, $4E, $04, $04, $48, $49, $49, $36 ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $05, $B3, $CC, $FC, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $74, $0D, $0C, $FE, $68, $34, $35, $35, $5A, $36, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $02, $D7, $E0, $05, $94, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $FF, $FF, $FF, $06, $D6, $E9, $99, $99, $99, $FF, $FD, $FF, $7D, $7F, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $B9, $B9 ; Tiles $20 - $2F
	.byte $B9, $B9, $BD, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DD, $06, $FC, $FC, $06, $06, $06, $06, $99, $99, $99, $99, $4C, $FE, $1B, $4B ; Tiles $40 - $4F
	.byte $4C, $FE, $1F, $4B, $54, $56, $54, $7B, $54, $23, $54, $5D, $33, $4C, $FE, $D9 ; Tiles $50 - $5F
	.byte $99, $99, $99, $99, $99, $99, $93, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5 ; Tiles $60 - $6F
	.byte $B5, $B9, $C1, $C1, $C1, $C1, $A5, $ED, $E4, $C1, $B2, $B2, $FE, $0B, $4B, $4B ; Tiles $70 - $7F
	.byte $06, $44, $46, $4C, $4E, $C4, $54, $56, $6D, $6D, $FE, $06, $06, $F2, $F2, $90 ; Tiles $80 - $8F
	.byte $90, $9C, $9E, $04, $04, $4E, $58, $59, $59, $41, $51, $51, $51, $43, $53, $53 ; Tiles $90 - $9F
	.byte $53, $3E, $AE, $61, $AE, $41, $41, $41, $63, $AE, $6C, $6E, $3A, $9C, $9E, $9C ; Tiles $A0 - $AF
	.byte $9E, $9C, $9E, $9C, $9E, $53, $53, $51, $41, $43, $AC, $AE, $B9, $9C, $9E, $53 ; Tiles $B0 - $BF
	.byte $41, $06, $51, $43, $53, $9C, $9E, $AC, $AE, $04, $04, $4E, $58, $59, $59, $36 ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $E6, $CD, $CD, $CD, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $75, $0A, $FE, $FE, $69, $5A, $36, $36, $5A, $36, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $12, $06, $E1, $06, $95, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $FF, $FF, $FF, $07, $07, $EA, $99, $FF, $99, $FF, $62, $63, $7C, $7E, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $BA, $BA ; Tiles $20 - $2F
	.byte $BA, $BA, $BE, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DE, $07, $FC, $FC, $07, $07, $07, $07, $99, $FF, $FF, $FF, $4A, $1C, $FE, $4D ; Tiles $40 - $4F
	.byte $4A, $2E, $FE, $4D, $45, $47, $78, $47, $20, $47, $30, $5E, $47, $4A, $4A, $DA ; Tiles $50 - $5F
	.byte $9A, $9A, $9A, $9A, $9A, $9A, $CA, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6 ; Tiles $60 - $6F
	.byte $B6, $BA, $C2, $C2, $C2, $C2, $A6, $EE, $E5, $C2, $D5, $B2, $0A, $FE, $FE, $4D ; Tiles $70 - $7F
	.byte $07, $41, $43, $49, $4B, $C6, $51, $53, $6E, $61, $FE, $85, $07, $F1, $F3, $81 ; Tiles $80 - $8F
	.byte $83, $8D, $8F, $4F, $0D, $0D, $49, $49, $48, $40, $70, $70, $70, $42, $72, $72 ; Tiles $90 - $9F
	.byte $72, $AD, $3D, $AD, $64, $69, $69, $39, $AD, $66, $42, $42, $42, $8D, $8F, $8D ; Tiles $A0 - $AF
	.byte $8F, $8D, $8F, $8D, $8F, $72, $72, $70, $40, $42, $AD, $AF, $BA, $8D, $8F, $72 ; Tiles $B0 - $BF
	.byte $40, $07, $70, $42, $72, $8D, $8F, $AD, $AF, $4F, $0D, $0D, $49, $49, $48, $36 ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $07, $B3, $CE, $FC, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $76, $09, $0C, $FE, $6A, $35, $35, $37, $36, $5B, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $03, $D7, $E2, $07, $96, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $FF, $FF, $FF, $08, $D6, $EB, $99, $99, $FF, $FF, $FD, $FF, $7D, $7F, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $BB, $BB ; Tiles $20 - $2F
	.byte $BB, $BB, $BF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DF, $08, $FC, $FC, $08, $08, $08, $08, $99, $99, $FF, $FF, $FE, $4D, $4B, $1D ; Tiles $40 - $4F
	.byte $FE, $4D, $4B, $2F, $55, $57, $7A, $57, $22, $57, $32, $5F, $57, $FE, $FE, $DB ; Tiles $50 - $5F
	.byte $9B, $9B, $9B, $9B, $9B, $9B, $CB, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7 ; Tiles $60 - $6F
	.byte $B7, $BB, $C3, $C3, $C3, $C3, $A7, $EF, $E5, $C3, $B2, $B2, $4D, $4B, $4B, $0C ; Tiles $70 - $7F
	.byte $08, $45, $47, $4D, $4F, $C6, $55, $57, $6F, $6F, $FE, $08, $08, $F3, $F3, $91 ; Tiles $80 - $8F
	.byte $91, $9D, $9F, $0D, $0D, $4F, $59, $59, $58, $41, $71, $71, $71, $43, $73, $73 ; Tiles $90 - $9F
	.byte $73, $AD, $3F, $AD, $65, $41, $41, $41, $AD, $67, $6D, $6F, $3B, $9D, $9F, $9D ; Tiles $A0 - $AF
	.byte $9F, $9D, $9F, $9D, $9F, $73, $73, $71, $41, $43, $AD, $AF, $BB, $9D, $9F, $73 ; Tiles $B0 - $BF
	.byte $41, $08, $71, $43, $73, $9D, $9F, $AD, $AF, $0D, $0D, $4F, $59, $59, $58, $36 ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $E7, $CF, $CF, $CF, $FE, $FE, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $77, $0B, $FE, $FE, $6B, $36, $36, $5B, $36, $5B, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $13, $08, $E3, $08, $97, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

Tile_Attributes_TS6_TS7_TS8:
	.byte $0A, $4C, $91, $E2, $0A, $4C, $91, $E2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS6
;
; Entry point for loading level layout data for Level_Tileset = 6
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS6:
	; Clear Tile memory
	LDY #$00	 
PRG018_A40A:
	LDA #TILE6_SKY
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$f0
	BNE PRG018_A40A

	JMP LevelLoad	; Begin actual level loading!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS7
;
; Entry point for loading level layout data for Level_Tileset = 7
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS7:
	; Clear Tile memory
	LDY #$00	 

	; No apparent visibility -- sky??
PRG018_A41B:
	LDA #TILE7_SKY
	JSR Tile_Mem_ClearA
	CPY #$f0
	BNE PRG018_A41B

	; Used as Toad House main background blocks
	LDY #$30	
PRG018_A426:
	LDA #TILE7_TOADHOUSEBG
	JSR Tile_Mem_ClearB	
	INY		
	CPY #$e0	
	BNE PRG018_A426	

	; No apparent visibility -- checkerboard floor??
PRG018_A430:
	LDA #TILE7_CHECKERBOARDUL
	JSR Tile_Mem_ClearB	
	INY		
	LDA #TILE7_CHECKERBOARDUR
	JSR Tile_Mem_ClearB
	INY		
	CPY #$f0	
	BNE PRG018_A430	

	JMP LevelLoad	; Begin actual level loading!


	; Vertical level's unique clear routine
	; (where 'Y' CAN cover the entire screen space!)
	; So, same deal: Affects all screens at once...
Tile_Mem_ClearV:
	STA Tile_Mem+$000,Y
	STA Tile_Mem+$0F0,Y
	STA Tile_Mem+$1E0,Y
	STA Tile_Mem+$2D0,Y
	STA Tile_Mem+$3C0,Y
	STA Tile_Mem+$4B0,Y
	STA Tile_Mem+$5A0,Y
	STA Tile_Mem+$690,Y
	STA Tile_Mem+$780,Y
	STA Tile_Mem+$870,Y
	STA Tile_Mem+$960,Y
	STA Tile_Mem+$A50,Y
	STA Tile_Mem+$B40,Y
	STA Tile_Mem+$C30,Y
	STA Tile_Mem+$D20,Y
	STA Tile_Mem+$E10,Y
	INY		 ; Y++
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS8
;
; Entry point for loading level layout data for Level_Tileset = 8
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS8:
	LDY #$00
PRG018_A477:
	LDA #$8d	; Possibly a mistake / oversight; this is a fake Jelectro background tile thing :)  Looks cool, though!
	JSR Tile_Mem_ClearV
	CPY #$f0
	BNE PRG018_A477

	JMP LevelLoad	; Begin actual level loading!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS678
;
; Based on the values in Temp_Var15 and LL_ShapeDef, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG018_A483:
	.byte 0, 15, 30, 45, 60, 75, 90, 105

LoadLevel_Generator_TS678:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data


	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = upper 3 bits of Temp_Var15 (0-7) (selects a multiple of 15 as the base)

	LDA LL_ShapeDef
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = upper 4 bits of LL_ShapeDef shifted down
	ADD PRG018_A483,X	; Add multiple of 15
	TAX
	DEX
	TXA		 ; A = ((LL_ShapeDef >> 4) + PRG015_A483[X]) - 1


	; PRG018_A483 provides values well in excess of 57, but only 57
	; addresses are defined here; reserved for expansion...

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_SceneryVPipe		;  0 - Vertical scenery pipe (with pipe-cross detection)
	.word LoadLevel_ScenHPipe_RightWall	;  1 - "Right wall" Horizontal scenery pipe (with pipe-cross detection)
	.word LoadLevel_ScenHPipe_LeftWall	;  2 - "Left wall" Horizontal scenery pipe (with pipe-cross detection)
	.word LoadLevel_BGVPipe			;  3 - Vertical BG pipe
	.word LoadLevel_BGVMinipipe		;  4 - Vertical BG minipipe
	.word LoadLevel_BGHPipeLeft		;  5 - Horizontal left-ended BG pipe
	.word LoadLevel_BGHPipeRight		;  6 - Horizontal right-ended BG pipe
	.word LoadLevel_BGHMinipipe		;  7 - Horizontal BG minipipe
	.word LoadLevel_Nothing18		;  8 - NOTHING!  (Old removed? unknown?)
	.word LoadLevel_ToadBlockV		;  9 - Vertical run of Toad House blocks
	.word LoadLevel_ToadBlockAndShadow	; 10 - Horizontal run of Toad House blocks with shadows underneath
	.word LoadLevel_ToadShadowV		; 11 - Vertical run of Toad House shadow
	.word LoadLevel_UnderwaterScenery	; 12 - Vertical run of underwater plant things
	.word LoadLevel_UnderwaterScenery	; 13 - Vertical run of underwater circle things
	.word LoadLevel_DownwardSpikes		; 14 - Run of downward pointing spikes
	.word LoadLevel_BlockRun		; 15 - Run of bricks
	.word LoadLevel_BlockRun		; 16 - Run of '?' blocks with a coin
	.word LoadLevel_BlockRun		; 17 - Run of bricks with a coin
	.word LoadLevel_BlockRun		; 18 - Run of wood blocks
	.word LoadLevel_BlockRun		; 19 - Run of green note blocks (?)
	.word LoadLevel_BlockRun		; 20 - Run of note blocks
	.word LoadLevel_BlockRun		; 21 - Run of bouncing wood blocks
	.word LoadLevel_BlockRun		; 22 - Run of coins
	.word LoadLevel_VGroundPipeRun		; 23 - Vertical ground pipe 1 (alt level)
	.word LoadLevel_VGroundPipeRun		; 24 - Vertical ground pipe 2 (Big [?] area)
	.word LoadLevel_VGroundPipeRun		; 25 - Vertical ground pipe 3 (no entrance)
	.word LoadLevel_VCeilingPipeRun		; 26 - Vertical ceiling pipe 1 (alt level)
	.word LoadLevel_VCeilingPipeRun		; 27 - Vertical ceiling pipe 2 (no entrance)
	.word LoadLevel_HRightWallPipeRun	; 28 - Horizontal right-hand wall pipe (alt level)
	.word LoadLevel_HRightWallPipeRun	; 29 - Horizontal right-hand wall pipe (no entrance)
	.word LoadLevel_HLeftWallPipeRun	; 30 - Horizontal left-hand wall pipe (alt level)
	.word LoadLevel_HLeftWallPipeRun	; 31 - Horizontal left-hand wall pipe (no entrance)
	.word LoadLevel_Cannon			; 32 - Bullet bill cannon
	.word LoadLevel_CCBridge		; 33 - Cheep-Cheep style 'oo' bridge
	.word LoadLevel_CCBridge		; 34 - Would result in empty tiles?  (form of 33)
	.word LoadLevel_TopDecoBlocks		; 35 - Top-Deco Rectangle Waterfall
	.word LoadLevel_TopDecoBlocks		; 36 - Top-Deco Rectangle Left waving water pool
	.word LoadLevel_TopDecoBlocks		; 37 - Top-Deco Rectangle No current waving water pool
	.word LoadLevel_TopDecoBlocks		; 38 - Top-Deco Rectangle Right waving water pool
	.word LoadLevel_TopDecoBlocks		; 39 - Top-Deco Rectangle Water wrong-way BG
	.word LoadLevel_TopDecoBlocks		; 40 - Top-Deco Rectangle Diamond blocks (not really any deco on top)
	.word LoadLevel_TopDecoBlocks		; 41 - Top-Deco Rectangle Sand ground 
	.word LoadLevel_TopDecoBlocks		; 42 - Top-Deco Rectangle orange block??
	.word LoadLevel_IceBricks		; 43 - Run of ice bricks
	.word LoadLevel_VTransitPipeRun		; 44 - Vertical in-level transit pipe
	.word LoadLevel_VGroundPipe5Run		; 45 - Vertical ground pipe 5 (exits to common end area)
	.word LoadLevel_HRightWallPipeRun3	; 46 - Horizontal right-hand wall pipe 3 (no entrance)
	.word LoadLevel_TwoRowsWater		; 47 - Run of two rows of water (seems rather specific for water?)
	.word LoadLevel_GrayBlock		; 48 - Gray block which runs down to the orange block
	.word LoadLevel_OrangeBlock		; 49 - Rectangle of orange block terrain as used by water level
	.word LoadLevel_ToadBlackBGH		; 50 - Horizontal run of black background tiles in a Toad House
	.word LoadLevel_ToadBlackBGV		; 51 - Vertical run of black background tiles in a Toad House
	.word LoadLevel_Jelectro		; 52 - Jelectros!
	.word LoadLevel_HMinipipe		; 53 - Horizontal minipipe
	.word LoadLevel_UnderwaterCirclesH	; 54 - Horizontal run of the little circles
	.word LoadLevel_DonutLifts		; 55 - Run of donut lifts
	.word LoadLevel_UpwardSpikes		; 56 - Run of upward pointing spikes
	.word LoadLevel_WaterFill		; 57 - Rectangle of water tiles 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS678
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS678:
	; It is verified before calling this function that all of
	; the upper 4 bits of LL_ShapeDef are ZERO

	; So the upper 3 bits of Temp_Var15 serve as the most significant bits
	; to a value where LL_ShapeDef provide the 4 least significant bits

	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	ADD LL_ShapeDef	
	TAX		 	; Resultant index is put into 'X'
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_PipeElbows		;  0 - Upper left pipe elbow
	.word LoadLevel_PipeElbows		;  1 - Upper right pipe elbow
	.word LoadLevel_PipeElbows		;  2 - Lower left pipe elbow
	.word LoadLevel_PipeElbows		;  3 - Lower right pipe elbow
	.word LoadLevel_ArrowLifts		;  4 - Arrow lift UP
	.word LoadLevel_ArrowLifts		;  5 - Arrow lift RIGHT
	.word LoadLevel_ArrowLifts		;  6 - Arrow lift LEFT
	.word LoadLevel_ArrowLifts		;  7 - Arrow lift RANDOM
	.word LoadLevel_ToadChest		;  8 - Toad House chest
	.word LoadLevel_ToadMiniChest		;  9 - Toad House mini chest (NOT USED!)
	.word LoadLevel_Door2			; 10 - Door style 2
	.word LoadLevel_18UNK			; 11 - UNKNOWN garbage background tile
	.word LoadLevel_VerticalAltClear	; 12 - Commonly used to change the vertical level to the common black background!
	.word LoadLevel_LargeWater		; 13 - Large rectangle of water; fills to bottom of screen
	.word LoadLevel_18UNK_B			; 14 - UNKNOWN garbage background tile
	.word LoadLevel_18UNK_B			; 15 - UNKNOWN garbage background tile
	.word LoadLevel_PowerBlock		; 16 - ? block with flower
	.word LoadLevel_PowerBlock		; 17 - ? block with leaf 
	.word LoadLevel_PowerBlock		; 18 - ? block with star
	.word LoadLevel_PowerBlock		; 19 - ? block with coin OR star
	.word LoadLevel_PowerBlock		; 20 - ? block with coin (??)
	.word LoadLevel_PowerBlock		; 21 - Muncher Plant!
	.word LoadLevel_PowerBlock		; 22 - Brick with flower
	.word LoadLevel_PowerBlock		; 23 - Brick with leaf
	.word LoadLevel_PowerBlock		; 24 - Brick with star
	.word LoadLevel_PowerBlock		; 25 - Brick with coin OR star
	.word LoadLevel_PowerBlock		; 26 - Brick with 10-coin
	.word LoadLevel_PowerBlock		; 27 - Brick with 1-up
	.word LoadLevel_PowerBlock		; 28 - Brick with vine
	.word LoadLevel_PowerBlock		; 29 - Brick with P-Switch
	.word LoadLevel_PowerBlock		; 30 - Invisible coin
	.word LoadLevel_PowerBlock		; 31 - Invisible 1-up
	.word LoadLevel_PowerBlock		; 32 - Invisible note
	.word LoadLevel_PowerBlock		; 33 - Note block with flower
	.word LoadLevel_PowerBlock		; 34 - Note block with leaf
	.word LoadLevel_PowerBlock		; 35 - Note block with star
	.word LoadLevel_PowerBlock		; 36 - Wood block with flower
	.word LoadLevel_PowerBlock		; 37 - Wood block with leaf
	.word LoadLevel_PowerBlock		; 38 - Wood block with star
	.word LoadLevel_PowerBlock		; 39 - Invisible note to coin heaven
	.word LoadLevel_PowerBlock		; 40 - P-Switch
	.word LoadLevel_EndGoal			; 41 - The end goal


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_SceneryVPipe
;
; Inserts a 1-16 height vertical scenery pipe which checks for
; crossing other pipes and uses appropriate crossing tiles.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; If the pipe being constructed crosses one of these...
LL_SceneryVPipe_CrossChk:	.byte TILE8_SCENPIPE_HT,     TILE8_SCENPIPE_HB,     TILE8_MINIPIPE_HM,     TILE1_PIPEHT,          TILE1_PIPEHB
LL_SceneryVPipe_CrossChk_End

	; Replace it with corresponding cross tile! 
LL_SceneryVPipe_CrossL:	.byte TILE8_SCENPIPE_VL_HTC, TILE8_SCENPIPE_VL_HBC, TILE8_SCENPIPE_VL_HMC, TILE8_SCENPIPE_VL_HTC, TILE8_SCENPIPE_VL_HBC
LL_SceneryVPipe_CrossR:	.byte TILE8_SCENPIPE_VR_HTC, TILE8_SCENPIPE_VR_HBC, TILE8_SCENPIPE_VR_HMC, TILE8_SCENPIPE_VR_HTC, TILE8_SCENPIPE_VR_HBC

LoadLevel_SceneryVPipe:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of pipe)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE8_SCENPIPE_ENDVL
	BNE PRG018_A59F	 	; If tile is not the end of a scenery pipe vertical left, jump to PRG018_A59F

	LDA #TILE1_PIPEVL	; Otherwise, use tile for standard vertical pipe
	JMP PRG018_A5A1	 	; Jump to PRG018_A5A1

PRG018_A59F:
	LDA #TILE8_SCENPIPE_ENDVL	; Keep it the same

PRG018_A5A1:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY			 ; Y++
	LDA [Map_Tile_AddrL],Y	 ; Get tile here

	CMP #TILE8_SCENPIPE_ENDVR
	BNE PRG018_A5AF	 	; If tile is not the end of a scenery pipe vertical right, jump to PRG018_A5AF

	LDA #TILE1_PIPEVR	; Otherwise, use tile for standard vertical pipe
	JMP PRG018_A5B1	 	; Jump to PRG018_A5B1

PRG018_A5AF:
	LDA #TILE8_SCENPIPE_ENDVR	; Keep it the same

PRG018_A5B1:
	STA [Map_Tile_AddrL],Y	; Store into tile mem
	JMP PRG018_A5C1	 	; Jump to PRG018_A5C1

PRG018_A5B6:
	JSR LL_SceneryVPipe_CheckCrossL	 ; Check for pipe crossing (left)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Y++

	JSR LL_SceneryVPipe_CheckCrossR	 ; Check for pipe crossing (i)
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A5C1:

	; Go to next row by adding 16 to offset
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEC <Temp_Var3		; Temp_Var3-- (height decrement)
	BNE PRG018_A5B6	 	; While Temp_Var3 > 0, loop

	LDA #TILE8_SCENPIPE_ENDVL
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Y++

	LDA #TILE8_SCENPIPE_ENDVR
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


	; If pipe left side crosses another pipe, use the crossing tile!
LL_SceneryVPipe_CheckCrossL:
	LDX #(LL_SceneryVPipe_CrossChk_End - LL_SceneryVPipe_CrossChk - 1)
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
PRG018_A5E3:
	CMP LL_SceneryVPipe_CrossChk,X	 
	BEQ PRG018_A5F0	 	; If this tile is one of the ones in the list, jump to PRG018_A5F0
	DEX		 ; X--
	BPL PRG018_A5E3	 ; While X >= 0, loop!

	LDA #TILE1_PIPEVL	; Use standard vertical pipe tile
	JMP PRG018_A5F3	 	; Jump to PRG018_A5F3

PRG018_A5F0:
	LDA LL_SceneryVPipe_CrossL,X	 ; $A5F0 

PRG018_A5F3:
	RTS		 ; Return


	; If pipe right side crosses another pipe, use the crossing tile!
LL_SceneryVPipe_CheckCrossR:
	LDX #(LL_SceneryVPipe_CrossChk_End - LL_SceneryVPipe_CrossChk - 1)
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
PRG018_A5F8:
	CMP LL_SceneryVPipe_CrossChk,X	 
	BEQ PRG018_A605	 	; If this tile is one of the ones in the list, jump to PRG018_A5F0
	DEX		 ; X--
	BPL PRG018_A5F8	 ; While X >= 0, loop!

	LDA #TILE1_PIPEVR	; Use standard vertical pipe tile
	JMP PRG018_A608  	; Jump to PRG018_A5F3

PRG018_A605:
	LDA LL_SceneryVPipe_CrossR,X	 ; $A5F0 
PRG018_A608:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ScenHPipe_RightWall
;
; Inserts a 1-16 width horizontal scenery pipe which checks for
; crossing other pipes and uses appropriate crossing tiles.
; "Right wall" meaning the end is on the left with a middle segment.
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_SceneryHPipe_Mid:	.byte TILE8_SCENPIPE_HT, TILE8_SCENPIPE_HB
LL_SceneryHPipe_End:	.byte TILE8_SCENPIPE_ENDH1T, TILE8_SCENPIPE_ENDH1B

LoadLevel_ScenHPipe_RightWall:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of pipe)

	LDX #$00	 	; X = 0
	STX <Temp_Var5		 ; Temp_Var5 = 0

PRG018_A618:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

	LDA LL_SceneryHPipe_End,X	 ; Store pipe end
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A62C	 	; Jump to PRG018_A62C

PRG018_A627:
	JSR LL_SceneryHPipe_CheckCross	; Check for crossing tiles while building pipe
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A62C:
	INY		 ; Next column; this is OK for vertical levels, nowhere to the right
	DEC <Temp_Var4	 ; Temp_Var4-- (width decrement)
	BPL PRG018_A627	 ; While Temp_Var4 >= 0, loop!

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	INX		 ; X++
	STX <Temp_Var5	 ; Temp_Var5 = X (backup update)
	CPX #$02	 
	BNE PRG018_A618	 ; If X <> 2, loop!

	RTS		 ; Return
	
	; If the pipe being constructed crosses one of these...
LL_SceneryHPipe_CrossChk:	.byte TILE1_PIPEVL, TILE1_PIPEVR, TILE8_MINIPIPE_VM
LL_SceneryHPipe_CrossChk_End

	; Replace it with corresponding cross tile! 
LL_SceneryHPipe_CrossT:	.byte TILE8_SCENPIPE_HT_VLC, TILE8_SCENPIPE_HT_VRC, TILE8_SCENPIPE_HT_VMC
LL_SceneryHPipe_CrossB:	.byte TILE8_SCENPIPE_HB_VLC, TILE8_SCENPIPE_HB_VRC, TILE8_SCENPIPE_HB_VMC

LL_SceneryHPipe_CheckCross:
	LDX #(LL_SceneryHPipe_CrossChk_End - LL_SceneryHPipe_CrossChk - 1)
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
PRG018_A655:
	CMP LL_SceneryHPipe_CrossChk,X	; Is thie tile one of the standard vertical pipe tiles?
	BEQ PRG018_A665	 	; If so, jump to PRG018_A665
	DEX		 	; X--
	BPL PRG018_A655	 	; While X >= 0, loop!

	LDX <Temp_Var5		 	; X = Temp_Var5
	LDA LL_SceneryHPipe_Mid,X	; Get appropriate horizontal pipe tile
	JMP PRG018_A672	 		; Jump to PRG018_A672

PRG018_A665:
	LDA <Temp_Var5
	BNE PRG018_A66F	 	; If Temp_Var5 <> 0, jump to PRG018_A66F

	LDA LL_SceneryHPipe_CrossT,X	 ; Get appropriate crossing tile (top)
	JMP PRG018_A672	 		; Jump to PRG018_A672

PRG018_A66F:
	LDA LL_SceneryHPipe_CrossB,X	 ; Get appropriate crossing tile (bottom)

PRG018_A672:
	LDX <Temp_Var5		 ; X = Temp_Var5
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ScenHPipe_LeftWall
;
; Inserts a 1-16 width horizontal scenery pipe which checks for
; crossing other pipes and uses appropriate crossing tiles.
; "Left wall" meaning the end is on the right with a middle segment.
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ScenHPipe_LeftWall:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDX #$00	 	; X = 0
	STX <Temp_Var5		 ; Temp_Var5 = 0

PRG018_A680:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

PRG018_A687:
	JSR LL_SceneryHPipe_CheckCross
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	INY		 	; Next column; this is OK for vertical levels, nowhere to the right
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BNE PRG018_A687	 	; While Temp_Var4 > 0, loop!

	LDA LL_SceneryHPipe_End,X	 ; Get pipe end
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH

	INX		 ; X++
	STX <Temp_Var5	 ; Temp_Var5 = X
	CPX #$02
	BNE PRG018_A680	 ; If X <> 2, jump to 018_A680

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGVPipe
;
; Inserts a 1-16 width double-ended vertical background pipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGVPipe:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (width of pipe)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE8_BGPIPE_ENDVL	 ; BG pipe end vertical left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	LDA #TILE8_BGPIPE_ENDVR	 ; BG pipe end vertical right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A6CB	 	; Jump to PRG018_A6CB

PRG018_A6C2:
	LDA #TILE8_BGPIPE_VL	; BG pipe middle vertical left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	LDA #TILE8_BGPIPE_VR	; BG pipe middle vertical right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A6CB:

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		
	LDA <Map_Tile_AddrH
	ADC #$00	 
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height decrement)
	BNE PRG018_A6C2	 ; While X > 0, loop!

	LDA #TILE8_BGPIPE_ENDVL	 ; BG pipe end vertical left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	LDA #TILE8_BGPIPE_ENDVR	 ; BG pipe end vertical right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGVMinipipe
;
; Inserts a 1-16 height double-ended vertical background minipipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGVMinipipe:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE8_BGPIPE_MVT	; BG minipipe vertical top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A6FC	 ; $A6F5 

PRG018_A6F8:
	LDA #TILE8_BGPIPE_MVM	; BG minipipe vertical middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A6FC:

	; Go to next line by adding 16
	TYA	
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BNE PRG018_A6F8	 ; While X > 0, loop!

	LDA #TILE8_BGPIPE_MVB	; BG minipipe vertical bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGHPipeLeft
;
; Inserts a 1-16 width left-ended horizontal background pipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_BGPipeHMid:	.byte TILE8_BGPIPE_HT, TILE8_BGPIPE_HB
LL_BGPipeHEnd:	.byte TILE8_BGPIPE_ENDHT, TILE8_BGPIPE_ENDHB

LoadLevel_BGHPipeLeft:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of pipe)

	LDX #$00	 	; X = 0

PRG018_A71C:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3	
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

	LDA LL_BGPipeHEnd,X	 ; BG pipe vertical end
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG018_A730	 ; $A728 

PRG018_A72B:
	LDA LL_BGPipeHMid,X	 ; BG pipe vertical middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A730:
	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	DEC <Temp_Var4		 ; Temp_Var4--
	BPL PRG018_A72B	 	; While Temp_Var4 >= 0, loop!

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	INX		 ; X++
	CPX #$02
	BNE PRG018_A71C	 ; If X <> 2, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGHPipeRight
;
; Inserts a 1-16 width right-ended horizontal background pipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGHPipeRight;
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of pipe)

	LDX #$00	 	; X = 0

PRG018_A753:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA <Temp_Var3	
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

PRG018_A75A:
	LDA LL_BGPipeHMid,X	 ; BG pipe vertical middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	DEC <Temp_Var4		 ; Temp_Var4--
	BNE PRG018_A75A	 	; While Temp_Var4 > 0, loop!

	LDA LL_BGPipeHEnd,X	 ; BG pipe vertical end
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	INX		 ; X++
	CPX #$02
	BNE PRG018_A753	 ; If X <> 2, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BGHMinipipe
;
; Inserts a 1-16 width double-ended horizontal background minipipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BGHMinipipe:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (width of pipe)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE8_BGPIPE_MHL	 ; BG Minipipe horizontal left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A792	 	; Jump to PRG018_A792

PRG018_A78E:
	LDA #TILE8_BGPIPE_MHM	 ; BG Minipipe horizontal middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A792:
	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	DEX		 ; X-- (width decrement)
	BNE PRG018_A78E	 ; While X > 0, loop

	LDA #TILE8_BGPIPE_MHR	 ; BG Minipipe horizontal right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_HMinipipe
;
; Inserts a 1-16 width double-ended horizontal minipipe
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_HMinipipe:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE8_MINIPIPE_HL	; Minipipe horizontal left
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG018_A7AF	 	; Jump to PRG018_A7AF

PRG018_A7AB:
	LDA #TILE8_MINIPIPE_HM	; Minipipe horizontal middle
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_A7AF:
	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	DEX		 ; X-- (width decrement)
	BNE PRG018_A7AB	 ; While X > 0, loop

	LDA #TILE8_MINIPIPE_HR	; Minipipe horizontal right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Nothing18
;
; Old removed? unknown?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Nothing18:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_UnderwaterScenery
;
; Generates a variable 1-16 height version of the underwater plant 
; things or the water circle things (what ARE those anyway?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_UnderwaterScenery:
	.byte TILE6_UNDERWATERPLANT_T, TILE6_UNDERWATERCIRCLE
	.byte TILE6_UNDERWATERPLANT_M, TILE6_UNDERWATERCIRCLE

LoadLevel_UnderwaterScenery:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	SUB #$d0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	PLA		 ; Restore LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_UnderwaterScenery,X 	; Get top tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	JMP PRG018_A7DE	 		; Jump to PRG018_A7DE

PRG018_A7D9:
	LDA LL_UnderwaterScenery+2,X	; Get mid tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

PRG018_A7DE:

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEC <Temp_Var3	 ; Temp_Var3-- (height decrement)
	BPL PRG018_A7D9	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_PipeElbows
;
; One of those things linking a pipe at a 90 degree junction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Each column is one elbow, all four rows belong to a single elbow in one column
LL_PipeElbows:
	.byte TILE8_PIPEELBOW_CUL, TILE8_PIPEELBOW_UL, TILE8_PIPEELBOW_UL, TILE8_PIPEELBOW_UL
	.byte TILE8_PIPEELBOW_UR, TILE8_PIPEELBOW_CUR, TILE8_PIPEELBOW_UR, TILE8_PIPEELBOW_UR
	.byte TILE8_PIPEELBOW_LL, TILE8_PIPEELBOW_LL, TILE8_PIPEELBOW_CLL, TILE8_PIPEELBOW_LL
	.byte TILE8_PIPEELBOW_LR, TILE8_PIPEELBOW_LR, TILE8_PIPEELBOW_LR, TILE8_PIPEELBOW_CLR

LoadLevel_PipeElbows:
	LDX LL_ShapeDef	 	; X = LL_ShapeDef
	LDY TileAddr_Off	; Y = TileAddr_Off

	LDA LL_PipeElbows,X	 ; Get upper left tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	LDA LL_PipeElbows+4,X	 ; Get upper right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	LDA LL_PipeElbows+8,X	 ; Get lower left tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	LDA LL_PipeElbows+12,X	 ; Get lower right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_UpwardSpikes
;
; Inserts a 1-16 width run of upward pointing spikes
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_UpwardSpikes:
	LDX #$01	; X = 1 (Upward spikes)
	BNE PRG018_A833	; Jump (technically always) to PRG018_A833

LL_Spikes:	.byte TILE8_SPIKE_DOWN, TILE8_SPIKE_UP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DownwardSpikes
;
; Inserts a 1-16 width run of downward pointing spikes
; For vertical pipe maze levels only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_DownwardSpikes:
	LDX #$00	; X = 0 (Downward spikes)

PRG018_A833:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of spike run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG018_A83D:
	LDA LL_Spikes,X	 	; Get spike tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 	; Next column; this is OK for vertical levels, nowhere to the right

	DEC <Temp_Var3	 ; Temp_Var3-- (width decrement)
	BPL PRG018_A83D	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_VerticalAltClear
;
; Alternate clear to all black tiles for vertical level
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_VerticalAltClear:
	LDY #$00	
PRG018_A84A:
	LDA #TILE8_BLACK
	JSR Tile_Mem_ClearV
	CPY #$f0
	BNE PRG018_A84A

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_TwoRowsWater
;
; Inserts a 1-16 width run of two rows of water
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_TwoRowsWater:
	; Backup Map_Tile_AddrL/H to Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDX #$01	 	; X = 1

PRG018_A868:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

PRG018_A86C:
	LDA #TILE6_WATER	; Water
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BPL PRG018_A86C	 	; While Temp_Var4 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	

	DEX		 ; X-- (row decrement)
	BPL PRG018_A868	 ; While X >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_GrayBlock
;
; Inserts a 1-16 width gray block that runs until it hits an 
; orange block tile (the main terrain of underwater levels)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_GrayLeft:	.byte TILE6_GRAYPLATFORM_UL, TILE6_GRAYPLATFORM_ML
LL_GrayMiddle:	.byte TILE6_GRAYPLATFORM_UM, TILE6_GRAYPLATFORM_MM
LL_GrayRight:	.byte TILE6_GRAYPLATFORM_UR, TILE6_GRAYPLATFORM_MR

LoadLevel_GrayBlock:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDX #$00	 ; X = 0

PRG018_A8A4:
	LDA <Temp_Var3
	STA <Temp_Var4	; Temp_Var4 = Temp_Var3

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE6_ORANGEBLK_UL
	BLT PRG018_A8B5	 	; If tile is less than the orange block's tiles, jump to PRG018_A8B5

	CMP #TILE6_ORANGEBLK_UR	 
	BLT PRG018_A8EA	 	; If in range of the orange block tiles, jump to PRG018_A8EA (RTS)

PRG018_A8B5:
	LDA LL_GrayLeft,X	; Left gray block
	JMP PRG018_A8BE	 	; Jump to PRG018_A8BE

PRG018_A8BB:
	LDA LL_GrayMiddle,X	 ; Middle gray block

PRG018_A8BE:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4-- (width decrement)
	BNE PRG018_A8BB	 	; While Temp_Var4 >= 0, loop

	LDA LL_GrayRight,X	 ; Right gray block

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$01	 	; X = 1 (use mid blocks for rest of run)
	JMP PRG018_A8A4	 	; Jump to PRG018_A8A4

PRG018_A8EA:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_OrangeBlock
;
; Rectangle of 1-256 x 1-16 of orange block terrain as common to
; the water levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_OrangeLeft:	.byte TILE6_ORANGEBLK_UL, TILE6_ORANGEBLK_LL
LL_OrangeMiddle:.byte TILE6_ORANGEBLK_UM, TILE6_ORANGEBLK_LM
LL_OrangeRight:	.byte TILE6_ORANGEBLK_UR, TILE6_ORANGEBLK_LR

LoadLevel_OrangeBlock:
	; Get byte from layout data
	LDY #$00	 
	LDA [Level_LayPtr_AddrL],Y
	STA <Temp_Var4

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef (height of block)

	LDX #$00	 	; X = 0

PRG018_A915:
	LDA <Temp_Var4
	STA <Temp_Var5		 ; Temp_Var5 = Temp_Var4 (width copy)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_OrangeLeft,X	; Get left tile
	JMP PRG018_A925	 	; Jump to PRG018_A925

PRG018_A922:
	LDA LL_OrangeMiddle,X	 ; Get middle tile

PRG018_A925:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var5		 ; Temp_Var5-- (width decrement)
	BNE PRG018_A922	 	; While Temp_Var5 >= 0, loop

	LDA LL_OrangeRight,X	 ; Get right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$01	 ; X = 1 (repeat bottom tiles)
	DEC <Temp_Var3	 ; Temp_Var3-- (height decrement)
	BPL PRG018_A915	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ToadBlackBGH
;
; Run of 1-16 toad black background tiles horizontally
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ToadBlackBGH:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (width of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG018_A95C:
	LDA #TILE7_BLACK
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- (width decrement)
	BPL PRG018_A95C	 ; While X >= 0, loop
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ToadBlackBGV
;
; Run of 1-16 toad black background tiles
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ToadBlackBGV:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (height of run)

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG018_A970:
	LDA #TILE7_BLACK	; Black background tile of Toad House
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height of run)
	BPL PRG018_A970	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_UnderwaterCirclesH
;
; Run of 1-16 of those underwater circle things
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_UnderwaterCirclesH:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG018_A98C:
	LDA #TILE6_UNDERWATERCIRCLE
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- (width of run)
	BPL PRG018_A98C	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WaterFill
;
; 1-256 x 1-32 rectangle of water 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_WaterFill:
	LDY #$00
	LDA [Level_LayPtr_AddrL],Y	; Get another byte from layout data
	STA <Temp_Var3		 	; Store into Temp_Var3

	; Level_LayPtr_Addr++
	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$1f
	STA <Temp_Var4		 ; Temp_Var4 = lower 5 bits of Temp_Var4

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDX <Temp_Var3		 ; X = Temp_Var3 (width)
 
PRG018_A9BE:
	LDA #TILE6_WATERTOP	; Top of water tile 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- 
	CPX #$ff	  
	BNE PRG018_A9BE	 ; While X >= 0, loop!
 
	JMP PRG018_A9DB	 ; Jump to PRG018_A9DB 

PRG018_A9CD:
	LDX <Temp_Var3		 ; X = Temp_Var3 
PRG018_A9CF:
	LDA #TILE6_WATER	; Water tile 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X-- 
	CPX #$ff 
	BNE PRG018_A9CF	 ; While X >= 0, loop!

PRG018_A9DB: 
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1 
	STA <Map_Tile_AddrL 
	LDA <Temp_Var2 
	STA <Map_Tile_AddrH

	; Go to next row by adding 16 
	LDA TileAddr_Off 
	ADD #16 
	STA TileAddr_Off 
	TAY 
	LDA <Map_Tile_AddrH 
	ADC #$00 
	STA <Map_Tile_AddrH 
	STA <Temp_Var2 
	DEC <Temp_Var4		 ; Temp_Var4-- (height decrement)
	BPL PRG018_A9CD	 	; While Temp_Var4 >= 0, loop! 
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ArrowLifts
;
; Insert one of the four arrow lifts
; Vertical pipe maze type level only!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_ArrowLifts:
	.byte TILE8_ARROWLIFT_UPL, TILE8_ARROWLIFT_RIGHTL, TILE8_ARROWLIFT_LEFTL, TILE8_ARROWLIFT_RANDOML
	.byte TILE8_ARROWLIFT_UPR, TILE8_ARROWLIFT_RIGHTR, TILE8_ARROWLIFT_LEFTR, TILE8_ARROWLIFT_RANDOMR

LoadLevel_ArrowLifts:
	LDA LL_ShapeDef
	SUB #$04
	TAX		 ; X = relative index

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA LL_ArrowLifts,X	 ; Get arrow lift left tile 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 ; Next column; this is OK for vertical levels, nowhere to the right

	LDA LL_ArrowLifts+4,X	 ; Get arrow lift right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_18UNK
;
; Places UNKNOWN TILE that is garbage in Tilesets 6-8
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_18UNK:
	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA #TILE7_UNK		 ; ?? tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LargeWater
;
; Inserts a potentially VERY large rectangle of water!  First row
; is always the top of water, followed by water tiles underneath.
; Width is 256 tiles.  Height can vary, appears to be intended as
; up to 26 rows (full screen height)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LargeWater:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	; This determines height of the water rectangle, which is number of rows to bottom of screen
	LDA <Temp_Var15	
	AND #%00011111	; lower 5 bits of Temp_Var15 used here

	STA <Temp_Var3
	LDA #26		; Full screen rows
	SUB <Temp_Var3	
	STA <Temp_Var3	; Temp_Var3 = $1a - lower 5 bits

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDX #$ef	 	; X = $EF
PRG018_AA3A:
	LDA #TILE6_WATERTOP	; Top of water
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	CPX #$ff	 
	BNE PRG018_AA3A	 ; While X <> $FF, loop

	JMP PRG018_AA55	 ; $AA46 

PRG018_AA49:
	LDA #TILE6_WATER	 ; Water tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column
	DEX		 ; X--
	CPX #$ff
	BNE PRG018_AA49	 ; While X <> $FF, loop!


PRG018_AA55:

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00	
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$ef	 ; X = $EF
	DEC <Temp_Var3	 ; Temp_Var3-- (height decrement)
	BPL PRG018_AA49	 ; While Temp_Var3 >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ToadBlockV
;
; Adds a vertical run of Toad House blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ToadBlockV:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef (height of run

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG018_AA7F:
	LDA #TILE7_TOADHOUSEBLOCK ; Toad house wall block
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA	
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X-- (height decrement)
	BPL PRG018_AA7F	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ToadBlockAndShadow
;
; Adds a horizontal run of Toad House blocks and adds the shadow
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_ToadHouseBlocks:	.byte TILE7_TOADHOUSEBGSHAD, TILE7_TOADHOUSEBLOCK

LoadLevel_ToadBlockAndShadow:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$01	 ; X = 1 (toad house building block)

PRG018_AA9E:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef
	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG018_AAA8:
	LDA LL_ToadHouseBlocks,X ; Get toad house tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG018_AAA8	 	; While Temp_Var3 >= 0, loop!

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2	
	STA <Map_Tile_AddrH

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2

	DEX		 ; X-- (now do the toad shaded background tile beneath it!)
	BPL PRG018_AA9E	 ; While X >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ToadShadowV
;
; Adds a vertical run of Toad House shadowed background blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ToadShadowV:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA [Map_Tile_AddrL],Y	 ; Get tile here

	; Point is, if we want to put a right shaded tile and it's not shaded,
	; okay, otherwise use the combined shadow tile...
	CMP #TILE7_TOADHOUSEBGSHAD
	BNE PRG018_AAE6	 	; If tile is not the top-shaded background, jump to PRG018_AAE6

	; Otherwise...
	LDX #TILE7_TOADHOUSEBGSHADUR	; Use the upper-right shaded background
	JMP PRG018_AAE8	 	; Jump to PRG018_AAE8

PRG018_AAE6:
	LDX #TILE7_TOADHOUSEBGSHADR	; If tile wasn't top-shaded, we're clear to use the right-shaded background

PRG018_AAE8:
	TXA		 
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG018_AAE6	 ; While Temp_Var3 >= 0, loop!

	RTS	; Return


;;; NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE 

	; At some point, it seemed there was an idea that each Toad House,
	; where each house would have an ID value from the map, would track
	; which chests had already been opened.  Perhaps the idea was that
	; you would revisit the Toad House up to three (or four?) times
	; before it would be "cleared", each time opening a different box.

	; Gameplay-wise it's a little awkward though, why not just give you
	; all the boxes at once?  Or only ever offer one?  The compromise
	; was that you only got one of three (typically)...

	; THouse_ChestColumns:
	; This was used in determining pre-opened chests
	; But note: For the "final version" Toad House, these values are all OFF BY 1.
	; To make the "pre-opened chests" code work, these need to be corrected
	; (subtract 1) first.  But maybe this array was aligned for the "mini chests"?
	; Also, we never have FOUR chests in a Toad House (maybe for "mini chests"?)
THouse_ChestColumns:	.byte $02, $05, $08, $0B

	; Bit value for each chest for the unused THouse_OpenByID array
THouse_ChestOpenBit:	.byte $08, $04, $02, $01


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ToadChest
;
; One of the up-to-3 boxes that appear in a Toad House
;
; Also contains code for the unused feature of "pre-open" the chest...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
	; Chest tiles
LL_Chest:	.byte TILE7_CHEST_UL, TILE7_CHEST_UR, TILE7_CHEST_LL, TILE7_CHEST_LR

LoadLevel_ToadChest:
	LDX #$00		; X = 0
	LDY TileAddr_Off	; Y = TileAddr_Off
PRG018_AB0C:
	LDA LL_Chest,X	 	; Get chest tile
	STA [Map_Tile_AddrL],Y	; Store into tile mem
	INY		 	; Next column (not edge checked!  But okay for Toad House)
	INX		 	; X++ (next chest tile)
	TXA		 
	AND #$01	 
	BNE PRG018_AB0C	 	; Only fall through on even 'X' values...

	; Go to next row by adding 16
	LDA TileAddr_Off
	ADD #16
	TAY	
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	CPX #$04
	BNE PRG018_AB0C	 ; If X <> 4, loop!

	; Considering the current box we just put down...

	; This attempts to figure out which box this is (of 4 ?!)
	; For use with the UNUSED "pre-opened chest" code...
	LDX #$03	 	; X = 3 (all FOUR potential chests)
	LDA TileAddr_Off
	AND #$0f		; By current column...
PRG018_AB30:
	CMP THouse_ChestColumns,X
	BEQ PRG018_AB38	 	; If the column we're at now = THouse_ChestColumns[X], jump to PRG018_AB38

	DEX		 ; X--
	BNE PRG018_AB30	 ; If X <> 0, loop!

PRG018_AB38:
	LDY THouse_ID			; Y = this Toad House's ID
	LDA THouse_OpenByID,Y		; Get chest opened bits
	AND THouse_ChestOpenBit,X	; Check if this chest should already be open
	BEQ PRG018_AB4F	 		; If chest is not opened already, jump to PRG018_AB4F (RTS)

	; Chest should be open already!

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE7_CHEST_OPEN_UL
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	INY		 ; $AB4A 

	LDA #TILE7_CHEST_OPEN_UR
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_AB4F:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_ToadMiniChest
;
; NOT USED, but INTERESTING -- little boxes in a toad house?
; A thought: Regular power ups come in small boxes; special suits
; come in big boxes (same as the ? blocks, right?)
;
; Also contains code for the unused feature of "pre-open" the chest...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_ToadMiniChest:
	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA #TILE7_MINICHEST	; Mini chest ?!
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem


	; Considering the current box we just put down...

	; This attempts to figure out which box this is (of 4 ?!)
	; For use with the UNUSED "pre-opened chest" code...
	LDX #$03	 	; X = 3 (all FOUR potential chests)

	; Check if mini chest was placed at one of the key locations...
	TYA		 
	AND #$0f	 ; By current column...
PRG018_AB5C:
	CMP THouse_ChestColumns,X
	BEQ PRG018_AB64 	; If the column we're at now = THouse_ChestColumns[X], jump to PRG018_AB64

	DEX		 ; X--
	BNE PRG018_AB5C	 ; If X <> 0, loop!

PRG018_AB64:
	LDY THouse_ID			; Y = this Toad House's ID
	LDA THouse_OpenByID,Y		; Get chest opened bits
	AND THouse_ChestOpenBit,X	; Check if this chest should already be open
	BEQ PRG018_AB76	 		; If chest is not opened already, jump to PRG018_AB76 (RTS)

	LDY TileAddr_Off	 ; Y = TileAddr_Off
	LDA #TILE7_MINICHEST_OPEN	; Mini chest OPENED ?!
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG018_AB76:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_18UNK_B
;
; Dunno what this is... the tiles are garbage in Tilesets 6-8
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG018_AB77:	.byte $06, $07
LoadLevel_18UNK_B:
	LDA LL_ShapeDef	
	SUB #$0e	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 ; X = relative index

	LDY TileAddr_Off	 ; Y = TileAddr_Off

	LDA PRG018_AB77,X	 ; Get tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return

	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/WatToPM.asm"

; Rest of ROM bank was unused

