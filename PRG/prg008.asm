; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-05 22:51:55.464428532 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
Level_TilesetIdx_ByTileset:
	; Basically Level_TilesetIdx is just Level_Tileset - 1
	.byte $FF	;  0 Map (UNUSED)
	.byte $00	;  1 Plains style
	.byte $01	;  2 Mini Fortress style
	.byte $02	;  3 Hills style
	.byte $03	;  4 High-Up style
	.byte $04	;  5 pipe world plant infestation
	.byte $05	;  6 water world
	.byte $06	;  7 Toad House
	.byte $07	;  8 Vertical pipe maze
	.byte $08	;  9 desert levels
	.byte $09	; 10 Airship
	.byte $0A	; 11 Giant World
	.byte $0B	; 12 Ice level
	.byte $0C	; 13 Sky level
	.byte $0D	; 14 Underground


	; Unused space I guess!  Reserved for the non-gameplay tilesets perhaps?
	.byte $FF, $FF, $FF, $FF

	; Defines 4 frames of animation to use while Player walks
Player_WalkFramesByPUp:
	.byte PF_WALKSMALL_BASE, PF_WALKSMALL_BASE+1, PF_WALKSMALL_BASE, PF_WALKSMALL_BASE+1	; 0 - Small
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 1 - Big
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 2 - Fire
	.byte PF_WALKSPECIAL_BASE, PF_WALKSPECIAL_BASE+1, PF_WALKSPECIAL_BASE+2, PF_WALKSPECIAL_BASE+1	; 3 - Leaf
	.byte PF_WALKSPECIAL_BASE, PF_WALKSPECIAL_BASE+1, PF_WALKSPECIAL_BASE+2, PF_WALKSPECIAL_BASE+1	; 4 - Frog
	.byte PF_WALKSPECIAL_BASE, PF_WALKSPECIAL_BASE+1, PF_WALKSPECIAL_BASE+2, PF_WALKSPECIAL_BASE+1	; 5 - Tanooki
	.byte PF_WALKBIG_BASE, PF_WALKBIG_BASE+1, PF_WALKBIG_BASE+2, PF_WALKBIG_BASE+1		; 6 - Hammer

	; Frames used during the "power up" sequence from small -> Big
Player_GrowFrames:
	.byte PF_WALKBIG_BASE+2, PF_MIDGROW_HALFWAY, PF_WALKBIG_BASE+2, PF_MIDGROW_HALFWAY, PF_WALKBIG_BASE+2
	.byte PF_MIDGROW_HALFWAY, PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY, PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY
	.byte PF_MIDGROW_SMALL, PF_MIDGROW_HALFWAY

	; Stores frame to be used while traversing a pipe
	; Order is small, small + kuribo, other, other + kuribo
PipeMove_Frame:
	.byte PF_INPIPE_SMALL, PF_INPIPE_SMALLKURIBO, PF_INPIPE_BIG, PF_INPIPE_BIGKURIBO

	; Frame used when Player is "skidding"
Player_SkidFrame:
	.byte PF_SKID_SMALL, PF_SKID_BIG	; First value is for small, the other for everything else

Player_SwimActiveFrames:
	; Everything but small
	.byte PF_SWIMACTIVE_BIG, PF_SWIMACTIVE_BIG+1, PF_SWIMACTIVE_BIG+2, PF_SWIMACTIVE_BIG, PF_SWIMACTIVE_BIG+1, PF_SWIMACTIVE_BIG+2	
	; Small
	.byte PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+1, PF_SWIMIDLE_SMALL+2, PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+1, PF_SWIMIDLE_SMALL+2

	; Player sprite frames for swimming; first four are all power-up/suits
	; EXCEPT small, and the other four are for small
Player_SwimIdleFrames:
	.byte PF_SWIMIDLE_BIG, PF_SWIMIDLE_BIG+1, PF_SWIMIDLE_BIG-8, PF_SWIMIDLE_BIG+1	; Everything but small
	.byte PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL, PF_SWIMIDLE_SMALL+3, PF_SWIMIDLE_SMALL+3	; Small

	; Player's tail attack frames
Player_TailAttackFrames:
	.byte PF_TAILATKGROUND_BASE, PF_TAILATKGROUND_BASE+1, PF_TAILATKGROUND_BASE, PF_TAILATKGROUND_BASE+2, PF_TAILATKGROUND_BASE	; On ground
	.byte PF_TAILATKINAIR_BASE, PF_TAILATKINAIR_BASE-5, PF_TAILATKINAIR_BASE, PF_TAILATKINAIR_BASE-4, PF_TAILATKINAIR_BASE	; In air

	; Frames for when Player is in Kuribo's shoe
Player_KuriboFrame:
	.byte PF_KURIBO_SMALL, PF_KURIBO_BIG	; First value is for small, the other for everything else

	; Player duck frame
Player_DuckFrame:
	; First value is for everything EXCEPT Raccoon power; value on right is for raccoon power
	.byte PF_DUCK_NOTRACCOON,  PF_DUCK_RACCOON

	; The three sprite frames for when Player shoots a fireball/hammer
Player_FireOnGround:	.byte PF_THROWONGROUND_BASE, PF_THROWONGROUND_BASE+3, PF_THROWONGROUND_BASE+2
Player_FireInAir:	.byte PF_THROWINAIR_BASE, PF_THROWINAIR_BASE+1, PF_THROWINAIR_BASE+2

	; Frames used while frog hopping
Player_FrogHopFrames:
	.byte PF_FROGHOP_BASE, PF_FROGHOP_BASE+2, PF_FROGHOP_BASE+1, PF_FROGHOP_BASE

	; Frames used when Player is running at high speed!
Player_SpreadEagleFrames:
	.byte PF_RUNBIG_BASE, PF_RUNBIG_BASE+1, PF_RUNBIG_BASE+2, PF_RUNBIG_BASE+1	; Player is not small
	.byte PF_RUNSMALL_BASE, PF_RUNSMALL_BASE+1, PF_RUNSMALL_BASE, PF_RUNSMALL_BASE+1	; Player is small


	; The raccoon power uses rotations of three frames based on different conditions
Player_TailWagFlyFrames:
	.byte PF_TAILWAGFLY_BASE+2, PF_TAILWAGFLY_BASE+1, PF_TAILWAGFLY_BASE	; Flying
	.byte PF_TAILWAGFLY_BASE+1, PF_TAILWAGFLY_BASE+2, PF_TAILWAGFLY_BASE	; Flying, apex
	.byte PF_JUMPRACCOON, PF_JUMPRACCOON, PF_JUMPRACCOON			; Jump/fall
	.byte PF_TAILWAGFALL+2, PF_TAILWAGFALL+1, PF_TAILWAGFALL		; Flutter wag

Player_HoldingFrames:
	.byte PF_HOLDBIG_BASE, PF_HOLDBIG_BASE+1, PF_HOLDBIG_BASE+2, PF_HOLDBIG_BASE+1	; Player is not small
	.byte PF_HOLDSMALL_BASE, PF_HOLDSMALL_BASE+1, PF_HOLDSMALL_BASE, PF_HOLDSMALL_BASE+1	; Player is small

Player_TwisterSpinFrames:
	.byte PF_SPINSMALLORFROG_BASE+12, PF_SPINSMALLORFROG_BASE, PF_SPINSMALLORFROG_BASE+12, PF_SPINSMALLORFROG_BASE	; small or frog
	.byte PF_SPINSLIDESUITS_BASE+10, PF_SPINSLIDESUITS_BASE, PF_SPINSLIDESUITS_BASE+10, PF_SPINSLIDESUITS_BASE+1	; suits that slide
	.byte PF_SPINOTHER_BASE, PF_SPINOTHER_BASE+2, PF_SPINOTHER_BASE, PF_SPINOTHER_BASE+3	; otherwise

	; Airship "caught anchor" frame or general vine climbing
Player_ClimbFrame:
	.byte PF_CLIMB_SMALL	; Small
	.byte PF_CLIMB_BIG	; Big
	.byte PF_CLIMB_BIG	; Fire
	.byte PF_CLIMB_BIG	; Leaf
	.byte PF_CLIMB_FROG	; Frog
	.byte PF_CLIMB_BIG	; Tanooki
	.byte PF_CLIMB_BIG	; Hammer

	; Airship jump frame used by power up
Airship_JumpFrameByPup:
	.byte PF_JUMPFALLSMALL		; Small
	.byte PF_JUMPBIG		; Big
	.byte PF_JUMPBIG		; Fire
	.byte PF_JUMPRACCOON		; Leaf
	.byte PF_WALKSPECIAL_BASE+2	; Frog
	.byte PF_JUMPRACCOON		; Tanooki
	.byte PF_JUMPBIG		; Hammer

Player_VibeDisableFrame:
	.byte PF_WALKSMALL_BASE		; Small
	.byte PF_WALKBIG_BASE+2		; Big
	.byte PF_WALKBIG_BASE+2		; Fire
	.byte PF_WALKSPECIAL_BASE+2	; Leaf
	.byte PF_WALKSPECIAL_BASE	; Frog
	.byte PF_WALKSPECIAL_BASE+2	; Tanooki
	.byte PF_WALKBIG_BASE+2		; Hammer

	; Unused data?
	.byte $FE, $02, $05, $FB, $01
	.byte $02, $03, $00

	; When Player hits water, splash!
Player_WaterSplash:
	LDA <Player_SpriteY
	CMP #$b8
	BGE PRG008_A111	 ; If sprite Y >= $B8, jump to PRG008_A111 (RTS)

	LDA Splash_DisTimer
	BNE PRG008_A0F9	 ; If Splash_DisTimer > 0 (Player splashes disabled), jump to PRG008_A0F9

	STA <Temp_Var1	 ; Temp_Var1 = 0

	LDA <Player_Suit
	BEQ PRG008_A0C8	 ; If Player is small, jump to PRG008_A0C8

	LDA Player_IsDucking
	BEQ PRG008_A0CC	 ; If Player is not ducking, jump to PRG008_A0CC

PRG008_A0C8:

	; Player is small or ducking

	LDA #10
	STA <Temp_Var1	 ; Temp_Var1 = 10

PRG008_A0CC:
	LDA #$01
	STA Splash_Counter	 ; Splash_Counter = 1 (begin splash)

	LSR A
	STA Splash_NoScrollY	 ; Splash_NoScrollY = 0 (splash Y is relative to screen scroll)

	LDA Level_AScrlConfig
	BEQ PRG008_A0E7	 ; If no auto scroll effects are occurring, jump to PRG008_A0E7

	; Auto scroll effect active...

	LDA <Player_SpriteY
	CMP #136
	BLT PRG008_A0E7	 ; If Player_SpriteY < 136, jump to PRG008_A0E7

	LDA #147
	STA Splash_NoScrollY	 ; Splash_NoScrollY = 147 (splash Y is not relative to screen scroll, appropriate for fixed water at bottom)

	BNE PRG008_A0F1	 ; Jump (technically always) to PRG008_A0F1

PRG008_A0E7:
	LDA <Player_Y
	ADD <Temp_Var1	; Y offset
	AND #$F0	; align to grid
	ADD #$02	; +2

PRG008_A0F1:
	STA Splash_Y	 ; 147 or above formula -> Splash_Y 

	LDA <Player_X
	STA Splash_X	 ; Splash_X = Player_X

PRG008_A0F9:
	LDA <Player_YVel
	BMI PRG008_A111	 ; If Player Y velocity < 0 (Player traveling up), jump to PRG008_A111 (RTS)

	LDA #$00
	STA <Player_YVel ; Otherwise, halt movement

	LDY <Player_InAir
	BEQ PRG008_A107	 ; If Player is not mid air, jump to PRG008_A107

	STA <Player_XVel ; Otherwise, stop horizontal movement, too

PRG008_A107:

	; When Player hits water, a bubble is made

	LDY #$02	 ; Y = 2 (all bubble slots)

PRG008_A109:
	LDA Bubble_Cnt,Y
	BEQ PRG008_A118	 ; If this bubble slot is free, jump to PRG008_A118

PRG008_A10E:
	DEY		 ; Y--
	BPL PRG008_A109	 ; While Y >= 0, loop!

PRG008_A111:
	RTS		 ; Return


	; Y offsets
SplashBubble_YOff:	.byte 16, 22, 19

	; X offsets
SplashBubble_XOff:	.byte  0,  4, 11

PRG008_A118:
	LDA RandomN,Y	 	; Get random number
	ORA #$10
	STA Bubble_Cnt,Y	; Store into bubble counter

	; Set Bubble Y
	LDA <Player_Y
	ADC SplashBubble_YOff,Y
	STA Bubble_Y,Y
	LDA <Player_YHi
	ADC #$00
	STA Bubble_YHi,Y

	; Set Bubble X
	LDA <Player_X
	ADC SplashBubble_XOff,Y
	STA Bubble_X,Y
	LDA <Player_XHi
	ADC #$00
	STA Bubble_XHi,Y

	JMP PRG008_A10E	 ; Jump to PRG008_A10E


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoGameplay
;
; This subroutine is MAJOR; it performs a LOT of tasks which make
; the Player gameplay; too much to discuss here, so go through it!
; About the only thing it doesn't cover is colliding with other
; objects; this is handled elsewhere...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DoGameplay:
	LDA #$04	; A = 4

	LDY Level_TilesetIdx	 ; Y = Level_TilesetIdx
	CPY #10
	BNE PRG008_A14C	 ; If Level_TilesetIdx <> 10 (Giant World), jump to PRG008_A14C

	LDA #60		; A = 60

PRG008_A14C:
	STA PatTable_BankSel+3	 ; Set VROM page (2/4 sprites)

	; Set Level_TilesetIdx by the current Tileset
	; Basically amounts to (Level_Tileset - 1)
	LDY Level_Tileset
	LDA Level_TilesetIdx_ByTileset,Y
	STA Level_TilesetIdx

	JSR Level_Initialize	 ; Initialize level if needed
	JSR LevelJunction_PartialInit	 

	; NOTE: If a partial initialization occurred (above),
	; it will NOT return here!  It will be back up at PRG030...

	LDA Map_Starman
	BEQ PRG008_A17B	 ; If Player did not use a Starman, jump to PRG008_A17B

	; The following is used to prevent the invincibility star 
	; from being wasted on the airship's intro
	LDA Level_Objects+1
	CMP #OBJ_TOADANDKING
	BEQ PRG008_A17B	 	; If the first object ID of this level is OBJ_TOADANDKING, then don't do invincibility yet (dodgy!)
	CMP #OBJ_AIRSHIPANCHOR
	BEQ PRG008_A17B	 	; If the first object ID of this level is OBJ_AIRSHIPANCHOR, then don't do invincibility yet (dodgy!)

	DEC Map_Starman	 ; Map_Starman = 0 (or so it assumes)

	LDA #$e0
	STA Player_StarInv	 ; Player_StarInv = $E0 (224 ticks of invincible fun)

	LDA #MUS2A_INVINCIBILITY
	STA Sound_QMusic2	 ; Queue invincibility song!

PRG008_A17B:

	; Quick clears all the sprites by setting all hardware
	; sprite Y positions to $F8
	LDY #$1c
	LDA #$f8
PRG008_A17F:
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$20,Y
	STA Sprite_RAM+$40,Y
	STA Sprite_RAM+$60,Y
	STA Sprite_RAM+$80,Y
	STA Sprite_RAM+$A0,Y
	STA Sprite_RAM+$C0,Y
	STA Sprite_RAM+$E0,Y
	DEY
	DEY
	DEY
	DEY
	BPL PRG008_A17F

	; Makes for "wobbly" raising of the airship at least..
	LDA Counter_Wiggly
	AND #$F0
	SUB #$90
	STA Counter_Wiggly

	JSR Player_Update	 ; WHERE THE PLAYER DOES EVERYTHING!! (Except touch other objects)

	; If Player is...
	LDA <Player_IsDying	; ... dying ....
	ORA Level_PipeMove	; ... moving through a pipe ...
	ORA Player_SuitLost	; ... just lost his suit ...
	ORA Player_StarOff	; ... starman is wearing off ...
	ORA Player_Grow		; ... is growing/shrinking ...
	STA Player_HaltGame	; ... means he's halting the gameplay for now

	BNE PRG008_A1C1	 	; And if that's the case, jump to PRG008_A1C1

	INC Level_NoStopCnt	; As long as none of the above is happening, continue the "no stop" counter...

PRG008_A1C1:
	LDA Level_ChgTileEvent
	CMP #CHNGTILE_DELETECOIN
	BNE PRG008_A1D7	 ; If Level_ChgTileEvent <> CHNGTILE_DELETECOIN, jump to PRG008_A1D7

	; Otherwise... Score_Earned += 5(0) points
	LDA Score_Earned
	ADD #$05
	STA Score_Earned

	INC Coins_Earned	 ; One more coin earned!
	INC Coins_ThisLevel	 ; One more coin collected this level

PRG008_A1D7:

	; Clear Player_LowClearance
	LDA #$00
	STA Player_LowClearance

	; Decrement several adjacent counters!
	LDX #$07	 ; X = 7

PRG008_A1DE:
	LDA Event_Countdown,X
	BEQ PRG008_A1E6	 ; If counter is = 0, jump to PRG008_A1E6

	DEC Event_Countdown,X	 ; Otherwise, decrement it!

PRG008_A1E6:
	DEX		 ; X--
	BPL PRG008_A1DE	 ; While X >= 0, loop!

	LDA Level_PSwitchCnt
	BEQ PRG008_A20C	 ; If Level_PSwitchCnt = 0 (P-Switch not active), jump to PRG008_A20C

	CMP #$01
	BNE PRG008_A203	 ; If Level_PSwitchCnt <> 1, jump to PRG008_A203

	LDY #$0A	 ; Y = $0A (Invincibility song)

	LDA Player_StarInv
	CMP #$20
	BGE PRG008_A1FE	 ; If Player_StarInv >= $20, jump to PRG008_A1FE

	LDY Level_MusicQueueRestore	 ; Y = regular BGM

PRG008_A1FE:
	STY Sound_QMusic2 ; Restore appropriate music
	BNE PRG008_A209	 ; If Level_PSwitchCnt > 0, jump to PRG008_A209

PRG008_A203:
	LDA <Counter_1
	AND #$03	 ; Cap 0 - 3
	BNE PRG008_A20C	 ; If 1 - 3, jump to PRG008_A20C (RTS)

PRG008_A209:
	DEC Level_PSwitchCnt	 ; Level_PSwitchCnt--

PRG008_A20C:
	RTS		 ; Return


	; Just amounts to calling Player_Draw, but takes care of switching to page 29 and back
Player_Draw29:
	JSR PChg_C000_To_29	 ; Change page @ C000 to 29
	JSR Player_Draw	 	; Draw Player
	JMP PChg_C000_To_0	 ; Change page @ C000 to 0 and don't come back!

Player_DrawAndDoActions29:
	JSR PChg_C000_To_29	 ; Change page @ C000 to 29

	LDA #$00	 
	STA Player_InPipe 	; Player_InPipe = 0

	JSR Player_DrawAndDoActions	 ; Draw Player and do actions (going to coin heaven, the airship intro, going through pipes, ...)

	INC Player_InPipe	 ; Player_InPipe = 1

PRG008_A224:

	; If Player did NOT enter a pipe, we jump here...

	; Pull return address (so we do NOT return to the original Player_DrawAndDoActions 
	; call, thus not setting Player_InPipe flag... seems like a stupid way to 
	; conditionalize that, but hey, I didn't program in the 80s...)
	PLA
	PLA

	JMP PChg_C000_To_0	 ; Jump to PChg_C000_To_0 (switch C000 back to page 0 and return)

PChg_C000_To_29:
	; Change page @ C000 to 29
	LDA #29
	STA PAGE_C000
	JMP PRGROM_Change_C000

PChg_C000_To_0:
	; Change page @ C000 to 0
	LDA #$00
	STA PAGE_C000
	JMP PRGROM_Change_C000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_Initialize
; 
; If level has not yet initialized, this does so, otherwise it
; simply exits and does nothing...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_XStarts:
	.byte $18, $70, $D8, $80

Level_Initialize:
	LDA <Player_XStart	
	BEQ PRG008_A242	 ; If Player_XStart = 0 (not yet initialized), jump to PRG008_A242
	RTS		 ; Return


PRG008_A242:
	STA Level_ChangeReset ; Set Level_ChangeReset = 0 (trigger scene-change reset)

	LDA #$28
	STA Player_SprOff ; Player sprite rooted at offset $28


	; Set player power up based on current suit on map
	LDX Player_Current
	LDA World_Map_Power,X
	STA <Player_Suit 	

	; Set power up's correct palette
	JSR Level_SetPlayerPUpPal

	LDA #SPR_HFLIP
	STA <Player_FlipBits	 ; Player_FlipBits = $40 (face right)

	; Set Player_X based on Level_SelXStart
	LDY Level_SelXStart
	LDA Level_XStarts,Y
	STA <Player_X
	STA <Player_XStart	; Also set Player_XStart

	JSR Level_InitAction_Do	; Do whatever action this level wants at the start, if any

	LDA Map_Power_Disp
	CMP #$08
	BNE PRG008_A277	 ; If Map_Power_Disp <> 8 (P-Wing), jump to PRG008_A277

	; Max "Power"
	LDA #$7f	
	STA Player_Power ; Player_Power = $7F

	; Infinite flight time
	LDA #$ff
	STA Player_FlyTime ; Player_FlyTime = $FF

PRG008_A277:
	JSR LevelInit_EnableSlopes	 ; Enable slopes if style calls for it

PRG008_A27A:
	LDA Level_7Vertical
	BEQ PRG008_A29E	 	; If level is not vertical, jump to PRG008_A29E

	LDY <Player_YHi		 ; Y = Player_YHi

	; Stores the vertical screen offset into Level_VertScrollH and Level_VertScroll
	LDA VertLevel_ScreenH,Y
	STA Level_VertScrollH
	LDA VertLevel_ScreenL,Y	
	STA Level_VertScroll	

	LDA <Player_Y
	LDY <Player_YHi
	JSR LevelJct_GetVScreenH2
	STY <Player_YHi
	STA <Player_Y

	; Level_UnusedFlag = 1 (unused; only set, never read!)
	LDA #$01
	STA Level_UnusedFlag

	RTS		 ; Return

PRG008_A29E:
	LDA <Vert_Scroll
	STA Level_VertScroll	; Level_VertScroll = Vert_Scroll

	LDA <Vert_Scroll_Hi
	STA Level_VertScrollH	; Level_VertScrollH = Vert_Scroll_Hi

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_InitAction_Do
;
; Performs whatever is requested by the level as an initial action
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_InitAction_JumpTable:
	.word LevelInit_DoNothing	; 0 - Do nothing
	.word LevelInit_StartSliding	; 1 - Start level sliding (if able by power-up)
	.word LevelInit_PipeExitTop	; 2 - Start by exiting top of pipe
	.word LevelInit_PipeExitBottom	; 3 - Start by exiting bottom of pipe
	.word LevelInit_PipeExitRight	; 4 - Start by exiting right of pipe
	.word LevelInit_PipeExitLeft	; 5 - Start by exiting left of pipe
	.word LevelInit_Airship		; 6 - Airship intro run & jump init
	.word LevelInit_Airship_Board	; 7 - Boarding the Airship

Level_InitAction_Do:
	LDA Level_InitAction
	ASL A		
	TAY		; Y = Level_InitAction << 1 (2 byte index)

	; Copy jump address into Temp_Var1/2
	LDA Level_InitAction_JumpTable,Y
	STA <Temp_Var1
	LDA Level_InitAction_JumpTable+1,Y
	STA <Temp_Var2

	LDA #$00
	STA Level_InitAction	; Level_InitAction = 0 (same memory gets used as Player_Slide after this!)

	JMP [Temp_Var1]		; Jump appropriately...


LevelInit_StartSliding:
	LDY <Player_Suit
	LDA PowerUp_Ability,Y
	AND #$02
	BNE LevelInit_DoNothing	; If this powerup is not able to slide on slopes, jump to LevelInit_DoNothing

	INC Player_Slide	 ; Otherwise, begin sliding...

LevelInit_DoNothing:
	RTS		 ; Return

LevelInit_PipeExitTop:
	LDA #$83	 ; A = $83 (sets Level_PipeMove)
	LDY #$01	 ; Y = 1 (come out pipe from the top, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_PipeExitBottom:
	LDA #$82	 ; A = $82 (sets Level_PipeMove)
	LDY #$02	 ; Y = 2 (come out pipe from the bottom, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_PipeExitRight:
	LDA #$80	 ; A = $80 (sets Level_PipeMove)
	LDY #$03	 ; Y = 3 (come out pipe to the right, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_PipeExitLeft:
	LDA #$81	 ; A = $81 (sets Level_PipeMove)
	LDY #$04	 ; Y = 4 (come out pipe to the left, sets Level_PipeExitDir)
	JMP PRG008_A324	 ; Jump to PRG008_A324

LevelInit_Airship:
	LDA #$01	 
	STA Level_AirshipCtl	 ; Level_AirshipCtl = 1
	STA Update_Request	 ; Update_Request = 1

	LSR A		 	; Essentially, A = 0
	STA <Vert_Scroll	; Vert_Scroll = 0
	RTS			; Return

LevelInit_Airship_Board:
	LDA #$04
	STA Level_AirshipCtl	; Level_AirshipCtl = 4

	LDA #SPR_HFLIP
	STA <Player_FlipBits	; Player face to the right
	STA <Player_InAir	; Flag Player as "in air"

	LDA #$90
	STA <Player_YVel	; Player_YVel = $90	; Throw Player upward
	STA <Player_X		; Player_X = $90

	LDA <Vert_Scroll
	ADD #$80
	STA <Player_Y		; Player_Y = Vert_Scroll + $80

	; Carry into Player_YHi if needed
	LDA #$00	
	ADC #$00	
	STA <Player_YHi

	RTS		 ; Return

PRG008_A324:
	; Set as appropriate from entry
	STA Level_PipeMove
	STY Level_PipeExitDir
	JMP PRG008_A38E	 ; Jump to PRG008_A38E


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelInit_EnableSlopes
;
; Enables slope tiles (different solidity set for 
; Hills / Underground styles)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelInit_EnableSlopes:
	LDY #$01	 ; Y = 1 (enable slopes)

	LDA Level_Tileset
	CMP #3
	BEQ PRG008_A347	 ; If Level_Tileset = 3 (Hills style), jump to PRG008_A347

	CMP #14
	BEQ PRG008_A347	 ; If Level_Tileset = 14 (Underground style), jump to PRG008_A347

	CMP #$05
	BNE PRG008_A345	 ; If Level_Tileset = 5 (pipe world plant infestation style), jump to PRG008_A345

	; Level_Tileset = 5...

	LDA Level_UnusedSlopesTS5	; Never set, so this is unused...
	CMP #$02
	BEQ PRG008_A347	 ; If Level_UnusedSlopesTS5 = 2, jump to PRG008_A347 (force slopes to be enabled on tileset 5)

PRG008_A345:
	LDY #$00	 ; Y = 0 (do not enable slopes)

PRG008_A347:
	STY Level_SlopeEn
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelJunction_PartialInit
; 
; Performs some re-initialization required after entering a door
; or pipe and handles some airship intro stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelJunction_PartialInit:
	LDA LevelPartialInit
	BEQ PRG008_A388	 ; If LevelPartialInit = 0, jump to PRG008_A388

	LDA #$00
	STA LevelPartialInit	 ; LevelPartialInit = 0

	STA Level_HAutoScroll	 ; Disable auto horizontal scrolling
	STA Level_AScrlConfig	 ; Clear auto scroll configuration (no auto scroll)
	STA Player_SlideRate	 ; No slide
	STA Level_ChangeReset	 ; Do level scene change reset

	JSR Level_SetPlayerPUpPal  ; Set power up's correct palette
	JSR PRG008_A27A		   ; Partial level initialization (basically continues after setting the power up)
	JSR LevelInit_EnableSlopes ; Enable slopes if needed (technically if they just jumped to PRG008_A277 they'd get that too?)

	LDA Level_AirshipCtl
	BEQ PRG008_A379	 ; If Level_AirshipCtl = 0, jump to PRG008_A379

	; While airship opening is occurring...
	LDA #$00	
	STA <Player_XVel		; Player_XVel = 0
	STA Level_InitAction		; Level_InitAction = 0
	JSR LevelInit_Airship_Board	; Board the airship

PRG008_A379:
	LDA Level_InitAction
	CMP #$06
	BNE PRG008_A383	 	; If Level_InitAction <> 6 (Run & Jump for the airship), jump to PRG008_A383

	JSR LevelInit_Airship	 ; Run & Jump for the airship
PRG008_A383:

	JSR PRG008_A38E	 

	; Pulls prior return address, meaning this function
	; will return to the caller's caller!
	PLA
	PLA

PRG008_A388:
	RTS		 ; Return

Event_Countdown_Init:
	; 0 = Not used, 1 = Up, 2 = Down, 3 = Right, 4 = Left
	; Ticks to initialize Event_Countdown
	.byte $00, $3F, $07, $20, $20

PRG008_A38E:
	; Common point for exiting and entering from pipe
	; and some other routines... (if Level_PipeMove = 0,
	; then clearly there's no pipe action going on)

	LDA Level_PipeMove
	BEQ PRG008_A3C9	 ; If Level_PipeMove = 0, jump to PRG008_A3C9 (RTS)

	; Queue pipe sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	LDA <Player_X	
	STA <Pipe_PlayerX	 ; Pipe_PlayerX = Player_X

	LDA <Player_Y
	AND #$F0	
	STA <Pipe_PlayerY
	DEC <Pipe_PlayerY 	; Pipe_PlayerY = Player_Y aligned to nearest 16, minus 1

	LDA Level_7Vertical
	BNE PRG008_A3B6	 	; If level is vertical, jump to PRG008_A3B6
	
	; For non-vertical levels...
	LDA <Vert_Scroll
	STA Level_VertScroll	; Level_VertScroll = Vert_Scroll

	LDA <Vert_Scroll_Hi
	STA Level_VertScrollH	; Level_VertScrollH = Vert_Scroll_Hi

PRG008_A3B6:
	LDA Level_PipeExitDir
	BNE PRG008_A3C0	 	; If Level_PipeExitDir <> 0, jump to PRG008_A3C0

	LDA #$02	 
	STA Level_PipeExitDir	 ; If Level_PipeExitDir is not set, assume we're coming out the bottom

PRG008_A3C0:
	AND #$0f	 ; Ensure Level_PipeExitDir is capped (note, though, only 0-3 is valid)
	TAY		 
	LDA Event_Countdown_Init,Y
	STA Event_Countdown	 ; Event_Countdown = Event_Countdown_Init[Y]

PRG008_A3C9:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Update
;
; Responsible for ALL of the magic; does everything
; needed to make a functional Player object!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Update:
	LDA Player_QueueSuit
	BEQ PRG008_A3FA	 ; If we don't have a suit change queued, jump to PRG008_A3FA

	CMP #$0f
	BLS PRG008_A3EC	 ; If Player_QueueSuit < $0F (statue enable), jump to PRG008_A3EC

	CMP #$80
	BNE PRG008_A3DC	 ; If Player_QueueSuit <> $80 (Kuribo's shoe), jump to PRG008_A3DC

	; Kuribo's shoe enable!
	INC Player_Kuribo	; Set the Player_Kuribo flag
	BNE PRG008_A3F2	 ; Jump (expectedly always) to PRG008_A3F2

PRG008_A3DC:
	CMP #$40
	BEQ PRG008_A3E7	 ; If Player_QueueSuit = $40 (make a splash), jump to PRG008_A3E7

	LDA #$c0
	STA Player_Statue	; Player_Statue = $C0
	BNE PRG008_A3F2	 	; Jump (technically always) to PRG008_A3F2

PRG008_A3E7:
	INC Player_InWater	; Set "in water" flag
	BNE PRG008_A3F2	 	; Jump (technically always) to PRG008_A3F2

PRG008_A3EC:
	; Suit queue
	AND #$0f
	TAY	
	DEY		 ; Y = Player_QueueSuit - 1
	STY <Player_Suit ; Store into Player_Suit

PRG008_A3F2:
	LDA #$00
	STA Player_QueueSuit	  ; Clear Player_QueueSuit

	JSR Level_SetPlayerPUpPal ; Set power up's correct palette

PRG008_A3FA:
	LDA <Player_IsDying
	ORA Player_HaltTick
	BNE PRG008_A472	 ; If gameplay is halted by Player_HaltTicks OR Player is dying, jump to PRG008_A472

	; Non-halted gameplay normal flow...

	LDA Level_GetWandState
	CMP #$03
	BGS PRG008_A472 	; If Level_GetWandState >= 3 (got the wand!), jump to PRG008_A472

	LDA Player_AboveTop
	BNE PRG008_A427	 ; If Player_AboveTop <> 0 (Player is above the top of screen), jump to PRG008_A427

	; "Fall in a pit and die"!
	LDA <Player_SpriteY
	AND #$F0
	CMP #$c0
	BNE PRG008_A427	 ; If Player_SpriteY < $C0 && Player_SpriteY > $CF, jump to PRG008_A427

	; Fell in a pit and died
	LDA #PLAYERSUIT_SMALL
	STA <Player_Suit ; Player_Suit = PLAYERSUIT_SMALL

	JSR Player_Die	 ; Begin death sequence

	; This jumps the initial part of the death sequence
	LDA #$c0
	STA Event_Countdown ; Event_Countdown = $C0
	LDA #$02
	STA <Player_IsDying	; Player_IsDying = 2 (already dropped off screen)

	BNE PRG008_A472	 	; Jump (technically always) to PRG008_A472

PRG008_A427:
	LDA Debug_Flag
	CMP #$80
	BEQ PRG008_A45A	 ; If debug mode is enabled, jump to PRG008_A45A

	LDA Level_TimerEn
	AND #$7f
	BNE PRG008_A472	 ; If the clock is disabled, jump to PRG008_A472

	LDA Level_TimerMSD
	ORA Level_TimerMid
	ORA Level_TimerLSD
	BNE PRG008_A45A	 ; If there's some sort of time left, jump to PRG008_A45A

	; TIME UP!
	JSR Player_Die	 ; Begin death sequence

	LDA #$03
	STA <Player_IsDying	 ; Player_IsDying = 3 (Death due to TIME UP)

	; I think this will hide any Player masking sprites (e.g. from pipe usage)
	; Not sure if the Player could die when a pipe is activated or not?
	LDA #$ff
	STA <Pipe_PlayerX ; Pipe_PlayerX = $FF
	STA <Pipe_PlayerY ; Pipe_PlayerY = $FF

PRG008_A44D:
	LDA #$01	 
	STA Player_QueueSuit	 ; Queue change to small (superfluous, Player_Die sets it to 1)

	LDA #$50	 ; Event_Countdown to be set to $50

	STA Event_Countdown
	JMP PRG008_A472	 	; Jump to PRG008_A472

PRG008_A45A:
	; Still have time left OR in debug mode...

	LDA <Player_SpriteX
	CMP #$f8
	BLT PRG008_A472	 ; Intended meaning: If Player_SpriteX > -8, jump to PRG008_A472

	; Player_SpriteX has been pushed too far left! Assumed crushed!
	; (Except in Vertical levels or if the level was completed)

	LDA Level_7Vertical
	ORA Player_EndLevel
	BNE PRG008_A472	 ; If either a vertical level or the level was completed, jump to PRG008_A472

	; Player was crushed!

	JSR Player_Die	 ; Begin death sequence

	LDA #$01
	STA <Player_IsDying	 ; Player_IsDying = 1 (superfluous, Player_Die sets it to 1)

	JMP PRG008_A44D	 ; Jump to PRG008_A44D

PRG008_A472:
	; The following are always called, dead or alive...

	JSR Player_DrawAndDoActions29	; Draw Player and perform reactions to various things (coin heaven, pipes, etc lots more)
	JSR Player_ControlJmp	 	; Controllable actions
	JSR Player_PowerUpdate	 	; Update "Power Meter"
	JSR Player_DoScrolling	 	; Scroll relative to Player against active rules
	JSR AScrlURDiag_HandleWrap 	; Handle the diagonal autoscroller wrapping
	JSR Player_DetectSolids		; Handle solid tiles, including slopes if applicable
	JSR Player_TailAttack_HitBlocks	; Do Tail attack against blocks
	JSR Player_DoSpecialTiles	; Handle unique-to-style tiles!
	JSR Player_DoVibration		; Shake the screen when required to do so!
	JSR Player_SetSpecialFrames	; Set special Player frames
	JSR Player_Draw29	 	; ... and if you get through all that, draw the Player!!

	LDA #$00
	STA Player_XVelAdj	 ; Player_XVelAdj = 0

	RTS		 ; Return

VibrationOffset:
	.byte 0,  2,  3,  1	; For when 0 >= Vert_Scroll >= $7F
	.byte 0, -2, -3, -1	; For when $80 >= Vert_Scrol >= $FF

	; Simple function which updates the "Shake" effect from something heavy
Player_DoVibration:
	LDA Level_Vibration	 
	BEQ PRG008_A4BE		; If level is NOT vibrating, jump to PRG008_A4BE

	DEC Level_Vibration	 ; Level_Vibration--
	AND #$03	 	; Cap 0 - 3

	LDY <Vert_Scroll
	BPL PRG008_A4B1	 ; If Vert_Scroll < $80, jump to PRG008_A4B1

	ORA #$04	 ; Otherwise, use value 4 - 7

PRG008_A4B1:
	TAY		 	; index value -> 'Y'
	LDA VibrationOffset,Y	; Get offset 
	PHA		 	; Save it
	ADD Level_VertScroll	
	STA Level_VertScroll	; Level_VertScroll += offset
	PLA		 	; Restore it

PRG008_A4BE:
	STA Vert_Scroll_Off	 ; Update Vert_Scroll_Off
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_PowerUpdate
;
; Handles updating the "Power Meter" as appropriate,
; and plays the annoying "ringing" noise :)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_PowerUpdate:
	LDY Player_FlyTime	 
	BEQ PRG008_A4E4	 ; If Player is not flying (or at least high-speed jumping), jump to PRG008_A4E4

	CPY #$ff
	BEQ Sound_FullPowerRing	 ; If Player_FlyTime = $FF (P-Wing active), jump to Sound_FullPowerRing

	LDA <Counter_1
	AND #$01
	BEQ PRG008_A4D5	 ; Every other tick, jump to PRG008_A4D5

	DEY			 
	STY Player_FlyTime ; Player_FlyTime--

PRG008_A4D5:
	TYA		 ; Y (Player_FlyTime) -> A 
	BNE Sound_FullPowerRing	 ; If Player_FlyTime <> 0, jump to Sound_FullPowerRing

	STY Player_Power ; Otherwise, clear Player_Power

Sound_FullPowerRing:

	; Full power ringing sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPOWER
	STA Sound_QPlayer

	RTS		 ; Return


PRG008_A4E4:
	LDA Player_Power
	CMP #$7f
	BNE PRG008_A4F8	 ; If Player_Power <> $7F (max power), jump to PRG008_A4F8

	JSR Sound_FullPowerRing	 ; Play full power ringing sound

	LDA Player_RunFlag
	BEQ PRG008_A4F8	 ; If Player is not running, jump to PRG008_A4F8

	LDY #$10	 ; Y = $10
	JMP PRG008_A51A	 ; Jump to PRG008_A51A

PRG008_A4F8:
	LDA Player_PMeterCnt
	BNE PRG008_A523	 ; If Player_PMeterCnt <> 0, jump to PRG008_A523

	SEC		 ; Set carry
	ROL Player_Power ; Player_Power is shifted left 1, its old bit 7 in the carry, and '1' introduced at bit 0

	LDA Player_RunFlag
	BNE PRG008_A50C	 ; If Player is running, jump to PRG008_A50C

	ROR Player_Power ; Restore Player_Power
	LSR Player_Power ; Shift it 1 to the right

PRG008_A50C:
	LDY #$18	 ; Y = $18

	LDA Player_Power
	BEQ PRG008_A520	 ; If Player_Power = 0, jump to PRG008_A520

	LDA Player_RunFlag
	BEQ PRG008_A51A	 ; If Player is not running, jump to PRG008_A51A

	LDY #$08	 ; Otherwise, Y = $8

PRG008_A51A:
	STY Player_PMeterCnt	 ; Set Player_PMeterCnt

	JMP PRG008_A523	 ; Jump to PRG008_A523

PRG008_A520:
	STA Player_FlyTime ; Clear Player_FlyTime

PRG008_A523:

	LDA #$00
	STA Player_RunFlag ; Player_RunFlag = 0

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_SetPlayerPUpPal
;
; Puts the palette required by the Player's current power-up into
; the graphics buffer.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Palette colors per power up level -- first byte is never used!
PowerUp_Palettes:
	.byte $00, $16, $36, $0F	; 0 - Mario default palette
	.byte $00, $2A, $36, $0F	; 1 - Luigi default palette
	.byte $00, $27, $36, $16	; 2 - Fire Flower
	.byte $00, $00, $00, $00	; 3 - Leaf (Not used, uses 0 or 1 as appropriate)
	.byte $00, $2A, $36, $0F	; 4 - Frog Suit
	.byte $00, $17, $36, $0F	; 5 - Tanooki Suit
	.byte $00, $30, $27, $0F	; 6 - Hammer Suit
	.byte $00, $00, $10, $0F	; 7 - Tanooki Statue

Level_SetPlayerPUpPal:
	LDY #$07	 ; Y = 7 (select statue palette)
	LDA Player_Statue
	BNE PRG008_A55E	 ; If Player is statue, jump to PRG008_A55E

	LDA <Player_Suit
	TAY		 ; Y = Player_Suit
	CMP #PLAYERSUIT_RACCOON 
	BEQ PRG008_A55B	 ; If Player_Suit = PLAYERSUIT_RACCOON, jump to PRG008_A55B

	CMP #PLAYERSUIT_FIRE	 
	BGS PRG008_A55E	 ; If Player_Suit >= PLAYERSUIT_FIRE, jump to PRG008_A55E

PRG008_A55B:
	; If Player_Suit is 0 (small) or 1 (big), we load Y = Player_Current instead!
	LDY Player_Current

PRG008_A55E:
	LDX Graphics_BufCnt
	TXA
	ADD #$06
	STA Graphics_BufCnt	 ; Graphics_BufCnt += 6 more bytes coming in...

	; Going to send in a palette update

	; PPU Address $3F11 (make sure to match with Palette_Buffer offsets below!)
	LDA #$3f
	STA Graphics_Buffer,X
	LDA #$11
	STA Graphics_Buffer+1,X

	; Run of 3 bytes
	LDA #$03
	STA Graphics_Buffer+2,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+6,X

	TYA
	ASL A
	ASL A
	TAY	; Y <<= 2 (4 bytes per index)

	LDA PowerUp_Palettes+1,Y
	STA Graphics_Buffer+3,X
	STA Palette_Buffer+$11	 ; Also put into Palette_Buffer

	LDA PowerUp_Palettes+2,Y
	STA Graphics_Buffer+4,X
	STA Palette_Buffer+$12	 ; Also put into Palette_Buffer

	LDA PowerUp_Palettes+3,Y
	STA Graphics_Buffer+5,X
	STA Palette_Buffer+$13	 ; Also put into Palette_Buffer

	RTS		 ; Return


	; This is the main value of X acceleration applied
Player_XAccelMain:

	; F = "Friction" (stopping rate), "N = "Normal" accel, S = "Skid" accel, X = unused
	; Without B button	With B button
	;      F   N   S   X     F   N   S   X
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Small
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Big
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Fire
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Leaf
	.byte -1,  2,  2,  0, 	-1,  2,  2,  0	; Frog
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Tanooki
	.byte -1,  0,  2,  0, 	-1,  0,  2,  0	; Hammer

Player_XAccelMain_UW:
	; If on the ground	If swimming above the ground
	.byte -1,  1,  1,  0, 	-1,  0,  0,  0

	.byte -1,  0,  0,  0, 	-1,  0,  1,  0
	.byte -1,  0,  0,  0, 	-1,  0,  0,  0


	; The following values are added to the "Counter_Wiggly"
	; value in an attempt to push the likelihood of a carry
	; which gives just a slight boost to the Player's X
	; velocity acceleration; way of making it sort of a
	; fractional increase while he moves...
Player_XAccelPseudoFrac:

	; F = "Friction" (stopping rate), "N = "Normal" accel, S = "Skid" accel, X = unused
	; Without B button		With B button
	;       F    N    S    X          F    N    S    X
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Small
	.byte $20, $E0, $00, $00,	$20, $E0, $00, $00	; Big
	.byte $20, $E0, $00, $00, 	$20, $E0, $00, $00	; Fire
	.byte $20, $E0, $00, $00, 	$20, $E0, $00, $00	; Leaf
	.byte $00, $00, $00, $00, 	$00, $00, $00, $00	; Frog
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Tanooki
	.byte $60, $E0, $00, $00, 	$60, $E0, $00, $00	; Hammer

Player_XAccelPseudoFrac_UW:
	; If on the ground		If swimming above the ground
	.byte $30, $00, $00, $00, 	$E0, $30, $80, $00

	.byte $A0, $E0, $C0, $00, 	$A0, $E0, $20, $00
	.byte $D0, $E0, $60, $00, 	$D0, $E0, $C0, $00

	.byte $10, $F0


	; Maximum tick count for walking animation tick counter
	; (i.e. what tick value to reach to go to next anim frame)
Player_WalkAnimTickMax:
	; 0-15 POSSIBLE, but only 0-7 defined (due to game's max X vel of $38)
	; Index is Player_XVel >> 3
	.byte $07, $06, $05, $04, $03, $02, $01, $01, $01	; Lower number = faster animation


	; Root jump velocity
Player_RootJumpVel:	.byte PLAYER_JUMP

	; Based on how fast Player is running, the jump is
	; increased just a little (this is subtracted, thus
	; for the negative Y velocity, it's "more negative")
Player_SpeedJumpInc:	.byte $00, $02, $04, $08

; FIXME: Anybody want to claim this?
	.byte $00, $03, $06, $08, $08, $08, $08, $06, $03, $00, $04, $08, $12, $16, $16, $12
	.byte $08, $04

	; This sets the sprite's H/V flip bits for the somersault
Player_SomersaultFlipBits:
	.byte $00, $00, $00, $00, $C0, $C0, $C0, $C0, $80, $01


	; Bit which must be set in FloatLevel_PlayerWaterStat to override 
	; system and assume that we're underwater no matter what tile detected
FloatLevel_StatCheck:
	.byte $40, $80


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_CheckIfTileUnderwater
;
; This checks if the given tile in Temp_Var1/2 (depending on 'X')
; is "underwater", based on Temp_Var3 (Level_TilesetIdx << 2) and
; the tile's "quadrant", which index "Level_MinTileUWByQuad"
;
; The result can be overridden if the proper bit in 
; FloatLevel_PlayerWaterStat is set, which will force the
; report to say underwater...
;
; CARRY: The "carry flag" will be set and the input tile not
; otherwise tested if the tile is in the "solid floor" region!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_CheckIfTileUnderwater:

	; X = 0 or 1

	LDY #$01
	STY <Temp_Var15	 ; Temp_Var15 = 1 (Indicates underwater)

	; UNDERWATER OVERRIDE (for "floating" levels that have fixed water at the bottom)
	LDA FloatLevel_PlayerWaterStat
	AND FloatLevel_StatCheck,X
	BNE PRG008_A6A8	 ; If bit is set, jump to PRG008_A6A8

	LDA <Temp_Var1,X
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		 ; Y = Quadrant of tile (i.e. 0-3 for $00, $40, $80, $C0)

	LDA <Temp_Var1,X
	CMP Tile_AttrTable,Y
	BGE PRG008_A6A9	 ; If tile is solid floor, jump to PRG008_A6A9 (RTS)

	CMP #TILEA_PSWITCH_PRESSED
	BNE PRG008_A68D	 ; If tile is not the pressed P-Switch, jump to PRG008_A68D

	LDY #$00	 ; Y = 0
	BEQ PRG008_A6A6	 ; Jump (technically always) to PRG008_A6A6

PRG008_A68D:

	; Temp_Var3 is (Level_TilesetIdx << 2), which is OR'ed into 'Y' here
	; So the value is expected to be in the range of 0 to (4 * 15) = 60
	; Basically there are 4 values per tileset, one for each tile quadrant 
	TYA
	ORA <Temp_Var3
	TAY

	; Get the minimum tile value for this quadrant which is considered
	; underwater (NOTE: If there are no underwater tiles in this quadrant,
	; the mostly unreachable value of $FF is what we get here)
	LDA Level_MinTileUWByQuad,Y

	LDY #$00	 ; Y = 0 (Not under water)

	CMP <Temp_Var1,X 
	BGE PRG008_A6A6	 ; If the starting underwater tile is greater than the detected tile, jump to PRG008_A6A6

	; Otherwise...

	INY		 ; Y = 1 (Underwater)

	LDA <Temp_Var1,X

	CMP #TILE1_WFALLTOP
	BEQ PRG008_A6A5	 ; If tile is the top of the waterfall, jump to PRG008_A6A5

	CMP #TILE1_WFALLMID
	BNE PRG008_A6A6	 ; If tile is NOT the middle part of the waterfall, jump to PRG008_A6A6

PRG008_A6A5:
	INY		 ; Y = 2 (In waterfall)

PRG008_A6A6:
	STY <Temp_Var15	 ; Store Y -> Temp_Var15 (0, 1, or 2)

PRG008_A6A8:
	CLC		 ; Clear carry (tile was not in the solid floor region)

PRG008_A6A9:
	RTS		 ; Return

Player_ControlJmp:
	JMP Player_Control	 ; Jump to Player_Control

; FIXME: Anybody want to claim this?
; $A6AD
	.byte $35, $35, $03

; FIXME: Anybody want to claim this?
; $A6B0 
	ORA <Temp_Var4
	JSR Player_ApplyXVelocity
	JSR Player_ApplyYVelocity
	JMP Player_Draw29

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Control
;
; Pretty much all controllable Player actions like ducking,
; sliding, tile detection response, doors, vine climbing, and 
; including basic power-up / suit functionality (except the actual 
; throwing of fireballs / hammers for some reason!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Control:
	LDA <Player_FlipBits
	STA Player_FlipBits_OLD

	LDA <Player_InAir
	STA Player_InAir_OLD

	LDA Player_EndLevel
	BNE PRG008_A6D2	 ; If Player is running off at the end of the level, jump to PRG008_A6D2

	LDA Player_VibeDisable
	BEQ PRG008_A6DA	 	; If Player is not "vibrationally disabled", jump to PRG008_A6DA

	DEC Player_VibeDisable	 ; Otherwise Player_VibeDisable--

PRG008_A6D2:

	; Remove horizontal velocity and cancel controller inputs
	LDA #$00	
	STA <Player_XVel
	STA <Pad_Holding
	STA <Pad_Input	

PRG008_A6DA:
	LDA Player_Slide
	BEQ PRG008_A6E5	 	; If Player is NOT sliding down slope, jump to PRG008_A6E5

	LDA <Pad_Input
	AND #~PAD_B
	STA <Pad_Input		; Otherwise, disable 'B' button

PRG008_A6E5:
	LDA Level_Objects+1
	CMP #OBJ_TOADANDKING
	BNE PRG008_A6F2	 	; If first object is not "Toad and the King" (i.e. we're in the end of world castle), jump to PRG008_A6F2

	LDA <Pad_Holding
	AND #~(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	STA <Pad_Holding	; Otherwise, disable all directional inputs

PRG008_A6F2:
	LDY <Player_Suit
	BEQ PRG008_A70E	 	; If Player is small, jump to PRG008_A70E

	CPY #PLAYERSUIT_FROG
	BEQ PRG008_A70E	 	; If Player is Frog, jump to PRG008_A70E

	LDA Player_IsHolding
	ORA Player_Slide
	ORA Player_Kuribo
	BNE PRG008_A70E	 	; If Player is holding something, sliding down a slope, or in a Kuribo's shoe, jump to PRG008_A70E 

	LDA <Player_InAir
	BEQ PRG008_A71C	 	; If Player is NOT mid air, jump to PRG008_A71C

	LDA Player_InWater
	BEQ PRG008_A715	 	; If Player is NOT in water, jump to PRG008_A715

PRG008_A70E:
	; Forcefully disable any ducking
	LDA #$00
	STA Player_IsDucking	; Player_IsDucking = 0

	BEQ PRG008_A736	 	; Jump (technically always) to PRG008_A736

PRG008_A715:
	LDA Player_IsDucking
	BNE PRG008_A733	 	; If Player is ducking down, jump to PRG008_A733
	BEQ PRG008_A736	 	; Otherwise, jump to PRG008_A736

PRG008_A71C:
	LDA #$00
	STA Player_IsDucking	; Player_IsDucking = 0

	LDA Level_SlopeEn
	BEQ PRG008_A72B	 	; If slopes are not enabled, jump to PRG008_A72B

	LDA Player_SlideRate 
	BNE PRG008_A736	 	; If Player has a slide magnitude, jump to PRG008_A736

PRG008_A72B:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	CMP #PAD_DOWN
	BNE PRG008_A736	 	; If Player is not just holding down, jump to PRG008_A736

PRG008_A733:
	STY Player_IsDucking	; Set ducking flag (uses non-zero suit value)

PRG008_A736:
	LDY #20		 	; Y = 20 (ducking or small)

	LDA <Player_Suit 	
	BEQ PRG008_A743	 	; If Player is small, jump to PRG008_A743

	LDA Player_IsDucking
	BNE PRG008_A743	 	; If Player is ducking, jump to PRG008_A743

	LDY #10		 	; Otherwise, Y = 10 (not ducking, not small)

PRG008_A743:
	STY <Temp_Var10		; Temp_Var10 (Y offset) = 20 or 10

	LDA #$08
	STA <Temp_Var11		; Temp_Var11 (X offset) = 8

	JSR Player_GetTileAndSlope ; Get tile above Player

	STA Level_Tile_Head	 ; -> Level_Tile_Head
	STA <Temp_Var1		 ; -> Temp_Var1

	LDA Level_Tile_GndL	 ; Get left ground tilee
	STA <Temp_Var2		 ; -> Temp_Var2

	LDA Player_Behind	
	STA Player_Behind_En	; Default enable with being behind the scenes
	BEQ PRG008_A77E	 	; If Player is not behind the scenes, jump to PRG008_A77E

	LDA <Counter_1
	LSR A	
	BCC PRG008_A766	 	; Every other tick, jump to PRG008_A766

	DEC Player_Behind	; Player_Behind--

PRG008_A766:
	LDY #$00	 ; Y = 0 (disable "behind the scenes")

	; If tile behind Player's head is $41 or TILE1_SKY, jump to PRG008_A77B
	LDA <Temp_Var1
	CMP #$41
	BEQ PRG008_A77B
	CMP #TILE1_SKY
	BEQ PRG008_A77B

	INY		 	; Y = 1 (enable "behind the scenes")

	LDA Player_Behind
	BNE PRG008_A77B	 	; If Player is behind the scenes, jump to PRG008_A77B

	STY Player_Behind	; Set Player as behind the scenes

PRG008_A77B:
	STY Player_Behind_En	; Store whether Player is actually behind scenery

PRG008_A77E:
	LDA <Temp_Var1
	AND #$c0
	ASL A
	ROL A
	ROL A
	TAY		 ; Y = uppermost 2 bits down by 6 (thus 0-3, depending on which "quadrant" of tiles we're on, $00, $40, $80, $C0)

	; Checks for solid tile at Player's head
	LDA <Temp_Var1	 
	CMP Tile_AttrTable+4,Y	; Wall/ceiling-solid tile quadrant limits begin at Tile_AttrTable+4
	BLT PRG008_A7AD	 ; If tile index is less than value in Tile_AttrTable (not solid for wall/ceiling), jump to PRG008_A7AD

	LDA <Player_InAir
	ORA Player_InWater
	ORA Level_PipeMove
	BNE PRG008_A7AD	 	; If Player is mid air, in water, or moving in a pipe, jump to PRG008_A7AD

	; Solid tile at Player's head; Player is stuck in a low clearance (or worse stuck in the wall!)

	; A is logically zero here...

	; Stop Player horizontally, disable controls
	STA <Player_XVel
	STA <Pad_Input

	AND #~PAD_A
	STA <Pad_Input	; ?? it's still zero?

	; Player_LowClearance = 1 (Player is in a "low clearance" situation!)
	LDA #$01
	STA Player_LowClearance

	; This makes the Player "slide" when he's in a space too narrow
	ADD <Player_X
	STA <Player_X	 ; Player_X += 1
	BCC PRG008_A7AD	 ; If not carry, jump to PRG008_A7AD
	INC <Player_XHi	 ; Otherwise, apply carry

PRG008_A7AD:

	; This will be used in Level_CheckIfTileUnderwater 
	; as bits 2-3 of an index into Level_MinTileUWByQuad
	LDA Level_TilesetIdx
	ASL A
	ASL A
	STA <Temp_Var3	 ; Temp_Var3 = Level_TilesetIdx << 2

	LDX #$00	; Checks Temp_Var1 for tile and $40 override bit in UNK_584
	JSR Level_CheckIfTileUnderwater

	; Carry is set by Level_CheckIfTileUnderwater if tile was in the
	; "solid floor" region regardless of being "underwater"
	BCS PRG008_A7BE	 ; If carry set (tile was in solid region), jump to PRG008_A7BE

	; 'Y' is the result of Level_CheckIfTileUnderwater:
	; 0 = Not under water, 1 = Underwater, 2 = Waterfall
	TYA		 
	BNE PRG008_A812	 ; If Y <> 0 (somehow under water), jump to PRG008_A812

PRG008_A7BE:

	; NOT underwater!

	LDA Player_InWater
	BEQ PRG008_A827	 ; If Player was not previously in water, jump to PRG008_A827

	LDA <Player_InAir
	BNE PRG008_A7CB	 ; If Player is mid air, jump to PRG008_A7CB

	; Player is NOT flagged as mid air...

	BCS PRG008_A827	 ; If tile was in the floor solid region, jump to PRG008_A827
	BCC PRG008_A80B	 ; If tile was NOT in the floor solid region, jump to PRG008_A80B

PRG008_A7CB:

	; Player is known as mid air!

	BCS PRG008_A7D1	 ; If tile was in floor solid region, jump to PRG008_A7D1

	LDA <Player_YVel
	BMI PRG008_A7E2	 ; If Player's Y velocity < 0 (moving upward), jump to PRG008_A7E2

PRG008_A7D1:

	; Player's Y velocity >= 0...
	; OR Player just hit a solid tile with the head

	ROR A		 ; The important concept here is to save the previous carry flag
	STA <Temp_Var16	 ; Temp_Var16 (most importantly) contains the previous carry flag in bit 7

	LDX #$01	 ; Checks Temp_Var2 for tile and $80 override bit in UNK_584
	JSR Level_CheckIfTileUnderwater

	BCS PRG008_A7DE	 ; If tile was in the floor solid region, jump to PRG008_A7DE

	TYA
	BEQ PRG008_A80B	 ; If Y = 0 (Not underwater), jump to PRG008_A80B

PRG008_A7DE:
	LDA <Temp_Var16
	BMI PRG008_A812	 ; If we had a floor solid tile in the last check, jump to PRG008_A812

	; Did NOT hit a solid floor tile with head last check

PRG008_A7E2:
	LDY <Player_YVel
	CPY #-$0C
	BGS PRG008_A7EA	 ; If Player_YVel >= -$0C, jump to PRG008_A7EA

	; Prevent Player_YVel from being less than -$0C
	LDY #-$0C

PRG008_A7EA:
	LDA <Counter_1
	AND #$07
	BNE PRG008_A7F1

	INY		 ; 1:8 chance velocity will be dampened just a bit

PRG008_A7F1:
	STY <Player_YVel ; Update Player_YVel

	LDA <Pad_Input
	AND #~PAD_A
	STA <Pad_Input	 ; Strip out 'A' button press

	LDA <Pad_Holding
	TAY		 ; Y = Pad_Holding

	AND #~PAD_UP
	STA <Pad_Holding ; Strip out 'Up'

	TYA		 ; A = original Pad_Holding
	AND #(PAD_UP | PAD_A)
	CMP #(PAD_UP | PAD_A)
	BNE PRG008_A827	 ; If Player is not pressing UP + A, jump to PRG008_A827

	; Player wants to exit water!
	LDA #-$34
	STA <Player_YVel ; Player_YVel = -$34 (exit velocity from water)

PRG008_A80B:

	; Player NOT marked as "in air" and last checked tile was NOT in the solid region
	; OR second check tile was not underwater

	LDY #$00	 
	STY Player_SwimCnt ; Player_SwimCnt = 0
	BEQ PRG008_A819	   ; Jump (technically always) to PRG008_A819

PRG008_A812:

	; Solid floor tile at head last check

	LDY <Temp_Var15
	CPY Player_InWater
	BEQ PRG008_A827	   ; If Player_InWater = Temp_Var15 (underwater flag = underwater status), jump to PRG008_A827

PRG008_A819:

	; Player's underwater flag doesn't match the water he's in...

	TYA
	ORA Player_InWater
	STY Player_InWater	; Merge water flag status
	CMP #$02	 
	BEQ PRG008_A827	 	; If it equals 2, jump to PRG008_A827

	JSR Player_WaterSplash	 ; Hit water; splash!

PRG008_A827:

	; Player not flagged as "under water"
	; Player not flagged as "mid air" and last checked tile was in solid region

	LDA <Player_FlipBits
	AND #%01111111	 
	STA <Player_FlipBits	 ; Clear vertical flip on sprite

	LDY Level_TilesetIdx	 ; Y = Level_TilesetIdx

	LDA #TILEA_DOOR2
	SUB <Temp_Var1	
	BEQ PRG008_A83F	 ; If tile is DOOR2's tile, jump to PRG008_A83F

	; Only fortresses can use DOOR1
	CPY #$01
	BNE PRG008_A86C	 ; If Level_TilesetIdx <> 1 (fortress style), jump to PRG008_A86C

	CMP #$01
	BNE PRG008_A86C	 ; If tile is not DOOR1, jump to PRG008_A86C

PRG008_A83F:

	; DOOR LOGIC

	LDA <Pad_Input
	AND #PAD_UP
	BEQ PRG008_A86C	 ; If Player is not pressing up in front of a door, jump to PRG008_A86C

	LDA <Player_InAir
	BNE PRG008_A86C	 ; If Player is mid air, jump to PRG008_A86C

	; If Level_PipeNotExit is set, we use Level_JctCtl = 3 (the general junction)
	; Otherwise, a value of 1 is used which flags that pipe should exit to map

	LDY #$01	; Y = 1

	LDA Level_PipeNotExit
	BEQ PRG008_A852	 ; If pipe should exit to map, jump to PRG008_A852

	LDY #$03	 ; Otherwise, Y = 3

PRG008_A852:
	STY Level_JctCtl ; Set appropriate value to Level_JctCtl

	LDY #0
	STY Map_ReturnStatus	 ; Map_ReturnStatus = 0

	STY <Player_XVel	 ; Player_XVel = 0

	LDA <Player_X
	AND #$08
	BEQ PRG008_A864	 ; If Player is NOT halfway across door, jump to PRG008_A864

	LDY #16		 ; Otherwise, Y = 16

PRG008_A864:
	TYA	
	ADD <Player_X	 ; Add offset to Player_X if needed
	AND #$F0	 ; Lock to nearest column (place directly in doorway)
	STA <Player_X	 ; Update Player_X

PRG008_A86C:

	; VINE CLIMBING LOGIC

	LDA Player_InWater
	ORA Player_IsHolding
	ORA Player_Kuribo
	BNE PRG008_A890	 ; If Player is in water, holding something, or in Kuribo's shoe, jump to PRG008_A890

	LDA <Temp_Var1
	CMP #TILE1_VINE
	BNE PRG008_A890	 ; If tile is not the vine, jump to PRG008_A890

	LDA Player_IsClimbing
	BNE PRG008_A898	 ; If climbing flag is set, jump to PRG008_A898

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_A890	 ; If Player is not pressing up or down, jump to PRG008_A890

	LDY <Player_InAir
	BNE PRG008_A898	 ; If Player is in the air, jump to PRG008_A898

	AND #%00001000
	BNE PRG008_A898	 ; If Player is pressing up, jump to PRG008_A898

PRG008_A890:
	LDA #$00
	STA Player_IsClimbing	 ; Player_IsClimbing = 0 (Player is not climbing)

	JMP PRG008_A8F9	 ; Jump to PRG008_A8F9

PRG008_A898:
	LDA #$01
	STA Player_IsClimbing	 ; Player_IsClimbing = 1 (Player is climbing)

	; Kill Player velocities
	LDA #$00
	STA <Player_XVel
	STA <Player_YVel

	LDY #$10 	; Y = $10 (will be Y velocity down if Player is pressing down)

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_A8CA	 ; If Player is not pressing up or down, jump to PRG008_A8CA

	; Player is pressing UP or DOWN...

	AND #PAD_UP
	BEQ PRG008_A8C8	 ; If Player is NOT pressing UP, jump to PRG008_A8C8

	; Player is pressing UP...

	LDY #16		; Y = 16

	LDA <Player_Suit
	BEQ PRG008_A8B7	 ; If Player is small, jump to PRG008_A8B7

	LDY #0	 	; Otherwise, Y = 0

PRG008_A8B7:
	STY <Temp_Var10	 ; Temp_Var10 = 16 or 0 (if small) (Y Offset for Player_GetTileAndSlope)

	LDA #$08
	STA <Temp_Var11	 ; Temp_Var11 = 8 (X Offset for Player_GetTileAndSlope)

	JSR Player_GetTileAndSlope	; Get tile

	CMP #TILE1_VINE
	BNE PRG008_A8CA	 ; If tile is NOT another vine, jump to PRG008_A8CA

	LDY #-$10
	STY <Player_InAir ; Flag Player as "in air"

PRG008_A8C8:
	STY <Player_YVel  ; Set Player's Y Velocity

PRG008_A8CA:
	LDY #$10	 ; Y = $10 (rightward X velocity)

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_A8DA	 ; If Player is NOT pressing LEFT or RIGHT, jump to PRG008_A8DA

	AND #PAD_LEFT
	BEQ PRG008_A8D8	 ; If Player is NOT pressing LEFT, jump to PRG008_A8D8

	LDY #-$10	 ; Y = -$10 (leftward X velocity)

PRG008_A8D8:
	STY <Player_XVel ; Set Player's X Velocity

PRG008_A8DA:
	LDA Player_IsClimbing
	BEQ PRG008_A8EC	 ; If Player is NOT climbing, jump to PRG008_A8EC

	; Player is climbing...

	LDA <Player_InAir
	BNE PRG008_A8EC	 ; If Player is in air, jump to PRG008_A8EC

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BNE PRG008_A8EC	 ; If Player is pressing UP or DOWN, jump to PRG008_A8EC

	STA Player_IsClimbing	 ; Set climbing flag

PRG008_A8EC:

	; Apply Player's X and Y velocity for the vine climbing
	JSR Player_ApplyXVelocity
	JSR Player_ApplyYVelocity

	JSR Player_DoClimbAnim	 ; Animate climbing
	JSR Player_Draw29	 ; Draw Player
	RTS		 ; Return

PRG008_A8F9:

	; Player not climbing...

	LDA Player_SlideRate
	BEQ PRG008_A906	 ; If Player sliding rate is zero, jump to PRG008_A906

	; Otherwise, apply it
	LDA <Player_XVel
	ADD Player_SlideRate
	STA <Player_XVel

PRG008_A906:
	JSR Player_ApplyXVelocity	 ; Apply Player's X Velocity

	LDA Player_SlideRate	 
	BEQ PRG008_A916	 ; If Player is not sliding, jump to PRG008_A916

	; Otherwise, apply it AGAIN
	LDA <Player_XVel
	SUB Player_SlideRate
	STA <Player_XVel

PRG008_A916:

	LDA #$00
	STA Player_SlideRate	 ; Player_SlideRate = 0 (does not persist)

	LDY #$02	 ; Y = 2 (moving right)

	LDA <Player_XVel
	BPL PRG008_A925	 ; If Player's X Velocity is rightward, jump to PRG008_A925

	JSR Negate	 ; Negate X Velocity (get absolute value)

	DEY		 ; Y = 1 (moving left)

PRG008_A925:
	BNE PRG008_A928	 ; If Player's X Velocity is not zero (what is intended by this check), jump PRG008_A928

	; Player's velocity is zero
	TAY		 ; And thus, so is Y (not moving left/right)

PRG008_A928:
	STA <Temp_Var3	 ; Temp_Var3 = absolute value of Player's X Velocity

	STY Player_MoveLR	; Set Player_MoveLR appropriately
 
	LDA <Player_InAir
	BEQ PRG008_A940	 ; If Player is not mid air, jump to PRG008_A940

	LDA <Player_YHi
	BPL PRG008_A93D	 ; If Player is on the upper half of the screen, jump to PRG008_A93D

	; Player is mid air, lower half of screen...

	LDA <Player_Y
	BMI PRG008_A93D	 ; If Player is beneath the half point of the lower screen, jump to PRG008_A93D

	LDA <Player_YVel
	BMI PRG008_A940	 ; If Player is moving upward, jump to PRG008_A940

PRG008_A93D:
	JSR Player_ApplyYVelocity	 ; Apply Player's Y velocity

PRG008_A940:
	JSR Player_CommonGroundAnims	 ; Perform common ground animation routines

	LDA Player_Kuribo
	BEQ PRG008_A94C	 ; If Player is not wearing Kuribo's shoe, jump to PRG008_A94C

	; If in Kuribo's shoe...

	LDA #14		 ; A = 14 (Kuribo's shoe code pointer)
	BNE PRG008_A956	 ; Jump (technically always) to PRG008_A956

PRG008_A94C:
	LDA <Player_Suit

	LDY Player_InWater
	BEQ PRG008_A956	 ; If Player is not under water, jump to PRG008_A956

	ADD #$07	 ; Otherwise, add 7 (underwater code pointers)

PRG008_A956:
	ASL A		 ; 2-byte pointer
	TAY		 ; -> Y

	; MOVEMENT LOGIC PER POWER-UP / SUIT

	; NOTE: If you were ever one to play around with the "Judgem's Suit"
	; glitch power-up, and wondered why he swam in the air and Kuribo'ed
	; in the water, here's the answer!


	; Get proper movement code address for power-up 
	; (ground movement, swimming, Kuribo's shoe)
	LDA PowerUpMovement_JumpTable,Y
	STA <Temp_Var1
	LDA PowerUpMovement_JumpTable+1,Y
	STA <Temp_Var2


	JMP [Temp_Var1]	 ; Jump into the movement code!

PowerUpMovement_JumpTable:
	; Ground movement code
	.word GndMov_Small	; 0 - Small
	.word GndMov_Big	; 1 - Big
	.word GndMov_FireHammer	; 2 - Fire
	.word GndMov_Leaf	; 3 - Leaf
	.word GndMov_Frog	; 4 - Frog
	.word GndMov_Tanooki	; 5 - Tanooki
	.word GndMov_FireHammer	; 6 - Hammer

	; Underwater movement code
	.word Swim_SmallBigLeaf	; 0 - Small
	.word Swim_SmallBigLeaf	; 1 - Big
	.word Swim_FireHammer	; 2 - Fire
	.word Swim_SmallBigLeaf	; 3 - Leaf
	.word Swim_Frog		; 4 - Frog
	.word Swim_Tanooki	; 5 - Tanooki
	.word Swim_FireHammer	; 6 - Hammer

	; Kuribo's shoe
	.word Move_Kuribo

GndMov_Small:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag

	LDA Player_SandSink
	LSR A		 
	BCS PRG008_A9A3	 ; If bit 0 of Player_SandSink was set, jump to PRG008_A9A3 (RTS)

	LDA Player_AllowAirJump
	BNE PRG008_A9A3	 ; If Player_AllowAirJump, jump to PRG008_A9A3 (RTS)

	LDA <Player_InAir
	BEQ PRG008_A9A3	 ; If Player is not mid air, jump to PRG008_A9A3 (RTS)

	; Player is mid-air...

	LDA #PF_JUMPFALLSMALL	; Standard jump/fall frame

	LDY Player_FlyTime
	BEQ PRG008_A9A1	 ; If Player_FlyTime = 0, jump to PRG008_A9A1

	LDA #PF_FASTJUMPFALLSMALL	 ; High speed jump frame

PRG008_A9A1:
	STA <Player_Frame ; Set appropriate frame

PRG008_A9A3:
	RTS		 ; Return

Swim_SmallBigLeaf:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	RTS		 ; Return

GndMov_Big:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	RTS		 ; Return

	RTS		 ; Return?

GndMov_FireHammer:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_SoarJumpFallFrame ; Do Player soar/jump/fall frame
	JSR Player_ShootAnim ; Do Player shooting animation
	RTS		 ; Return

Swim_FireHammer:
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	JSR Player_ShootAnim ; Do Player shooting animation
	RTS		 ; Return

GndMov_Leaf:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_AnimTailWag ; Do Player's tail animations
	JSR Player_TailAttackAnim ; Do Player's tail attack animations
	RTS		 ; Return

	RTS		 ; Return?

GndMov_Frog:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag

	LDA Player_IsHolding
	BNE PRG008_AA23	 ; If Player is holding something, jump to PRG008_AA23

	LDA <Player_InAir
	BEQ PRG008_AA00	 ; If Player is NOT in mid air, jump to PRG008_AA00

	LDA Player_SandSink
	LSR A
	BCS PRG008_AA00	 ; If bit 0 of Player_SandSink is set, jump to PRG008_AA00

	LDA #$00
	STA Player_FrogHopCnt	 ; Player_FrogHopCnt = 0

	LDY #$01	 ; Y = 1
	JMP PRG008_AA1E	 ; Jump to PRG008_AA1E

PRG008_AA00:
	LDA Player_FrogHopCnt
	BNE PRG008_AA1A	 ; If Player_FrogHopCnt <> 0, jump to PRG008_AA1A

	STA <Player_XVel	; Player_XVel = 0
	LDA <Pad_Holding	
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AA1A	 ; If Player is not pressing left/right, jump to PRG008_AA1A

	; Play frog hop sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERFROG
	STA Sound_QPlayer

	LDA #$1f
	STA Player_FrogHopCnt ; Player_FrogHopCnt = $1f

PRG008_AA1A:
	LSR A
	LSR A
	LSR A
	TAY	 ; Y = Player_FrogHopCnt >> 3

PRG008_AA1E:
	LDA Player_FrogHopFrames,Y	; Get frog frame
	STA <Player_Frame		; Store as frame

PRG008_AA23:
	RTS		 ; Return

Frog_SwimSoundMask:
	.byte $03, $07

	; Base frame for the different swimming directions of the frog
Frog_BaseFrame:
	; Down, Up, Left/Right
	.byte PF_FROGSWIM_DOWNBASE, PF_FROGSWIM_UPBASE, PF_FROGSWIM_LRBASE

	; Frame offset to frames above
Frog_FrameOffset:
	.byte $02, $02, $02, $01, $00, $01, $02, $02

	; Base velocity for frog swim right/down, left/up
Frog_Velocity:
	.byte 16, -16

Swim_Frog:
	LDX #$ff	 ; X = $FF

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_AA61	 ; If Player is NOT pressing up/down, jump to PRG008_AA61

	; 
	STA <Player_InAir

	LSR A
	LSR A
	LSR A
	TAX		 ; X = 1 if pressing up, else 0

	LDA Frog_Velocity,X	; Get base frog velocity
	BPL PRG008_AA4D	 ; If value >= 0 (if pressing down), jump to PRG008_AA4D

	LDY Player_AboveTop
	BPL PRG008_AA4D	 ; If Player is not off top of screen, jump to PRG008_AA4D

	LDA #$00	 ; A = 0

PRG008_AA4D:
	LDY <Pad_Holding
	BPL PRG008_AA52	 ; If Player is not pressing 'A', jump to PRG008_AA52

	ASL A		 ; Double vertical speed

PRG008_AA52:
	CMP #(PLAYER_FROG_MAXYVEL+1)
	BLT PRG008_AA5C	 

	LDY <Player_InAir
	BNE PRG008_AA5C	 ; If Player is swimming above ground, jump to PRG008_AA5C

	LDA #PLAYER_FROG_MAXYVEL	 ; Cap swim speed

PRG008_AA5C:
	STA <Player_YVel ; Set Y Velocity
	JMP PRG008_AA6E	 ; Jump to PRG008_AA6E

PRG008_AA61:
	LDY <Player_YVel
	BEQ PRG008_AA6E	 ; If Y Velocity = 0, jump to PRG008_AA6E

	INY		 ; Y++

	LDA <Player_YVel
	BMI PRG008_AA6C	 ; If Player_YVel < 0, jump to PRG008_AA6C

	DEY
	DEY		 ; Y -= 2

PRG008_AA6C:
	STY <Player_YVel ; Update Y Velocity

PRG008_AA6E:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AA84	 ; If Player is not pressing left or right, jump to PRG008_AA84

	; Player is pressing left/right...

	LSR A
	TAY
	LDA Frog_Velocity,Y	; Get base frog velocity

	LDY <Pad_Holding
	BPL PRG008_AA7E	 ; If Player is not pressing 'A', jump to PRG008_AA7E

	ASL A		 ; Double horizontal velocity

PRG008_AA7E:
	STA <Player_XVel ; Update X Velocity

	LDX #$02	 ; X = 2
	BNE PRG008_AA9C	 ; Jump (technically always) to PRG008_AA9C

PRG008_AA84:
	LDY <Player_XVel
	BEQ PRG008_AA94	 ; If Player is not moving horizontally, jump to PRG008_AA94

	INY		 ; Y++

	LDA <Player_XVel
	BMI PRG008_AA8F	 ; If Player_XVel < 0, jump to PRG008_AA8F

	DEY
	DEY		 ; Y -= 2

PRG008_AA8F:
	STY <Player_XVel ; Update X Velocity
	JMP PRG008_AA9C	 ; Jump to PRG008_AA9C

PRG008_AA94:
	LDA <Player_InAir
	BNE PRG008_AA9C	 ; If Player is swimming above ground, jump to PRG008_AA9C

	LDA #$15	 ; A = $15
	BNE PRG008_AAD2	 ; Jump (technically always) to PRG008_AAD2

PRG008_AA9C:
	TXA		 
	BMI PRG008_AAC8	 ; If X < 0, jump to PRG008_AAC8

	LDA <Counter_1
	LSR A
	LSR A

	LDY #$00	 ; Y = 0

	BIT <Pad_Holding
	BMI PRG008_AAAB	 ; If Player is holding 'A', jump to PRG008_AAAB

	LSR A		 ; Otherwise, reduce velocity adjustment
	INY		 ; Y++

PRG008_AAAB:
	AND #$07
	TAY	
	BNE PRG008_AABF	

	LDA <Counter_1
	AND Frog_SwimSoundMask,Y
	BNE PRG008_AABF	 ; If timing is not right for frog swim sound, jump to PRG008_AABF

	; Play swim sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

PRG008_AABF:
	LDA Frog_BaseFrame,X
	ADD Frog_FrameOffset,Y
	BNE PRG008_AAD2

PRG008_AAC8:
	LDY #PF_FROGSWIM_IDLEBASE

	LDA <Counter_1
	AND #$08
	BEQ PRG008_AAD1

	INY

PRG008_AAD1:
	TYA

PRG008_AAD2:
	STA <Player_Frame ; Update Player_Frame
	RTS		 ; Return

GndMov_Tanooki:
	JSR Player_TanookiStatue  ; Change into/maintain Tanooki statue (NOTE: Will not return here if statue!)
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag
	JSR Player_AnimTailWag ; Do Player's tail animations
	JSR Player_TailAttackAnim ; Do Player's tail attack animations
	RTS		 ; Return

Swim_Tanooki:
	JSR Player_TanookiStatue ; Change into/maintain Tanooki statue (NOTE: Will not return here if statue!)
	JSR Player_UnderwaterHControl ; Do Player left/right input for underwater
	JSR Player_SwimV ; Do Player up/down swimming action
	JSR Player_SwimAnim ; Do Player swim animations
	RTS		 ; Return

Move_Kuribo:
	JSR Player_GroundHControl ; Do Player left/right input control
	JSR Player_JumpFlyFlutter ; Do Player jump, fly, flutter wag

	LDA <Player_InAir
	BNE PRG008_AAFF	 ; If Player is mid air, jump to PRG008_AAFF

	STA Player_KuriboDir	 ; Clear Player_KuriboDir

PRG008_AAFF:
	LDA Player_KuriboDir
	BNE PRG008_AB17	 ; If Kuribo's shoe is moving, jump to PRG008_AB17

	LDA <Player_InAir
	BNE PRG008_AB25	 ; If Player is mid air, jump to PRG008_AB25

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	STA Player_KuriboDir	 ; Store left/right pad input -> Player_KuriboDir
	BEQ PRG008_AB25	 	; If Player is not pressing left or right, jump to PRG008_AB25
	INC <Player_InAir	 ; Flag as in air (Kuribo's shoe bounces along)

	LDY #-$20
	STY <Player_YVel	 ; Player_YVel = -$20

PRG008_AB17:
	LDA <Pad_Input
	BPL PRG008_AB25	 ; If Player is NOT pressing 'A', jump to PRG008_AB25

	LDA #$00
	STA Player_KuriboDir	 ; Player_KuriboDir = 0

	LDY Player_RootJumpVel	 ; Get initial jump velocity
	STY <Player_YVel	 ; Store into Y velocity

PRG008_AB25:
	LDY <Player_Suit
	BEQ PRG008_AB2B	 ; If Player is small, jump to PRG008_AB2B

	LDY #$01	 ; Otherwise, Y = 1

PRG008_AB2B:

	; Y = 0 if small, 1 otherwise

	LDA Player_KuriboFrame,Y	; Get appropriate Kuribo's shoe frame
	STA <Player_Frame		; Store as active Player frame

	LDA <Counter_1
	AND #$08	
	BEQ PRG008_AB38	 	; Every 8 ticks, jump to PRG008_AB38

	INC <Player_Frame	; Player_Frame++

PRG008_AB38:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GroundHControl
;
; Routine to control based on Player's left/right pad input (not
; underwater); configures walking/running
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Table of values that have to do with Player_UphillSpeedIdx override
Player_UphillSpeedVals:
	.byte $00, $16, $15, $14, $13, $12, $11, $10, $0F, $0E, $0D

Player_GroundHControl:
	LDA Player_UphillFlag
	BEQ PRG008_AB56	 ; If Player is not going up hill, jump to PRG008_AB56

	INC Player_WalkAnimTicks	; Player_WalkAnimTicks++

	LDY #10	 ; Y = 10 (Player NOT holding B)

	BIT <Pad_Holding
	BVC PRG008_AB5B	 ; If Player is NOT holding 'B', jump to PRG008_AB5B

	LDY #1	 ; Y = 1 (Player holding B)
	BNE PRG008_AB5B	 ; Jump (technically always) to PRG008_AB5B

PRG008_AB56:

	; Use override value
	
	LDY Player_UphillSpeedIdx	 ; Y = Player_UphillSpeedIdx
	BEQ PRG008_AB62	 ; If Player_UphillSpeedIdx = 0 (not walking uphill), jump to PRG008_AB62

PRG008_AB5B:
	LDA Player_UphillSpeedVals,Y	 ; Get uphill speed value
	TAY		 	; -> Y
	JMP PRG008_AB83	 ; Jump to PRG008_AB83

PRG008_AB62:
	LDY #Pad_Input

	BIT <Pad_Holding
	BVC PRG008_AB83	; If Player is NOT holding 'B', jump to PRG008_AB83

	; Player is holding B...

	LDA <Player_InAir
	ORA Player_Slide
	BNE PRG008_AB78	 ; If Player is mid air or sliding, jump to PRG008_AB78

	LDA <Temp_Var3
	CMP #PLAYER_TOPRUNSPEED
	BMI PRG008_AB78	 ; If Player's X Velocity magnitude is less than PLAYER_TOPRUNSPEED, jump to PRG008_AB78

	; Player is going fast enough while holding B on the ground; flag running!
	INC Player_RunFlag ; Player_RunFlag = 1

PRG008_AB78:
	; Start with top run speed
	LDY #PLAYER_TOPRUNSPEED ; Y = PLAYER_TOPRUNSPEED

	LDA Player_Power
	CMP #$7f
	BNE PRG008_AB83	 ; If Player has not hit full power, jump to PRG008_AB83

	; Otherwise, top power speed
	LDY #PLAYER_TOPPOWERSPEED	 ; Y = PLAYER_TOPPOWERSPEED

PRG008_AB83:
	STY <Temp_Var14	 ; Store top speed -> Temp_Var14

	LDY Player_Slippery
	BEQ PRG008_AB98	 ; If ground is not slippery at all, jump to PRG008_AB98

	INC Player_WalkAnimTicks ; Player_WalkAnimTicks++

	DEY
	TYA
	ASL A
	ASL A
	ASL A
	ADD #$40
	TAY		 ; Y = ((selected top speed - 1) << 3) + $40 ??
	BNE PRG008_AB9E	 ; And as long as that's not zero, jump to PRG008_AB9E

PRG008_AB98:
	LDA <Player_Suit
	ASL A
	ASL A
	ASL A
	TAY		 ; Y = Player_Suit << 3

PRG008_AB9E:
	BIT <Pad_Holding
	BVC PRG008_ABA6	 ; If Player is NOT pressing 'B', jump to PRG008_ABA6

	; Otherwise...
	INY
	INY
	INY
	INY	; Y += 4 (offset 4 inside Player_XAccel* tables)

PRG008_ABA6:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG008_ABB8	 ; If Player is pressing LEFT or RIGHT, jump to PRG008_ABB8

	; Player not pressing LEFT/RIGHT...

	LDA <Player_InAir
	BNE PRG008_AC01	 ; If Player is mid air, jump to PRG008_AC01 (RTS)

	LDA <Player_XVel
	BEQ PRG008_AC01	 ; If Player is not moving horizontally, jump to PRG008_AC01 (RTS)
	BMI PRG008_ABD3	 ; If Player is moving leftward, jump to PRG008_ABD3
	BPL PRG008_ABEB	 ; If Player is moving rightward, jump to PRG008_ABEB

PRG008_ABB8:

	; Player is pressing left/right...

	INY
	INY		 ; Y += 2 (offset 2 within Player_XAccel* tables, the "skid" rate)

	AND Player_MoveLR
	BNE PRG008_ABCD	  ; If Player suddenly reversed direction, jump to PRG008_ABCD

	DEY		 ; Y-- (back one offset, the "normal" rate)

	LDA <Temp_Var3	 
	CMP <Temp_Var14	 
	BEQ PRG008_AC01	 ; If Player's current X velocity magnitude is the same as the selected top speed, jump to PRG008_AC01 (RTS)
	BMI PRG008_ABCD	 ; If it's less, then jump to PRG008_AC01

	LDA <Player_InAir
	BNE PRG008_AC01	 ; If Player is mid air, jump to PRG008_AC01

	DEY		 ; Y-- (back one offset, the "friction" stopping rate)

PRG008_ABCD:


	; At this point, 'Y' contains the current power-up in bits 7-3, 
	; bit 2 is set if Player pressed B, bit 1 is set if the above
	; block was jumped, otherwise bit 0 is set if the X velocity is
	; less than the specified maximum, clear if over the max


	LDA <Pad_Holding
	AND #PAD_RIGHT
	BNE PRG008_ABEB	 ; If Player is holding RIGHT, jump to PRG008_ABEB (moving rightward code)

PRG008_ABD3:

	; Player moving leftward

	LDA #$00	 
	SUB Player_XAccelPseudoFrac,Y ; Negate value from Player_XAccelPseudoFrac[Y]
	STA <Temp_Var1	  ; -> Temp_Var1

	LDA Player_XAccelMain,Y ; Get Player_XAccelMain[Y]
	EOR #$ff	 ; Negate it (sort of)
	STA <Temp_Var2	 ; -> Temp_Var2

	LDA <Temp_Var1
	BNE PRG008_ABF5	 ; If Temp_Var1 <> 0, jump to PRG008_ABF5

	INC <Temp_Var2	 ; Otherwise, Temp_Var2++
	JMP PRG008_ABF5	 ; Jump to PRG008_ABF5

PRG008_ABEB:

	; Player moving rightward

	LDA Player_XAccelPseudoFrac,Y ; Get value from Player_XAccelPseudoFrac[Y]
	STA <Temp_Var1	  ; -> Temp_Var1

	LDA Player_XAccelMain,Y ; Get value from Player_XAccelMain[Y]
	STA <Temp_Var2	  ; -> Temp_Var2

PRG008_ABF5: 
	LDA <Temp_Var1
	ADD Counter_Wiggly	; actual value not used, looking for a semi-random carry

	LDA <Player_XVel
	ADC <Temp_Var2
	STA <Player_XVel	; Player_XVel += Temp_Var2 (and sometimes carry)

PRG008_AC01:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_UnderwaterHControl
;
; Routine to control based on Player's left/right pad input underwater
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_UnderwaterHControl:
	LDY #(Player_XAccelMain_UW - Player_XAccelMain)	; Y = index to appropriate under water values

	LDA #%00001000
	STA <Temp_Var14	 ; Temp_Var14 = pretend like Player is definitely hitting UP

	LDA <Player_InAir
	BEQ PRG008_AC14	 ; If Player is not in the air, jump to PRG008_AC14

	LDA #Pad_Input
	STA <Temp_Var14	 ; Temp_Var14 = actual Pad_Input (as compared to what happened above)

	INY
	INY
	INY
	INY		 ; Y += 4 (offset into Player_XAccel* tables)
 
PRG008_AC14:
	LDA <Player_InAir
	PHA		 ; Save Player_InAir

	LDA #$00
	STA <Player_InAir ; Player_InAir= 0

	JSR PRG008_ABA6	 ; Reuses part of normal movement code

	PLA		 
	STA <Player_InAir ; Restore Player_InAir

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_JumpFlyFlutter
;
; Controls the acts of jumping, flying, and fluttering (tail wagging)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG008_AC22:
	.byte $D0, $CE, $CC, $CA, $CA, $CA

Player_JumpFlyFlutter:
	LDA Player_AllowAirJump
	BEQ PRG008_AC30	 ; If Player_AllowAirJump = 0, jump to PRG008_AC30

	DEC Player_AllowAirJump ; Player_AllowAirJump--

PRG008_AC30:

	LDA <Pad_Input
	AND #PAD_A
	STA <Temp_Var1	 ; Temp_Var1 = $80 if Player is pressing 'A', otherwise 0
	BEQ PRG008_AC9E	 ; If Player is NOT pressing 'A', jump to PRG008_AC9E

	LDA Player_AllowAirJump
	BNE PRG008_AC41	 ; If Player_AllowAirJump <> 0, jump to PRG008_AC41

	LDA <Player_InAir
	BNE PRG008_AC9E	 ; If Player is mid air, jump to PRG008_AC9E

PRG008_AC41:

	; Play jump sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERJUMP	 
	STA Sound_QPlayer

	LDA Player_StarInv
	BEQ PRG008_AC6C	 ; If Player is not invincible by star, jump to PRG008_AC6C

	LDA Player_Power
	CMP #$7f
	BEQ PRG008_AC6C	 ; If Player is at max power, jump to PRG008_AC6C

	LDA Player_IsHolding
	BNE PRG008_AC6C	 ; If Player is holding something, jump to PRG008_AC6C

	LDA <Player_Suit
	BEQ PRG008_AC6C	 ; If Player is small, jump to PRG008_AC6C
	CMP #PLAYERSUIT_FROG
	BEQ PRG008_AC6C	 ; If Player is wearing frog suit, jump to PRG008_AC6C

	; Otherwise, mark as mid air AND backflipping
	STA Player_Flip
	STA <Player_InAir

	LDA #$00
	STA Player_AllowAirJump	 ; Cut off Player_AllowAirJump

PRG008_AC6C:

	; Get absolute value of Player's X velocity
	LDA <Player_XVel
	BPL PRG008_AC73
	JSR Negate
PRG008_AC73:

	LSR A
	LSR A
	LSR A
	LSR A
	TAX	 ; X = Magnitude of Player's X Velocity >> 4 (the "whole" part)

	LDA Player_RootJumpVel	 	; Get initial jump velocity
	SUB Player_SpeedJumpInc,X	; Subtract a tiny bit of boost at certain X Velocity speed levels
	STA <Player_YVel		; -> Y velocity

	LDA #$01
	STA <Player_InAir ; Flag Player as mid air

	LDA #$00	
	STA Player_WagCount	 ; Player_WagCount = 0
	STA Player_AllowAirJump	 ; Player_AllowAirJump = 0

	LDA Player_Power
	CMP #$7f
	BNE PRG008_AC9E		; If Player is not at max power, jump to PRG008_AC9E

	LDA Player_FlyTime
	BNE PRG008_AC9E	 	; If Player still has flight time left, jump to PRG008_AC9E

	LDA #$80
	STA Player_FlyTime	; Otherwise, Player_FlyTime = $80

PRG008_AC9E:
	LDA <Player_InAir
	BNE PRG008_ACB3		; If Player is mid air, jump to PRG008_ACB3

	LDY <Player_Suit
	LDA PowerUp_Ability,Y	; Get "ability" flags for this power up
	AND #$01
	BNE PRG008_AD1A	 	; If power up has flight ability, jump to PRG008_AD1A

	LDA #$00
	STA Player_FlyTime	; Otherwise, Player_FlyTime = 0 :(
	JMP PRG008_AD1A	 ; Jump to PRG008_AD1A

PRG008_ACB3:

	; Player is mid air...

	LDY #$05	 ; Y = 5

	LDA <Player_YVel
	CMP #-$20
	BGS PRG008_ACC8	 ; If Player's Y velocity >= -$20, jump to PRG008_ACC8

	LDA Player_mGoomba
	BNE PRG008_ACCD	 ; If Player has got a microgoomba stuck to him, jump to PRG008_ACCD

	LDA <Pad_Holding
	BPL PRG008_ACC8	 ; If Player is NOT pressing 'A', jump to PRG008_ACC8

	LDY #$01	 ; Y = 1
	BNE PRG008_ACCD	 ; Jump (technically always) to PRG008_ACCD

PRG008_ACC8:
	LDA #$00
	STA Player_mGoomba ; Player_mGoomba = 0

PRG008_ACCD:
	TYA	
	ADD <Player_YVel
	STA <Player_YVel ; Player_YVel += Y

	LDA <Player_WagCount
	BEQ PRG008_ACD9	 ; If Player_WagCount = 0, jump to PRG008_ACD9

	DEC <Player_WagCount ; Otherwise, $F0--

PRG008_ACD9:
	LDA Player_Kuribo
	BNE PRG008_ACEF	 ; If Player is wearing Kuribo's shoe, jump to PRG008_ACEF

	LDX <Player_Suit

	LDA PowerUp_Ability,X	; Get "ability" flags for this power up
	AND #$01	 
	BEQ PRG008_ACEF	 	; If this power up does not have flight, jump to PRG008_ACEF

	LDY <Temp_Var1		; Y = $80 if Player was pressing 'A' when this all began
	BEQ PRG008_ACEF	 	; And if he wasn't, jump to PRG008_ACEF

	LDA #$10	 
	STA <Player_WagCount 	; Otherwise, Player_WagCount = $10

PRG008_ACEF:
	LDA <Player_WagCount
	BEQ PRG008_AD1A	 	; If Player has not wag count left, jump to PRG008_AD1A

	; RACCOON / TANOOKI TAIL WAG LOGIC

	LDA <Player_YVel
	CMP #PLAYER_FLY_YVEL
	BLS PRG008_AD1A	 ; If Player's Y velocity is < PLAYER_FLY_YVEL, jump to PRG008_AD1A

	LDY #PLAYER_FLY_YVEL	 ; Y = PLAYER_FLY_YVEL

	LDA Player_FlyTime
	BEQ PRG008_AD0E	 ; If Player is not flying, jump to PRG008_AD0E

	CMP #$0f
	BGE PRG008_AD18	 ; If Player has a great amount of flight time left, jump to PRG008_AD18

	; Player has a small amount of flight time left

	LDY #$F0
	AND #$08	 
	BNE PRG008_AD18	 ; Every 8 ticks, jump to PRG008_AD18

	LDY #$00	 ; Y = 0 (at apex of flight, Player no longer rises)
	BEQ PRG008_AD18	 ; Jump (technically always) to PRG008_AD18

PRG008_AD0E:
	LDA <Player_YVel
	BMI PRG008_AD1A	 ; If Player's Y velocity < 0 (moving upward), jump to PRG008_AD1A

	CMP #PLAYER_TAILWAG_YVEL
	BLT PRG008_AD1A	 ; If Player's Y velocity < PLAYER_TAILWAG_YVEL, jump to PRG008_AD1A

	LDY #PLAYER_TAILWAG_YVEL ; Y = PLAYER_TAILWAG_YVEL

PRG008_AD18:
	STY <Player_YVel ; Set appropriate Y velocity

PRG008_AD1A:
	LDA Player_UphillSpeedIdx
	BEQ PRG008_AD2E	 ; If Player_UphillSpeedIdx = 0 (not walking uphill), jump to PRG008_AD2E

	LSR A
	TAY		 ; Y = Player_UphillSpeedIdx >> 1

	LDA <Player_YVel
	BPL PRG008_AD2E	 ; If Player's Y vel >= 0, jump to PRG008_AD2E (RTS)

	CMP PRG008_AC22,Y
	BLS PRG008_AD2E	; If Player's uphill speed < Y velocity, jump to PRG008_AD2E

	LDA #$20
	STA <Player_YVel ; Player_YVel = $20

PRG008_AD2E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SwimV
;
; Controls the acts of swimming (the up/down part only), not
; including the Frog Suit style (which is totally different)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SwimV:
	LDA <Pad_Input		 
	BPL PRG008_AD4C	 ; If Player is NOT pressing 'A', jump to PRG008_AD4C

	; Player swimming sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	LDY <Player_InAir
	BNE PRG008_AD45	 ; If Player is swimming above ground, jump to PRG008_AD4A

	LDA #PLAYER_SWIMSTART_YVEL
	STA <Player_InAir ; "mid air" underwater
	BNE PRG008_AD4A	 ; Jump (technically always) to PRG008_AD4A

PRG008_AD45:

	; Swimming speed the rest of the time

	LDA <Player_YVel
	SUB #PLAYER_SWIM_YVEL	 ; A = Player_YVel - PLAYER_SWIM_YVEL

PRG008_AD4A:
	STA <Player_YVel ; Set Player_YVel appropriately

PRG008_AD4C:
	LDA <Player_InAir
	BEQ PRG008_AD7E	 ; If Player is on the ground, jump to PRG008_AD7E

	LDA <Player_YVel
	BMI PRG008_AD5A	 ; If Player's Y velocity is < 0 (moving upward), jump to PRG008_AD5A

	LDA <Counter_1
	AND #$02
	BNE PRG008_AD5C	 ; Every 4 ticks, jump to PRG008_AD5C

PRG008_AD5A:

	; Player's sink rate...

	INC <Player_YVel ; Player_YVel++

PRG008_AD5C:
	LDY #PLAYER_SWIM_YVEL	 ; Y = PLAYER_SWIM_YVEL

	LDA <Player_YVel
	BPL PRG008_AD75	 ; If Player's Y velocity is < 0 (moving upward), jump to PRG008_AD75

	LDY Player_AboveTop
	BPL PRG008_AD73	 ; If Player is not above top of screen, jump to PRG008_AD73

	LDY Player_SpriteY
	CPY #-8	 
	BGE PRG008_AD73	 ; If Player sprite is a bit high up, jump to PRG008_AD73

	ADD #$10
	STA <Player_YVel ; Player_YVel += $10

PRG008_AD73:
	LDY #PLAYER_SWIMSTART_YVEL	 ; Y = PLAYER_SWIMSTART_YVEL

PRG008_AD75:
	ADD #PLAYER_SWIM_YVEL
	CMP #PLAYER_MAXSPEED
	BLT PRG008_AD7E	 ; If result is less than Player's max speed, jump to PRG008_AD7E

	STY <Player_YVel ; Otherwise, update it

PRG008_AD7E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SwimAnim
;
; Animates Player for swimming
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SwimAnim:
	LDA <Player_InAir
	BEQ PRG008_ADBC	 ; If Player is NOT swimming above ground, jump to PRG008_ADBC (RTS)

	LDA <Pad_Input
	BPL PRG008_AD9A	 ; If Player is NOT pressing 'A', jump to PRG008_AD9A

	LDA Player_SwimCnt
	BNE PRG008_AD97	 ; If Player_SwimCnt <> 0, jump to PRG008_AD97

PRG008_AD8C:
	LDA #$00
	STA Player_SwimCnt	 ; Player_SwimCnt = 0
	STA Counter_ByPlayerSpd	 ; Counter_ByPlayerSpd = 0
	STA Player_WalkAnimTicks ; Player_WalkAnimTicks = 0

PRG008_AD97:
	INC Player_SwimCnt	 ; Player_WalkAnimTicks++

PRG008_AD9A:
	LDA Player_SwimCnt
	BNE PRG008_ADBD	 ; If Player_SwimCnt <> 0, jump to PRG008_ADBD

	LDA <Player_XVel
	BNE PRG008_ADAD	 ; If Player is moving left or right, jump to PRG008_ADAD

	; Player NOT moving left/right

	LDA <Counter_1
	AND #$30
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	STA <Player_WalkFrame	 ; Choose a "walk" (swim) relative frame based on game counter

PRG008_ADAD:
	LDY <Player_WalkFrame

	LDA <Player_Suit
	BNE PRG008_ADB7	 ; If Player is not small, jump to PRG008_ADB7

	INY
	INY
	INY
	INY	; Otherwise, use Player_WalkFrame + 4

PRG008_ADB7:
	LDA Player_SwimIdleFrames,Y	 ; Get appropriate swim frame
	STA <Player_Frame	 ; Set it!

PRG008_ADBC:
	RTS		 ; Return


PRG008_ADBD:
	LDA Counter_ByPlayerSpd
	CMP #$06
	BLT PRG008_ADCB	 ; If Counter_ByPlayerSpd < 6, jump to PRG008_ADCB

	DEC Player_SwimCnt	; Player_SwimCnt--
	BNE PRG008_AD8C	 	; If Player_SwimCnt > 0, jump to PRG008_AD8C

	LDA #$05	 ; A = 5

PRG008_ADCB:
	LDY <Player_Suit ; Y = Player_Suit
	BNE PRG008_ADD2	 ; If Player is not small, jump to PRG008_ADD2

	ADD #$06	 ; For small, A = 11

PRG008_ADD2:
	TAY		 ; Y = 5 or 11

	; Set Player swimming frame
	LDA Player_SwimActiveFrames,Y
	STA <Player_Frame

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_CommonGroundAnims
;
; Performs "common" animations for walking around on the ground
; (walking/standing, ducking, sliding) and, for some reason, also
; contains the debug mode power-up cycle logic (SELECT to cycle
; through all available power-ups and toggle Kuribo's shoe)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_CommonGroundAnims:

	; Get absolute value of Player_XVel
	LDA <Player_XVel
	BPL PRG008_ADE0
	JSR Negate
PRG008_ADE0:

	LSR A
	LSR A
	LSR A
	TAY		 ; Y = Absolute value of Player's X Velocity shifted right by 3 (1 bit left of "whole" part)

	INC Player_WalkAnimTicks
	LDA Player_WalkAnimTicks
	CMP Player_WalkAnimTickMax,Y
	BMI PRG008_AE03	 ; If we haven't reached the rollover point in the walking animation ticks, jump to PRG008_AE03

	LDA #$00
	STA Player_WalkAnimTicks ; Player_WalkAnimTicks = 0

	INC <Player_WalkFrame	 ; Next Player frame
	INC Counter_ByPlayerSpd	 ; Increment Player-speed-based counter

	; Cap Player_WalkFrame at 0-3 (why not just AND it?)
	LDA <Player_WalkFrame
	CMP #$04
	BMI PRG008_AE03

	LDA #$00
	STA <Player_WalkFrame

PRG008_AE03:

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BNE PRG008_AE11	 ; If Player is pressing left or right, jump to PRG008_AE11

	; Player NOT pressing left/right

	LDA <Player_XVel
	BNE PRG008_AE11	 ; If Player_XVel <> 0, jump to PRG008_AE11

	LDA #$02
	STA <Player_WalkFrame	 ; Otherwise, force Player_WalkFrame to 2 (standing still)

PRG008_AE11:
	LDA Player_TailAttack
	BNE PRG008_AE26	 ; If Player is performing tail attack, jump to PRG008_AE26

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ PRG008_AE26	 ; If Player is NOT pressing left or right, jump to PRG008_AE26

	; Player is pressing left/right

	LDY #$00	; No flip

	AND #%00000010
	BNE PRG008_AE24	 ; If Player is pressing left, jump to PRG008_AE24

	LDY #SPR_HFLIP	; Horizontal flip

PRG008_AE24:
	STY <Player_FlipBits	; Set appropriate flip

PRG008_AE26:
	LDA Debug_Flag
	CMP #$80
	BNE PRG008_AE58	 ; If we're not in debug mode, jump to PRG008_AE58

	; DEBUG SUIT/POWER-UP SWITCH AND KURIBO TOGGLE

	LDA <Pad_Input
	AND #PAD_SELECT
	BEQ PRG008_AE58	 ; If Player is NOT pressing select, jump to PRG008_AE58

	LDA <Pad_Holding
	AND #(PAD_A | PAD_B)
	BNE PRG008_AE50	 ; If Player is holding A or B, jump to PRG008_AE50


	; In short, cycle through power-up 0-6 (all power ups)
	LDA <Player_Suit
	ADD #$01
	STA Player_QueueSuit
	CMP #(PLAYERSUIT_LAST+1)	; +1 because it's by Player_QueueSuit
	BLS PRG008_AE47			; If not the last suit, jump to PRG008_AE47
	LDA #$00
PRG008_AE47:
	STA Player_QueueSuit
	INC Player_QueueSuit
	JMP PRG008_AE58	 ; Jump to PRG008_AE58

PRG008_AE50:

	; Kuribo's shoe toggle!
	LDA Player_Kuribo
	EOR #$01
	STA Player_Kuribo

PRG008_AE58:
	LDA <Player_Suit
	ASL A
	ASL A
	ORA <Player_WalkFrame	 ; Take the walk frame and push the current power-up to bit 2
	TAY		 ; -> Y
	LDA Player_WalkFramesByPUp,Y	 ; Get appropriate sprite frame
	STA <Player_Frame		 ; -> Player_Frame

	LDA Player_InWater
	BNE PRG008_AE90	 ; If Player is in water, jump to PRG008_AE90

	; Player not in water...

	LDA <Player_XVel
	ADD #$01
	CMP #$03
	BLT PRG008_AE90	 ; If (Player_XVel + 1) < 3, jump to PRG008_AE90

	LDA Player_MoveLR
	AND <Pad_Holding
	BEQ PRG008_AE90	 ; If Player is pressing the opposite direction from his movement, jump to PRG008_AE90

	LDY <Player_Suit
	BEQ PRG008_AE7F	 ; If Player is small, jump to PRG008_AE7F

	LDY #$01	 ; Otherwise, Y = 1

PRG008_AE7F:
	LDA <Player_InAir
	BNE PRG008_AE90	 ; If Player is mid air, jump to PRG008_AE90

	; Play "skid" sound
	LDA Sound_QLevel2
	ORA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA Player_SkidFrame,Y
	STA <Player_Frame ; Set skid frame

PRG008_AE90:
	LDA Player_IsDucking
	BEQ PRG008_AEA2	 ; If Player is not ducking

	LDY <Player_Suit
	LDA PowerUp_Ability,Y	; Get "ability" bits for suit
	AND #$01	 	; Bit 0 specifies that the power up can do raccoon style flying and fluttering
	TAY		 
	LDA Player_DuckFrame,Y	; Get appropriate duck frame
	STA <Player_Frame	; Set frame!

PRG008_AEA2:
	LDA Player_Slide
	BEQ PRG008_AEC0	 ; If Player is not sliding, jump to PRG008_AEC0

	; Player is sliding...

	LDA <Player_InAir
	BNE PRG008_AEB1	 ; If Player is mid air, jump to PRG008_AEB1

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP)
	BEQ PRG008_AEB6	 ; If Player is not holding LEFT, RIGHT, or UP, jump to PRG008_AEB6

PRG008_AEB1:

	; Otherwise, cancel the sliding
	; Aside: Did you know pressing UP would stop you from sliding in Mario 3?  I didn't :P

	LDA #$00
	STA Player_Slide ; Player_Slide = 0 (stop sliding)

PRG008_AEB6:
	LDA #PF_SLIDE_BIG	 ; Frame for anything besides small
	LDY <Player_Suit
	BNE PRG008_AEBE	 ; If Player is not small, jump to PRG008_AEBE

	LDA #PF_SLIDE_SMALL	 ; Frame for small

PRG008_AEBE:
	STA <Player_Frame ; Set appropriate Player frame

PRG008_AEC0:
	RTS		 ; Return

TwisterSpin_FlipBits:	.byte $00, $40

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SetSpecialFrames
;
; Set one of the "special" frames, i.e. "spread eagle" running,
; somersaulting, holding, pipe facing, kicking, twirling, and
; even the forced-to-standing frame of "vibrationally disabled"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SetSpecialFrames:

	; Get absolute value of Player_XVel
	LDA <Player_XVel
	BPL PRG008_AECA
	JSR Negate
PRG008_AECA:

	CMP #$37
	BLT PRG008_AEF0	 ; If magnitude of Player's horizontal velocity is < $37, jump to PRG008_AEF0

	LDA Player_FlyTime
	BNE PRG008_AEF0	 ; If Player already has flight time, jump to PRG008_AEF0

	LDA Player_IsDucking
	ORA Player_Kuribo
	ORA Player_IsClimbing
	ORA Player_Slide
	BNE PRG008_AEF0	 ; If Player is ducking, in a Kuribo's shoe, climbing a vine, or sliding, jump to PRG008_AEF0!!

	LDY <Player_WalkFrame	; Y = Player_WalkFrame (0 - 3)

	LDA <Player_Suit
	BNE PRG008_AEEB	 ; If Player is NOT small, jump to PRG008_AEEB

	INY
	INY
	INY
	INY		 ; Otherwise, Y += 4

PRG008_AEEB:
	LDA Player_SpreadEagleFrames,Y	 ; Get cooresponding spread-eagle frame
	STA <Player_Frame		 ; Store that!

PRG008_AEF0:
	LDA Player_Flip
	BEQ PRG008_AF0F	 ; If Player is NOT somersaulting, jump to PRG008_AF0F

	LDA <Counter_1
	LSR A		; A = Counter_1 >> 1
	PHA		 ; Save it

	AND #$07	 ; Cap 0 - 7
	TAY		 ; -> 'Y'

	LDA Player_SomersaultFlipBits,Y	 ; Get proper somersault flip bits

	LDY <Player_XVel
	BPL PRG008_AF05	 ; If Player_XVel >= 0, jump to PRG008_AF05

	EOR #SPR_HFLIP	 ; Otherwise, horizontally flip!

PRG008_AF05:
	STA <Player_FlipBits		 ; Update Player flip bits
	PLA		 ; Restore Counter_1 >> 1

	AND #$03	 ; Cap 0 - 3
	ADD #PF_SOMERSAULT_BASE	 ; Add base somersault frame
	STA <Player_Frame ; Update Player_Frame!

PRG008_AF0F:
	LDA Player_IsHolding
	BEQ PRG008_AF2F	 ; If Player is NOT holding something, jump to PRG008_AF2F

	LDY <Player_WalkFrame	 ; Y = PRG008_AF2F

	LDA Player_InAir_OLD
	BEQ PRG008_AF22	 ; If Player was NOT in air, jump to PRG008_AF22

	LDY #$00	; Otherwise, Y = 0

	LDA <Player_Suit
	BNE PRG008_AF22	
	INY		 ; ... unless small, in which case, Y = 1

PRG008_AF22:
	LDA <Player_Suit
	BNE PRG008_AF2A	 ; If Player is NOT small, jump to PRG008_AF2A

	INY
	INY
	INY
	INY		 ; Otherwise, Y += 4

PRG008_AF2A:
	LDA Player_HoldingFrames,Y ; Get appropriate "holding" frame
	STA <Player_Frame	 ; Update Player frame!

PRG008_AF2F:
	LDA Player_PipeFace
	BNE PRG008_AF45	 ; If Player is facing forward, jump to PRG008_AF45

	LDA Player_IsHolding
	BEQ PRG008_AF52	 ; If Player is NOT holding something, jump to PRG008_AF52

	LDA <Player_FlipBits
	CMP Player_FlipBits_OLD
	BEQ PRG008_AF52	 ; If Player's flip bits haven't changed, jump to PRG008_AF52

	LDA #$07
	STA Player_PipeFace ; Otherwise, Player_PipeFace = 7 (Player briefly faces forward while turning around holding something)

PRG008_AF45:
	DEC Player_PipeFace	 ; Player_PipeFace--

	LDA #PF_INPIPE_BIG	; Face-forward frame when Player is NOT small

	LDY <Player_Suit
	BNE PRG008_AF50	 ; If Player is NOT small, jump to PRG008_AF50

	LDA #PF_INPIPE_SMALL	 ; Face-forward frame when Player is small

PRG008_AF50:
	STA <Player_Frame ; Update Player frame !

PRG008_AF52:
	LDA Player_Kick
	BEQ PRG008_AF69	 ; If Player is NOT kicking something, jump to PRG008_AF69

	LDA #$00
	STA Player_TailAttack	 ; Player_TailAttack = 0 (stop tail attack effect if active!)

	LDY #PF_KICK_SMALL	 ; Kick frame when small

	LDA <Player_Suit
	BEQ PRG008_AF64	 ; If Player is small, jump to PRG008_AF64

	LDY #PF_KICK_BIG	 ; Kick frame when NOT small

PRG008_AF64:
	STY <Player_Frame ; Update Player frame!

	DEC Player_Kick	 ; PRG008_AF64--

PRG008_AF69:
	LDA Player_TwisterSpin
	BEQ PRG008_AFA1	 ; If Player is NOT twirling, jump to PRG008_AFA1

	DEC Player_TwisterSpin	 ; Player_TwisterSpin--

	LDY #$00	; Y = 0 (base index for small or frog)

	LDA <Player_Suit
	BEQ PRG008_AF87	 ; If Player is small, jump to PRG008_AF87

	CMP #$04
	BEQ PRG008_AF85	 ; If Player is Frog, jump to PRG008_AF85

	LDY #$04	 ; Y = 4 (base index all suits that can slide on slopes)

	TAX		 ; Power up -> 'X'

	LDA PowerUp_Ability,X
	AND #$01	 
	BEQ PRG008_AF87	 ; If able to slide on slopes, jump to PRG008_AF87

PRG008_AF85:
	LDY #$08	 ; Y = 8 (base value otherwise)

PRG008_AF87:
	STY <Temp_Var1	 ; Temp_Var1 = 0, 4, or 8

	LDA <Counter_1
	AND #$0c	 ; Cap value 0 - 11
	LSR A		 
	LSR A		 ; >> 2 (0 - 3)
	PHA		 ; Save it

	LSR A		 ; Shift down one more time
	TAY		 ; -> 'Y'
	LDA TwisterSpin_FlipBits,Y ; Get appropriate flip bits
	STA <Player_FlipBits	  ; ... and set them!

	PLA		 ; Restore (0 - 2)

	ADD <Temp_Var1	 ; Add base index
	TAY		 ; -> 'Y'

	LDA Player_TwisterSpinFrames,Y	 ; Get appropriate spin frame
	STA <Player_Frame		 ; Update Player frame!

PRG008_AFA1:
	LDA Player_VibeDisable
	BEQ PRG008_AFAD	 ; If Player is not "vibrationally disabled", jump to PRG008_AFAD

	LDY <Player_Suit
	LDA Player_VibeDisableFrame,Y	 ; Get appropriate "vibrationally disabled" frame (typ. standing)
	STA <Player_Frame	; Update Player frame!

PRG008_AFAD:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_TanookiStatue
;
; Change into or maintain Tanooki statue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_TanookiStatue:
	LDA <Pad_Holding		 
	AND #PAD_DOWN
	TAY
	BEQ PRG008_AFE3	 ; If Player is NOT pressing down, jump to PRG008_AFE3

	BIT <Pad_Input
	BVC PRG008_AFE3	 ; If Player is NOT pressing 'B', jump to PRG008_AFE3

	LDA Player_Statue
	BNE PRG008_AFE3	 ; If Player is transformed into a statue, jump to PRG008_AFE3

	JSR Sound_StatueSwitch	 ; Play statue transformation sound

	LDA #$20
	STA Player_QueueSuit	 ; Player_QueueSuit = $20

	; Not really "suit lost", but same poof effect
	LDA #$17
	STA Player_SuitLost	 ; Player_SuitLost = $17
	BNE PRG008_B010	 	; Jump (technically always), jump to PRG008_B010

PRG008_AFCD:
	LDA #PF_STATUE
	STA <Player_Frame 	; Statue frame

	LDA #$00
	STA <Player_XVel	; Halt horizontal movement

	LDA <Player_InAir
	BEQ PRG008_AFE0	 	; If Player is not mid air, jump to PRG008_AFE0

	; Fall fast as statue
	LDA <Player_YVel
	ADD #$07
	STA <Player_YVel

PRG008_AFE0:

	; Pull return address, i.e. don't do other things normal to Tanooki suit
	PLA
	PLA

	RTS		 ; Return

PRG008_AFE3:
	LDA Player_Statue
	BEQ PRG008_B010	 ; If Player is not a statue, jump to PRG008_B010 (RTS)

	CMP #$01
	BEQ PRG008_AFFB	 ; If Tanooki statue is about to run out, jump to PRG008_AFFB

	CMP #$60
	BNE PRG008_AFF5	 ; If Player_Statue <> $60, jump to PRG008_AFF5

	; Player_FlashInv = $60 (flashing with remainder of statue)
	LDA #$60
	STA Player_FlashInv

PRG008_AFF5:
	DEC Player_Statue ; Player_Statue--

	TYA
	BNE PRG008_AFCD	 ; If Player is pressing DOWN, jump to PRG008_AFCD

PRG008_AFFB:

	; Clear Player_Statue / Player_FlashInv
	LDA #$00
	STA Player_Statue
	STA Player_FlashInv

	JSR Level_SetPlayerPUpPal	; Set power up's correct palette
	JSR Sound_StatueSwitch	 	; Play statue change sound

	; Poof like Player lost the suit
	LDA #$17
	STA Player_SuitLost

	BNE PRG008_AFCD	 ; Jump (technically always) to PRG008_AFCD

PRG008_B010:
	RTS		 ; Return


Sound_StatueSwitch:
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1
	RTS		 ; Return


	; Player's climb "animation", which is really just flipping the sprite
Player_DoClimbAnim:
	LDA Player_IsClimbing
	BEQ PRG008_B035	 ; If Player is NOT climbing, jump to PRG008_B035 (RTS)

	LDY <Player_Suit
	LDA Player_ClimbFrame,Y	 ; Get appropriate climbing frame
	STA <Player_Frame	 ; Store into Player_Frame

	LDA <Pad_Holding
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG008_B035	 ; If Player is NOT pressing UP or DOWN, jump to PRG008_B035

	; Every 8 ticks, flip Player horizontally
	LDA <Counter_1
	AND #$08
	ASL A	
	ASL A	
	ASL A	
	STA <Player_FlipBits

PRG008_B035:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_AnimTailWag
;
; Animates the Player's tail wag for flying and fluttering
; Also plays the "wag" sound as appropriate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_AnimTailWag:
	LDA Player_SandSink
	LSR A
	BCS PRG008_B09F	 ; If bit 0 of Player_SandSink is set, jump to PRG008_B09F (RTS)

	LDA Player_AllowAirJump
	BNE PRG008_B09F	 ; If Player_AllowAirJump, jump to PRG008_B09F (RTS)

	LDA <Player_InAir
	BEQ PRG008_B09F	 ; If Player is NOT mid air, jump to PRG008_B09F (RTS)

	LDA Player_IsDucking
	BNE PRG008_B082	 ; If Player is ducking, jump to PRG008_B082

	LDA <Pad_Input
	BPL PRG008_B062	 ; If Player is NOT pressing A, jump to PRG008_B062


	; The following replaces what would be a queued jump sound with the "wag" sound
	LDA Sound_QPlayer
	CMP #SND_PLAYERJUMP
	BEQ PRG008_B05D	 ; If jump sound is NOT queued, jump to PRG008_B05D

	; Plays the tail wag sound
	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

PRG008_B05D:
	LDA #10
	STA Player_TailCount	 ; Player_TailCount = $10

PRG008_B062:
	LDA Player_TailCount
	LSR A
	LSR A
	STA <Temp_Var1	 ; Temp_Var1 = Player_TailCount >> 2

	LDA #$00	; A = 0 (flying!)

	LDY Player_FlyTime
	BNE PRG008_B072	 ; If flying, jump to PRG008_B072

	LDA #$06	 ; A = 6 (fluttering/falling)

PRG008_B072:
	LDY <Player_YVel
	BMI PRG008_B079	 ; If Player Y velocity < 0, jump to PRG008_B079

	ADD #$03	 ; Otherwise, add 3 (apex, when just running out of power, flying steady)

PRG008_B079:
	ADD <Temp_Var1	 ; Add specific frame offset
	TAY		 ; A -> Y
	LDA Player_TailWagFlyFrames,Y	 ; Get correct frame
	STA <Player_Frame ; And set it!

PRG008_B082:
	LDA Player_FlyTime
	ORA Player_WagCount
	BEQ PRG008_B09F	 ; If flying or fluttering, jump to PRG008_B09F (RTS)

	LDY #-1		 ; Y = -1
	LDA <Player_XVel
	BPL PRG008_B095	 ; If Player_XVel >= 0, jump to PRG008_B095

	LDY #1		 ; Y = 1
	JSR Negate	 ; Negate Player_XVel (get absolute value)

PRG008_B095:

	; Y = -1 and Player_XVel >= 0
	;    OR
	; Y = 1 and Player_XVel < 0
	;    (but magnitude is in 'A' either way)

	CMP #PLAYER_TOPWALKSPEED	
	BLS PRG008_B09F	 ; If X Velocity magnitude is < PLAYER_TOPWALKSPEED, jump to PRG008_B09F (RTS)

	; Otherwise add 'Y', which gives a slow acceleration up to that speed when in air as raccoon
	TYA
	ADD <Player_XVel
	STA <Player_XVel

PRG008_B09F:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_SoarJumpFallFrame
;
; Sets Player's frame appropriate for "soaring" (high speed jump),
; standard jumping, or falling...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_SoarJumpFallFrame:
	LDA Player_SandSink
	LSR A
	BCS PRG008_B0C5	 ; If bit 0 of Player_SandSink is set, jump to PRG008_B0C5

	LDA Player_AllowAirJump
	BNE PRG008_B0C5	 ; If Player_AllowAirJump, jump to PRG008_B0C5 (RTS)

	LDA <Player_InAir
	BEQ PRG008_B0C5	 ; If Player is mid air, jump to PRG008_B0C5 (RTS)

	LDA Player_IsDucking
	BNE PRG008_B0C5	 ; If Player is ducking, jump to PRG008_B0C5 (RTS)

	LDA #PF_FASTJUMPBIG	 ; High speed "soar" jump frame

	LDY Player_FlyTime
	BNE PRG008_B0C3	 ; If Player has jumped at high speed, jump to PRG008_B0C3

	LDA #PF_JUMPBIG	 ; Normal "fist pump" jump frame

	LDY <Player_YVel
	BMI PRG008_B0C3	 ; If Player is moving upward, jump to PRG008_B0C3

	LDA #PF_FALLBIG	 ; Standard "fall" frame

PRG008_B0C3:
	STA <Player_Frame ; Set appropriate frame

PRG008_B0C5:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_TailAttackAnim
;
; Animate tail attack
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_TailAttackAnim:
	LDA <Pad_Holding
	AND #PAD_DOWN
	BNE PRG008_B109	 ; If Player is holding down, jump to PRG008_B109

	BIT <Pad_Input
	BVC PRG008_B0E2	 ; If Player is NOT pressing 'B', jump to PRG008_B0E2

	LDA Player_TailAttack
	BNE PRG008_B0E2	 ; If Player is performing tail attack, jump to PRG008_B0E2

	LDA #$12
	STA Player_TailAttack	 ; Player_TailAttack = $12

	; Plays the tail wag sound
	LDA Sound_QLevel1
	ORA #SND_LEVELTAILWAG
	STA Sound_QLevel1

PRG008_B0E2:
	LDA Player_TailAttack
	BEQ PRG008_B109	 ; If Player is not performing tail attack, jump to PRG008_B109

	LSR A
	LSR A
	TAY		 ; Y = Player_TailAttack >> 2

	LDA <Player_InAir
	BEQ PRG008_B0F3	 ; If Player is NOT in mid air, jump to PRG008_B0F3

	INY
	INY
	INY
	INY
	INY		 ; Y += 5 (use mid air tail attack frames)

PRG008_B0F3:
	LDA Player_TailAttackFrames,Y	 ; Get appropriate tail attack frame
	STA <Player_Frame		 ; Store it


	; Flips player at particular times

	LDA Player_TailAttack
	CMP #$0b
	BEQ PRG008_B103

	CMP #$03
	BNE PRG008_B109

PRG008_B103:
	LDA <Player_FlipBits
	EOR #SPR_HFLIP
	STA <Player_FlipBits

PRG008_B109:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ShootAnim
;
; Animate shooting a fireball / hammer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ShootAnim:
	LDA Player_FireCount
	BEQ PRG008_B11E	 ; If Player has not just shot something, jump to PRG008_B11E

	LSR A
	LSR A		; A = Player_FireCount >> 2

	LDY <Player_InAir
	BEQ PRG008_B118	 ; If Player is mid air, jump to PRG008_B118

	ADD #(Player_FireInAir - Player_FireOnGround)	 ; Otherwise, offset to "on ground" frames

PRG008_B118:
	TAY		 ; A -> Y
	LDA Player_FireOnGround,Y ; Get appropriate frame
	STA <Player_Frame	 ; Set it!

PRG008_B11E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoScrolling
;
; Scrolls screen horizontally and vertically (including Raster
; Effects) as appropriate for Player's position
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DoScrolling:
	LDA Level_7Vertical
	BEQ PRG008_B127	 ; If Level is not vertical, jump to PRG008_B127

	JMP PRG008_B2AB	 ; Otherwise, jump to PRG008_B2AB

PRG008_B127:
	LDA LevelJctBQ_Flag
	BEQ PRG008_B12F	 ; If we're NOT in a Big Question Block area, jump to PRG008_B12F

	JMP PRG008_B1CE	 ; Otherwise, jump to PRG008_B1CE

PRG008_B12F:
	LDY Level_AScrlConfig
	BEQ PRG008_B150	 ; If no raster effects, jump to PRG008_B150
	BMI PRG008_B150	 ; If ASCONFIG_HDISABLE is set, jump to PRG008_B150

	; Sets horizontal scroll to auto scroll alternate values

	LDA Level_AScrlPosH
	PHA		 ; Save Level_AScrlPosH

	SUB <Horz_Scroll
	STA Level_ScrollDiffH	 ; Difference between horizontal scroll and Level_AScrlPosH

	PLA		 ; Restore Level_AScrlPosH
	STA <Horz_Scroll ; Set as new horizontal scroll

	LDA Level_AScrlPosHHi
	STA <Horz_Scroll_Hi	 ; Set proper "high" position for raster

	LDA Level_AScrlSclLastDir
	STA <Scroll_LastDir	 ; Set "Scroll_LastDir" as appropriate for raster

	JMP PRG008_B208		; Jump to PRG008_B208

PRG008_B150:

	; No raster effects or horizontal auto scroll not desired

	LDA <Player_X
	SUB <Horz_Scroll
	BPL PRG008_B195	 ; If Player_X >= Horz_Scroll, jump to PRG008_B195

	LDA <Horz_Scroll_Hi
	STA <Temp_Var1		; Temp_Var1 = Horz_Scroll_Hi

	LDA #$80
	ADD <Horz_Scroll
	STA <Temp_Var2	 ; Temp_Var2 = $80 + Horz_Scroll
	BCC PRG008_B166	 ; If no carry, jump to PRG008_B166

	INC <Temp_Var1	 ; Apply carry

PRG008_B166:
	LDA <Player_XHi
	CMP <Temp_Var1
	BLS PRG008_B1CE	 ; If Player_XHi < Temp_Var1 (Horizontal scroll as appropriate when adding $80), jump to PRG008_B1CE

	LDA <Player_X
	SUB <Temp_Var2
	BEQ PRG008_B1CE	 ; If Player_X = Temp_Var2 ($80 + Horz_SCroll), jump to PRG008_B1CE
	BMI PRG008_B1CE	 ; If Player_X < Temp_Var2 ($80 + Horz_SCroll), jump to PRG008_B1CE

	STA Level_ScrollDiffH	 ; Result stored into Level_ScrollDiffH

	ADD <Horz_Scroll
	STA <Horz_Scroll	 ; Horz_Scroll += Level_ScrollDiffH
	BCC PRG008_B181	 	; If no carry, jump to PRG008_B181
	INC <Horz_Scroll_Hi	 ; Otherwise, apply carry

PRG008_B181:
	LDA #$00	 
	STA <Scroll_LastDir	 ; Scroll_LastDir = 0 (screen last moved right)

	LDA <Horz_Scroll_Hi
	CMP <Level_Width
	BLS PRG008_B1CE	 	; If Horz_Scroll_Hi < Level_Width, jump to PRG008_B1CE

	; Otherwise...
	LDA #$00
	STA <Horz_Scroll	 ; Horz_Scroll = 0
	STA Level_ScrollDiffH	 ; Level_ScrollDiffH = 0
	JMP PRG008_B1CE	 	; Jump to PRG008_B1CE

PRG008_B195:
	LDA <Horz_Scroll_Hi
	STA <Temp_Var1		; Temp_Var1 = Horz_Scroll_Hi

	LDA #$70
	ADD <Horz_Scroll
	STA <Temp_Var2		; Temp_Var2 = $70 + Horz_Scroll
	BCC PRG008_B1A4	 	; If no carry, jump to PRG008_B1A4
	INC <Temp_Var1		 ; Otherwise, apply carry

PRG008_B1A4:
	LDA <Temp_Var1
	CMP <Player_XHi
	BLS PRG008_B1CE	 	; If Temp_Var1 < Player_XHi, jump to PRG008_B1CE

	LDA <Player_X
	SUB <Temp_Var2
	BPL PRG008_B1CE	 	; If Player_X >= Temp_Var2, jump to PRG008_B1CE

	STA Level_ScrollDiffH	; Store difference into Level_ScrollDiffH

	ADD <Horz_Scroll
	STA <Horz_Scroll	; Horz_Scroll += Level_ScrollDiffH
	BCS PRG008_B1BD	 	; If carry set, jump to PRG008_B1BD
	DEC <Horz_Scroll_Hi	; Otherwise, remove carry

PRG008_B1BD:
	LDA #$01
	STA <Scroll_LastDir	; Scroll_LastDir = 1 (last moved left)

	LDA <Horz_Scroll_Hi
	BPL PRG008_B1CE	 	; If Horz_Scroll_Hi >= 0, jump to PRG008_B1CE

	; Clear a bunch
	LDA #$00	 
	STA <Horz_Scroll_Hi
	STA <Horz_Scroll
	STA Level_ScrollDiffH

PRG008_B1CE:
	LDA <Player_SpriteX

	LDY <Player_XVel
	BMI PRG008_B1DD	 ; If Player X velocity < 0 (moving leftward), jump to PRG008_B1DD

	; Player moving rightward...

	CMP #232
	BLT PRG008_B208	 ; If Player_SpriteX < 232, jump to PRG008_B1DD

	LDA #232	; Cap max at 232
	JMP PRG008_B1E3	 ; Jump to PRG008_B1E3

PRG008_B1DD:
	CMP #17
	BGE PRG008_B208	 ; If Player_SpriteX >= 17, jump to PRG008_B208
	LDA #16	 	; Cap min at 16

PRG008_B1E3:
	STA <Player_SpriteX ; Update Player_SpriteX

	LDY #$00	 ; Y = 0 (offset of Player_XHi)

	SUB <Player_X
	BPL PRG008_B1EE	 ; If Player_SpriteX >= Player_X, jump to PRG008_B1EE

	LDY #$ff	 ; Y = $FF (offset of Player_XHi, sign extended high part of negative)

PRG008_B1EE:
	ADD <Player_X	 
	STA <Player_X	 ; Player_X += difference between this and Player_SpriteX
	BCC PRG008_B1F6	 ; If no carry, jump to PRG008_B1F6

	INY		 ; Otherwise, apply carry

PRG008_B1F6:
	TYA		 ; A = Y ("high" part offset)
	ADD <Player_XHi	 ; Apply high adjustment
	STA <Player_XHi	 ; And store it!

	LDA <Player_XVel
	PHP		 ; Save processor status

	AND #%00001111	 ; Just take lower 4 bits (the "fractional" part)

	PLP		 ; Restore processor status

	BPL PRG008_B206	 ; If Player_XVel >= 0, jump to PRG008_B206

	ORA #$F0	 ; Otherwise, provide negative sign extention for fractional part

PRG008_B206:
	STA <Player_XVel ; Revise Player_XVel with only signed fractional part!

PRG008_B208:
	LDA Level_FreeVertScroll
	BEQ PRG008_B214	 ; If Level_FreeVertScroll = 0 (not freely scrolling), jump to PRG008_B214

	CMP #$01
	BEQ PRG008_B258	 ; If Level_FreeVertScroll = 1 (freely scrolling), jump to PRG008_B258

	; Otherwise, arbitrarily locked (whatever Vert_Scroll is)...
	JMP PRG008_B2A0	 ; Jump to PRG008_B2A0

PRG008_B214:

	; Not freely vertical scrolling (which persists as "NEVER" if 
	; Auto Scroll is active, but otherwise MAY be overridden)

	LDA Level_AScrlConfig
	BEQ PRG008_B246	 ; If auto scroll effect active, jump to PRG008_B246

	; Calculates Player Y based on auto scroll position
AutoScroll_CalcPlayerY:
	LDA Level_AScrlPosV
	PHA		 ; Save "Level_AScrlPosV"

	SUB <Vert_Scroll
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = difference of current scroll position from Level_AScrlPosV

	PLA		 	; Restore "Level_AScrlPosV"
	STA <Vert_Scroll 	; Becomes the new Vert_Scroll
	STA Level_VertScroll	; Becomes the new Level_VertScroll

	LDA <Player_InAir
	BEQ PRG008_B245	 ; If Player is not mid-air, jump to PRG008_B245 (RTS)

	LDA Player_IsClimbing
	ORA AScrlURDiag_WrapState_Copy
	BNE PRG008_B245	 ; If Player is climbing or diagonal autoscroller is wrapping, jump to PRG008_B245

	LDA Level_ScrollDiffV
	BPL PRG008_B23C	 ; If Level_ScrollDiffV >= 0, jump to PRG008_B23C

	DEC <Player_YHi	; Player_YHi--

PRG008_B23C:
	ADD <Player_Y
	STA <Player_Y	 ; Player_Y = Level_ScrollDiffV + Player_Y

	BCC PRG008_B245	 ; If no carry, jump to PRG008_B245

	INC <Player_YHi	 ; Otherwise, carry into Player_YHi

PRG008_B245:
	RTS		 ; Return


PRG008_B246:

	; VERTICAL SCROLL LOCK LOGIC

	; Checking whether vertical scrolling should be allowed in levels that explicitly disable it.
	; When set to not allow it by default, so long as no raster effects are going on (see above),
	; then we may allow it if the Player is flying (or high speed jumping) or climbing a vine.

	; Once the scroll point has reached Vert_Scroll = $EF (lowest scroll point) it stays there
	; unless one of the above specified overrides occur.  And here we go...

	LDA <Vert_Scroll
	CMP #$ef
	BNE PRG008_B258	 ; If Vert_Scroll <> $EF (lowest scroll point), jump to PRG008_B258 (allow free while Vert_Scroll < $EF)

	LDA Player_FlyTime
	ORA Player_IsClimbing
	PHP		 ; Save processor status

	LDA #$ef	 ; A = $EF (locked vertical scroll value)

	PLP		 ; Restore processor status

	; Optional free vertical scroll override...

	BEQ PRG008_B2A2	 ; If Player is not flying or climbing, jump to PRG008_B2A2

PRG008_B258:

	; Free vertical scrolling allowed

	LDA <Player_Y
	SUB Level_VertScroll
	STA <Temp_Var1		; Temp_Var1 = Player_Y - Level_VertScroll (difference between Player_Y and vertical scroll)

	LDA <Player_YHi
	SBC Level_VertScrollH
	BMI PRG008_B272	 ; If (Player_YHi - Level_VertScrollH) < 0, jump to PRG008_B272

	LDA <Temp_Var1
	SUB #$30
	BCS PRG008_B284	 ; If there was no borrow, jump to PRG008_B284

	; Minimum vertical scroll delta is -3
	CMP #-3
	BGE PRG008_B274	 ; If difference is -3 or above, jump to PRG008_B274

PRG008_B272:
	LDA #-3	 	; Otherwise, enforce -3 minimum

PRG008_B274:
	STA Level_ScrollDiffV ; Store as vertical difference

	ADD <Vert_Scroll   ; Add Vert_Scroll 
	BCS PRG008_B281	   ; If carry occurred, jump to PRG008_B281

	LDA #$00
	STA Level_ScrollDiffV	; Level_ScrollDiffV = 0

PRG008_B281:
	JMP PRG008_B29E	 ; Jump to PRG008_B29E

PRG008_B284:
	LDA <Temp_Var1
	SUB #$58
	BCC PRG008_B2A0	 ; If borrow occurred, jump to PRG008_B2A0

	STA Level_ScrollDiffV	; Store as vertical difference

	ADD <Vert_Scroll
	BCS PRG008_B297	 ; If carry occurred, jump to PRG008_B297

	CMP #$ef
	BLT PRG008_B29E	 ; If calculated value is less than $EF, we're not at the bottom yet, and so jump to PRG008_B29E

PRG008_B297:
	LDA #$00
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = 0

	LDA #$ef	 ; Bottom scroll position is $EF

PRG008_B29E:
	STA <Vert_Scroll	 ; Update Vert_Scroll

PRG008_B2A0:
	LDA <Vert_Scroll	

PRG008_B2A2:

	; Entry point if free vertical scrolling is disabled and Player did not override it

	STA Level_VertScroll	 ; Set Level_VertScroll

	LDA #$00
	STA Level_VertScrollH	 ; Level_VertScroll = 0

	RTS		 ; Return

PRG008_B2AB:
	; Vertical style for Player_DoScrolling

	LDA #$00	 
	STA <Player_XHi	 ; Player_XHi = 0 (never used in vertical mode)

	LDY <Level_Width ; Y = Level_Width ("height" actually, in this context)

	; Get address starting this screen -> Temp_Var1/2
	LDA VertLevel_ScreenH,Y
	STA <Temp_Var1		
	LDA VertLevel_ScreenL,Y	
	STA <Temp_Var2

	LDA <Player_Y
	SUB Level_VertScroll
	TAY		 ; Y = Player_Y - Level_VertScroll

	LDA <Player_YHi
	SBC Level_VertScrollH
	BNE PRG008_B345	 ; If Player_YHi <> Level_VertScrollH, jump to PRG008_B345 (RTS)

	TYA		 ; A = Player_Y - Level_VertScroll
	SUB #$30
	BCS PRG008_B2F9	 ; If no borrow occurred, jump to PRG008_B2F9

	; Minimum vertical scroll delta value is -3
	DEC Level_VertScrollH
	CMP #-3
	BGE PRG008_B2D8

	LDA #-3

PRG008_B2D8:
	STA Level_ScrollDiffV	 ; Set difference

	ADD Level_VertScroll
	STA Level_VertScroll	 ; Level_VertScroll += Level_ScrollDiffV

	LDA #$00
	STA <Scroll_LastDir	 ; Scroll_LastDir = 0 (last scrolled up)

	ADC Level_VertScrollH	; Apply carry, if any
	BPL PRG008_B2F3	 	; If Level_VertScrollH >= 0, jump to PRG008_B2F3

	; Otherwise clear Level_VertScroll and Level_ScrollDiffV
	LDA #$00
	STA Level_VertScroll
	STA Level_ScrollDiffV

PRG008_B2F3:
	STA Level_VertScrollH	 ; Update Level_VertScrollH
	JMP PRG008_B338	 ; Jump to PRG008_B338

PRG008_B2F9:
	TYA		 ; A = Player_Y - Level_VertScroll
	SBC #$58
	BCC PRG008_B345	 ; If borrow occurred, jump to PRG008_B345 (RTS)

	; Maximum vertical scroll delta value is 4
	CMP #$04
	BLT PRG008_B304	 ; If value is < 4, jump to PRG008_B304

	LDA #$04	 ; A = 4

PRG008_B304:
	STA Level_ScrollDiffV	 ; Store vertical difference

	ADD Level_VertScroll
	STA Level_VertScroll	 ; Level_VertScroll += Level_ScrollDiffV

	LDA #$00
	ADC Level_VertScrollH
	STA Level_VertScrollH	 ; Apply carry, if any

	CMP <Temp_Var1

	PHP		 ; Save processor status

	LDA #$01
	STA <Scroll_LastDir	 ; Scroll_LastDir = 1 (last scrolled down)

	PLP		 ; Restore processor status

	BLT PRG008_B338		; If Level_VertScrollH < Temp_Var1 (base screen high address start), jump to PRG008_B338
	BNE PRG008_B329		; If Level_VertScrollH <> Temp_Var1 (base screen high address start), jump to PRG008_B329

	LDA Level_VertScroll
	CMP <Temp_Var2
	BLT PRG008_B338	 	; If Level_VertScroll < Temp_Var2, jump to PRG008_B338

PRG008_B329:

	; Update Level_VertScrollH and Level_VertScroll
	LDA <Temp_Var1
	STA Level_VertScrollH
	LDA <Temp_Var2
	STA Level_VertScroll

	LDA #$00
	STA Level_ScrollDiffV	 ; Level_VertScrollH = 0

PRG008_B338:
	LDA Level_VertScroll
	LDY Level_VertScrollH

	JSR LevelJct_GetVScreenH

	STA <Vert_Scroll
	STY <Vert_Scroll_Hi

PRG008_B345:
	RTS		 ; Return


	; Offsets used for tile detection in non-sloped levels
	; +16 if moving downward
	; +8 if on the right half of the tile
TileAttrAndQuad_OffsFlat:
	;     Yoff Xoff

	; Not small or ducking moving downward - Left half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $0E	; In-front lower
	.byte $0E, $0E	; In-front upper

	; Not small or ducking moving downward - Right half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $01	; In-front lower
	.byte $0E, $01	; In-front upper

	; Not small or ducking moving upward - Left half
	.byte $06, $08	; Ground left
	.byte $06, $08	; Ground right
	.byte $1B, $0E	; In-front lower
	.byte $0E, $0E	; In-front upper

	; Not small or ducking moving upward - Right half
	.byte $06, $08	; Ground left
	.byte $06, $08	; Ground right
	.byte $1B, $01	; In-front lower
	.byte $0E, $01	; In-front upper


TileAttrAndQuad_OffsFlat_Sm:
	; Small or ducking moving downward - Left half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $0D	; In-front lower
	.byte $14, $0D	; In-front upper

	; Small or ducking moving downward - Right half
	.byte $20, $04	; Ground left
	.byte $20, $0B	; Ground right
	.byte $1B, $02	; In-front lower
	.byte $14, $02	; In-front upper

	; Small or ducking moving upward - Left half
	.byte $10, $08	; Ground left
	.byte $10, $08	; Ground right
	.byte $1B, $0D	; In-front lower
	.byte $14, $0D	; In-front upper

	; Small or ducking moving upward - Right half
	.byte $10, $08	; Ground left
	.byte $10, $08	; Ground right
	.byte $1B, $02	; In-front lower
	.byte $14, $02	; In-front upper



	; Offsets used for tile detection in sloped levels
TileAttrAndQuad_OffsSloped:
	; Offsets pushed into Player_GetTileAndSlope
	;    Yoff Xoff

	; Not small or ducking - Left half
	.byte $20, $08	; feet
	.byte $05, $08	; head
	.byte $18, $03	; in-front lower
	.byte $0C, $03	; in-front upper

	; Not small or ducking - Right half
	.byte $20, $08	; feet
	.byte $05, $08	; head
	.byte $18, $0D	; in-front lower
	.byte $0C, $0D	; in-front upper

TileAttrAndQuad_OffsSloped_Sm:
	; Small or ducking - Left half
	.byte $20, $08	; feet
	.byte $12, $08	; head
	.byte $18, $03	; in-front lower
	.byte $17, $03	; in-front upper

	; Small or ducking - Right half
	.byte $20, $08	; feet
	.byte $12, $08	; head
	.byte $18, $0D	; in-front lower
	.byte $17, $0D	; in-front upper

	; Explicitly for walking off an edge in a sloped area
TileAttrAndQuad_OffsSlopeEdge:
	.byte $20, $04	; Right half
	.byte $20, $0B	; Left half

PlayerY_HeightOff:	.byte $12, $05	; Left value is Player_Y offset for small/ducking, right for otherwise
PRG008_B3AC:	
	.byte $02, $0E	; Left/Right half, not small
	.byte $03, $0D	; Left/Right half, small

PRG008_B3B0:	.byte $04, $0D

	; If $01, this is treated as a "not floor" tile, which means to watch out
	; for the Player to hit his head rather than track the sloped floor...
Slope_IsNotFloorShape:
	.byte $01, $00, $00, $00, $00, $01, $01, $00	; $00-$07
	.byte $01, $01, $00, $01, $00, $00, $00, $00	; $08-$0F
	.byte $01, $01, $01, $01, $01			; $10-$14

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileAndSlope
;
; Gets tile and attribute of tile for either non-vertical or
; vertical levels based on Player's position
;
; Temp_Var10 is a Y offset (e.g. 0 for Player's feet, 31 for Player's head)
; Temp_Var11 is an X offset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileAndSlope:

	LDA #$00
	STA Temp_VarNP0 ; Temp_VarNP0 = 0

	LDA Level_7Vertical
	BNE PRG008_B442	 ; If level is vertical, jump to PRG008_B442

	LDA Player_PartDetEn
	BEQ PRG008_B3F7	 ; If Player_PartDetEn is not set, jump to PRG008_B3F7

	; Bottom two tile rows forced detection enabled when Player Y >= 160...

	LDA Player_AboveTop
	BNE PRG008_B3F7	 ; If Player is above top of screen, jump to PRG008_B3F7

	LDA <Player_Y
	ADD <Temp_Var10		; Temp_Var10 is the Y offset 
	SUB Level_VertScroll	; Make relative to Vertical Scroll

	CMP #160
	BLT PRG008_B3F7	 ; If result < 160, jump to PRG008_B3F7

	; Player is low enough to the visual floor... detect the bottom two rows of tiles!

	SBC #16		; - 16
	AND #$F0	; Align to tile grid
	STA <Temp_Var14	; -> Temp_Var14

	LDA #$01
	STA <Temp_Var13	 ; Temp_Var13 = 1 (implied high byte / carry)

	STA Temp_VarNP0 ; Temp_VarNP0 = 1

	BNE PRG008_B406	 ; Jump (technically always) to PRG008_B406

PRG008_B3F7:
	LDA <Player_YHi
	STA <Temp_Var13	 ; Temp_Var13 = Player_YHi

	LDA <Temp_Var10	 ; Temp_Var10 is the Y offset 
	ADD <Player_Y	 
	STA <Temp_Var14	 ; Temp_Var14 = Temp_Var10 + Player_Y

	BCC PRG008_B406	 ; If no carry, jump to PRG008_B406

	INC <Temp_Var13	 ; Apply carry to Temp_Var13

PRG008_B406:
	LDA <Temp_Var13
	BEQ PRG008_B419	 ; If Temp_Var13 (high byte / carry) = 0, jump to PRG008_B419

	; When carry exists..

	CMP #$01
	BNE PRG008_B414	 ; If Temp_Var13 <> 1, jump to PRG008_B414

	LDA <Temp_Var14
	CMP #$b0	
	BLT PRG008_B419	 ; If Temp_Var14 < $B0, jump to PRG008_B419

PRG008_B414:
	LDA #$00
	STA <Player_Slopes	 ; Player_Slopes = 0 

	RTS		 ; Return


PRG008_B419:
	LDA <Player_XHi
	STA <Temp_Var15	 ; Temp_Var15 = Player_XHi

	LDA <Temp_Var11
	BPL PRG008_B423	 ; If Temp_Var11 >= 0, jump to PRG008_B423

	DEC <Temp_Var15	 ; Temp_Var15--

PRG008_B423:
	LDA <Player_X
	ADD <Temp_Var11
	STA <Temp_Var16	 ; Temp_Var16 = Player_X + Temp_Var11
	BCC PRG008_B42E	 ; If no carry, jump to PRG008_B42E

	INC <Temp_Var15	 ; Temp_Var15++ (apply carry to Temp_Var15)

PRG008_B42E:

	; So in total we've calculated:
	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	; X/Y were not modified, so as inputs:
	; X = 0 (going down) or 1 (going up)
	; Y = Player_YVel

	STY <Temp_Var10	 ; Temp_Var10 = Player_YVel
	STX <Temp_Var11	 ; Temp_Var11 = 0 or 1

	JSR Player_GetTileAndSlope_Normal	 ; Set Level_Tile and Player_Slopes

	LDX <Temp_Var11	 	; Temp_Var11 = 0 (going down) or 1 (going up)
	LDY Level_PipeMove	; Y = Level_PipeMove (movement command in $8x form)
	BNE PRG008_B43F	 	; If Level_PipeMove <> 0, jump to PRG008_B43F

	JSR PSwitch_SubstTileAndAttr	 ; Otherwise, substitute tile if effected by P-Switch

PRG008_B43F:
	LDY <Temp_Var10	 ; Y = Player_YVel
	RTS		 ; Return

PRG008_B442:
	LDA <Player_YHi
	STA <Temp_Var13	 ; Temp_Var13 = Player_YHi

	LDA <Temp_Var10
	ADD <Player_Y
	STA <Temp_Var14	 ; Temp_Var14 = Temp_Var10 + Player_Y
	BCC PRG008_B451	 ; If there's no carry, jump to PRG008_B451

	INC <Temp_Var13	 ; Otherwise, apply the carry

PRG008_B451:
	LDA <Temp_Var13	
	BPL PRG008_B458	 ; If Temp_Var13 (the "High" part) >= 0, jump to PRG008_B458

	; Otherwise...
	LDA #$00	 ; A = 0
	RTS		 ; Return

PRG008_B458:
	LDA <Player_X
	ADD <Temp_Var11
	STA <Temp_Var16	 ; Temp_Var16 = Player_X + Temp_Var11

	STY <Temp_Var10	 ; Temp_Var10 = Y

	JSR Player_GetTileV	 ; Get tile, set Level_Tile

	LDY Level_PipeMove	 ; Y = Level_PipeMove
	BNE PRG008_B46C	 	; If Level_PipeMove <> 0, jump to PRG008_B46C

	JSR PSwitch_SubstTileAndAttr	 ; Otherwise, substitute tile if effected by P-Switch

PRG008_B46C:
	LDY #$00
	STY <Temp_Var15	 ; Temp_Var15 = 0

	LDY <Temp_Var10	 ; Y = Temp_Var10
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DetectSolids
;
; Handles Player's collision against solid tiles (wall and ground,
; handles slopes and sliding on them too!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DetectSolids:
	LDA #$00
	STA Player_HitCeiling ; Clear Player_HitCeiling

	LDA Level_PipeMove
	BEQ PRG008_B47E	 ; If not going through a pipe, jump to PRG008_B47E

	RTS		 ; Return


PRG008_B47E:
	LDA Slope_LUT_Addr
	STA <Level_GndLUT_Addr

	LDA Slope_LUT_Addr+1
	STA <Level_GndLUT_Addr+1

	LDA Level_SlopeEn
	BEQ PRG008_B4A5	 ; If not a sloped level, jump to PRG008_B4A5

	LDA Level_Tileset
	CMP #$03
	BEQ PRG008_B4A2	 ; If Level_Tileset = 3 (Hills style), jump to PRG008_B4A2
	CMP #14
	BEQ PRG008_B4A2	 ; If Level_Tileset = 14 (Underground style), jump to PRG008_B4A2

	; Non-sloped levels use this:
	; SB: NOTE: I don't think this really means anything; this ends up pointing to
	; Level_LayPtrOrig_AddrH (original layout pointer high byte), which doesn't make
	; sense, but Level_GndLUT_Addr/H isn't used in a non-slope level anyway, so this is
	; probably some bit of "dead" code or something...

	LDA NonSlope_LUT_Addr
	STA <Level_GndLUT_Addr

	LDA NonSlope_LUT_Addr+1
	STA <Level_GndLUT_Addr+1

PRG008_B4A2:
	JMP PRG000_B9D8	 ; Jump to PRG000_B9D8

PRG008_B4A5:
	; Slopes not enabled...

	LDY #(TileAttrAndQuad_OffsFlat_Sm - TileAttrAndQuad_OffsFlat) + 6	; 6 = 3 * 2 (the offset we start on below) and work backwards from

	LDA <Player_Suit
	BEQ PRG008_B4B2	 ; If Player is small, jump to PRG008_B4B2

	LDA Player_IsDucking
	BNE PRG008_B4B2	 ; If Player is ducking, jump to PRG008_B4B2

	LDY #6		; 6 = 3 * 2 (the offset we start on below) and work backwards from

PRG008_B4B2:
	LDX #$03	 ; X = 3 (the reason for +6 above)

	LDA <Player_YVel 
	BPL PRG008_B4BD	 ; If Player_YVel >= 0 (moving downward), jump to PRG008_B4BD

	; Otherwise, add 16 to index
	TYA
	ADD #16
	TAY

PRG008_B4BD:
	LDA <Player_X
	AND #$0f
	CMP #$08
	BLS PRG008_B4CA	 ; If Player is on the left half of the tile, jump to PRG008_B4CA

	; If on the right half, add 8 to index
	TYA	
	ADD #$08
	TAY	

PRG008_B4CA:
	TYA		 ; Offset -> 'A'
	PHA		 ; Save offset

	; Get X/Y offset for use in detection routine
	LDA TileAttrAndQuad_OffsFlat,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)
	LDA TileAttrAndQuad_OffsFlat+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

	JSR Player_GetTileAndSlope	 ; Get tile
	STA Level_Tile_GndL,X	 ; Store it

	PHA		 ; Save tile

	AND #%11000000	 ; Get quadrant
	ASL A		 
	ROL A		 
	ROL A		 ;
	STA Level_Tile_Quad,X	 ; Store quadrant number

	PLA		 ; Restore tile

	JSR Level_DoCommonSpecialTiles	 ; Handle tile apporiately

	PLA		 
	TAY		 ; Restore 'Y' index
	DEY
	DEY		 ; Y -= 2 (next pair of offsets)

	DEX		 ; X--

	BMI PRG008_B4F3	 ; If X < 0, jump to PRG008_B4F3
	JMP PRG008_B4CA	 ; Otherwise, loop!

PRG008_B4F3:
	; Wall hit detection
	LDY #$02	 ; Y = 2 (checking "in front" tiles, lower and upper)

	JSR Level_CheckGndLR_TileGTAttr
	BCC PRG008_B53B	 ; If not touching a solid tile, jump to PRG008_B53B

	LDA Player_LowClearance	 
	BNE PRG008_B53B	 ; If Player_LowClearance is set, jump to PRG008_B53B

	INC Player_WalkAnimTicks	 ; Player_WalkAnimTicks++

	LDY #$01	 ; Y = 1
	LDX #$00	 ; X = 0

	LDA <Player_X
	AND #$0f	
	CMP #$08	
	BGS PRG008_B511	 ; If Player is on the right side of the tile, jump to PRG008_B511

	; Otherwise...
	LDY #-1		 ; Y = -1
	INX		 ; X = 1

PRG008_B511:
	LDA <Player_Suit
	BNE PRG008_B517	 ; If Player is NOT small, jump to PRG008_B517

	INX		 
	INX		 ; X += 2 (X = 2 or 3)

PRG008_B517:
	LDA PRG008_B3AC,X
	ADD <Player_X	 ; Add appropriate offset to Player_X

	AND #$0f
	BEQ PRG008_B53B	 ; If Player is on new tile, jump to PRG008_B53B

	TYA		 ; A = 1 or -1
	BPL PRG008_B526	 ; If the positive version, jump to PRG008_B526

	DEC <Player_XHi	 ; When negative, decrement the "Hi" component

PRG008_B526:
	ADD <Player_X	 ; Add +1/-1 to Player_X
	STA <Player_X	 ; Update Player_X

	BCC PRG008_B52F	 ; If no carry, jump to PRG008_B52F
	INC <Player_XHi	 ; Otherwise, apply carry

PRG008_B52F:
	INY		 ; Y++

	LDA <Player_XVel
	BPL PRG008_B536	 ; If Player_XVel >= 0, jump to Player_XVel

	; This basically amounts to a single decrement of 'Y' if Player_XVel < 0
	DEY
	DEY

PRG008_B536:
	TYA		
	BNE PRG008_B53B	 ; If Y <> 0, jump to PRG008_B53B

	STA <Player_XVel ; Otherwise, halt Player horizontally

PRG008_B53B:
	LDA <Player_YVel
	BPL PRG008_B55B	 ; If Player Y velocity >= 0 (moving downward), jump to PRG008_B55B

	LDA <Player_InAir
	BEQ PRG008_B55B	 ; If Player is NOT mid air, jump to PRG008_B55B

	LDY #$00	 ; Y = 0

	JSR Level_CheckGndLR_TileGTAttr
	BCC PRG008_B55A	 ; If not touching a solid tile, jump to PRG008_B55A

	INY		 ; Y = 1
	STY Player_HitCeiling	 ; Flag Player as having just hit head off ceiling

	LDA Level_AScrlVVel	; Get autoscroll vertical velocity
	JSR Negate	 ; Negate it
	BPL PRG008_B558	 ; If positive, jump to PRG008_B558

	; Otherwise, just use 1
	LDA #$01	

PRG008_B558:
	STA <Player_YVel ; Update Player_YVel

PRG008_B55A:
	RTS		 ; Return

PRG008_B55B:
	LDX Level_Tile_Quad+1	 ; Get right tile quadrant
	LDA Level_Tile_GndR	 ; Get right tile
	CMP Tile_AttrTable,X	
	BGE PRG008_B57E	 	 ; If the tile is >= the attr value, jump to PRG008_B57E

	LDX Level_Tile_Quad	 ; Get left tile quadrant
	LDA Level_Tile_GndL	 ; Get left tile
	CMP Tile_AttrTable,X	
	BGE PRG008_B57E	 	 ; If the tile is >= the attr value, jump to PRG008_B57E


	LDA <Player_InAir
	BNE PRG008_B5BB	 ; If Player is mid air, jump to PRG008_B5BB

	; Otherwise...

	STA <Player_YVel ; Halt Player vertically

	LDA #$01
	STA <Player_InAir ; Mark Player as mid air

	JMP PRG008_B5BB	 ; Jump to PRG008_B5BB

PRG008_B57E:
	LDA Temp_VarNP0
	BEQ PRG008_B59C		; If did not use "high" Y last call to Player_GetTileAndAttr, jump to PRG008_B59C

	LDA <Player_Y		; Get Player Y
	SUB Level_VertScroll	; Make scroll relative
	AND #$F0	 	; Nearest 16
	ADD #$01	 	; +1
	ADD Level_VertScroll	; Make un-relative
	STA <Player_Y		; Set Player_Y!

	LDA #$00
	ADC #$00
	STA <Player_YHi		; Apply carry if needed
	BPL PRG008_B5B2	 	; If carry >= 0, jump to PRG008_B5B2

PRG008_B59C:
	LDA <Player_Y
	AND #$0f	; Relative to tile vertical position
	CMP #$06
	BGE PRG008_B5BB	 ; If Player's vertical tile position >= 6, jump to PRG008_B5BB

	LDA <Player_Y
	AND #$0f	 ; Relative to tile vertical position
	BEQ PRG008_B5B2	 ; If zero, jump to PRG008_B5B2

	CMP #$01	 
	BEQ PRG008_B5B0	 ; If 1, jump to PRG008_B5B0

	DEC <Player_Y	 ; Player_Y--

PRG008_B5B0:
	DEC <Player_Y	 ; Player_Y--

PRG008_B5B2:
	LDA #$00	 
	STA <Player_InAir ; Player NOT mid air
	STA <Player_YVel  ; Halt Player vertically
	STA Kill_Tally	  ; Reset Kill_Tally

PRG008_B5BB:
	RTS		 ; Return


	; This checks if the given tile is greater-than-or-equal-to
	; the related "AttrTable" slot and, if so, returns 'carry set'
Level_CheckGndLR_TileGTAttr:

	LDX Level_Tile_Quad+1,Y	; Get this particular "quad" (0-3) index
	LDA Level_Tile_GndR,Y		; Check the tile here
	CMP Tile_AttrTable+4,X
	BGE PRG008_B5D0			; If the tile is >= the attr value, jump to PRG008_B5D0 (NOTE: Carry set when true)

	LDX Level_Tile_Quad,Y		; Get this particular "quad" (0-3) index
	LDA Level_Tile_GndL,Y		; Check the tile here
	CMP Tile_AttrTable+4,X		; Set carry if tile is >= the attr value

PRG008_B5D0:

	; NOTE: The return value is "carry set" for true!

	RTS		 ; Return


	; Handle all common special tiles (ice blocks, P-Switches, bump blocks, etc.)
	; Does not include things like instant-kill lava tiles...
Level_DoCommonSpecialTiles:
	TYA		 ; A = Y (offset into TileAttrAndQuad_OffsSloped)
	PHA		 ; Save it

	LDY Player_Kuribo
	BNE PRG008_B604	 ; If Player is in Kuribo's shoe, jump to PRG008_B604

	LDA #TILEA_ICEBLOCK
	CMP Level_Tile_GndL,X
	BNE PRG008_B604	 ; If Player is not touching an ice block, jump to PRG008_B604
 
	; Player is touching an ice block...
	BIT <Pad_Input
	BVC PRG008_B604	 ; If Player is not pushing 'B', jump to PRG008_B604

	CPX #$03
	BEQ PRG008_B604	 ; If tile at head, jump to PRG008_B604

	LDA Level_ChgTileEvent
	BNE PRG008_B604	 ; If Level_ChgTileEvent <> 0 (tile change already queued), jump to PRG008_B604

	TXA
	PHA		 ; Save 'X' (current tile index) 

	JSR Level_IceBlock_GrabNew ; Grab a new ice block object!  (If there's room)

	; Of note, if there was no room for an Ice Block, X = $FF (-1) right now
	TXA		 ; Transfer new object index 'X' -> 'A'
	ASL A		 ; Shift left 1 (setting carry if there was no room for Ice Block)

	PLA		 ; Restore current tile index -> 'A'
	TAX		 ; X = A

	BCS PRG008_B604	 ; If we didn't have room for an ice block, jump to PRG008_B604

	; Otherwise...

	LDA #$00
	STA Player_TailAttack	 ; Disable any tail attacking

	LDA #CHNGTILE_DELETETOBG
	JSR Level_QueueChangeBlock	 ; Queue a block change to erase to background!

	JMP PRG008_B652	 ; Jump to PRG008_B652

PRG008_B604:

	; Not an ice block or if it was, Player was not interested in it...

	LDA Level_Tile_GndL,X
	CMP #TILEA_COIN
	BNE PRG008_B623	 ; If Player is not touching coin, jump to PRG008_B623

	LDA #CHNGTILE_DELETECOIN
	JSR Level_QueueChangeBlock	 ; Queue a block change to erase to background!
	JSR Level_RecordBlockHit	 ; Record having grabbed this coin so it does not come back

	; Play coin collected sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1

	LDA #$00
	STA Level_Tile_GndR	; Clear this tile detect (probably to prevent "double collecting" a coin the Player is straddling)

	JMP PRG008_B652	 ; Jump to PRG008_B652

PRG008_B623:

	; Player not touching coin...

	CMP #TILEA_PSWITCH
	BNE PRG008_B64F	 ; If Player is not touching P-Switch, jump to PRG008_B64F

	; Player touching P-Switch...

	CPX #$02
	BGS PRG008_B64F	 ; If it is being detected by Player's head, then jump to PRG008_B64F (don't hit with head!)

	LDA #CHNGTILE_PSWITCHSTOMP	; P-Switch hit tile change

	CMP Level_ChgTileEvent
	BEQ PRG008_B64F	 ; If we've already got a tile change in the queue, jump to PRG008_B64F

	; Queue tile change 9!
	JSR Level_QueueChangeBlock

	LDA #$10
	STA Level_Vibration	; Level_Vibration = $10 (little shake effect)

	; Wham! sound effect
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	LDA #$80	 
	STA Level_PSwitchCnt	 ; Level_PSwitchCnt = $80 (duration of switch)

	; Play P-Switch song
	LDA #MUS2B_PSWITCH
	STA Sound_QMusic2

	JMP PRG008_B652	 ; Jump to PRG008_B652

PRG008_B64F:
	JSR Level_DoBumpBlocks	 ; Handle any bumpable blocks (e.g. ? blocks, note blocks, etc.)

PRG008_B652:
	PLA		 
	TAY		 ; Restore offset into TileAttrAndQuad_OffsSloped -> 'Y'

	RTS		 ; Return


	; This routine "grabs a new ice block" object and puts 
	; it in the Player's hands, if there's room for it!
Level_IceBlock_GrabNew:
	LDX #4 	; X = 4 (considering first 5 object slots)
PRG008_B657:
	LDA Objects_State,X
	BEQ PRG008_B660	 ; If this object slot is "dead/empty", jump to PRG008_B660

	DEX		 ; X--
	BPL PRG008_B657	 ; While X >= 0, loop!

	; If you get here, there was no room for a new ice block :(

	RTS		 ; Return

PRG008_B660:
	JSR Level_PrepareNewObject ; Prepare new Ice Block object!

	LDA #$04	 
	STA Objects_State,X	; Set "held by Player" state (implies position of object)

	LDA #OBJ_ICEBLOCK
	STA Level_ObjectID,X	; Set object ID (ice block)

	LDA #$80	 
	STA Objects_Timer3,X	; Set object long timer (ticks until ice block evaporates in Player's hands)

	RTS		 ; Return


	; After a block is hit, it does the little bounce thing, and then 
	; a power up MAY come from it!  This defines which power-up will
	; appear, if any:
	; 0 = None, 1 = Mushroom/Flower, 2 = Mushroom/Leaf, 3 = Star, 4 = Coin, 5 = Coin/Star
	; 6 = brick behavior (i.e. bump/smash), 7 = Vine, 8 = 10 coin,  = 1-up, A = P-Switch
	; LATP = Level_ActionTiles powerup
	; Note that this array should match elements with the LATR_'s below!
LATP_PowerUps:
LATP_GNote:	.byte $00
LATP_HNote:	.byte $00
LATP_Notes:	.byte $00, $01, $02, $03
LATP_Woodblocks:.byte $00, $01, $02, $03
LATP_QBlocks:	.byte $01, $02, $03, $04, $05, $04, $00, $06, $01, $02, $03, $04, $05, $08, $09, $07, $0A
LATP_InvisCoin:	.byte $04, $09, $00
LATP_InvisNote:	.byte $00
LATP_PWrksJct:	.byte $0B	; UNUSED breakable pipeworks junction tile!
LATP_End


	; After a block is hit, it does the little bounce thing, and then 
	; "restores" the tile which was previously there; this defines what
	; tile that is exactly...
	;
	; NOTE: This does not fix the attribute colors (immediately), so
	; you shouldn't mix and match differently palettized blocks!
	;
	; $10 - Coin Heaven note block
	; $20 - "Metal plate" post-? block hit
	; $30 - Empty brick
	; $40 - Generic note block
	; $50 - Wood block
	; $60 - Brick (with coins)
	; $70 - ??

	; LATR = Level_ActionTiles restore
	; Note that this array should match elements with the LATP_'s above!
LATR_BlockResult:
LATR_GNote:	.byte $00
LATR_HNote:	.byte $10
LATR_Notes:	.byte $40, $40, $40, $40
LATR_Woodblocks:.byte $50, $50, $50, $50
LATR_QBlocks:	.byte $20, $20, $20, $20, $20, $20, $20, $30, $20, $20, $20, $20, $20, $60, $20, $20, $20
LATR_InvisCoin:	.byte $20, $20, $10
LATR_InvisNote:	.byte $40
LATR_PWrksJct:	.byte $70	; UNUSED breakable pipeworks junction tile!


	; This defines a "range" passed the base tile defined in Level_ActionTiles
	; where a related effect takes place; so see Level_ActionTiles for the bases!
Level_ActionTiles_Range:
	; Tiles activated anytime
	.byte (LATP_HNote - LATP_GNote), (LATP_Notes - LATP_HNote), (LATP_Woodblocks - LATP_Notes), (LATP_QBlocks - LATP_Woodblocks)

	; Tiles activated only when Player is moving upward
	.byte (LATP_InvisCoin - LATP_QBlocks), (LATP_InvisNote - LATP_InvisCoin), (LATP_PWrksJct - LATP_InvisNote)

	; And in the desert only... (UNUSED, would be a breakable tile in a pipeworks structure!)
	.byte (LATP_End - LATP_PWrksJct)


	; Offset fix applied to the selected "action tile" set
LATR_Off .func (\1 - LATR_GNote)
Level_ActionTiles_OffFix:
	; Tiles activated anytime
	.byte LATR_Off(LATR_GNote), LATR_Off(LATR_HNote), LATR_Off(LATR_Notes), LATR_Off(LATR_Woodblocks)

	; Tiles activated only when Player is moving upward
	.byte LATR_Off(LATR_QBlocks), LATR_Off(LATR_InvisCoin), LATR_Off(LATR_InvisNote)

	; And in the desert only... (UNUSED, would be a breakable tile in a pipeworks structure!)
	.byte LATR_Off(LATR_PWrksJct)


	; This defines the base tile index for "action tiles", tiles which, when the
	; Player hits them right, causes something to happen...
Level_ActionTiles:
	; Tiles activated anytime
	.byte TILEA_GNOTE, TILEA_HNOTE, TILEA_NOTE, TILEA_WOODBLOCKBOUNCE

	; Tiles activated only when Player is moving upward
	.byte TILEA_QBLOCKFLOWER, TILEA_INVISCOIN, TILEA_NOTEINVIS

	; And in the desert only... (UNUSED, would be a breakable tile in a pipeworks structure!)
	.byte TILE9_PIPEWORKS_JCT

	; Hit Enable bits specify whether blocks can be hit horizontally
	; vertically, or both!  While they can be somewhat refined to only
	; act on a particular detection "half", the typical use is:
	;	%0011 - Enable hitting from top and bottom
	;	%1100 - Enable hitting from left and right
	;	%1111 - Enable hitting in all directions
	; Note that certain tiles are just not checked by behavior noted
	; in the comments, e.g. to enable hitting ? blocks from the top,
	; the code must be reworked to not disable checking them if the 
	; Player is not moving upward!
Level_ActionTiles_HitEnable:
	; Tiles activated anytime
	.byte %1111, %1111, %0011, %1100

	; Tiles activated only when Player is moving upward
	.byte %0010, %0010, %0010

	; And in the desert only... (UNUSED, would be a breakable tile in a pipeworks structure!)
	.byte %0010


	; Bit set based on which index of the tile detection we're on;
	; matches up to the type of hit which will occur on the block!
Level_ActionTiles_TIHitBit:
	.byte %0001, %0010, %0100, %1000, %1111


	; Logic to handle "bump blocks", e.g. ? blocks, note blocks, etc.
Level_DoBumpBlocks:
	TYA		 
	PHA		 ; Save offset into TileAttrAndQuad_OffsSloped

	LDY #$03	 ; Y = 3 (by default, only consider first 4 tiles of Level_ActionTiles)

	CPX #$04
	BEQ PRG008_B6E4	 ; If tile index = 4, jump to PRG008_B6E4

	LDA <Player_YVel
	BPL PRG008_B6EF	 ; If Player is moving downward, jump to PRG008_B6EF

PRG008_B6E4:
	INY
	INY
	INY		 ; Y += 3 (consider next 3 tiles for moving upward)

	LDA Level_TilesetIdx
	CMP #$08	 
	BNE PRG008_B6EF	 ; If Level_TilesetIdx <> 8 (desert levels), jump to PRG008_B6EF
	INY		 ; Otherwise, Y += 1 (and in the desert only, the UNUSED breakable pipeworks tile)

PRG008_B6EF:
	LDA Level_Tile_GndL,X	 ; Get tile index
	SUB Level_ActionTiles,Y
	CMP Level_ActionTiles_Range,Y
	BCC PRG008_B701	 ; If the tile is in range, jump to PRG008_B701!

PRG008_B6FB:
	DEY		 ; Y--
	BPL PRG008_B6EF	 ; While Y >= 0, loop!
	JMP PRG008_B78B	 ; Otherwise, jump to PRG008_B78B

PRG008_B701:
	ADD Level_ActionTiles_OffFix,Y	 ; Add an offset fix to this tile
	STA <Temp_Var6		 ; -> Temp_Var6

	LDA Level_ActionTiles_TIHitBit,X	 ; Get bitfield value appropriate for this tile detect index
	AND Level_ActionTiles_HitEnable,Y	 ; Mask to check if this block should respond
	BEQ PRG008_B6FB	 ; If block does not respond to this hit, jump to PRG008_B6FB

	; Block's getting hit...!

	; Splash_DisTimer = $10 (disables water splahes briefly, probably to make sure it doesn't effect the bounce block sprites?)
	LDA #$10
	STA Splash_DisTimer

	LDY <Temp_Var6	 	; Y = Tile detected relative index with offset fix
	LDA LATP_PowerUps,Y	; Get appropriate power-up for this block
	JSR LATP_HandleSpecialBounceTiles	; Do what this special tile ought to do!
	TYA		 ; Power up result (if any) is in 'Y'!
	BNE PRG008_B722	 ; If there's a powerup to spawn, jump to PRG008_B722

	JMP PRG008_B78B	 ; Otherwise, jump to PRG008_B78B

PRG008_B722:
	BMI PRG008_B74A	 ; If Y = $80, a brick was busted!  Jump to PRG008_B74A

	LDY <Temp_Var6	 ; Y = Tile detected relative index with offset fix
	ORA LATR_BlockResult,Y	 ; Get block which should result
	STA Player_Bounce	 ; Indicate to Player he should bounce

	; Play bump sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	LDA #CHNGTILE_DELETETOBG
	STA <Temp_Var12	 ; Temp_Var12 = CHNGTILE_DELETETOBG

	CPX #$02
	BLS PRG008_B74A	 ; If tile detected index < 2, jump to PRG008_B74A

	LDY #$02	 ; Y = 2 (bounce left)

	LDA <Player_X
	AND #$0f	 ; Tile relative X
	CMP #$08
	BLS PRG008_B747	 ; If Player was on the left half of the block, jump to PRG008_B747

	INY		 ; Otherwise Y = 3 (bounce right)

PRG008_B747:
	JMP PRG008_B75B	 ; Jump to PRG008_B75B

PRG008_B74A:
	LDY #$00	 ; Y = 0 (bounce down)
	LDA Level_SlopeEn
	BEQ PRG008_B756	 ; If not a sloping level, jump to PRG008_B756

	TXA		 
	BEQ PRG008_B75B	 ; If tile detect index = 0, jump to PRG008_B75B (keeps Y = 0)
	BNE PRG008_B75A	 ; Otherwise, jump to PRG008_B75A (sets Y = 1)

PRG008_B756:
	LDA <Player_YVel
	BPL PRG008_B75B	 ; If Player not moving upward, jump to PRG008_B75B (keeps Y = 0)

PRG008_B75A:
	INY		 ; Y = 1 (bounce up)

PRG008_B75B:

	STY Player_BounceDir	 ; Set Player bounce direction

	LDY #$06	; Y = 6

	LDA Objects_State,Y
	BEQ PRG008_B766	 ; If this object is dead/empty, jump to PRG008_B766
	INY		 ; Y++

PRG008_B766:

	; Align Y lo to tile grid
	LDA <Temp_Var14
	AND #$F0
	STA <Temp_Var14
	STA Objects_Y,Y	 ; Store into object slot

	LDA <Temp_Var13
	STA Objects_YHi,Y ; Store Y Hi into object slot

	LDA <Temp_Var15	
	STA Objects_XHi,Y ; Store X Hi into object slot

	LDA <Temp_Var16
	STA Objects_X,Y	 ; Store X Lo into object slot

	JSR BlockBump_Init	; Init the block bump effect!

	LDA Player_BounceDir
	BEQ PRG008_B78B	 ; If Player_BounceDir = 0 (bounce up), jump to PRG008_B78B

	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars	 ; Change tile (in grid memory, not immediate display)

PRG008_B78B:
	PLA		 ; Restore offset into TileAttrAndQuad_OffsSloped
	TAY		 ; -> 'Y'

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LATP_HandleSpecialBounceTiles
;
; Ever wondered where the code was that makes ? blocks emerge 
; powerups, music note blocks bounce you around, and bricks bust?
; Well, here it is!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LATP_HandleSpecialBounceTiles:
	STA <Temp_Var1	 ; Backup power-up request -> Temp_Var1 
	LDA Player_Bounce
	BNE PRG008_B7B7	 ; If Player is already in a bounce, jump to PRG008_B7B7

	LDY #$06	 ; Y = 6 (object slot index)
	LDA Objects_State,Y	; Check this object's state
	ORA Level_BlkBump	; And block bump 1...
	BEQ PRG008_B7A7	 	; If item is "dead/empty" and block bump 1 isn't in use, jump to PRG008_B7A7

	LDA Objects_State+1,Y ; Check next object's state
	ORA Level_BlkBump+1  ; And block bump 2...
	BNE PRG008_B7B7	 	; If item is NOT "dead/empty" or block bump 2 is in use, jump to PRG008_B7B7

PRG008_B7A7:
	LDY #$05	 ; Y = 5 (object slot index)

	LDA Objects_Timer,Y
	BEQ PRG008_B7BA	 ; If timer expired, jump to PRG008_B7BA

	LDA <Temp_Var16	 ; Player detect X low
	AND #$F0	 ; Aligned to tile grid
	CMP Objects_X,Y	 
	BNE PRG008_B7BA	 ; If this object's X does not match the aligned detect X, jump to PRG008_B7BA

PRG008_B7B7:
	LDY #$00	 ; Y = 0 (no space for bounce object found)

 
	RTS		 ; Return


PRG008_B7BA:

	; Align X Detect low to tile grid
	LDA <Temp_Var16
	AND #$F0
	STA <Temp_Var16

	LDA <Temp_Var1	 ; Get power-up value
	ASL A		 ; Make into 2-byte index
	TAY		 ; -> 'Y'

	; Load jump address as per block tile type...
	LDA LATP_JumpTable,Y
	STA <Temp_Var1	
	LDA LATP_JumpTable+1,Y
	STA <Temp_Var2	

	JMP [Temp_Var1]	 ; Handle special block!

LATP_JumpTable:
	.word LATP_None		; 0 = None
	.word LATP_Flower	; 1 = Mushroom/Flower
	.word LATP_Leaf		; 2 = Mushroom/Leaf
	.word LATP_Star		; 3 = Star
	.word LATP_Coin		; 4 = Coin
	.word LATP_CoinStar	; 5 = Coin/Star
	.word LATP_Brick	; 6 = Standard brick behavior
	.word LATP_Vine		; 7 = Vine
	.word LATP_10Coin	; 8 = 10 coin
	.word LATP_1up		; 9 = 1-up
	.word LATP_PSwitch	; A = P-Switch
	.word LATP_BrickAltClear; B = Brick which clears to alternate tile when smashed

LATP_None:
	LDY #1		; Y = 1 (spawn .. nothing?) (index into PRG001 Bouncer_PUp)
	RTS		 ; Return

LATP_Flower:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$05	 ; Y = 5 (spawn a mushroom) (index into PRG001 Bouncer_PUp)

	LDA <Player_Suit
	BEQ PRG008_B7F9	 ; If Player is small, jump to PRG008_B7F9

	LDY #$02	 ; Y = 2 (spawn a fire flower) (index into PRG001 Bouncer_PUp)

PRG008_B7F9:
	RTS		 ; Return


LATP_Leaf:
	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$05	 ; Y = 5 (spawn a mushroom) (index into PRG001 Bouncer_PUp)

	LDA <Player_Suit
	BEQ PRG008_B807	 ; If Player is small, jump to PRG008_B807

	LDY #$03	 ; Y = 3 (spawn a leaf) (index into PRG001 Bouncer_PUp)

PRG008_B807:
	RTS		 ; Return

LATP_Star:
	LDA #$80
	STA PUp_StarManFlash	 ; PUp_StarManFlash = $80 (activate star man flash)

	LDY #$04	 ; Y = 4 (spawn a starman) (index into PRG001 Bouncer_PUp)

	RTS		 ; Return

LATP_Coin:
	JSR LATP_CoinCommon	 ; Do common "power up" coin routine

	LDY #$01	 ; Y = 1 (spawn a coin) (index into PRG001 Bouncer_PUp, i.e. nothing)

	LDA <Temp_Var16
	ORA <Temp_Var15	; Regenerate 10 coin block ID
	CMP B10Coin_ID
	BNE PRG008_B82F	; If this is a DIFFERENT coin block than the last one we started, jump to PRG008_B82F (RTS)

	LDA B10Coin_Timer
	BEQ PRG008_B82F	; In any case, if a 10 coin timer is not still on, jump to PRG008_B82F (RTS)

	LDA B10Coin_Count
	BMI PRG008_B82F	; If you've already got 10 coins (ideally), jump to PRG008_B82F (RTS)

	DEC B10Coin_Count	 ; B10Coin_Count--

	LDA #$17
	STA <Temp_Var6	 ; Temp_Var6 = $17

PRG008_B82F:
	RTS		 ; Return

LATP_CoinStar:
	LDA #$80
	STA PUp_StarManFlash	 ; Get that Starman flash ready just in case...

	LDY #$04	 	; Y = 4 (spawn a starman) (index into PRG001 Bouncer_PUp)

	LDA Player_StarInv
	BNE PRG008_B83F	 ; If Player if invincible, jump to PRG008_B83F!

	; Otherwise, sorry, just a coin :(
	JMP LATP_Coin

PRG008_B83F:
	RTS		 ; Return

LATP_Brick:
	JSR LATP_GetCoinAboveBlock	; Get coin above block, if any

	CPX #$04
	BEQ PRG008_B84E	 ; If on tile check index 4 (tail attack's tile), jump to PRG008_B84E (bust brick!)

	LDA <Player_Suit
	BNE PRG008_B84E	 ; If Player is not small, jump to PRG008_B84E (bust brick!)

	LDY #$01	 ; Y = 1 (spawn a coin) (index into PRG001 Bouncer_PUp, i.e. nothing)

	RTS		 ; Return

PRG008_B84E:
	; Crumbling sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR BrickBust_MoveOver	 ; If a brick is busting in slot 1, move it to slot 2

	LDA #$02
	STA BrickBust_En	 ; Set brick bust enable

	; Y
	LDA <Temp_Var14
	AND #$F0
	CLC
	SBC Level_VertScroll
	STA BrickBust_YUpr	 ; Store upper brick segment Y

	ADD #$08
	STA BrickBust_YLwr	 ; Store lower brick segment Y

 	; X
	LDA <Temp_Var16
	SUB <Horz_Scroll
	STA BrickBust_X	 ; Store X base coordinate

	LDA #$00	 
	STA BrickBust_XDist	 ; Reset X fan out distance
	STA BrickBust_HEn	 ; Reset horizontal enablers

	LDA #-6	 
	STA BrickBust_YVel	 ; Y velocity = -6

	LDA #$01	
	STA Score_Earned	 ; 10 points!

	LDY #CHNGTILE_DELETETOBG
	STY <Temp_Var12		 ; Temp_Var12 = CHNGTILE_DELETETOBG

	LDY #$80	 	; Y = $80
	RTS		 ; Return

LATP_Vine:
	LDY #$00	 ; Y = 0 (??)

	; Vine raise sound!
	LDA Sound_QLevel1
	ORA #SND_LEVELVINE
	STA Sound_QLevel1

	LDY #$06	 ; Y = 6 (vine) (index into PRG001 Bouncer_PUp)
	RTS		 ; Return

LATP_10Coin:
	LDA <Temp_Var16
	ORA <Temp_Var15
	STA B10Coin_ID	 ; X & Y are merged into a sort of unique ID for this block

	LDA #$09
	STA B10Coin_Count ; Set coin counter to 9

	LDA #200
	STA B10Coin_Timer ; B10Coin_Timer = 200

	JMP LATP_Coin	; Jump to common coin routine...

LATP_1up:
	JSR Level_RecordBlockHit	 ; Record having grabbed this 1-up so it does not come back

	LDA #$00
	STA PUp_StarManFlash	 ; PUp_StarManFlash = 0 (don't activate star man flash)

	LDY #$07	 ; Y = 7 (1-up) (index into PRG001 Bouncer_PUp)

	RTS		 ; Return

LATP_PSwitch:
	LDY #$05	 ; Y = 5

PRG008_B8BE:
	LDA SpecialObj_ID,Y
	BEQ PRG008_B8C9	 ; If this is a free spawn event slot, jump to PRG008_B8C9
	DEY		 ; Y--
	BPL PRG008_B8BE	 ; While Y >= 0, loop!
	JMP PRG008_B8D3	 ; Jump to PRG008_B8D3

PRG008_B8C9:
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y	 ; Special object "poof"
	LDA #$20	 
	STA SpecialObj_Data,Y	 ; Used as "counter" while poof is in effect

PRG008_B8D3: 
	LDA <Temp_Var14	 ; Get Y Low
	AND #$F0	 ; Align to tile grid
	SUB #16		 ; Above hit tile
	PHP		 ; Save processor status

	CPY #$00
	BLS PRG008_B8E2	 ; If index < 0, then we don't have a special object, and skip setting Y Lo

	STA SpecialObj_YLo,Y	 ; Otherwise, store Y Lo

PRG008_B8E2:
	STA Level_BlockChgYLo	 ; Store block change Y low coord
	PLP		 ; Restore processor status

	LDA <Temp_Var13	 ; Get Y high
	SBC #$00	 ; Apply carry as necessary from previous subtraction

	CPY #$00	 
	BLS PRG008_B8F1	 ; If index < 0, then we don't have a special object, and skip setting Y Hi
	STA SpecialObj_YHi,Y	 ; Otherwise, store Y Hi

PRG008_B8F1:
	STA Level_BlockChgYHi	 ; Store block change Y high coord

	LDA <Temp_Var16	 ; Get X Low

	CPY #$00
	BLS PRG008_B8FD	 ; If index < 0, then we don't have a special object, and skip setting X Lo
	STA SpecialObj_XLo,Y	 ; Otherwise, store X Lo

PRG008_B8FD:
	STA Level_BlockChgXLo	 ; Store block change X low coord

	LDA <Temp_Var15		 ; Get X Hi
	STA Level_BlockChgXHi	 ; Store block change X high coord

	LDA #CHNGTILE_PSWITCHAPPEAR	 
	STA Level_ChgTileEvent	 ; Queue P-Switch appear!

	LDY #$01	 ; Y = 1 (index into PRG001 Bouncer_PUp, i.e. nothing)
	RTS		 ; Return

LATP_BrickAltClear:
	JSR LATP_Brick	 ; Act like a brick!  ('A' = 0 when small)
	BEQ PRG008_B916	 ; If Player is small, then do nothing...

	LDA #CHNGTILE_DELETETOBGALT
	STA <Temp_Var12	 ; Temp_Var12 = 12

PRG008_B916:
	RTS		 ; Return

LATP_CoinCommon:
	INC Coins_Earned ; One more coin earned
	INC Coins_ThisLevel	 ; One more coin earned this level

	; Y Lo - into Temp_Var1
	LDA <Temp_Var14	
	STA <Temp_Var1	

	; X Lo - center it up, shove into Temp_Var2
	LDA <Temp_Var16
	ORA #$04
	STA <Temp_Var2

	JMP PRG000_C49B	 ; Jump to PRG000_C49B (common "power up" coin entry)


	; Special routine which gets a coin above a ? block, if one is present!
LATP_GetCoinAboveBlock:
	LDA <Temp_Var14
	PHA		 ; Save Temp_Var14 (Y Lo)
	SUB #16	
	STA <Temp_Var14	 ; Temp_Var14 -= 16 (get tile above)

	STX <Temp_Var5	 ; Backup X into Temp_Var5
	JSR Player_GetTileAndSlope_Normal	 ; Get a tile here
	LDX <Temp_Var5	 ; Restore X into Temp_Var5

	CMP #TILEA_COIN
	BNE PRG008_B948	 ; If tile above is not a coin, jump to PRG008_B948

	; Tile above was a coin...
	; The following will collect the coin along with the ? block hit!

	LDA #CHNGTILE_DELETETOBG
	JSR Level_QueueChangeBlock	; Delete to background

	PLA		 
	STA <Temp_Var14		 ; Restore Temp_Var14
	JMP LATP_CoinCommon	 ; Jump to common coin routine

PRG008_B948:
	PLA		 
	STA <Temp_Var14	 ; Restore Temp_Var14
	RTS		 ; Return


Player_TailAttack_Offsets: ; (Y and X)
	.byte 28, -6	; Player not horizontally flipped
	.byte 28, 21	; Player horizontally flipped

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_TailAttack_HitBlocks
;
; Short routine that handles the tail attack hitting blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_TailAttack_HitBlocks:
        LDA Player_TailAttack
        CMP #$09
        BNE PRG008_B979        ; If Player_TailAttack <> 9, jump to PRG008_B979

        LDY #$00         ; Y = 0 (Player not flipped)

	LDA <Player_FlipBits
	BNE PRG008_B95F	 ; If Player is horizontally flipped, jump to PRG008_B95F

	LDY #$02	 ; Y = 2 (Player flipped)

PRG008_B95F:
	LDA Player_TailAttack_Offsets,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)
	LDA Player_TailAttack_Offsets+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

	JSR Player_GetTileAndSlope	 ; Get tile near tail

	LDX #$04	 
	STA Level_Tile_GndL,X	 ; Store into tail's special slot
	JSR Level_DoBumpBlocks	 ; Handle blocks that can be "bumped"

	LDA #$01
	STA Player_BounceDir	 ; Player_BounceDir = 1 (bounced sideways)

PRG008_B979:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Object_BumpOffBlocks
;
; Handle a kicked shelled object bouncing off blocks.  Modifies
; Level_Tile_Whack as part of the logic (i.e. like the Player
; tail-attacked whatever block got hit) 
; A = input detected tile by kicked shelled object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Object_BumpOffBlocks:
	LDX #$04	 ; X = 4 
	STA Level_Tile_GndL,X	 ; Essentially store into Level_Tile_Whack
 
	LDA Player_Bounce 
	BNE PRG008_B9D3	 ; If Player is bouncing, jump to PRG008_B9D3 
 
	JSR Level_DoBumpBlocks	 ; Have kicked object hit bumpable blocks

	LDA Player_Bounce 
	BEQ PRG008_B994	 ; If block is NOT a bouncing type, jump to PRG008_B994  

	; Set bounce direction and flag that it was an object that bounced
	LDA #$01 
	STA Player_BounceDir 
	STA Player_BounceObj 

PRG008_B994:
	LDA Level_TilesetIdx
	CMP #10
	BNE PRG008_B9D3	 ; If Level_TilesetIdx <> 10 (Giant World), jump to PRG008_B9D3 (RTS)
 
	LDX #$04	 ; X = 4 

	LDA Objects_Timer,X 
	BNE PRG008_B9D3	 ; If this object's timer is NOT expired, jump to PRG008_B9D3

	; Object's YHi = Temp_Var13 (aligns to initiator's tile detect Y Hi) 
	LDA <Temp_Var13	 
	STA <Objects_YHi,X

	; Object's Y = Temp_Var14 - 16 (aligns to one tile above the initator's tile detect Y)
	LDA <Temp_Var14 
	SUB #16 
	BCS PRG008_B9AF 
	DEC <Objects_YHi,X	; Apply carry if needed
PRG008_B9AF: 
	AND #$e0	 ; Keep value sane 
	ORA #$10	 
	STA <Objects_Y,X
 
	; Object's XHi = Temp_Var15 (aligns to initiator's tile detect X Hi) 
	LDA <Temp_Var15	 
	STA <Objects_XHi,X

	; Object's X = Temp_Var16 (aligns to initator's tile detect X)
	LDA <Temp_Var16 
	AND #$e0	 ; Keep value sane 
	STA <Objects_X,X 

	SUB <Horz_Scroll 
	TAY		 ; Y = screen scroll relative X
 
	LDA <Objects_XHi,X 
	SBC <Horz_Scroll_Hi 
	BNE PRG008_B9D3	 ; If Object is not on same screen, jump to PRG008_B9D3 (RTS)
 
	CPY #224
	BGE PRG008_B9D3	 ; If object X is further than screen coordinate 224, jump to PRG008_B9D3 (RTS)  

	; Set object's Var2 to object detected by Player's tail attack
	LDA Level_Tile_Whack 
	STA Objects_Var2,X 

PRG008_B9D3:
	RTS		 ; Return

	; "Slope correction" values; as Player transitions from one slope tile to the next,
	; slight Player_Y correction is needed to keep him on track.  The left value pairs
	; are for when moving up a slope, the right pair is for when moving down a slope.
	; Thus -1 to bump up to then next tile going up, or +16 to bump down when going down
Slope_CorrectH:	.byte $FF, $00	; sign extension of next two values 
Slope_CorrectL:	.byte -1, 16

PRG000_B9D8:	; <-- go back up from here
        LDY #(TileAttrAndQuad_OffsSloped_Sm - TileAttrAndQuad_OffsSloped) + 6         ; Y = $16 (Player small or ducking)

        LDA Player_IsDucking 
        BNE PRG008_B9E5  ; If Player is ducking, jump to PRG008_B9E5

        LDA <Player_Suit
        BEQ PRG008_B9E5  ; If Player is small, jump to PRG008_B9E5
 
	LDY #$06	 ; Y = $06 (Player not small, not ducking; 6 because of 3 * 2 = 6, based on X = 3 down below)

PRG008_B9E5:
	LDA <Player_X
	AND #$0f	 ; offset within tile column
	CMP #$08	 
	BPL PRG008_B9F2	 ; If Player is >= halfway across current tile, jump to PRG008_B9F2

	; Player is on left half of tile
	TYA		 
	ADD #$08
	TAY		 ; Y += 8	 

PRG008_B9F2:
	LDX #$03	 ; X = 3 (reason for +6 init to 'Y')

	; This loop handles detecting tiles at or near a detection point
	; Makes tile detection just a little fuzzier for sake of the Player
PRG008_B9F4:
	JSR Player_GetTileSlopeAndQuad	 ; Get quadrant and tile attribute info
	JSR Level_DoCommonSpecialTiles	 ; Handle any common special tiles

	DEY
	DEY		 ; Y -= 2

	DEX		 ; X--
	BPL PRG008_B9F4	 ; While X >= 0, loop!

	LDX #$00	 ; X = 0 (slope at feet)

	LDY #$00	 ; Y = 0 

	LDA Level_Tile_Slope,X	 ; Get this slope "shape"

	CMP #$04
	BEQ PRG008_BA58	 ; If slope "shape" = 4 (wall), jump to PRG008_BA58

	CMP #$08
	BEQ PRG008_BA58  ; If slope "shape" = 8 (unsloped ceiling), jump to PRG008_BA58

	LDY <Player_InAir
	BNE PRG008_BA1B	 ; If Player is mid air, jump to PRG008_BA1B

	LDY Player_NoSlopeStick
	BNE PRG008_BA1B	 ; If Player_NoSlopeStick is set (don't stick to slopes), jump to PRG008_BA1B

	CMP #$00
	BEQ PRG008_BA4F	 ; If slope "shape" = 0 (BG tile), jump to PRG008_BA58

PRG008_BA1B:
	LDY #$00
	STY Player_NoSlopeStick ; Clear Player_NoSlopeStick

	INX	; X = 1 (slope at head)
	LDA Level_Tile_Slope,X	 ; Get this slope "shape"

	CMP #$07
	BEQ PRG008_BA2C	 ; If slope "shape" = 7 (unsloped ground, not square tiles), jump to PRG008_BA2C

	CMP #$04	 
	BNE PRG008_BA77	 ; If slope "shape" <> 4 (wall), jump to PRG008_BA77

PRG008_BA2C:
	; Note: Jump here for slope "shape" of 7 (unsloped ground) or 4 (wall)
	; Use for Player rubbing against sloped ceiling, specifically for the
	; "solid square" type of tiles listed above, "push" the Player completely
	; beneath the block so that he (crudely) tracks the ceiling slope

	; XX/
	; X/   <-- Where 'X' is e.g. a type 4 slope, Player is pushed to its
	; /        bottom, keep him at the ceiling and not creeping into it

	LDX <Player_Suit
	BEQ PRG008_BA38	 ; If Player is small, jump to PRG008_BA38

	LDX #$01	 ; X = 1

	LDA Player_IsDucking
	BEQ PRG008_BA38	 ; If Player is NOT ducking, jump to PRG008_BA38

	DEX		 ; Otherwise, X = 0

PRG008_BA38:
	LDA <Player_Y
	ADD PlayerY_HeightOff,X ; Add appropriate offset to where the top of the Player's "head" should be
	JSR Negate	 ; Negate this value
	AND #$0f	 ; But keep only lower 4 bits (essentially, we calculated 15 - offset)
	ADD <Player_Y	 ; Add this with Player_Y
	BCC PRG008_BA4A	 ; If no carry, jump to PRG008_BA4A

	INC <Player_YHi	 ; Otherwise, apply carry

PRG008_BA4A:
	STA <Player_Y	 ; Update Player_Y
	JMP PRG008_BA69	 ; Jump to PRG008_BA69

PRG008_BA4F:

	; Note Y = 0 here

	LDA <Player_Y
	AND #$0f	 ; Tile row offset of Player Y
	CMP #10
	BLS PRG008_BA77	 ; If Player's row offset is less than 10, jump to PRG008_BA77

	INY		 ; Otherwise, Y = 1

PRG008_BA58:
	; Note: Direct jump on slope shapes 0 (BG tile), 4 (wall), and 8 (unsloped ceiling)
	; Used for corrections while Player runs along a slope

	LDA <Player_Y
	AND #$F0	 	; Tile grid aligned Y
	ADD Slope_CorrectL,Y	; Add appropriate offset based on Player's relative vertical position within tile
	STA <Player_Y		; Update Player Y

	; Apply carry as needed
	LDA <Player_YHi
	ADC Slope_CorrectH,Y
	STA <Player_YHi	

PRG008_BA69:
	; Get proper base offset into TileAttrAndQuad_OffsSloped for checking at Player's feet or head
	LDA Slope_ChkFeetOrHead,X	 ; X = 0 for floor, 1 for ceiling

	LDY <Player_Suit
	BEQ PRG008_BA73	 ; If Player is small, jump to PRG008_BA73

	ADD #(TileAttrAndQuad_OffsSloped_Sm - TileAttrAndQuad_OffsSloped)	; Otherwise, add 16 to height at this point on slope (NOTE: Ducking included!)

PRG008_BA73:
	TAY		 ; Y = A
	JSR Player_GetTileSlopeAndQuad	 ; Get quadrant and tile attribute info

PRG008_BA77:
	; Note: Jump here for something not an unsloped floor or wall
	; Generally all paths drop you here...

	LDY #$02	 ; Y = 2 (checking "in front" tiles, lower and upper)
	JSR Level_CheckGndLR_TileGTAttr
	BCC PRG008_BABC	 ; If not touching a solid tile, jump to PRG008_BABC

	LDA Player_LowClearance
	BNE PRG008_BABC	 ; If Player_LowClearance is set, jump to PRG008_BABC

	LDX #$00	 ; X = 0
	LDY #$01	 ; Y = 0
	LDA <Player_X	
	AND #$0f	 
	CMP #$08
	BGS PRG008_BA92	 ; If Player is more than halfway across the tile, jump to PRG008_BA92

	; Otherwise...
	INX		 ; X = 1
	LDY #-1		 ; Y = -1

PRG008_BA92:
	LDA PRG008_B3B0,X ; Get appropriate offset
	ADD <Player_X	 ; Add Player_X
	AND #$0f	 ; Make tile relative
	BEQ PRG008_BABC	 ; If result = 0, jump to PRG008_BABC

	TYA
	BPL PRG008_BAA1	 ; If Y is not -1, jump to PRG008_BAA1

	DEC <Player_XHi	 ; Otherwise, Player_XHi--

PRG008_BAA1:
	ADD <Player_X	 ; Add Player_X to offset
	STA <Player_X	 ; Update Player_X

	BCC PRG008_BAAA	 ; If no carry, jump to PRG008_BAAA

	INC <Player_XHi	 ; Otherwise, apply carry

PRG008_BAAA:
	INY		 ; Y++ (0 or 1, depending)

	LDA <Player_XVel
	BPL PRG008_BAB1	 ; If Player is moving rightward, jump to PRG008_BAB1

	DEY		 
	DEY		 ; Y -= 2 (guarantees 'Y' is not zero)

PRG008_BAB1:
	TYA		 
	BNE PRG008_BABC	 ; If Y <> 0, jump to PRG008_BAB1

	; Player hit wall; stop!
	STA <Player_XVel
	STA Player_Slide
	INC Player_WalkAnimTicks

PRG008_BABC:
	LDX #$00	 ; X = 0
	LDY Level_Tile_Slope	 ; Y = Level_Tile_Slope (slope "shape" index at feet)
	LDA Slope_IsNotFloorShape,Y
	BEQ PRG008_BAC7	 ; If 0 (this is a floor slope tile), jump to PRG008_BAC7

	; We hit a ceiling type tile; set X = 1, so to check ceiling tiles
	INX	; X = 1

PRG008_BAC7:
	LDA <Player_X		 
	ADD TileAttrAndQuad_OffsSloped+1
	AND #$0f	 
	STA <Temp_Var1		 ; Temp_Var1 = (Player_X + [TileAttrAndQuad_OffsSloped+1]) & $0F (offset locked across tile)

	LDA Level_Tile_Slope,X
	TAY		; Y = slope

	; Tile "shape" index values $1x will add 1 to Level_GndLUT_Addr+1
	; Because of 16 entries per tile in Slope_LUT
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ADD <Level_GndLUT_Addr+1
	STA <Level_GndLUT_Addr+1

	; Lower 4 bits of "shape" index value shifted up (so $0-$F * $10)
	; Because of 16 entries per tile in Slope_LUT
	TYA
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var1	; Apply existing offset across tile
	STA <Temp_Var1	; -> Temp_Var1 (now offset into Slope_LUT for specific height of slope)

	LDA Slope_PlayerVel_Effect,Y
	STA <Temp_Var16	 ; Temp_Var16 = effect on velocity by this slope

	LDY <Temp_Var1	 ; Y = Temp_Var1 (calculated height from slope)
	TXA		 ; A = 0 (floor slope tile) or 1 (non-floor slope tile)
	BNE PRG008_BAF4	 ; If non-floor slope, jump to PRG008_BAF4
	JMP PRG008_BB69	 ; Otherwise, jump to PRG008_BB69

PRG008_BAF4:

	; Non-floor slope...

	LDA Level_Tile_Slope+1	; Assumed since X = 1 anyway
	CMP #$00
	BNE PRG008_BB1B	 ; If slope tile at head <> 0 (BG tile), jump to PRG008_BB1B

	; Slope tile at head is a BG tile...

	LDA <Player_InAir
	BNE PRG008_BB1A	 ; If Player is mid air, jump to PRG008_BB1A (RTS)

	; This has to do with Player walking off an edge (e.g. cliff-like) on a sloped level
	; The tile being stepped off from does not necessarily need to be a slope-related tile.

	LDX #4		; X = 4
	LDY #(TileAttrAndQuad_OffsSlopeEdge - TileAttrAndQuad_OffsSloped)
	LDA <Player_X	
	AND #$0f	
	CMP #$08	
	BGS PRG008_BB0D	 ; If Player is more than halfway across current tile, jump to PRG008_BB0D

	; Otherwise, Y += 2
	INY
	INY

PRG008_BB0D:
	JSR Player_GetTileSlopeAndQuad	 ; Get tile slope and quadrants
	CMP #$03	 
	BEQ PRG008_BB1A	 ; If slope = 3, jump to PRG008_BB1A (RTS)

	LDA #$00
	STA <Player_YVel	 ; Player_YVel = 0 (stop vertical movement)

	INC <Player_InAir	 ; Set Player in mid air!

PRG008_BB1A:
	RTS		 ; Return

PRG008_BB1B:

	; Player head ceiling tile check, not BG tile

	LDX <Player_Suit
	BEQ PRG008_BB27	 ; If Player is small, jump to PRG008_BB27

	LDX #$01	 ; X = 1

	LDA Player_IsDucking
	BEQ PRG008_BB27	 ; If Player is NOT ducking, jump to PRG008_BB27

	DEX		 ; X = 0 (they could've just put the duck check before X = 1, right?)

PRG008_BB27:
	LDA <Player_Y		 ; Get Player Y
	ADD PlayerY_HeightOff,X	 ; Add appropriate offset based on ducking or not
	AND #$0f	 	; Make Y relative to current tile
	STA <Temp_Var1		 ; -> Temp_Var1

	; Ceiling slope impact

	; The upper 4 bits hold the ceiling slope height value, so need to shift right by 4
	LDA [Level_GndLUT_Addr],Y
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var2		 ; Temp_Var2 = ceiling slope height

	SUB <Temp_Var1
	BMI PRG008_BB68	 ; If Temp_Var1 (relative vertical position on tile) > Temp_Var2 (height at this point on slope), jump to PRG008_BB68 (RTS)

	INC Player_HitCeiling	 ; Flag Player as having hit head off this sloped ceiling

	PHA		 ; Save difference

	LDA <Player_YVel
	BPL PRG008_BB52	 ; If Player_YVel >= 0 (Player moving downward), jump to PRG008_BB52

	LDA Level_AScrlVVel	 ; Get autoscroll vertical velocity
	JSR Negate	 ; Negate it
	BPL PRG008_BB50	 ; If positive, jump to PRG008_BB50

	LDA #$00	 ; Otherwise, just set to zero

PRG008_BB50:
	STA <Player_YVel ; Store as Player's Y velocity

PRG008_BB52:
	PLA		 ; Restore difference

	LDY Level_Tile_Slope+1
	CPY #$03
	BNE PRG008_BB5F	 ; If Level_Tile_Slope+1 <> 3 (solid square tile), jump to PRG008_BB5F

	LDY Player_LowClearance
	BNE PRG008_BB68	 ; If Player_LowClearance is set, jump to PRG008_BB68 (RTS)

PRG008_BB5F:
	ADD <Player_Y	 
	STA <Player_Y	 ; Add to Player_Y

	BCC PRG008_BB68	 ; If no carry, jump to PRG008_BB68 (RTS)

	INC <Player_YHi	 ; Otherwise, apply carry!

PRG008_BB68:
	RTS		 ; Return

PRG008_BB69:

	; Player feet floor tile check

	LDX <Temp_Var16	 ; X = Temp_Var16 (effect on velocity by this slope)

	LDA <Player_InAir
	BEQ PRG008_BB7E	 ; If Player is NOT mid air, jump to PRG008_BB7E

	; Player is mid air...

	LDA <Player_YVel
	CMP #-$1c
	BLS PRG008_BB1A	 ; If Player Y velocity < -$1C, jump to PRG008_BB1A (RTS)

	; Get difference between Player and ground slope height

	LDA <Player_Y	
	AND #$0f		; Get Player's vertical position within tile
	SUB [Level_GndLUT_Addr],Y	 ; NOTE: This makes an assumption that the would-be ceiling component is always zero!!
	BMI PRG008_BB1A	 ; If 'A' (relative vertical position on tile) > (height at this point on slope), jump to PRG008_BB1A (RTS)

PRG008_BB7E:
	LDA #$00
	STA <Player_InAir ; Player is no longer mid air!
	STA <Player_YVel  ; Player hit solid!
	STA Kill_Tally	  ; Reset Kill_Tally

	; Ground slope impact

	LDA [Level_GndLUT_Addr],Y
	AND #$0f		; Lower 4 bits hold ground slope height
	STA <Temp_Var1	 ; Temp_Var1 = fractional slope value

	LDA <Player_Y
	AND #$F0
	ADD <Temp_Var1	; Slope height adjustment
	STA <Player_Y	 ; Set Player's position on slope!

	BCC PRG008_BB9A	 ; If no carry, jump to PRG008_BB9A

	INC <Player_YHi	 ; Otherwise, apply carry

PRG008_BB9A:
	TXA		 ; Effect on velocity -> 'A'
	BEQ PRG008_BBA1	 ; If none, jump to PRG008_BBA1

	; Otherwise...
	EOR <Player_XVel 
	AND #$80	 ; Sort of aboslute

PRG008_BBA1:
	STA Player_UphillFlag ; Set whether player is marching uphill!

	LDA Player_InWater
	BEQ PRG008_BBB0	 ; If Player is NOT underwater, jump to PRG008_BBB0

	LDA #$00
	STA Player_Slide ; Otherwise, stop sliding!

	BEQ PRG008_BC0D	 ; Jump (technically always) to PRG008_BC0D

PRG008_BBB0:
	TXA		 ; Effect on velocity -> 'A'

	LDY Player_Slide 
	BEQ PRG008_BBBF	 ; If Player is NOT sliding, jump to PRG008_BBBF

	; Get absolute value of slide
	BPL PRG008_BBBB	 
	JSR Negate 
PRG008_BBBB:

	CMP #$00
	BLS PRG008_BBFD	 ; If slide < 0, jump to PRG008_BBFD (should never happen because of absolute value??)

PRG008_BBBF:
	LDA Player_Slide
	BNE PRG008_BBE0	 ; If Player is sliding, jump to PRG008_BBE0

	; Check ability to slide

	TXA		 ; Effect on velocity -> 'A'
	BEQ PRG008_BC0D	 ; If no effect (flat ground), jump to PRG008_BC0D

	LDY <Player_Suit
	LDA PowerUp_Ability,Y
	AND #$02	 
	BNE PRG008_BC0D	 ; If the Player's suit CANNOT slide on slopes, jump to PRG008_BC0D

	LDA Player_Kuribo
	BNE PRG008_BC0D	 ; If Player is wearing Kuribo's shoe, jump to PRG008_BC0D

	LDA <Pad_Holding
	AND #(PAD_DOWN | PAD_LEFT | PAD_RIGHT)	; checking down/left/right
	CMP #PAD_DOWN	; but we only want down
	BNE PRG008_BC0D	 ; If NOT only pressing ONLY down, jump to PRG008_BC0D

	JSR PRG008_AEB6	 ; Set sliding frame

PRG008_BBE0:
	TXA		 ; Effect on velocity -> 'A'
	ADD Player_Slide
	STA Player_Slide ; Apply effect to Player_Slide

	; Absolute value of Player_Slide
	BPL PRG008_BBED	
	JSR Negate	
PRG008_BBED:

	CMP #$40
	BLS PRG008_BBFD	 ; If magnitude of Player_Slide < $40, jump to PRG008_BBFD

	; Player is sliding too fast!! 
	; If Player_Slide is negative, stop it at -$40, otherwise stop it at $40
	LDY #$40
	LDA Player_Slide
	BPL PRG008_BBFA
	LDY #-$40	
PRG008_BBFA:
	STY Player_Slide

PRG008_BBFD:
	DEC Player_Slide ; Player_Slide--
	BPL PRG008_BC08	 ; If Player_Slide >= 0, jump to PRG008_BC08

	; Amounts to a single increment (against the above decrement) for negative Player_Slide
	INC Player_Slide
	INC Player_Slide

PRG008_BC08:
	LDA Player_Slide
	STA <Player_XVel ; Player_XVel = Player_Slide

PRG008_BC0D:
	LDA <Player_XVel
	BEQ PRG008_BC14	 ; If Player_XVel = 0 (came to a stop), jump to PRG008_BC14 (RTS)

	STX Player_SlideRate	 ; Otherwise, update Player_SlideRate with velocity effect value

PRG008_BC14:
	RTS		 ; Return

	; Offset into TileAttrAndQuad_OffsSloped for checking at Player's feet or head
Slope_ChkFeetOrHead:	.byte $00, $02	; Left value is small/ducking, right value is otherwise

	; Fills in the Level_Tile_Quad[rant] and Level_Tile_Slope values
Player_GetTileSlopeAndQuad:

	; 'X' defines which tile index to do
	; 'Y' defines an X and Y offset index for the TileAttrAndQuad_OffsSloped table

	LDA TileAttrAndQuad_OffsSloped,Y
	STA <Temp_Var10	 ; Temp_Var10 (Y offset)
	LDA TileAttrAndQuad_OffsSloped+1,Y
	STA <Temp_Var11	 ; Temp_Var11 (X offset)

	JSR Player_GetTileAndSlope ; Get tile
	STA Level_Tile_GndL,X	 ; Store into appropriate location

	AND #$c0	 ; Get quadrant of tile
	ASL A
	ROL A
	ROL A		 ; A = 0-3, based on quadrant
	STA Level_Tile_Quad,X	; Store quadrant

	LDA <Player_Slopes	 ; Get slope
	STA Level_Tile_Slope,X	 ; Store slope
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoSpecialTiles
;
; Handles special tiles unique to level styles:
; Pipe logic, conveyors, spikes, muncher/jelectro, white block, 
; quicksand, toad house treasure chests... 
; Good place to put custom-by-Tileset tiles!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; This table enables certain pipe tiles by tileset 
	; (since some have more pipe tile types than others)
	; bit 6 enables TILE8_PIPEH3_B (not enterable)
	; bit 7 enables TILE3_PIPETB5_L/R (takes Player to common exit area)
PipeTile_EnableByTileset:
	; Indexed by Level_TilesetIdx
	.byte %00000000	;  0 Plains style
	.byte %00000000	;  1 Mini Fortress style
	.byte %10000000	;  2 Hills style
	.byte %00000000	;  3 High-Up style
	.byte %00000000	;  4 pipe world plant infestation
	.byte %00000000	;  5 water world
	.byte %00000000	;  6 Toad House
	.byte %11000000	;  7 Vertical pipe maze
	.byte %01000000	;  8 desert levels
	.byte %00000000	;  9 Airship
	.byte %11000000	; 10 Giant World
	.byte %00000000	; 11 Ice level
	.byte %11000000	; 12 Sky level
	.byte %10000000	; 13 Underground

PRG008_BC43:
	.byte $08, $04, $04	; Offset applied to Player_X when: in air or level is sloped, Player is NOT small, Player is small

Pipe_PadDirForEnter:	
	.byte PAD_RIGHT, PAD_LEFT	; What to press to enter a horizontal pipe; pad right and left, respectively
	.byte PAD_DOWN, PAD_UP		; What to press to enter a vertical pipe; pad down and up, respectively


	; The sliding values applied when Player is touching a conveyor
ConveyorSlide:	.byte 16, -16

	.byte $01, $0F

	; To check for damage caused by the fully extended piranha
	; Note that they technically count touching their base pipes
	; as a damage too!  Careful about that, eh?
PlantInfest_PiranhaTiles: .byte TILE5_MUNCHER_2, TILE5_MUNCHER_1
PlantInfest_MiniPipes:	.byte TILE5_MINIPIPE_TOP2, TILE5_MINIPIPE_TOP1

Player_DoSpecialTiles:

	LDA Player_Statue
	ORA Player_TailAttack
	ORA Player_Flip	 
	BNE PRG008_BCA7	 ; If Player is a Tanooki Statue, tail attacking, or invincibility flipping, jump to PRG008_BCA7

	LDY Level_TilesetIdx	 ; Y = Level_TilesetIdx

	; Copy in the mask of allowable pipe tiles -> Temp_Var16
	LDA PipeTile_EnableByTileset,Y
	STA <Temp_Var16

	LDA <Player_InAir
	BNE PRG008_BCAA	 	; If Player is mid air, jump to PRG008_BCAA

	LDA Level_Tile_InFL	 ; Get tile near head...

	LDY Level_7Vertical
	BEQ PRG008_BC79	 ; If Level is NOT a vertical level, jump to PRG008_BC79

	; Vertical level...

	LDY #$02	 ; Y = 2
	CMP #TILE8_SCENPIPE_ENDH1B
	BEQ PRG008_BC87	 ; If tile near head is TILE8_SCENPIPE_ENDH1B, jump to PRG008_BC87

	LDY #$00	 ; Y = 0

PRG008_BC79:
	CMP #TILE1_PIPEH1_B
	BEQ PRG008_BC87	 ; If tile near head is TILE1_PIPEH1_B, jump to PRG008_BC87

	BIT <Temp_Var16	 ; PipeTile_EnableByTileset value
	BVC PRG008_BCAA	 ; If Temp_Var16 bit 6 is clear (TILE8_PIPEH3_B disabled), jump to PRG008_BCAA

	LDY #$03	 ; Y = 3

	CMP #TILE8_PIPEH3_B
	BNE PRG008_BCAA	 ; If tile near head is NOT TILE8_PIPEH3_B, jump to PRG008_BCAA

PRG008_BC87:
	LDX #$00	 ; X = 0 

	LDA <Player_X
	AND #$0f	
	CMP #$08	
	BLS PRG008_BC92	 ; If Player is on left half of tile, jump to PRG008_BC92
 
	INX		 ; X = 1

PRG008_BC92:
	LDA <Pad_Holding
	AND Pipe_PadDirForEnter,X
	BEQ PRG008_BCAA	 ; If Player is NOT pressing correct direction to enter pipe, jump to PRG008_BCAA

	; Correct direction to enter pipe...

	TYA
	BNE PRG008_BCA4	 ; If pipe type (Y) is not 0, jump to PRG008_BCA4

	LDY #$01	 ; Y = 1 

	LDA LevelJctBQ_Flag	
	BEQ PRG008_BCA4	 ; If not currently junctioning, jump to PRG008_BCA4

	DEY		 ; Y = 0 

PRG008_BCA4:
	JSR PipeEntryPrepare	 ; Prepare pipe entry

PRG008_BCA7:
	JMP PRG008_BD4B	 ; Jump to PRG008_BD4B

PRG008_BCAA:
	LDX #$02	 ; X = 2
	LDA Level_Tile_GndL	 

	LDY <Player_InAir
	BEQ PRG008_BCC4	 ; If Player is NOT mid air, jump to PRG008_BCC4

	LDY Player_HitCeiling
	BEQ PRG008_BCA7	 ; If Player has not just hit off a ceiling, jump to PRG008_BCA7

	LDY Player_IsDucking
	BEQ PRG008_BCC0	 ; If Player is NOT ducking, jump to PRG008_BCC0

	JMP PRG008_BD4B	 ; Otherwise, jump to PRG008_BD4B

PRG008_BCC0:
	INX		 ; X = 3

	LDA Level_Tile_GndR	 

PRG008_BCC4:
	STA <Temp_Var1		 ; Store tile -> Temp_Var1
	STX <Temp_Var3		 ; Store pipe mode -> Temp_Var3

	LDA #TILE1_PIPETB2_R
	SUB <Temp_Var1	
	CMP #$04		; Looking to compare the pipe tile against any of the vertical pipe 1 & 2 end tiles

	LDY LevelJctBQ_Flag
	BEQ PRG008_BCD6	 ; If not in a Big Question Block area, jump to PRG008_BCD6
 
	AND #$01	 ; Not sure what they need this for?

PRG008_BCD6:
	TAY		 ; Tile index result -> 'A'
	BCC PRG008_BCFA	 ; If tile was in range (from CMP above), jump to PRG008_BCFA

	; Not a pipe 1 or 2 end tile...

	LDY <Temp_Var16	 ; PipeTile_EnableByTileset value
	BPL PRG008_BCE8	 ; If bit 7 is clear (TILE3_PIPETB5_L/R disabled), jump to PRG008_BCE8

	LDA #TILE3_PIPETB5_R
	SUB <Temp_Var1
	CMP #$02
	LDY #$06	 ; Y = 6
	BCC PRG008_BCFA	 ; If tile was in range (Pipe 5 left/right), jump to PRG008_BCFA

PRG008_BCE8:
	LDA #TILE1_PIPETB4_R
	LDY Level_7Vertical
	BEQ PRG008_BCF1	 ; If NOT a vertical level, jump to PRG008_BCF1

	LDA #TILE8_SCENPIPE_ENDVR

PRG008_BCF1:
	SUB <Temp_Var1
	CMP #$02	
	BCS PRG008_BD4B	 ; If this pipe tile wasn't in range EITHER, jump to PRG008_BD4B

	; Pipe tile in range...

	LDY #$04	 ; Y = 4

PRG008_BCFA:
	STY <Temp_Var1	 ; Store pipe type -> Temp_Var1

	AND #$01	 ; Determine left vs right tile (odd/bit 0 indicates right tile)
	ASL A
	ASL A
	ASL A
	ASL A		 ; Multiply 0/1 by 16
	STA <Temp_Var2	 ; Temp_Var2 = 0 or 16

	LDA <Pad_Holding
	AND Pipe_PadDirForEnter,X
	BEQ PRG008_BD4B	 ; If Player is NOT pressing the correct direction to enter pipe, jump to PRG008_BD4B

	LDA Level_PipeMove
	BNE PRG008_BD4B	 ; If Player is already in pipe, jump to PRG008_BD4B

	LDY #$00	 ; Y = 0 (Player is mid-air or level is sloped)

	LDA <Player_InAir
	ORA Level_SlopeEn
	BNE PRG008_BD1F	 ; If Player is mid air or this is a sloping level, jump to PRG008_BD1F

	INY		 ; Y = 1 (Player is NOT small)
	LDA <Player_Suit
	BNE PRG008_BD1F	 ; If Player is NOT small, jump to PRG008_BD1F

	INY		 ; Y = 2 (Player is small)

PRG008_BD1F:
	LDA <Player_X	
	AND #$0f	
	PHA		 ; Save Player's relative X across tile

	ADD PRG008_BC43,Y ; Add appropriate offset
	AND #$10	 ; Check if on "odd" tile (only true on Player_X 16, 48, 80, etc.) AKA right tile
	BNE PRG008_BD30	 ; If so, jump to PRG008_BD30

	PLA		 ; Restore Player's relative X across tile
	ORA #$F0	 ; Make negative, sort of
	PHA		 ; Save it again

PRG008_BD30:
	PLA		 ; Restore Player's relative X across tile
	ADD <Temp_Var2	 ; 0 or 16, left or right tile
	SUB #3	 
	CMP #10
	BGE PRG008_BD4B	 ; If Player_X >= 10 after subtracting 3 (??), jump to PRG008_BD4B

	LDA <Temp_Var1	 ; Get pipe type
	LSR A		 
	TAY		 
	JSR PipeEntryPrepare	 ; Prepare entry into pipe!
	JSR PipeMove_SetPlayerFrame	 ; Update Player frame!
	JSR Player_Draw29	 ; Draw Player

	; Do not return to caller!!
	PLA		 
	PLA

	RTS		 ; Return

PRG008_BD4B:
	LDY Level_TilesetIdx

	LDA <Player_InAir
	BNE PRG008_BD73	 ; If Player is mid air, jump to PRG008_BD73

	LDA Level_PSwitchCnt
	BNE PRG008_BD73	 ; If P-Switch is active, jump to PRG008_BD73


	; CONVEYOR BELT LOGIC!

	LDX #$01	 ; X = 1 (check one tile by foot, then check the other!)

PRG008_BD59:
	LDA ConveyorEnable,Y
	BEQ PRG008_BD73	 ; If value is zero, jump to PRG008_BD73

	; Otherwise...
	SUB Level_Tile_GndL,X	 ; Subtract value we just retrieved 
	CMP #$02	 
	BGE PRG008_BD70	 ; If tile is >= 2, this is not a conveyor tile, jump to PRG008_BD70

	; We're on a conveyor tile!!

	TAX		 	; Transfer conveyor tile index -> 'X'
	LDA ConveyorSlide,X	; Get appropriate conveyor slide amount
	STA Player_SlideRate	; Set slide factor for conveyor
	JMP PRG008_BD73		; Jump to PRG008_BD73

PRG008_BD70:
	DEX		 ; X--
	BPL PRG008_BD59	 ; While X >= 0, loop!

	; SPIKE TILE LOGIC

PRG008_BD73:
	LDX #$02	 ; X = 2

PRG008_BD75:
	LDA SpikesEnable,Y
	CMP #$ff	 
	BEQ PRG008_BD96	 ; If specified value is $FF, no spikes here, jump to PRG008_BD96

	; Otherwise...
	SUB Level_Tile_Head,X
	CMP #$02
	BLT PRG008_BD89	 ; If this is a spike tile, jump to PRG008_BD89
	DEX		 ; X--
	BPL PRG008_BD75	 ; While X >= 0, loop!
	BMI PRG008_BD96	 ; Not a spike tile, jump to PRG008_BD96

PRG008_BD89:

	; It's a spike tile...

	LDA Player_Kuribo
	BEQ PRG008_BD93	 ; If Player is NOT in a Kuribo's shoe, jump to PRG008_BD93

	LDA Player_HitCeiling
	BEQ PRG008_BD96	 ; If Player has not just hit head off ceiling, jump to PRG008_BD96

PRG008_BD93:
	JMP Player_GetHurt	; Hurt Player!!

PRG008_BD96:
	LDX #$03	 ; X = 3

PRG008_BD98:
	LDA Level_Tile_GndL,X
	CMP MuncherJelectroSet,Y
	BEQ PRG008_BDA4		; If Player is touching muncher/jelectro (whichever is appropriate), jump to PRG008_BDA4
 
	; SB: This check seems superfluous and also incorrect
	CMP #TILEA_MUNCHER	; Assuming muncher tile!  Should be MuncherJelectroSet,Y?
	BNE PRG008_BDB1	 ; If Player is NOT touching a muncher, jump to PRG008_BDB1

	; Kuribo-on-muncher handling
PRG008_BDA4:
	LDA Player_Kuribo
	BEQ PRG008_BDAE	 ; If Player does NOT have Kuribo's shoe, jump to PRG008_BDAE (get hurt!)

	LDA Player_HitCeiling
	BEQ PRG008_BDB4	 ; If Player has not just hit off ceiling, jump to PRG008_BDB4

PRG008_BDAE:
	JMP Player_GetHurt	 ; Get hurt!

PRG008_BDB1:
	DEX		 ; X--
	BPL PRG008_BD98	 ; While X >= 0, loop!

PRG008_BDB4:
	LDA Level_Tileset
	CMP #$05	 
	BNE PRG008_BDEB	 ; If not in a pipe world plant infestation, jump to PRG008_BDEB

	; ALTERNATING PIRANHA HURT LOGIC IN INFESTATION LEVELS

	LDY #$00	 ; Y = 0 (first alternation piranha tile)

	LDA PatTable_BankSel+1
	CMP #$60	 
	BEQ PRG008_BDC9	 ; If current pattern table is $60, jump to PRG008_BDC9

	INY		 ; Y = 1 (second alternation piranha tile)
	CMP #$3e	 
	BNE PRG008_BDEB	 ; If current pattern table is NOT $3E, jump to PRG008_BDEB

PRG008_BDC9:
	LDX #$02	 ; X = 2

PRG008_BDCB:
	LDA Level_Tile_Head,X	; Get tile
	PHA		 ; Save tile 

	SUB PlantInfest_PiranhaTiles,Y
	CMP #$01	 
	PLA		 ; Restore tile
	BLT PRG008_BDE3	 ; If you just hit the piranha that's fully extended, you get hurt!

	CMP PlantInfest_MiniPipes,Y
	BEQ PRG008_BDE3	 ; If you even just touched his base pipe, you get hurt!

	DEX		 ; X--
	BPL PRG008_BDCB	 ; While X >= 0, loop!

	JMP PRG008_BDEB	 ; Jump to PRG008_BDEB

PRG008_BDE3:

	; Gonna get hurt!

	; SB: Interesting ... this never happens of course...
	LDA Player_Kuribo
	BNE PRG008_BDEB	 ; If Player is wearing Kuribo's shoe, jump to PRG008_BDEB

	JSR Player_GetHurt	 ; Get hurt!

PRG008_BDEB:

	; SLIPPERY, ICY GROUND LOGIC

	LDA #$00
	STA Player_Slippery	 ; Player_Slippery = 0 (default ground not slippery)

	LDA Level_TilesetIdx
	CMP #11
	BNE PRG008_BE31	 ; If not in an ice level, jump to PRG008_BE31

	LDA <Player_InAir
	BNE PRG008_BE31	 ; If Player is in air, jump to PRG008_BE31

	LDX #$01	 ; X = 1

PRG008_BDFD:
	LDA Level_Tile_GndL,X
	TAY		 ; Tile -> 'Y'

	SUB #TILE12_SNOWBLOCK_UL
	CMP #$03
	BLT PRG008_BE10	 ; If Player is on top of snow block, jump to PRG008_BE10	

	TYA		 ; Restore tile -> 'A'
	SUB #TILE12_GROUND_L
	CMP #$03
	BGE PRG008_BE16	 ; If Player is not on bottom ground, jump to PRG008_BE16

PRG008_BE10:
	INC Player_Slippery	 ; Player_Slippery = 1 (bottom ground is a little slippery!)
	JMP PRG008_BE31	 	; Jump to PRG008_BE31

PRG008_BE16:
	TYA		 ; Restore tile -> 'A'
	SUB #TILE12_LARGEICEBLOCK_UL
	CMP #$05
	BLT PRG008_BE26	 ; If Player is touching any of the small or large ice blocks, jump to PRG008_BE26

	CPY #TILE12_FROZENCOIN	
	BEQ PRG008_BE26	 ; If Player is touching frozen coin blocks, jump to PRG008_BE26

	CPY #TILE12_FROZENMUNCHER
	BNE PRG008_BE2E	 ; If Player is NOT touching frozen muncher blocks, jump to PRG008_BE2E

PRG008_BE26:
	LDA #$02	 
	STA Player_Slippery	 ; Player_Slippery = 2 (ground is REALLY slippery!)

	JMP PRG008_BE31	 ; Jump to PRG008_BE31

PRG008_BE2E:
	DEX		 ; X--
	BPL PRG008_BDFD	 ; While X >= 0, loop!

PRG008_BE31:
	LDA Level_TilesetIdx
	CMP #$00
	BNE PRG008_BE76	 ; If Player is NOT in a Plains style level, jump to PRG008_BE76

	LDY #$01	 ; Y = 1

PRG008_BE3A:
	LDA Level_Tile_GndL,Y

	SUB #TILE1_WBLOCKTH
	CMP #$03
	BLT PRG008_BE4E	 ; If Player is on a big white block, jump to PRG008_BE4E

	DEY		 ; Y--
	BPL PRG008_BE3A	 ; While Y >= 0, loop!

	; Not on a white block...

PRG008_BE47:
	LDA #$00	 
	STA Player_WhiteBlkCnt	 ; Reset white block counter if not on a white block!
	BEQ PRG008_BE76	 ; Jump (technically always) to PRG008_BE76

PRG008_BE4E:
	LDA <Pad_Holding
	AND #PAD_DOWN
	BEQ PRG008_BE47	 ; If Player is NOT pressing down, jump to PRG008_BE47

	INC Player_WhiteBlkCnt	 ; Player_WhiteBlkCnt++

	LDA Player_WhiteBlkCnt
	CMP #$F0	 
	BNE PRG008_BE76	 ; If Player_WhiteBlkCnt <> $F0, jump to PRG008_BE76

	; Count max reached!  Fall into background...

	LDA #$F0	 ; Superfluous!
	STA Player_Behind	 ; Set Player as behind the scene...

	; To make Player fall, do everything in our power to make sure
	; the Player doesn't get a chance to jump or anything else :)
	LDA #$00
	STA <Player_YVel	 ; Halt Player vertically 

	LDA <Player_Y
	ADD #$06
	STA <Player_Y		; Force Player down by 6 pixels (fall)

	INC <Player_InAir	 ; Set Player as in air

	; Don't register 'A' button
	LDA <Pad_Input
	AND #~PAD_A
	STA <Pad_Input

PRG008_BE76:
	LDA Level_TilesetIdx
	CMP #$02	 
	BEQ PRG008_BE81	 ; If level is Hills style, jump to PRG008_BE81

	CMP #$0d	
	BNE PRG008_BEE5	 ; If level is NOT underground style, jump to PRG008_BEE5

PRG008_BE81:

	; QUICKSAND LOGIC

	; Hills & Underground...

	LDA <Player_YVel
	BMI PRG008_BEE5	 ; If Player is moving upward, jump to PRG008_BEE5

	LDX #$03	 ; X = 3 

PRG008_BE87:
	LDA Level_Tile_GndL,X	 ; Get tile

	; If tile is TILE3_QUICKSAND_TOP or TILE3_QUICKSAND_MID, jump to PRG008_BE9D
	CMP #TILE3_QUICKSAND_TOP
	BEQ PRG008_BE9D
	CMP #TILE3_QUICKSAND_MID
	BEQ PRG008_BE9D

	DEX		 ; X--
	BPL PRG008_BE87	 ; While X >= 0, loop!

	LDA #$00
	STA Player_SandSink	 ; Player is not sinking in sand!

	JMP PRG008_BEE5	 ; Jump to PRG008_BEE5

PRG008_BE9D:

	; Sinking in quicksand!!

	LDA #$00	 
	STA Player_IsDucking	 ; Player is not ducking
	STA Player_Slide	 ; Player is not sliding

	LDA Player_SandSink
	BNE PRG008_BEAC	 	; If Player was already sinking in quicksand, jump to PRG008_BEAC

	LDA <Player_Y		 ; Get Player_Y at initial quicksand hit only...

PRG008_BEAC:
	AND #%11110000	 	; Keep only upper 4 bits
	STA Player_SandSink	 ; Set as Player_SandSink value

	LDA <Player_Y	
	SUB Player_SandSink	 ; Get difference between Player_Y and top of quicksand

	LDY #-$20	 ; Y = -$20 (escape jump vel)
	TAX		 ; difference -> 'X'
	AND #%11110000	 ; Keep only upper 4 bits
	BNE PRG008_BEC7	 ; If Player is not at top of sand, jump to PRG008_BEC7

	; Player must be close to top of sand...
	TXA		 ; difference back to 'A'
	AND #%00001111	 ; Keep only lower 4 bits
	CMP #$03	 
	BGE PRG008_BEC7	 ; If still at least 3 pixels under, jump to PRG008_BEC7

	LDY #-$30	 ; Otherwise, Y = -$30 (escape jump vel, almost out!)

PRG008_BEC7:
	LDA <Pad_Input
	BMI PRG008_BED2	 ; If Player is pressing 'A', jump to PRG008_BED2

	INC Player_SandSink	; Set bit 0 of Player_SandSink (sinking)

	LDY #$06	 ; Y = $06 (sinking vel)
	BNE PRG008_BEDA	 ; Jump (technically always) to PRG008_BEDA

PRG008_BED2:
	; Player is trying to escape!  Play jump sound!
	LDA Sound_QPlayer
	ORA #SND_PLAYERJUMP	
	STA Sound_QPlayer

PRG008_BEDA:

	STY <Player_YVel ; Set Player's Y velocity

	; Limit Player's horizontal movement
	LDA <Player_XVel
	ASL A		
	ROR <Player_XVel
	BPL PRG008_BEE5
	INC <Player_XVel
PRG008_BEE5:

	LDY Level_TilesetIdx
	CPY #$06	 
	BNE PRG008_BF03	 ; If level is not a Toad House, jump to PRG008_BF03 (RTS)

	BIT <Pad_Input
	BVC PRG008_BF03	 ; If Player is not pressing 'B', jump to PRG008_BF03 (RTS)

	JSR PChg_C000_To_29	 	; Change page @ C000 to 29
	JSR ToadHouse_ChestPressB	; Attempt to open a chest!
	JSR PChg_C000_To_0 		; Change page @ C000 to 0

	TXA		 ; X -> A 
	BEQ PRG008_BF03	 ; If no treasure box opened, jump to PRG008_BF03 (RTS)

	DEX		 ; X-- (fix to proper inventory index)

	LDA Level_BlockChgXLo
	JSR ToadHouse_GiveItem	; Pop out item!

PRG008_BF03:
	RTS		 ; Return


PipeMove_SetPlayerFrame:
	LDY <Player_Suit
	BEQ PRG008_BF0A	 ; If small, jump to PRG008_BF0A

	LDY #$02	 ; Otherwise, Y = 2

PRG008_BF0A:
	LDA Player_Kuribo
	BEQ PRG008_BF10	 ; If not wearing Kuribo's shoe, jump to PRG008_BF10

	INY		 ; Otherwise Y++

PRG008_BF10:
	LDA PipeMove_Frame,Y ; Get appropriate pipe traversal frame
	STA <Player_Frame	  ; Store as Player frame
	RTS		 ; Return


	; X and Y offsets to "correct" Player masking sprite when entering pipe
PipeEnter_XYOffs:
	.byte 16,   0	; right
	.byte  0,   0	; left
	.byte  0,  32	; up
	.byte  0, -16	; down	<-- not applied if Player is small


	; Does common stuff to prepare to enter a pipe!
PipeEntryPrepare:
	STX Level_PipeMove	 ; Set appropriate pipe movement

	; Play pipe sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPIPE
	STA Sound_QPlayer

	; If Y = 3, A = 4
	LDA #$04
	CPY #$03
	BEQ PRG008_BF49

	; If Y = 2, A = 5
	LDA #$05
	CPY #$02
	BEQ PRG008_BF49

	; If Y = 0, A = 2
	LDA #$02
	CPY #$00
	BEQ PRG008_BF49

	; Use A = 1 unless Level_PipeNotExit is set, in which case use A = 3
	LDA #$01	; A = 1 (pipe will exit level)
	LDY Level_PipeNotExit
	BNE PRG008_BF47		; If pipes in this level do NOT exit to map, jump to PRG008_BF47

	LDY LevelJctBQ_Flag
	BEQ PRG008_BF49	 ; If NOT in the Big Question Block area, jump to PRG008_BF49

PRG008_BF47:
	LDA #$03	 ; A = 3 (regular pipe mechanics)

PRG008_BF49:

	; Construct pipe movement
	ASL A
	ASL A
	ORA Level_PipeMove
	STA Level_PipeMove

	; Set timer while in pipe
	LDA #$3c
	STA Event_Countdown

	; X <<= 1 (pipe movement, shifted left 1)
	TXA
	ASL A
	TAX

	LDA <Player_X
	ADD PipeEnter_XYOffs,X	 ; Add appropriate X offset
	CPX #$04	 
	BGS PRG008_BF65	 	; If pipe movement is up/down, jump to PRG008_BF65

	AND #$F0	 ; Otherwise, align Player_X to grid

PRG008_BF65:
	STA <Pipe_PlayerX	; Update Player_X

	LDA <Player_Y
	CPX #$06	
	BNE PRG008_BF71	 ; If not a downward pipe, jump to PRG008_BF71

	LDY <Player_Suit
	BEQ PRG008_BF75	 ; If Player is small, jump to PRG008_BF75

PRG008_BF71:
	ADD PipeEnter_XYOffs+1,X ; Add appropriate Y offset

PRG008_BF75:
	AND #$F0	 ; Align Player_Y to grid

	CPX #$04	 
	BLS PRG008_BF7E	 ; If left/right pipe, jump to PRG008_BF7E

	SUB #$01	 ; Move Player up one pixel 

PRG008_BF7E:
	STA <Pipe_PlayerY ; Set Pipe_PlayerY

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_QueueChangeBlock
;
; Changes a block, used for tiles which appear/disappear
;
; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
; Temp_Var15 / Temp_Var16 -- X Hi and Lo
;
; Register 'A' as input sets Level_ChgTileEvent
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Level_QueueChangeBlock: 
	STA Level_ChgTileEvent	 ; Store type of block change!

	; Store change Y Hi and Lo
	LDA <Temp_Var13
	STA Level_BlockChgYHi
	LDA <Temp_Var14
	AND #$F0		; Align to nearest grid coordinate
	STA Level_BlockChgYLo

	; Store change X Hi and Lo
	LDA <Temp_Var15
	STA Level_BlockChgXHi
	LDA <Temp_Var16	
	AND #$F0	 	; Align to nearest grid coordinate
	STA Level_BlockChgXLo

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyXVelocity
;
; Applies Player's X velocity and makes sure he's not moving
; faster than the cap value (PLAYER_MAXSPEED)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ApplyXVelocity:
	LDX #$00	; X = 0
	LDY #PLAYER_MAXSPEED	; Y = PLAYER_MAXSPEED

	LDA <Player_XVel
	BPL PRG008_BFAC	 ; If Player_XVel >= 0, jump to Player_ApplyXVelocity 

	LDY #-PLAYER_MAXSPEED	 ; Y = -PLAYER_MAXSPEED

	; Negate Player_XVel (get absolute value)
	NEG

PRG008_BFAC:
	STA <Temp_Var16		; Store absolute value Player_XVel -> Temp_Var166
	CMP #PLAYER_MAXSPEED
	BLS Player_ApplyVelocity ; If we haven't hit the PLAYER_MAXSPEED yet, apply it!
	STY <Player_XVel	 ; Otherwise, cap at max speed!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyVelocity
;
; Applies Player's velocity for X or Y (depending on register 'X')
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ApplyVelocity:
	; X may specify offset to YVel, or else be zero

	LDA <Player_XVel,X	; Get velocity
	CPX #$00	 
	BNE PRG008_BFBE	 	; If we're not doing the X velocity, jump to PRG008_BFBE

	; X Velocity only:
	ADD Player_XVelAdj	; Add Player_XVelAdj

PRG008_BFBE:
	PHA		 ; Save result

	ASL A
	ASL A
	ASL A
	ASL A		 ; Get "fractional" part of velocity
	STA <Temp_Var12	 ; Store into Temp_Var12

	LDY #$00	 ; Y = 0

	PLA		 ; Restore prior result

	LSR A
	LSR A
	LSR A
	LSR A		 ; Get "whole" part of velocity

	; "Whole" part is like a 4-bit signed integer
	; $0 - $7 is therefore rightward
	; $8 - $F is therefore leftward
	CMP #$08
	BLT PRG008_BFD3	 ; If whole part is less than 8, jump to PRG008_BFD3

	DEY		 ; Y = $FF (sign extended negative)

	; Turn "whole part" into a full 8-bit signed
	ORA #$F0

PRG008_BFD3:
	STA <Temp_Var11	 ; Store velocity into Temp_Var11 (low part)
	STY <Temp_Var13	 ; Temp_Var13 = 0 or $FF (High part)

	; Accumulating fractional component
	LDA Player_XVelFrac,X
	ADD <Temp_Var12	
	STA Player_XVelFrac,X

	; Apply velocity to X if there's carry
	LDA <Player_X,X
	ADC <Temp_Var11
	STA <Player_X,X

	; Apply velocity to XHi if there's carry
	LDA <Player_XHi,X
	ADC <Temp_Var13	
	STA <Player_XHi,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_ApplyYVelocity
;
; Applies Player's Y velocity and makes sure he's not falling 
; faster than the cap value (FALLRATE_MAX)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_ApplyYVelocity:
	LDA <Player_YVel
	BMI PRG008_BFF9	 ; If Player_YVel < 0, jump to PRG008_BFF9

	CMP #FALLRATE_MAX
	BLS PRG008_BFF9	 ; If Player_YVelo < FALLRATE_MAX, jump to PRG008_BFF9

	; Cap Y velocity at FALLRATE_MAX
	LDA #FALLRATE_MAX
	STA <Player_YVel ; Player_YVel = FALLRATE_MAX

PRG008_BFF9:
	LDX #(Player_YVel - Player_XVel) ; Do the Y velocity
	JSR Player_ApplyVelocity	 ; Apply it!

	RTS		 ; Return

; Rest of ROM bank was empty


