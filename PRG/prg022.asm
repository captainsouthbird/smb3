; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-01-05 18:09:49.828384346 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

;---------------------------------------------------------------------------
; THE [LOST] BONUS GAMES!
;---------------------------------------------------------------------------
;
; If you don't know about it: http://themushroomkingdom.net/smb3_lost.shtml
;
; While in previous exploits I did find traces of the "lost" Bonus Games,
; the translation efforts on various sites (e.g. The Mushroom Kingdom)
; and the game "restoring" patch by BMF54123 makes some of this clear.
; It should be noted that BMF54123's patch works by constructing a custom
; pattern bank to replace the missing sprites so it's unknown how much of
; it is truly accurate (except for the alternate game hosts, which still
; exist in stock SMB3), but for now I'll have faith in his reproduction.
;
; The only thing we really have to go on with the "lost" Bonus Games are
; some scattered graphics and the string translations.  During this work
; I formulated a few theories, although all of it is ultimately speculation.
;
; There appeared to have been at least four Bonus Games planned, and they
; are vaguely described as follows:
;
; The Key/Coin Game
;	"If 1 appears, 1 (?)
;	If 2 appears, I'll give you a key
;	Otherwise, I'll give you coins."
;
; The Odd Game
;	"If an odd number appears, I'll let you play the Roulette Game."
;
; The Even Game	
;	"If an even number appears, I'll let you play the Card Game."
;
; Koopa Troopa's "Prize" Game
;	No text to describe this one, but pictures speak louder than words
;	(More below...)
;
; All of these games were powered by a rotating die (as it is displayed in
; BMF54123's patch.)  What the die face values meant are determined by the
; bonus game type (Bonus_GameType.)
;
; While in fact none of the prizes stated in these messages can be obtained,
; they allude to a completely different bonus game structure and another
; perhaps lost SMB3 gameplay device, the "key."
;
; Bearing in mind this is only speculation, it would make sense that the
; "Roulette" game mentioned in the text is in fact what we now know as
; the "Spade" game from the World Map, where you line up the three rows of
; images to form the picture.  The "Card" game then is most likely what
; we now know as "N-Spade", the memory card matching game.  Thus it can
; be suggested that direct access to either was not the original intention,
; they were "prizes" for a lucky roll of the die.
;
; However, it is not as easy to determine the purpose of two other glaring
; omissions -- the alternate game hosts (Koopa Troopa and Hammer Bro) as
; well as the mysterious "key."  Why the villains would EVER host the game
; has no clear rhyme or reason.  The "key" could perhaps once have been the
; means of unlocking the "locks" on the World Map, instead of the present
; day means of unlocking via the Mini-Fortress.  Whether this would have
; been an item the Player carried to use at his whim or whether the lock
; would automatically clear like it does now is also indeterminable.
;
; The current state as it exists in the code:
;
;---------------------------------------------------------------------------
; Die Face 1: "If 1 appears, 1 (?)"
;---------------------------------------------------------------------------
; This currently actually gives you an extra life, but does not play the
; 1-Up sound or worry about a 99 lives cap.  Like Die Face 1, it is quite
; possible that this extra life is also not the intended prize.  Perhaps
; either a placeholder or a last ditch effort to spare the die games when
; it became apparent they were potentially to be cut...
;
;
;---------------------------------------------------------------------------
; Die Face 2: "If 2 appears, I'll give you a key"
;---------------------------------------------------------------------------
; This attempts to give you "something."  Literally what it does is add 1
; to the lowest byte of the Player-specific score storage.  But not in an
; appropriate way with carry-arithmetic.  So most likely this was not 
; really what was supposed to be getting incremented; it likely was giving
; you one more of "something."  Whether or not that "something" was
; actually obtained is unclear, especially since the incomplete messsage
; does not allude to what it was supposed to be, if it was ever even known.
; But since it effects Player-specific memory, it can at least be assumed
; that they intended to give the current Player one of "something."
;
;
;---------------------------------------------------------------------------
; Die Face 3-6: "Otherwise, I'll give you coins."
;---------------------------------------------------------------------------
; Visually, this promise is held true; "coins" will pop out in a confetti
; like motion for Die Face 3-6.  Code-wise, however, it actually ends up
; giving you (Face Value * 10) points.  Don't let the multiplication lead
; you on too far, because SMB3 uses a fake leading zero on the score, so
; it's really only adding the face value of the die to your score variable.
; It is quite easy to believe that there is simply a mistake in the code
; or that this code is old and unmaintained, and in fact what is now the
; earned score used to be the earned coins.  In any case, this is the only
; segment of the Die Game that seems to be almost at its intended form.
;
; The final note that should be made here is that coins have no purpose on
; the world map.  Your coin total is changed to bonus at the end of every
; level, or lost upon death.  So this further suggests that there was once
; a persistence of coin count on the world map, perhaps to purchase items
; (maybe Toad House would have been a shop?) or gamble with.
;
;---------------------------------------------------------------------------
; The Odd/Even Games
;	"If an odd number appears, I'll let you play the Roulette Game."
;	"If an even number appears, I'll let you play the Card Game."
;---------------------------------------------------------------------------
; This one is interesting and, as suggested above, most likely connected
; you to the now-known-as Spade and N-Spade games respectively.  What's
; also interesting is the code for playing the Odd/Even game is still
; present but logically inaccessible; the values that originally selected
; to play the Odd/Even games have now actually been replaced by the Spade
; and N-Spade respectively!  (Further suggesting the connection.)  
;
; But the code and lookup tables that make the game possible still exist, 
; and the way they play out now is that "winning" the Odd game sets 
; Bonus_DieCnt to 5 and the Even game forces it to 6.  This would be used
; to determine which game you got to play after that...
;
; It seems that the Odd/Even games were refactored to slot 5 and 6 after
; formerly occupying slot 1 and 2, respectively.  This is further suggested
; by the fact that the "Round 2" strings for Bonus_Round2 1 and 2 are
; duplicated for Bonus_GameType 5 and 6.
;
;
;---------------------------------------------------------------------------
; "Round 2"
;---------------------------------------------------------------------------
; What I refer to as "Round 2" in the code was where apparently the Die game
; could transition into another bonus game.  The only place this is apparently
; set up to work are the Odd/Even Games, which intended to proceed to the
; Roulette (Spade) or Card (N-Spade) games in "Round 2."
;
; At the end of all the "Host Greet" strings, there is a value that gets 
; pushed into Bonus_Round2.  This determines what Round 2 will be!
;
; In summary (example for Odd/Even):
;	Round 1: Get instructed and play Odd/Even Game; if you win...
;	Round 2: Previous dialog is erased, get instructed and play Roulette/Card Game
;
; The code was likely possibly considering that other games would have a 
; "Round 2" component, but this never materialized... but some hints of what
; other "Round 2" things may have occurred are hinted by some of the strings
;
;
;---------------------------------------------------------------------------
; Koopa Troopa's "Prize" Game
;---------------------------------------------------------------------------
; This is the most incomplete of all of the games.  There is no definite string
; of text to hint what the rules might have been.  The only things known are:
;	1) A big [?] appears when Bonus_GameHost = 1 (Koopa Troopa with "Prize")
;	2) A "prize" emerges from it and sits atop of the box
;	3) There is code reference to these first two things (Bonus_KTPrizeGame)
;	4) Bonus_Return2_SetMapPos can set your map position partly by Bonus_KTPrizeGame
;
; There is no way to absolutely determine how this game worked, but most likely
; it would start up with you and the Koopa Troopa with a box in the middle.
; The "prize" would remain inside the box until you did whatever it took to
; "win" the prize, at which point it would rise up and presumably you'd get it.
; The reason for it rising immediately is most likely a programmer's test and
; it simply wasn't very far along yet.
;
; The big [?] that appears covers over the Die, although the die is still in
; operation behind it and for all intents and purposes, the engine is still
; running the die game.  The die game should probably be disabled in this
; case, but there's just no logic for that.
;
; A possible suggestion is that this was a trading game (using the unknown 
; "Round 2" string which is loosely translated as "Give Something?"), where
; you gave the Koopa Troopa an item and you got whatever was in the
; "Mystery Box", perhaps to your benefit or chagrin.  But this is only a guess.
;
; If bonus loop is exited and Bonus_GameType = BONUS_UNUSED_2RETURN,
; the Player is forced to a map position based on their last movement
; and the Bonus_KTPrizeGame value!  (See Bonus_Return2_SetMapPos)
; So perhaps BONUS_UNUSED_2RETURN MAY have been Koopa Troopa's "Prize" Game?
;
;
; P.S.
;
; Bonus_GameType = BONUS_UNUSED_DDDD actually sets a special variable
; Bonus_DDDD = 1 when you exit the bonus loop... interesting!!
; 
; There is an unused variable Roulette_Turns which when greater than zero,
; gives you additional spins if you should lose the Roulette game!  This is
; likely the unused "Play three times" message (BonusGame_UNUSED_Etc1)
; 
; "Hey you! How about lending me your clothes?
; No dice?
; What a drag"
; -- Possible in-joke no one got after all these years? :P


Tile_Layout_TS15_TS16_TS17:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $FD, $FD, $FD, $A6, $A7, $A8, $A4, $A5, $FE, $FF, $FD, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $72, $50, $54, $FD, $58, $5C, $FD, $40, $44, $FD, $74, $08, $0A, $28, $2A, $48 ; Tiles $40 - $4F
	.byte $4A, $68, $6A, $FE, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $FD, $60, $64, $68, $6C, $46, $78, $20, $24, $21, $2C, $FF, $FF, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $90 - $9F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $A0 - $AF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $70, $FF, $FF, $FF, $FF, $70, $FF, $07, $07, $80, $82, $84, $86, $72, $10, $12 ; Tiles $C0 - $CF
	.byte $12, $17, $1F, $1B, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $A0, $A1, $A2, $A6, $A7, $FD, $FD, $FD, $FE, $FF, $FD, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $73, $51, $55, $FD, $59, $5D, $FD, $41, $55, $FD, $75, $18, $1A, $38, $3A, $58 ; Tiles $40 - $4F
	.byte $5A, $78, $7A, $FE, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $FD, $61, $65, $69, $6D, $69, $79, $21, $25, $29, $2B, $FF, $FF, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $90 - $9F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $A0 - $AF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $71, $FF, $FF, $FF, $01, $04, $02, $07, $05, $90, $92, $94, $96, $73, $11, $14 ; Tiles $C0 - $CF
	.byte $13, $18, $FD, $1C, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $FD, $FD, $FD, $FE, $FD, $A4, $A4, $FD, $FE, $FF, $FD, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $73, $52, $FD, $56, $5A, $FD, $66, $42, $FD, $45, $76, $09, $0B, $29, $2B, $49 ; Tiles $40 - $4F
	.byte $4B, $69, $6B, $FE, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $5E, $62, $FD, $6A, $FD, $6A, $7A, $22, $26, $2A, $27, $FF, $FF, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $90 - $9F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $A0 - $AF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $71, $FF, $06, $06, $FF, $71, $FF, $FF, $FF, $81, $83, $85, $87, $73, $12, $12 ; Tiles $C0 - $CF
	.byte $15, $19, $1F, $1D, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $A1, $A1, $FD, $FE, $FD, $FD, $FD, $FD, $FE, $FF, $FD, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $20 - $2F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $72, $53, $FD, $57, $5B, $FD, $67, $43, $FD, $FD, $77, $19, $1B, $39, $3B, $59 ; Tiles $40 - $4F
	.byte $5B, $79, $7B, $FE, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $50 - $5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $60 - $6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $70 - $7F
	.byte $5F, $63, $FD, $6B, $FD, $6B, $7B, $23, $27, $2B, $2F, $FF, $FF, $FF, $FF, $FF ; Tiles $80 - $8F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $90 - $9F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $A0 - $AF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $B0 - $BF
	.byte $70, $00, $06, $03, $01, $04, $FF, $FF, $FF, $91, $93, $95, $97, $72, $13, $14 ; Tiles $C0 - $CF
	.byte $16, $1A, $FD, $1E, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $D0 - $DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $E0 - $EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $F0 - $FF


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS9
;
; Entry point for loading level layout data for Level_Tileset = 15-17
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS15_TS16_TS17:
	LDY #$00
PRG022_C402:
	LDA #TILE15_BLACK
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$40
	BNE PRG022_C402

PRG022_C40E:
	LDA #TILE15_BRICKBG
	JSR Tile_Mem_ClearB
	LDA #TILE15_BLACK
	JSR Tile_Mem_ClearA
	CPY #$f0
	BNE PRG022_C40E

	JMP LevelLoad	; Begin actual level loading!


	; The bonus room is typical level layout data...
	; Only BonusLayout_Typical is ever possibly loaded, the other ones are never touched.
	; See PRG012 for the indexing instruction; too bad it's fixed at Y = 0...
Bonus_LayoutData:
	.word BonusLayout_Typical	; 0: Mario and Table; The only bonus game we ever saw 
	.word BonusLayout_NoTable	; 1: Mario only; for the die game perhaps?
	.word BonusLayout_BlueBox	; 2: Mario and blue box; maybe Koopa Troopa's prize game?
	.word BonusLayout_Empty1	; 3: Empty/unused, who knows
	.word BonusLayout_Empty2	; 4: Empty/unused, who knows

	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/Bonus.asm"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS151617
;
; Based on the values in Temp_Var15 and LL_ShapeDef, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Generator_TS151617:

	; NOTE: This is not a  "complete" Generator as in the other level banks,
	; but that's because of the simplicity (there's only one!)
	
	LDA LL_ShapeDef
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX

	DEX
	TXA		 ; X = (LL_ShapeDef >> 4) - 1

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_BonusFloor	; 0 - Brick tiles that make up the floor

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS151617
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS151617:

	; It is verified before calling this function that all of
	; the upper 4 bits of LL_ShapeDef are ZERO

	; So the upper 3 bits of Temp_Var15 serve as the most significant bits
	; to a value where LL_ShapeDef provide the 4 least significant bits

	; NOTE: This is not a "complete" Generator as in the other level banks,
	; but that's because of the simplicity... so only the 4 LSb do anything!

	LDA LL_ShapeDef
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_BonusPlayer	; 0 - Inserts the appropriate Player based on power up level
	.word LoadLevel_UNKTALL		; 1 - Unknown tall something?
	.word LoadLevel_Border		; 2 - Outside host border
	.word LoadLevel_QBoxOrange	; 3 - "Orange" box, maybe once was a ? block (??)
	.word LoadLevel_Table		; 4 - The table in the center of the bonus room
	.word LoadLevel_Background	; 5 - Background setup (a smattering of brick tiles or whitespace behind where sprites are)
	.word LoadLevel_QBoxBlue	; 6 - Blue ? block

BonusTable_Tiles:
	.byte TILE15_TABLE_UL, TILE15_TABLE_UM, TILE15_TABLE_UR
	.byte TILE15_TABLE_LL, TILE15_TABLE_LM, TILE15_TABLE_LR

	
LoadLevel_Table:

	; Temp_Var1 = 0
	LDA #$00
	STA <Temp_Var1
PRG022_C4B2:
	LDX <Temp_Var1	 ; X = Temp_Var1

	; Left table tile -> Temp_Var2
	LDA BonusTable_Tiles,X
	STA <Temp_Var2	

	; Middle table tile -> Temp_Var3
	LDA BonusTable_Tiles+1,X
	STA <Temp_Var3	

	; Right table tile -> Temp_Var4
	LDA BonusTable_Tiles+2,X
	STA <Temp_Var4	

	; Temp_Var1 += 3
	TXA
	ADD #$03
	STA <Temp_Var1

	LDX #$00	 ; X = 0
	LDY TileAddr_Off ; Y = TileAddr_Off

	; Place left tile
	LDA <Temp_Var2
	STA [BonusText_BaseL],Y

PRG022_C4D2:
	INY		 ; Y++ (next grid tile, DANGEROUS!)
	INX		 ; X++

	; Place middle tile (repeated)
	LDA <Temp_Var3
	STA [BonusText_BaseL],Y

	TXA
	AND #$07
	CMP #$05
	BNE PRG022_C4D2	 ; If X is not at the fifth iteration, loop!

	; Place right tile
	LDA <Temp_Var4
	STA [BonusText_BaseL],Y

	; TileAddr_Off += 16 (next row)
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off

	LDA <Temp_Var1
	CMP #$06
	BNE PRG022_C4B2	 ; While Temp_Var1 <> 6, loop!

	RTS		 ; Return

Background_Layout:
	; $80 works as a "line break"
	; $FF is the terminator
	; For everything else: Upper 4 bits index a tile from Background_Tiles and lower 4 bits are a repeat count (base value 1)
	.byte $00, $80
	.byte $00, $80
	.byte $00, $10, $80
	.byte $10, $03, $10, $23, $10, $80
	.byte $14, $23, $00, $23, $80
	.byte $13, $01, $21, $00, $23, $10, $80
	.byte $23, $10, $00, $21, $10, $21, $00
	.byte $FF

Background_Tiles:
	.byte TILE15_WHITESPACE_PAL3, TILE15_BRICKBG, TILE15_WHITESPACE_PAL0


LoadLevel_Background:
	LDY TileAddr_Off ; Y = TileAddr_Off

	; Temp_Var12 = 0
	LDX #$00
	STX <Temp_Var12
PRG022_C51E:
	LDX <Temp_Var12	

	LDA Background_Layout,X
	STA <Temp_Var1	

	CMP #$ff
	BNE PRG022_C52A	 ; If not yet hit $FF value, jump to PRG022_C52A

	; Terminated!
	RTS		 ; Return

PRG022_C52A:
	CMP #$80
	BNE PRG022_C53D	 ; If not hit $80 value, jump to PRG022_C53D

	; Next tile row
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY	; -> 'Y'

	INC <Temp_Var12	 ; Temp_Var12++

	JMP PRG022_C51E	 ; Jump to PRG022_C51E

PRG022_C53D:
	LSR A
	LSR A
	LSR A
	LSR A
	TAX		 ; X = upper 4 bits, shifted down

	; Lower 4 bits -> Temp_Var11
	LDA <Temp_Var1
	AND #$0f
	STA <Temp_Var11

PRG022_C548:
	LDA Background_Tiles,X
	STA [BonusText_BaseL],Y

	INY		 ; Y++ (next tile, DANGEROUS)

	DEC <Temp_Var11	; Temp_Var11-- (repeat)
	BPL PRG022_C548	 ; While Temp_Var11 >= 0, loop!

	INC <Temp_Var12	 ; Temp_Var12++

	JMP PRG022_C51E	 ; Jump to PRG022_C51E


	; The 16x16 tiles that make up Player when he is Big (or other not supported power up)
Player_BonusTiles_Big:
	.byte TILE15_BRICKBG, 		TILE15_PLAYERBIG_TOPM,	TILE15_PLAYERBIG_TOPR
	.byte TILE15_PLAYERBIG_HEADL,	TILE15_PLAYERBIG_HEADM,	TILE15_PLAYERBIG_HEADR
	.byte TILE15_PLAYERBIG_TORL,	TILE15_PLAYERBIG_TORM,	TILE15_PLAYERBIG_TORR
	.byte TILE15_PLAYERBIG_BOTL,	TILE15_PLAYERBIG_BOTM,	TILE15_PLAYERBIG_BOTR

	; The 16x16 tiles that make up Player when he is Raccoon
Player_BonusTiles_Raccoon:
	.byte TILE15_BRICKBG, 		TILE15_PLAYERRAC_TOPM,	TILE15_PLAYERRAC_TOPR
	.byte TILE15_PLAYERBIG_HEADL,	TILE15_PLAYERBIG_HEADM,	TILE15_PLAYERBIG_HEADR
	.byte TILE15_PLAYERBIG_TORL,	TILE15_PLAYERBIG_TORM,	TILE15_PLAYERBIG_TORR
	.byte TILE15_PLAYERBIG_RACL,	TILE15_PLAYERBIG_RACM,	TILE15_PLAYERBIG_BOTR

	; The 16x16 tiles that make up Player when he is Small
Player_BonusTiles_Small:
	.byte TILE15_BRICKBG,	TILE15_BRICKBG,		TILE15_BRICKBG
	.byte TILE15_BRICKBG,	TILE15_BRICKBG,		TILE15_BRICKBG
	.byte TILE15_BRICKBG,	TILE15_PLAYERSM_TOP,	TILE15_BRICKBG
	.byte TILE15_BRICKBG,	TILE15_PLAYERSM_BOTTOM,	TILE15_BRICKBG

PlayerSuit_ToIndex:
	.byte PLAYERSUIT_BIG		; 0 (Default when all else fails)
	.byte PLAYERSUIT_RACCOON	; 1
	.byte PLAYERSUIT_SMALL		; 2
PlayerSuit_ToIndex_End

PlayerSuit_TileBaseIndex:
	.byte (Player_BonusTiles_Big - Player_BonusTiles_Big)
	.byte (Player_BonusTiles_Raccoon - Player_BonusTiles_Big)
	.byte (Player_BonusTiles_Small - Player_BonusTiles_Big)


LoadLevel_BonusPlayer:

	; This loop tries to match the Player's power up with an index
	; If nothing else, X = 0, which uses "Big"
	LDX #(PlayerSuit_ToIndex_End - PlayerSuit_ToIndex - 1)
	LDY Player_Current	; Y = Player_Current
	LDA World_Map_Power,Y	; Get current Player's power
PRG022_C589:
	CMP PlayerSuit_ToIndex,X
	BEQ PRG022_C591	 ; If this is the Player's current power up, jump to PRG022_C591

	DEX		 ; X--
	BNE PRG022_C589	 ; While X > 0, loop!

PRG022_C591:

	; Get starting tile for Player
	LDA PlayerSuit_TileBaseIndex,X
	TAX		 ; -> 'X'

	; Temp_Var3 = 0
	LDA #$00
	STA <Temp_Var3

	LDY TileAddr_Off	; Y = TileAddr_Off

PRG022_C59C:
	; Temp_Var1 = 2
	LDA #$02
	STA <Temp_Var1

PRG022_C5A0:
	; Get tile for Player -> grid
	LDA Player_BonusTiles_Big,X
	STA [BonusText_BaseL],Y

	INY		 ; Y++ (next grid tile, DANGEROUS!)
	INX		 ; X++ (next Player tile)

	INC <Temp_Var3	 ; Temp_Var3++
	DEC <Temp_Var1	 ; Temp_Var1--

	BPL PRG022_C5A0	 ; While Temp_Var1 >= 0, loop

	; Go to next row of tiles
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		 ; -> 'Y'

	LDA <Temp_Var3
	CMP #(Player_BonusTiles_Raccoon - Player_BonusTiles_Big)
	BNE PRG022_C59C	 ; If we have more tiles to go, loop!

	RTS		 ; Return


BonusUNKTALL_Tiles:
	.byte TILE15_UNKTALL_UL,	TILE15_UNKTALL_UR
	.byte TILE15_UNKTALL_R1L,	TILE15_UNKTALL_R1R
	.byte TILE15_UNKTALL_R2L,	TILE15_UNKTALL_R2R 
	.byte TILE15_UNKTALL_LL,	TILE15_UNKTALL_LR
BonusUNKTALL_Tiles_End

LoadLevel_UNKTALL:
	LDX #$00		; X = 0 
	LDY TileAddr_Off	; Y = TileAddr_Off

PRG022_C5CB:
	; Temp_Var1 = 1
	LDA #$01
	STA <Temp_Var1

PRG022_C5CF:
	LDA BonusUNKTALL_Tiles,X
	STA [BonusText_BaseL],Y	

	INY		 ; Y++ (next grid tile, DANGEROUS!)
	INX		 ; X++

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG022_C5CF	 ; While Temp_Var1 >= 0, loop

	; Next tile row
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		 ; -> 'Y'

	CPX #(BonusUNKTALL_Tiles_End - BonusUNKTALL_Tiles)
	BNE PRG022_C5CB	 ; While X < number of tiles, loop!

	RTS		 ; Return


LoadLevel_Border:
	LDY TileAddr_Off	; Y = TileAddr_Off

	; Border upper left
	LDA #TILE15_BORDER_UL
	STA [BonusText_BaseL],Y

	; Run of 14 middle tiles
PRG022_C5F0:
	INY		 ; Y++

	LDA #TILE15_BORDER_UM
	STA [BonusText_BaseL],Y

	CPY #$0f
	BNE PRG022_C5F0

	; Border upper right
	LDA #TILE15_BORDER_UR
	STA [BonusText_BaseL],Y

PRG022_C5FD:
	INY		 ; Y++
	TYA
	AND #$0f
	BNE PRG022_C607	 ; If not time to place left border, jump to PRG022_C607

	LDA #TILE15_BORDER_ML
	BNE PRG022_C60D	 ; Jump (technically always) to PRG022_C60D

PRG022_C607:
	CMP #$0f
	BNE PRG022_C5FD	 ; If not time to place right border, jump to PRG022_C5FD

	LDA #TILE15_BORDER_MR

PRG022_C60D:
	STA [BonusText_BaseL],Y	 ; Store appropriate middle border

	CPY #$9f
	BNE PRG022_C5FD	 ; If Y <> $9F, loop!

	INY		 ; Y++

	; Lower left border
	LDA #TILE15_BORDER_LL
	STA [BonusText_BaseL],Y

	; Run of 14 middle tiles
PRG022_C618:
	INY		 ; Y++

	LDA #TILE15_BORDER_LM
	STA [BonusText_BaseL],Y

	CPY #$af
	BNE PRG022_C618

	; Lower right border
	LDA #TILE15_BORDER_LR
	STA [BonusText_BaseL],Y

	RTS		 ; Return

QBoxOrange_Tiles:
	.byte $C9, $CA, $CB, $CC
QBoxOrange_Tiles_End

LoadLevel_QBoxOrange:
	LDX #$00	 ; X = 0
	LDY TileAddr_Off ; Y = TileAddr_Off
PRG022_C62F:

	; Temp_Var1 = 1
	LDA #$01
	STA <Temp_Var1

PRG022_C633:

	; Add prize box tile
	LDA QBoxOrange_Tiles,X
	STA [BonusText_BaseL],Y

	INY		 ; Y++ (next tile, DANGEROUS)
	INX		 ; X++ (next prize box tile)

	DEC <Temp_Var1	; Temp_Var1--
	BPL PRG022_C633 ; While Temp_Var1 >= 0, loop!

	; Next row
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		 ; -> 'Y'

	CPX #(QBoxOrange_Tiles_End - QBoxOrange_Tiles)
	BNE PRG022_C62F	; While tiles to go, loop!

	RTS		 ; Return

QBoxBlue_Tiles:
	.byte $87, $88, $89, $8A
QBoxBlue_Tiles_End


LoadLevel_QBoxBlue:
	LDX #$00	 ; X = 0
	LDY TileAddr_Off ; Y = TileAddr_Off
PRG022_C656:

	; Temp_Var1 = 1
	LDA #$01
	STA <Temp_Var1

PRG022_C65A:

	; Add prize box tile
	LDA QBoxBlue_Tiles,X
	STA [BonusText_BaseL],Y

	INY		 ; Y++ (next tile, DANGEROUS)
	INX		 ; X++ (next prize box tile)

	DEC <Temp_Var1	; Temp_Var1--
	BPL PRG022_C65A ; While Temp_Var1 >= 0, loop!

	; Next row
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		 ; -> 'Y'

	CPX #(QBoxBlue_Tiles_End - QBoxBlue_Tiles)
	BNE PRG022_C656	; While tiles to go, loop!

	RTS		 ; Return


LoadLevel_BonusFloor:

	; Temp_Var1 = 1
	LDA #$01
	STA <Temp_Var1

	LDY TileAddr_Off	 ; Y = TileAddr_Off

PRG022_C67B:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

PRG022_C681:
	LDA #TILE15_BRICKFLOOR
	STA [Map_Tile_AddrL],Y

	INY		 ; Y++  (NOT SAFE!)

	DEX		 ; X--
	BPL PRG022_C681	 ; While X >= 0, loop

	; Next row
	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY		 ; -> 'Y'

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG022_C67B	 ; While Temp_Var1 >= 0, loop

	RTS		 ; Return

; FIXME: Anyone want to claim this?
; $C698

	; Y += 16
	TYA
	ADD #16
	TAY

	LDA <BonusText_BaseH
	ADC #$00
	STA <BonusText_BaseH

	RTS		 ; Return

; FIXME: Anyone want to claim this?
; $C6A4
	LDA <Temp_Var6		 
	STA <BonusText_BaseH

	LDY TileAddr_Off
	INY
	TYA
	AND #$0f
	BNE PRG022_C6E2

	LDY #$00

	LDA <Temp_Var15
	AND #$10
	BEQ PRG022_C6BA

	INY	

PRG022_C6BA:
	STY <Temp_Var10

	LDA <BonusText_BaseL
	ADD #$b0
	STA <BonusText_BaseL
	LDA <BonusText_BaseH
	ADC <Temp_Var10	
	STA <BonusText_BaseH
	STA <Temp_Var6

	LDA <Temp_Var16
	AND #$f0
	LSR A
	LSR A
	LSR A
	TAY

	INY
	INY

	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var5

	INC <Temp_Var5

	LDA TileAddr_Off
	AND #$f0
	TAY

PRG022_C6E2:
	STY TileAddr_Off
	RTS		 ; Return


BonusGame_HostDraw:
	LDA Bonus_GameHost
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word HostToad_Draw			; 0: Standard Toad Host
	.word HostTroopa_DrawWithGameBits	; 1: (Unused, glitched) Koopa Troopa Host w/ (unused, glitched) large [?] and card
	.word HostTroopa_Draw			; 2: (Unused, glitched) Koopa Troopa Host w/o the other thing
	.word HostHammerBro_Draw		; 3: (Unused, glitched) Hammer Bro Host

HostToad_Draw:
	JSR HostToad_DrawSprites
	RTS		 ; Return

HostTroopa_DrawWithGameBits:
	JSR HostTroopa_DrawSprites

	LDA #$3f	; <-- denotes starting tile, for other prize boxes??
	JSR Draw_KTPrizeGameBox	 ; Draw the Koopa Troopa "Prize" Game box and the prize

	RTS		 ; Return

HostTroopa_Draw:
	JSR HostTroopa_DrawSprites
	RTS		 ; Return

HostHammerBro_Draw:
	JSR HostHammerBro_DrawSprites
	RTS		 ; Return

HostToad_SpriteYs:
	.byte $60, $60, $60, $60, $70, $70, $70, $70, $80, $80, $80
HostToad_SpriteYs_End

HostToad_SpriteXs:
	.byte $C0, $C8, $D0, $D8, $C0, $C8, $D0, $D8, $C0, $C8, $D0

HostToad_DrawSprites:

	; Temp_Var11 = $95 (starting pattern of Toad Host sprites)
	LDA #$95	 
	STA <Temp_Var11

	LDY #$00	 ; Y = 0
	LDX #(HostToad_SpriteYs_End - HostToad_SpriteYs - 1)
PRG022_C727:

	; Set Sprite Y of this sprite of the Toad Host
	LDA HostToad_SpriteYs,X
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set pattern of this sprite of the Toad Host
	LDA <Temp_Var11
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set palette of this sprite of the Toad Host
	LDA #SPR_PAL0
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set Sprite X of this sprite of the Toad Host
	LDA HostToad_SpriteXs,X
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Temp_Var11 -= 2 (two patterns backward)
	DEC <Temp_Var11
	DEC <Temp_Var11

	DEX		 ; X--
	BPL PRG022_C727	 ; While X >= 0, loop

	RTS		 ; Return

HostTroopa_SpriteYs:
	.byte $60, $60, $60, $70, $70, $70, $70, $80, $80, $80
HostTroopa_SpriteYs_End

HostTroopa_SpriteXs:
	.byte $C0, $C8, $D0, $C0, $C8, $D0, $D8, $C8, $D0, $D8

HostTroopa_DrawSprites:
	; Temp_Var11 = $99 (starting pattern of Koopa Troopa Host sprites)
	LDA #$99	; WRONG!  Should be $A9, then he'll display correctly :D
	STA <Temp_Var11

	LDY #$00	 ; Y = 0
	LDX #(HostTroopa_SpriteYs_End - HostTroopa_SpriteYs - 1)
PRG022_C765:

	; Set Sprite Y of this sprite of the Koopa Troopa Host
	LDA HostTroopa_SpriteYs,X
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set pattern of this sprite of the Koopa Troopa Host
	LDA <Temp_Var11
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set palette of this sprite of the Koopa Troopa Host
	LDA #SPR_PAL0
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set Sprite X of this sprite of the Koopa Troopa Host
	LDA HostTroopa_SpriteXs,X
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Temp_Var11 -= 2 (two patterns backward)
	DEC <Temp_Var11
	DEC <Temp_Var11

	DEX		 ; X--
	BPL PRG022_C765	 ; While X >= 0, loop

	RTS		 ; Return


HostHammerBro_SpriteYs:
	.byte $60, $60, $60, $70, $70, $70, $70, $80, $80, $80, $80
HostHammerBro_SpriteYs_End

HostHammerBro_SpriteXs:
	.byte $C0, $C8, $D0, $C0, $C8, $D0, $D8, $C0, $C8, $D0, $D8


HostHammerBro_DrawSprites:
	; Temp_Var11 = $AF (starting pattern of Koopa Troopa Host sprites)
	LDA #$AF	; WRONG!  Should be $BF, then he'll display correctly :D
	STA <Temp_Var11

	LDY #$00	 ; Y = 0
	LDX #(HostHammerBro_SpriteYs_End - HostHammerBro_SpriteYs - 1)
PRG022_C7A5:
	; Set Sprite Y of this sprite of the Hammer Bro Host
	LDA HostHammerBro_SpriteYs,X
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set pattern of this sprite of the Hammer Bro Host
	LDA <Temp_Var11
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set palette of this sprite of the Hammer Bro Host
	LDA #SPR_PAL0
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set Sprite X of this sprite of the Hammer Bro Host
	LDA HostHammerBro_SpriteXs,X
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Temp_Var11 -= 2 (two patterns backward)
	DEC <Temp_Var11
	DEC <Temp_Var11

	DEX		 ; X--
	BPL PRG022_C7A5	 ; While X >= 0, loop
	RTS		 ; Return

BonusGameBox_SpriteYs:
	.byte $70, $70, $70, $70, $80, $80, $80, $80
BonusGameBox_SpriteYs_End

BonusGameBox_SpriteXs:
	.byte $70, $78, $80, $88, $70, $78, $80, $88

Bonus_KTPrizeFlipBits:	.byte SPR_HFLIP, $00

Bonus_KTPrizePattern:
	.byte $21, $25, $23, $27



	; Draws the box and the "prize" for Koopa Troopa's "Prize" Game
Draw_KTPrizeGameBox:
	STA <Temp_Var11	 


	; Draw the game box first

	LDX #(BonusGameBox_SpriteYs_End - BonusGameBox_SpriteYs - 1)
PRG022_C7E1:

	; Set Sprite Y of this sprite
	LDA BonusGameBox_SpriteYs,X
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set pattern of this sprite
	LDA <Temp_Var11
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set palette of this sprite 
	LDA #SPR_PAL0
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Set Sprite X of this sprite
	LDA BonusGameBox_SpriteXs,X
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite RAM byte)

	; Temp_Var11 -= 2 (two patterns backward)
	DEC <Temp_Var11
	DEC <Temp_Var11

	DEX		 ; X--
	BPL PRG022_C7E1	 ; While X >= 0, loop

	; Koopa Troopa must be finished introducing the game before the "Prize" is even displayed!
	LDA Bonus_GameState
	CMP #$02
	BLT PRG022_C852	 ; If Bonus_GameState < 2, jump to PRG022_C852 (RTS)

	LDX Bonus_KTPrize	; X = Bonus_KTPrize

	; Store pattern for prize -> Temp_Var11
	LDA Bonus_KTPrizePattern,X
	STA <Temp_Var11

	; Temp_Var12 = Bonus_PrizeX
	LDA Bonus_PrizeX
	STA <Temp_Var12	

	LDX #$01	 ; X = 1 (the two sprites that make up the prize)
PRG022_C818:

	; Store prize sprite Y
	LDA Bonus_PrizeY
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite byte)

	; Store prize pattern
	LDA <Temp_Var11
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite byte)

	; Store prize attributes
	LDA Bonus_KTPrizeFlipBits,X
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite byte)

	; Store prize sprite X
	LDA <Temp_Var12	
	STA Sprite_RAM+$10,Y

	INY		 ; Y++ (next sprite byte)

	; Temp_Var12 += 8
	LDA <Temp_Var12	
	ADD #$08
	STA <Temp_Var12

	DEX		 ; X--
	BPL PRG022_C818	 ; While X >= 0, loop


	LDA Bonus_PrizeY
	CMP #$60
	BEQ PRG022_C852	 ; If Bonus_PrizeY = $60 (Bonus prize rose to the top), jump to PRG022_C852 (RTS)

	; NOTE: It is possible that the "prize" wasn't suppose to rise until you actually won it, so
	; there would be some kind of logic here to jump passed... of course, I don't know for sure.

	DEC Bonus_PrizeY ; Bonus_PrizeY--

	LDA Bonus_PrizeY
	CMP #$5f
	BGE PRG022_C852	 ; If Bonus_PrizeY >= $5F (not at the top), jump to PRG022_C852

	; Otherwise, stop at the top (what, thought you'd miss this with your DEC Mr. Programmer?)
	LDA #$60
	STA Bonus_PrizeY

PRG022_C852:
	RTS		 ; Return

BonusText_HostGreetPtrL:
	.byte LOW(BonusGame_UNUSED0_Text)	; 0: UNUSED (Japanese) Give key / coins
	.byte LOW(BonusGame_Spade_Text)		; 1: Standard Spade Game instruction (OLD position of "Odd" game)
	.byte LOW(BonusGame_NSpade_Text)	; 2: N-Spade instruction (OLD position of "Even" Game)
	.byte LOW(BonusGame_UNUSED3_Text)	; 3: UNUSED "CCCCCCC CCCCCCC"
	.byte LOW(BonusGame_UNUSED4_Text)	; 4: UNUSED "DDDDDDD"
	.byte LOW(BonusGame_UNUSED5_Text)	; 5: UNUSED (Japanese) "If an odd number appears, I'll let you play the Roulette Game."
	.byte LOW(BonusGame_UNUSED6_Text)	; 6: UNUSED (Japanese) "If an even number appears, I'll let you play the Card Game."
	.byte LOW(BonusGame_UNUSED7_Text)	; 7: UNUSED (Japanese) "2, return (?)"

BonusText_HostGreetPtrH:
	.byte HIGH(BonusGame_UNUSED0_Text)	; 0: UNUSED (Japanese) Give key / coins
	.byte HIGH(BonusGame_Spade_Text)	; 1: Standard Spade Game instruction (OLD position of "Odd" game)
	.byte HIGH(BonusGame_NSpade_Text)	; 2: N-Spade instruction (OLD position of "Even" game)
	.byte HIGH(BonusGame_UNUSED3_Text)	; 3: UNUSED "CCCCCCC CCCCCCC"
	.byte HIGH(BonusGame_UNUSED4_Text)	; 4: UNUSED "DDDDDDD"
	.byte HIGH(BonusGame_UNUSED5_Text)	; 5: UNUSED (Japanese) "If an odd number appears, I'll let you play the Roulette Game."
	.byte HIGH(BonusGame_UNUSED6_Text)	; 6: UNUSED (Japanese) "If an even number appears, I'll let you play the Card Game."
	.byte HIGH(BonusGame_UNUSED7_Text)	; 7: UNUSED (Japanese) "2, return (?)"

	; A whole bunch of unused, untranslated text only really hooked into the Odd/Even game
	; These would be used in "Round 2."
BonusText_Round2PtrL:
	.byte LOW(BonusGame_UNUSED_Etc0)	; 0
	.byte LOW(BonusGame_UNUSED_Etc1)	; 1: OLD position of Odd Game winner (string identical to 5)
	.byte LOW(BonusGame_UNUSED_Etc2)	; 2: OLD position of Even Game winner (string identical to 6)
	.byte LOW(BonusGame_UNUSED_Etc3)	; 3
	.byte LOW(BonusGame_UNUSED_Etc4)	; 4
	.byte LOW(BonusGame_UNUSED_Etc5)	; 5: Odd Game winner! (BONUS_UNUSED_ODDROULETTE)
	.byte LOW(BonusGame_UNUSED_Etc6)	; 6: Even Game winner! (BONUS_UNUSED_EVENCARD)
	.byte LOW(BonusGame_UNUSED_Etc7)	; 7

BonusText_Round2PtrH:
	.byte HIGH(BonusGame_UNUSED_Etc0)	; 0
	.byte HIGH(BonusGame_UNUSED_Etc1)	; 1: OLD position of Odd Game winner (string identical to 5)
	.byte HIGH(BonusGame_UNUSED_Etc2)	; 2: OLD position of Even Game winner (string identical to 6)
	.byte HIGH(BonusGame_UNUSED_Etc3)	; 3
	.byte HIGH(BonusGame_UNUSED_Etc4)	; 4
	.byte HIGH(BonusGame_UNUSED_Etc5)	; 5: Odd Game winner! (BONUS_UNUSED_ODDROULETTE)
	.byte HIGH(BonusGame_UNUSED_Etc6)	; 6: Even Game winner! (BONUS_UNUSED_EVENCARD)
	.byte HIGH(BonusGame_UNUSED_Etc7)	; 7


BonusGame_Do:
	JSR BonusGame_HostDraw		; Draw the Bonus Game host

	LDA Bonus_GameState
	CMP #$04
	BLS PRG022_C880	 ; If Bonus_GameState < 4, jump to PRG022_C880

	; Bonus_GameState >= 4

	JSR Bonus_DrawDie	 ; Draw the bonus die!

PRG022_C880:
	LDA Bonus_GameState
	CMP #$07
	BLT PRG022_C8A0	 ; If Bonus_GameState < 7, jump to PRG022_C8A0

	LDA <Pad_Input
	AND #(PAD_A | PAD_B)
	BEQ PRG022_C8A0	 ; If Player is pushing neither A nor B, jump to PRG022_C8A0

	; Player pushing A or B...

	LDA SndCur_Music2
	BNE PRG022_C897	 ; If music is playing from set 2, jump to PRG022_C897

	; Otherwise, start the Bonus Game music
	LDA #MUS2A_BONUSGAME
	STA Sound_QMusic2

PRG022_C897:

	; Bonus_GameState = 9
	LDA #$09
	STA Bonus_GameState

	; Exit to map!  (NOTE: Exits to either Spade/N-Spade game)
	LDA #$01
	STA <Level_ExitToMap

PRG022_C8A0:
	LDA Bonus_GameState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Bonus_Init	; 0: Draw the dialog box, initialize the greeting text, 
	.word Bonus_DoHostText	; 1: Giving instructions for ALL UNUSED GAMES (then initializing the "prize"!)
	.word Bonus_DieRotate	; 2: Rotating die logic; press 'A' and you may get a prize by the game type (or so it was intended)
	.word Bonus_GetDiePrize	; 3: Get your die prize!  (If you "won") Includes the "coin confetti"
	.word Bonus_Wait80	; 4: Waits $80 ticks
	.word Bonus_DieFlyAway	; 5: Die "flies away"; go to state 6 if you won the Odd/Even game and to state 8 otherwise
	.word Bonus_InitRound2	; 6: Initialize for Round 2
	.word Bonus_DoHostText	; 7: Giving instructions for Spade/N-Spade (LEGACY: For "Round 2" game)
	.word Bonus_WaitA0	; 8: Wait $A0 ticks
	.word Bonus_KTPrizeGame	; 9: Appears to be all that was implemented toward "winning" the Koopa Troopa "Prize" Game


Bonus_Init:
	; Graphics_Queue values $8 to $C, inclusive, build the dialog box
	LDA Bonus_CurBufOffset
	ADD #$08
	STA <Graphics_Queue

	INC Bonus_CurBufOffset	 ; Bonus_CurBufOffset++

	CMP #$0c
	BNE PRG022_C8EF	 ; If we've still more to queue for the instruction box, jump to PRG022_C8EF

	; Done queueing the instruction box...

	; Bonus_UnusedFlag = 0
	LDA #$00
	STA Bonus_UnusedFlag

	INC Bonus_GameState	 ; Bonus_GameState = 1

	LDY Bonus_GameType	 ; Y = Bonus_GameType

	; Load the pointer to the host's greeting/instructional text
	LDA BonusText_HostGreetPtrL,Y
	STA <BonusText_BaseL
	LDA BonusText_HostGreetPtrH,Y
	STA <BonusText_BaseH


	; NOTE: This breaks the original Odd/Even game!  For Odd/Even to work the way
	; it was originally intended (sort of), always jump to PRG022_C8EF!

	CPY #BONUS_SPADE
	BEQ PRG022_C8E6	 ; If this is the Spade game, jump to PRG022_C8E6

	CPY #BONUS_NSPADE
	BNE PRG022_C8EF	 ; If this is NOT the N-Spade game, jump to PRG022_C8EF (RTS)

PRG022_C8E6:

	; Spade / N-Spade

	; BonusDie_Y = $F8 (hide the die)
	LDA #$f8
	STA <BonusDie_Y

	; Bonus_GameState = 7 (give instructions to Spade/N-Spade game)
	LDA #$07
	STA Bonus_GameState

PRG022_C8EF:
	RTS		 ; Return

Bonus_WaitA0:
	LDA Bonus_Timer
	BNE PRG022_C8FA	 ; If Bonus_Timer <> 0, jump to PRG022_C8FA

	; Bonus_Timer = $A0
	LDA #$a0
	STA Bonus_Timer

PRG022_C8FA:
	DEC Bonus_Timer	 ; Bonus_Timer--
	BNE PRG022_C906	 ; If Bonus_Timer not expired, jump to PRG022_C906

	INC Bonus_GameState	 ; Bonus_GameState = 9 (bad state but nothing really happens because we're exiting)

	; Exit to map
	LDA #$01
	STA <Level_ExitToMap

PRG022_C906:
	RTS		 ; Return


Bonus_DoHostText:
	DEC BonusText_CharPause	; BonusText_CharPause--

	BNE PRG022_C970	 ; If BonusText_CharPause <> 0, jump to PRG022_C970 (RTS)

	; BonusText_CharPause = 4
	LDA #$04
	STA BonusText_CharPause

PRG022_C911:
	LDA BonusText_CPos
	AND #$01
	BEQ PRG022_C91D	 ; Every other character, jump to PRG022_C91D

	; Every other character, play the "blip" sound
	LDA #SND_LEVELBLIP
	STA Sound_QLevel1

PRG022_C91D:
	LDY BonusText_CPos	 ; Y = BonusText_CPos

	LDA [BonusText_BaseL],Y
	BNE PRG022_C941	 ; If character is not $00 (line break), jump to PRG022_C941

	; Line break hit..

	LDA BonusText_VL
	ADD #32		; +32 to next row
	TAY		; -> 'Y'

	LDA BonusText_VH
	ADC #$00	 ; Apply carry
	STA BonusText_VH

	; Return character to initial column
	TYA
	AND #$e0
	ORA #$05
	STA BonusText_VL

	INC BonusText_CPos	 ; BonusText_CPos++
	JMP PRG022_C911	 ; Jump to PRG022_C911

PRG022_C941:
	CMP #$ff
	BEQ PRG022_C971	 ; If $FF character (terminator), jump to PRG022_C971

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	; Store character into graphics buffer
	STA Graphics_Buffer+$03,X

	; Set current text VRAM address into graphics buffer
	LDA BonusText_VH
	STA Graphics_Buffer+$00,X
	LDA BonusText_VL
	STA Graphics_Buffer+$01,X

	; Run length of 1
	LDA #$01
	STA Graphics_Buffer+$02,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$04,X

	; Graphics_BufCnt += 4
	LDA Graphics_BufCnt
	ADD #$04
	STA Graphics_BufCnt

	INC BonusText_VL	 ; BonusText_VL++ (next VRAM byte)
	INC BonusText_CPos	 ; BonusText_CPos++ (next character of string)

PRG022_C970:
	RTS		 ; Return


PRG022_C971:
	LDA Bonus_GameState
	CMP #$07
	BEQ PRG022_C980	 ; If Bonus_GameState = 7 (instructions for Spade/N-Spade [Or Round 2]), jump to PRG022_C980

	; Set Bonus Prize X/Y = $78
	LDA #$78
	STA Bonus_PrizeY
	STA Bonus_PrizeX

PRG022_C980:

	; BonusText_CPos = 0
	LDA #$00
	STA BonusText_CPos

	INC Bonus_GameState	 ; Bonus_GameState = 2 or 8 (the latter ONLY in the final game)

	INY		 ; Y++ (byte after string terminator)

	; Get this byte -> Bonus_Round2
	LDA [BonusText_BaseL],Y
	STA Bonus_Round2

	RTS		 ; Return

	; High/Low VRAM address to blank out the dialog lines in preparation for Round 2
Round2LineBlank_VRAMH:	.byte $28, $28, $29
Round2LineBlank_VRAML:	.byte $CA, $EA, $0A

Bonus_InitRound2:

	; Reset the dialog address!
	LDA #$28
	STA BonusText_VH
	LDA #$ca
	STA BonusText_VL

	INC Bonus_GameState	 ; Bonus_GameState = 7

	LDY Bonus_Round2	 ; Y = Bonus_Round2

	; Set the "Round 2" Text pointer
	LDA BonusText_Round2PtrL,Y
	STA <BonusText_BaseL
	LDA BonusText_Round2PtrH,Y
	STA <BonusText_BaseH


	; Create a Graphics Buffer command set to clear the three lines of dialog...
	; It probably would have been simpler and more efficient just to store the
	; raw commands, but whatever...

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt
	LDY #$02	 ; Y = 2 (0, 1, 2; three lines of dialog)
PRG022_C9B4: 
	; Set VRAM high for line blanking
	LDA Round2LineBlank_VRAMH,Y
	STA Graphics_Buffer+$00,X

	INX		 ; X++ (next graphics buffer byte)

	; Set VRAM low for line blanking
	LDA Round2LineBlank_VRAML,Y
	STA Graphics_Buffer+$00,X

	INX		 ; X++ (next graphics buffer byte)

	; Run length to blank a line of dialog
	LDA #(VU_REPEAT | $12)
	STA Graphics_Buffer+$00,X

	INX		 ; X++ (next graphics buffer byte)

	; "Space" character pattern
	LDA #$fe
	STA Graphics_Buffer+$00,X

	INX		 ; X++ (next graphics buffer byte)

	DEY		 ; Y--
	BPL PRG022_C9B4	 ; While Y >= 0, loop!


	; Terminator
	LDA #$00
	STA Graphics_Buffer+$00,X

	; Graphics_BufCnt += $0C
	LDA Graphics_BufCnt
	ADD #$0c
	STA Graphics_BufCnt

	RTS		 ; Return

Bonus_KTPrizeGame:

	; PAY ATTENTION:
	;	1) This actually cares about which host is running the game!
	;	2) This actually cares about what height the "powerup prize" is at!

	; Also, there's no way out of this state (nothing changes Bonus_GameState!)
	; so you're kind of stuck if you get into this routine...
	; But incidentally, the game DOES put itself in here as it is exiting, but
	; since Level_ExitToMap is set, it's already on its way out...

	LDA Bonus_GameHost
	CMP #$01
	BNE PRG022_C9EE	 ; If this is NOT the Koopa Troopa host (!!), jump to PRG022_C9EE

	; This IS the Koopa Troopa host...

	LDA Bonus_PrizeY
	CMP #$60
	BNE PRG022_C9F1	 ; If Bonus_PrizeY <> $60 (Prize not fully raised), jump to PRG022_C9F1 (RTS)

PRG022_C9EE:
	JSR Bonus_DoNothing	; Who knows??

PRG022_C9F1:
	RTS		 ; Return

Bonus_DoNothing:

	; WHAT WAS THIS?  D:
	; Maybe you earned the prize?

	RTS		 ; Return

Bonus_InstBoxTop:

	; Left corner
	vaddr $28A4
	.byte $01, $94

	; Bar
	vaddr $28A5
	.byte VU_REPEAT | $18, $90

	; Right corner
	vaddr $28BD
	.byte $01, $96

	.byte $00	; Terminator

Bonus_InstBoxLine1:

	; Left edge
	vaddr $28C4
	.byte $01, $92
	
	; Middle
	vaddr $28C5
	.byte VU_REPEAT | $18, $FE

	; Right edge
	vaddr $28DD
	.byte $01, $93

	.byte $00	; Terminator

Bonus_InstBoxLine2:

	; Left edge
	vaddr $28E4
	.byte $01, $92
	
	; Middle
	vaddr $28E5
	.byte VU_REPEAT | $18, $FE

	; Right edge
	vaddr $28FD
	.byte $01, $93

	.byte $00	; Terminator

Bonus_InstBoxLine3:

	; Left edge
	vaddr $2904
	.byte $01, $92
	
	; Middle
	vaddr $2905
	.byte VU_REPEAT | $18, $FE

	; Right edge
	vaddr $291D
	.byte $01, $93

	.byte $00	; Terminator


Bonus_InstBoxBot:

	; Left corner
	vaddr $2924
	.byte $01, $95

	; Bar
	vaddr $2925
	.byte VU_REPEAT | $18, $91

	; Right corner
	vaddr $293D
	.byte $01, $97

	.byte $00	; Terminator


	; NOTE!  Bonus_Round2 is actually set by a byte which follows the end of the text string!

	; UNUSED (Japanese) If "1" appears, 1 (?) / If "2" appears, I'll give you a key / Otherwise, I'll give you coins.
	; English mangled display "1FnSnPg 1" / "2FnSnPg FGnp" / "OjBFnBZ JBmpAInfC"
BonusGame_UNUSED0_Text:

	;       1    F    n    S    n    P    g         1
	.byte $9D, $B5, $DD, $C2, $DD, $BF, $D6, $FE, $9D, $00

	;       2    F    n    S    n    P    g         F    G    n    p
	.byte $9E, $B5, $DD, $C2, $DD, $BF, $D6, $FE, $B5, $B6, $DD, $DF, $00

	;       O    j    B    F    n    B    Z         J    B    m    p    A    I    n    f    C
	.byte $BE, $D9, $B1, $B5, $DD, $B1, $C9, $FE, $B9, $B1, $DC, $DF, $B0, $B8, $DD, $D5, $B2

	; (Terminator, value into Bonus_Round2)
	.byte $FF, BONUS_UNUSED_KEYCOIN

	; Spade Instruction
	; English: "Line up the pictures and" / "get a prize!" / "You only get one try."
BonusGame_Spade_Text:
	;       L    i    n    e         u    p         t    h    e         p    i    c    t    u    r    e    s         a    n    d
	.byte $BB, $D8, $DD, $D4, $FE, $CE, $DF, $FE, $CD, $D7, $D4, $FE, $DF, $D8, $D2, $CD, $CE, $CB, $D4, $CC, $FE, $D0, $DD, $D3, $00

	;       g    e    t         a         p    r    i    z    e    !
	.byte $D6, $D4, $CD, $FE, $D0, $FE, $DF, $CB, $D8, $8F, $D4, $EA, $00

	;       Y    o    u         o    n    l    y         g    e    t         o    n    e         t    r    y    .
	.byte $C8, $DE, $CE, $FE, $DE, $DD, $DB, $8C, $FE, $D6, $D4, $CD, $FE, $DE, $DD, $D4, $FE, $CD, $CB, $8C, $E9

	; (Terminator, value into Bonus_Round2)
	.byte $FF, BONUS_SPADE

	; N-Spade Instruction
	; English: "Flip over any two cards" / "and see if they match." / "You can only miss twice!"
BonusGame_NSpade_Text:
	;       F    l    i    p         o    v    e    r         a    n    y         t    w    o         c    a    r    d    s
	.byte $B5, $DB, $D8, $DF, $FE, $DE, $CF, $D4, $CB, $FE, $D0, $DD, $8C, $FE, $CD, $81, $DE, $FE, $D2, $D0, $CB, $D3, $CC, $00

	;       a    n    d         s    e    e         i    f         t    h    e    y         m    a    t    c    h    .
	.byte $D0, $DD, $D3, $FE, $CC, $D4, $D4, $FE, $D8, $D5, $FE, $CD, $D7, $D4, $8C, $FE, $DC, $D0, $CD, $D2, $D7, $E9, $00

	;       Y    o    u         c    a    n         o    n    l    y         m    i    s    s         t    w    i    c    e    !
	.byte $C8, $DE, $CE, $FE, $D2, $D0, $DD, $FE, $DE, $DD, $DB, $8C, $FE, $DC, $D8, $CC, $CC, $FE, $CD, $81, $D8, $D2, $D4, $EA

	; (Terminator, value into Bonus_Round2)
	.byte $FF, BONUS_NSPADE

	; UNUSED "CCCCCCC" / "CCCCCCC"
BonusGame_UNUSED3_Text:
	;       C    C    C    C    C    C    C
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2, $00

	;       C    C    C    C    C    C    C
	.byte $B2, $B2, $B2, $B2, $B2, $B2, $B2

	; (Terminator, value into Bonus_Round2)
	.byte $FF, BONUS_UNUSED_KEYCOIN

	; UNUSED "DDDDDDD"
BonusGame_UNUSED4_Text:
	;       D    D    D    D    D    D    D
	.byte $B3, $B3, $B3, $B3, $B3, $B3, $B3

	; (Terminator, value into Bonus_Round2)
	.byte $FF, BONUS_UNUSED_KEYCOIN

	; UNUSED (Japanese) "If an odd number appears, I'll let you play the Roulette Game."
	; English mangled display "GMCFn SnPg" / "i-j-TIn-ap" / "dgNS AInfC"
BonusGame_UNUSED5_Text:
	;       G    M    C    F    n         S    n    P    g
	.byte $B6, $BC, $B2, $B5, $DD, $FE, $C2, $DD, $BF, $D6, $00

	;       i    -    j    -    T    I    n    -    a    p
	.byte $D8, $E5, $D9, $E5, $C3, $B8, $DD, $E5, $D0, $DF, $00

	;       d    g    N    S         A    I    n    f    C
	.byte $D3, $D6, $BD, $C2, $FE, $B0, $B8, $DD, $D5, $B2

	; (Terminator, value into Bonus_Round2)
	.byte $FF, BONUS_UNUSED_ODDROULETTE

	; UNUSED (Japanese) "If an even number appears, I'll let you play the Card Game."
	; English mangled display "Hn-MCFnSnPg" / "F-TnIn-ap" / "KNS AInfC"
BonusGame_UNUSED6_Text:
	;       H    n    -    M    C    F    n    S    n    P    g
	.byte $B7, $DD, $E5, $BC, $B2, $B5, $DD, $C2, $DD, $BF, $D6, $00

	;       F    -    T    n    I    n    -    a    p
	.byte $B5, $E5, $C3, $DD, $B8, $DD, $E5, $D0, $DF, $00

	;       K    N    S         A    I    n    f    C
	.byte $BA, $BD, $C2, $FE, $B0, $B8, $DD, $D5, $B2

	; (Terminator, value into Bonus_Round2)
	.byte $FF, BONUS_UNUSED_EVENCARD

	; UNUSED (Japanese) "2, return (?)"
	; English mangled display "2 cTnj"
BonusGame_UNUSED7_Text:
	;       2         c    T    n    j    
	.byte $9E, $FE, $D2, $C3, $DD, $D9

	; (Terminator, value into Bonus_Round2)
	.byte $FF, BONUS_UNUSED_KEYCOIN


	; The following strings are not in the "primary" set, so they would not have
	; been spoken by the host at first entrance; perhaps they were in response
	; to an action you would have taken within the game?

	; I also notice that they used a shorter terminator...


	; UNUSED (Japanese) "Give something?"  (Google translates as "I'll give you something?")
	; English mangled display " cYp dkC?"
BonusGame_UNUSED_Etc0:
	;            c    Y    p         d    k    C    ?
	.byte $FE, $D2, $C8, $DF, $FE, $D3, $DA, $B2, $EB

	; (Terminator)
	.byte $FF

	; UNUSED (Japanese) "Play three times!" (This apparently was for the Roulette game; would set Roulette_Turns)
	; English mangled display "3FB rojBPnf"
BonusGame_UNUSED_Etc1:
	;       3    F    B         r    o    j    B    P    n    f    
	.byte $9F, $B5, $B1, $FE, $CB, $DE, $D9, $B1, $BF, $DD, $D5

	; (Terminator)
	.byte $FF

	; UNUSED (Japanese) "Chance to twice" / "Set aside two identical cards"
	; English mangled display "QmyMZ 2FB" / "EULn F-Tnp" / "2uB ASSJngm"
BonusGame_UNUSED_Etc2:
	;       Q    m    y    M    Z         2    F    B    
    	.byte $C0, $8C, $DC, $BC, $C9, $FE, $9E, $B5, $B1, $00

	;       E    U    L    n         F    -    T    n    p    
	.byte $B4, $C4, $BB, $DD, $FE, $B5, $E5, $C3, $DD, $DF, $00

	;       2    u    B         A    S    S    J    n    g    m
	.byte $9E, $CE, $B1, $FE, $B0, $C2, $C2, $B9, $DD, $D6, $DC

	; (Terminator)
	.byte $FF

	; UNUSED "CCCC CCCC"
BonusGame_UNUSED_Etc3:
	;       C    C    C    C
	.byte $B2, $B2, $B2, $B2, $00

	;       C    C    C    C
	.byte $B2, $B2, $B2, $B2

	; (Terminator)
	.byte $FF

	; UNUSED "DDDD"
BonusGame_UNUSED_Etc4:
	;       D    D    D    D
	.byte $B3, $B3, $B3, $B3

	; (Terminator)
	.byte $FF

	; UNUSED (Japanese) "Play three times!"
	; English mangled display "3FB rojBPnf"
BonusGame_UNUSED_Etc5:
	;       3    F    B         r    o    j    B    P    n    f    
	.byte $9F, $B5, $B1, $FE, $CB, $DE, $D9, $B1, $BF, $DD, $D5

	; (Terminator)
	.byte $FF

	; UNUSED (Japanese) "Chance to twice" / "Set aside two identical cards"
	; English mangled display "QmyMZ 2FB" / "EULn F-Tnp" / "2uB ASSJngm"
BonusGame_UNUSED_Etc6:
	;       Q    m    y    M    Z         2    F    B    
    	.byte $C0, $8C, $DC, $BC, $C9, $FE, $9E, $B5, $B1, $00

	;       E    U    L    n         F    -    T    n    p    
	.byte $B4, $C4, $BB, $DD, $FE, $B5, $E5, $C3, $DD, $DF, $00

	;       2    u    B         A    S    S    J    n    g    m
	.byte $9E, $CE, $B1, $FE, $B0, $C2, $C2, $B9, $DD, $D6, $DC

	; (Terminator)
	.byte $FF

	; UNUSED (Japanese) "2, return (?)"
	; English mangled display "2 cTnj"
BonusGame_UNUSED_Etc7:
	;       2         c    T    n    j    
	.byte $9E, $FE, $D2, $C3, $DD, $D9

	; (Terminator)
	.byte $FF


	; Bonus_Return2_SetMapPos:
	;
	; A strange subroutine called for Bonus_GameType = BONUS_UNUSED_2RETURN!!
	; It forces the Player to a different map position ??
	; And marks them as having died in the bonus game ??!
	;
	; Since it references Bonus_KTPrize, it MAY have been Koopa Troopa's 
	; "Prize" Game... but death?  I'm not sure the prize is worth it! D:

Bonus_Return2Row:	.byte $50, $40, $80, $60	; Literally Map Y
Bonus_Return2Col:	.byte $50, $A0, $40, $A0	; Upper bits is column, lower bits is map screen i.e. XHi

Bonus_Return2_SetMapPos:

	; Temp_Var1 = Bonus_KTPrize * 2
	LDA Bonus_KTPrize	; <-- !! A reference to Bonus_KTPrize
	ASL A
	STA <Temp_Var1

	LDY Player_Current	 ; Y = Player_Current

	LDA Map_Previous_Dir,Y
	AND #$0a
	BEQ PRG022_CBDD	 ; If Player didn't move up or left, jump to PRG022_CBDD

	INC <Temp_Var1		 ; Temp_Var1++

PRG022_CBDD:
	LDX <Temp_Var1		 ; X = Temp_Var1

	LDA Bonus_Return2Row,X
	STA Map_Previous_Y,Y

	LDA Bonus_Return2Col,X
	AND #$f0
	STA Map_Previous_X,Y

	LDA Bonus_Return2Col,X
	AND #$0f
	STA Map_Previous_XHi,Y

	; Player "died" ?!!
	LDA #$01
	STA Map_ReturnStatus

	RTS		 ; Return

Die_OddEven:		.byte $00, $01	; Match the odd/even (NOTE: Die face is 0 = 1, 1 = 2, etc. so odd first, then even, etc.)
Die_OddEvenMatch:	.byte BONUS_UNUSED_ODDROULETTE, BONUS_UNUSED_EVENCARD	; Sets Bonus_DieCnt to this value!

Bonus_DieRotate:
	INC Bonus_DieCnt	; Bonus_DieCnt++

	LDA Bonus_DieCnt
	AND #$03
	BNE PRG022_CC18	 ; 1:4 ticks proceed, otherwise jump to PRG022_CC18

	INC Bonus_DiePos	 ; Bonus_DiePos++

	; Cap the die 0-5
	LDA Bonus_DiePos
	CMP #$06
	BNE PRG022_CC18	 ; If Bonus_DiePos <> $06, jump to PRG022_CC18

	; Bonus_DiePos= 0
	LDA #$00
	STA Bonus_DiePos

PRG022_CC18:
	LDA <Pad_Input
	AND #PAD_A
	BEQ Bonus_DrawDie	; If Player is not pressing 'A', just go draw the Die

	; Player pressed 'A'...
	
	LDA #$00
	STA Bonus_DieCnt ; Bonus_DieCnt = 0 
	STA Bonus_UnusedFlag ; Bonus_UnusedFlag = 0


	; The following is WRONG, because the Spade/N-Spade Bonus Games will never use this state!

	; This was the Odd/Even game as specified by the Japanese messages:
	; "If an odd number appears, I'll let you play the Roulette Game."
	; "If an even number appears, I'll let you play the Card Game."

	LDY #$00	 ; Y = 0 (Odd die face value will "win")

	LDA Bonus_GameType
	CMP #BONUS_SPADE	; <-- should be replaced by BONUS_UNUSED_ODDROULETTE
	BEQ PRG022_CC34	 ; If Bonus_GameType = BONUS_SPADE, jump to PRG022_CC34

	INY		 ; Y = 1 (Even die face value will "win")

	CMP #BONUS_NSPADE	; <-- should be replaced by BONUS_UNUSED_EVENCARD
	BNE PRG022_CC4C	 ; If Bonus_GameType <> BONUS_NSPADE, jump to PRG022_CC4C

PRG022_CC34:

	; Even / Odd Bonus Game

	LDA Bonus_DiePos
	AND #$01	 	; Check odd/even of die
	CMP Die_OddEven,Y
	BNE PRG022_CC44	 	; If die is not on proper odd/even, jump to PRG022_CC44

	; Odd/Even matched win

	; Set Bonus_DieCnt to the cooresponding Die_OddEvenMatch value
	LDA Die_OddEvenMatch,Y
	STA Bonus_DieCnt

PRG022_CC44:

	; End of the Odd or Even game!  Whether you won or lost, the die will now fly away.  
	; If you won, you go on to "Round 2"; if you lost, bail to world map.

	; Bonus_GameState = 4
	LDA #$04
	STA Bonus_GameState

	JMP Bonus_DrawDie	; Draw Die and don't come back!!

PRG022_CC4C:

	; Not the Even / Odd game

	LDX Bonus_DiePos	; X = Bonus_DiePos
	CPX #$02
	BLT PRG022_CC57	 	; If Bonus_DiePos < 2 (Die face value 3), jump to PRG022_CC57

	; Die face value 3 or greater nets you (Face Value * 10) points

	; NOTE: This was "probably" supposed to go to your coins if the Japanese message is correct
	; Further hinted because "coins" pop out...

	; If "1" appears, 1 (?)
	; If "2" appears, I'll give you a key
	; Otherwise, I'll give you coins.

	INX		 ; X++ (because "pos 0" --> Face value 1, etc.)
	STX Score_Earned ; -> Score_Earned

PRG022_CC57:
	INC Bonus_GameState	; Bonus_GameState = 3


Bonus_DrawDie:

	; Set left/right die sprites Y
	LDA <BonusDie_Y		 
	STA Sprite_RAM+$F8
	STA Sprite_RAM+$FC

	; Set left/right die sprites patterns
	LDA Bonus_DiePos
	ASL A
	ORA #$11
	STA Sprite_RAM+$F9
	STA Sprite_RAM+$FD

	; Set left half of die attributes
	LDA #SPR_PAL3
	STA Sprite_RAM+$FA

	; Set right half of die attributes
	LDA #(SPR_PAL3 | SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$FE

	; Set left half of die X
	LDA <BonusDie_X
	STA Sprite_RAM+$FB

	; Set right half of die X
	ADD #$08
	STA Sprite_RAM+$FF

	RTS		 ; Return

	; ?? Is this another message?
PRG022_CC84:
	.byte $CB, $DE, $E5, $BB, $E7, $FE, $B3, $E5, $FF, $60
	
; FIXME: Anyone want to claim this?
; Seems like it would display a short message maybe (above)
; $CC8E
	LDA Bonus_UnusedFlag
	BNE PRG022_CCED	 ; If Bonus_UnusedFlag <> 0, jump to PRG022_CCED (RTS)

	INC BonusText_CharPause	 ; BonusText_CharPause++

	LDA BonusText_CharPause
	AND #$03
	BNE PRG022_CCED	 ; 1:4 ticks proceed, otherwise jump to PRG022_CCED (RTS)

PRG022_CC9D:
	LDX BonusText_CPos	 ; X = BonusText_CPos

	LDA PRG022_CC84,X
	BNE PRG022_CCB0

	; Bonus_UnusedVL = $55
	LDA #$55
	STA Bonus_UnusedVL

	INC BonusText_CPos

	JMP PRG022_CC9D	 ; Jump to PRG022_CC9D

PRG022_CCB0:
	CMP #$ff
	BNE PRG022_CCC2	

	LDA #$35
	STA Bonus_UnusedVL

	LDA #$00
	STA BonusText_CPos

	INC Bonus_UnusedFlag

	RTS		 ; Return


PRG022_CCC2:
	LDY Graphics_BufCnt
	STA Graphics_Buffer+$03,Y

	LDA Bonus_UnusedVH
	STA Graphics_Buffer+$00,Y
	LDA Bonus_UnusedVL
	STA Graphics_Buffer+$01,Y

	LDA #$01
	STA Graphics_Buffer+$02,Y

	LDA #$00
	STA Graphics_Buffer+$04,Y

	LDA Graphics_BufCnt
	ADD #$04
	STA Graphics_BufCnt

	INC Bonus_UnusedVL
	INC BonusText_CPos

PRG022_CCED:
	RTS		 ; Return


Bonus_DieFlyAway:
	LDA <Counter_1		 
	AND #$01
	BNE PRG022_CD03	 ; Every other tick, jump to PRG022_CD03


	; The die rotates through its faces as it "flies away"

	INC Bonus_DiePos	 ; Bonus_DiePos++

	; Cap the die 0-5
	LDA Bonus_DiePos
	CMP #$06
	BNE PRG022_CD03	 ; If Bonus_DiePos <> $06, jump to PRG022_CD03

	; Bonus_DiePos = 0
	LDA #$00
	STA Bonus_DiePos

PRG022_CD03:
	LDA <BonusDie_YVel
	CMP #-$80
	BEQ PRG022_CD0E	 ; If BonusDie_YVel = -$80, jump to PRG022_CD0E

	; BonusDie_YVel -= $08
	SUB #$08
	STA <BonusDie_YVel

PRG022_CD0E:
	LDA <BonusDie_YVel	; Get die Velocity
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 	; Fractional part shifted up
	STA <Temp_Var1		; -> Temp_Var1

	LDA <BonusDie_YVel	; Get Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PRG022_CD22	 ; If the value was not negatively signed, jump to PRG022_CD22
	ORA #%11110000	 ; Apply a sign extension
PRG022_CD22:
	STA <Temp_Var2	 ; -> Temp_Var2

	; Add to die's velocity fractional accumulator
	LDA <BonusDie_YVelFrac
	ADD <Temp_Var1
	STA <BonusDie_YVelFrac

	; Add appropriately to die's Y
	LDA <BonusDie_Y
	ADC <Temp_Var2
	STA <BonusDie_Y
 
	LDA <BonusDie_Y
	CMP #$f8
	BLT PRG022_CD50	 ; If bonus die hasn't wrapped, jump to PRG022_CD50

	; Hide bonus die
	LDA #$f8
	STA <BonusDie_Y

	; Halt its velocity
	LDA #$00
	STA <BonusDie_YVel

	; Bonus_UnusedFlag = 0 
	STA Bonus_UnusedFlag

	LDA Bonus_DieCnt
	BEQ PRG022_CD4B		; If Bonus_DieCnt = 0 (not a winner of the Odd/Even game), jump to PRG022_CD4B

	; Winners of Odd/Even Game only!
	INC Bonus_GameState	; Bonus_GameState = 6

	; NOTE: Bonus_Round2 (i.e. what game we're going to next) was set by the intro dialog text!

	RTS		 ; Return

PRG022_CD4B:

	; Bonus_GameState = 8
	LDA #$08
	STA Bonus_GameState

PRG022_CD50:
	RTS		 ; Return


Bonus_GetDiePrize:
	LDA Bonus_DiePos
	CMP #$02
	BGE PRG022_CD6F		; If Bonus_DiePos >= 2 (Die face value of 3 or more, coin prizes), jump to PRG022_CD6F

	CMP #$01
	BNE PRG022_CD65	 ; If Die face value is NOT 2 (i.e. it is 1), jump to PRG022_CD65

	; "If 2 appears, I'll give you a key"

	; Ultimately it is unclear what this was INTENDED to do.  It modifies the first
	; byte of the Player's "inventory" score (i.e. the backup used for Players
	; switching turns), but not in a "safe" way that carries through the other bytes.
	; That alone makes me believe that the memory in that area originally was for
	; "something else"... what exactly I can't say!  I only know it presently makes
	; no sense and is -- in a small way -- corrupting memory and nothing more...

	; This will increment the byte at Inventory_Cards + 3, which is the Player's score; but that
	; will be overwritten when the game exits with the "current" score)
	; In any case, not a "key" :(
	LDX #$03	 ; X = 3
	JSR Bonus_Prize1 ; Get your prize?

	INC Bonus_GameState	 ; Bonus_GameState = 4

	RTS		 ; Return

PRG022_CD65:

	; "If 1 appears, 1 (?)"

	; Give Player an extra life ... apparently
	LDX Player_Current
	INC Player_Lives,X

	INC Bonus_GameState	 ; Bonus_GameState = 4

	RTS		 ; Return

PRG022_CD6F:

	; Coin prizes

	LDA BonusCoins_State
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BonusCoins_Init		; 0: Initializes bonus coins based on value of the Die (Bonus_DiePos)
	.word BonusCoins_UpdateAndDraw	; 1: Update and draw bonus coins until they've all fallen off-screen

BonusCoins_Init:
	LDY Bonus_DiePos	 ; Y = Bonus_DiePos
PRG022_CD7C:

	; Set coins to appear front and center!
	LDA #$78
	STA Bonus_CoinsY,Y
	STA Bonus_CoinsX,Y

	LDX #-$10	 ; X = -$10

	LDA RandomN,Y	; Get random value
	ASL A		; Multiply by 2
	PHA		; Save it
	BCC PRG022_CD8F	; 50/50 chance jump to PRG022_CD8F

	LDX #$00	; Otherwise, X = $00
PRG022_CD8F:

	; Temp_Var1 = -$10 or $00
	TXA
	STA <Temp_Var1

	PLA		 	; Restore random value
	AND #$0f	 	; Keep lower 4 bits
	ORA <Temp_Var1	 	; OR onto Temp_Var1
	STA Bonus_CoinsXVel,Y	; -> Bonus_CoinsXVel

	LDA RandomN,Y
	AND #$07		; Random 0-7
	ORA #-$40		; Base -$40
	STA Bonus_CoinsYVel,Y	; -> Bonus_CoinsYVel

	DEY		 ; Y--
	BPL PRG022_CD7C	 ; While Y >= 0, loop!

	INC BonusCoins_State	; BonusCoins_State = 1
	RTS		 ; Return

BonusCoins_UpdateAndDraw:
	LDY Bonus_DiePos	 ; Y = Bonus_DiePos
PRG022_CDAE:
	JSR BonusCoin_ApplyYVel	 ; Apply Y velocity to coin
	JSR BonusCoin_ApplyXVel	 ; Apply X velocity to coin

	; Coins fall rate
	LDA Bonus_CoinsYVel,Y
	ADD #$02
	STA Bonus_CoinsYVel,Y

	DEY		 ; Y--
	BPL PRG022_CDAE	 ; While Y >= 0, loop

	JSR BonusCoins_Draw	 ; Draw the bonus coins


	LDY Bonus_DiePos	 ; Y = Bonus_DiePos
PRG022_CDC6:
	LDA Bonus_CoinsY,Y
	CMP #$f8
	BNE PRG022_CDD3	 ; If this coin is not off-screen, jump to PRG022_CDD3 (RTS)

	DEY		 ; Y--
	BPL PRG022_CDC6	 ; While Y >= 0, loop

	; All coins are off-screen; proceed!
	INC Bonus_GameState	 ; Bonus_GameState = 4

PRG022_CDD3:
	RTS		 ; Return

BonusCoin_ApplyXVel:

	; Offset to coin X velocity
	TYA		 
	ADD #(Bonus_CoinsXVelFrac - Bonus_CoinsYVelFrac)
	TAY

	JSR BonusCoin_ApplyVel	 ; Apply X velocity to coin

	; Offset back
	TYA
	SUB #(Bonus_CoinsXVelFrac - Bonus_CoinsYVelFrac)
	TAY

	RTS		 ; Return


BonusCoin_ApplyYVel:
	; Note: This check is superfluous because of the following one!
	LDA Bonus_CoinsYVel,Y	 
	BMI BonusCoin_ApplyVel	 ; If coin is moving upward, apply velocity to coin and don't come back

	CMP #$40
	BLS BonusCoin_ApplyVel	 ; If coin is moving downward < $40, apply velocity to coin and don't come back

	; Max coin falling speed at $40
	LDA #$40
	STA Bonus_CoinsYVel,Y

BonusCoin_ApplyVel:
	LDA Bonus_CoinsYVel,Y	; Get coin Velocity
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 	; Fractional part shifted up
	STA <Temp_Var1		; -> Temp_Var1

	LDX #$00	 ; X = 0 (positive high part)

	LDA Bonus_CoinsYVel,Y	; Get Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PRG022_CE09	 ; If the value was not negatively signed, jump to PRG022_CE09
	DEX		 ; X = $FF (negative high part)
	ORA #%11110000	 ; Apply a sign extension
PRG022_CE09:
	STA <Temp_Var2	 ; -> Temp_Var2

	; Add to coin's velocity fractional accumulator
	LDA Bonus_CoinsYVelFrac,Y
	ADD <Temp_Var1
	STA Bonus_CoinsYVelFrac,Y

	; Add appropriately to coin's Y
	LDA Bonus_CoinsY,Y
	ADC <Temp_Var2
	STA Bonus_CoinsY,Y

	RTS		 ; Return


BonusCoins_Draw:
	LDY Bonus_DiePos	; Y = Bonus_DiePos

PRG022_CE20:
	TYA
	ASL A
	ASL A
	TAX		; X = Y * 4 (offset in Sprite RAM to coin's sprite)

	LDA Bonus_CoinsY,Y
	CMP #192
	BLT PRG022_CE30	 ; If coin Y < 192 (top of status bar), jump to PRG022_CE30

	; Coin too low; set coin Y = $F8 (hide it!)
	LDA #$f8
	STA Bonus_CoinsY,Y

PRG022_CE30:

	; Set coin sprite Y
	STA Sprite_RAM+$80,X

	; Set coin sprite pattern
	LDA #$61
	STA Sprite_RAM+$81,X

	; Set coin attribute
	LDA #SPR_PAL1
	STA Sprite_RAM+$82,X

	; Set coin sprite X
	LDA Bonus_CoinsX,Y
	STA Sprite_RAM+$83,X

	DEY		 ; Y--
	BPL PRG022_CE20	 ; While Y >= 0, loop
	RTS		 ; Return


Bonus_Wait80:
	LDA Bonus_Timer
	BNE PRG022_CE51	 ; If Bonus_Timer <> 0, jump to PRG022_CE51

	; Bonus_Timer = $80
	LDA #$80
	STA Bonus_Timer

PRG022_CE51:
	DEC Bonus_Timer	 ; Bonus_Timer--
	BNE PRG022_CE64	 ; If Bonus_Timer has not expired, jump to PRG022_CE64

	INC Bonus_GameState	 ; Bonus_GameState = 5/9

	LDA Bonus_GameState
	CMP #$09
	BNE PRG022_CE64	 ; If Bonus_GameState <> 9, jump to PRG022_CE64 (RTS)

	; Otherwise, exit to map
	LDA #$01
	STA <Level_ExitToMap

PRG022_CE64:
	RTS		 ; Return


Roulette_BorderSprites:
	.byte $0F, $03, $00, $08
	.byte $0F, $05, $00, $F0
	.byte $0F, $0B, $00, $F8
	.byte $AF, $09, $00, $08
	.byte $AF, $07, $00, $F0
	.byte $AF, $0B, $00, $F8

Roulette_DrawBorderSprites:

	; Temp_Var1 = 31 (Sprite Y start)
	LDA #31
	STA <Temp_Var1

	LDY #$60	; Y = $60 (Sprite RAM offset)
PRG022_CE83:

	; Set Sprite Ys
	LDA <Temp_Var1	
	STA Sprite_RAM+$04,Y
	STA Sprite_RAM+$08,Y
	STA Sprite_RAM+$0C,Y

	; Set border sprite patterns
	LDA #$01
	STA Sprite_RAM+$05,Y
	STA Sprite_RAM+$09,Y

	; Set right edge black sprite pattern
	LDA #$0b
	STA Sprite_RAM+$0D,Y

	; Set sprite attributes
	LDA #SPR_PAL0
	STA Sprite_RAM+$06,Y
	STA Sprite_RAM+$0A,Y
	STA Sprite_RAM+$0E,Y

	; Set sprite Xs
	LDA #8
	STA Sprite_RAM+$07,Y
	LDA #240
	STA Sprite_RAM+$0B,Y
	LDA #248
	STA Sprite_RAM+$0F,Y

	; Temp_Var1 (Sprite Y) += 16
	LDA <Temp_Var1
	ADD #16
	STA <Temp_Var1

	TYA
	SUB #12		; -12 (3 sprites prior)
	TAY	

	BPL PRG022_CE83	 ; While Y >= 0, loop!


	LDY #$17
PRG022_CEC5:
	LDA Roulette_BorderSprites,Y
	STA Sprite_RAM+$70,Y

	DEY		 ; Y--
	BPL PRG022_CEC5	 ; While Y >= 0, loop

	RTS		 ; Return


UpdSel_Roulette:
	; Caution: You're on interrupt time here!

	; Performing some work that got skipped because we diverted here in the interrupt

	LDA #$00	 ; A = 0
	STA PPU_CTL2	 ; Hide sprites and bg (most importantly)
	STA PPU_SPR_ADDR ; Resets to sprite 0 in memory

	LDA #$02	 ; A = 2
	STA SPR_DMA	 ; DMA sprites from RAM @ $200 (probably trying to blank them out)

	JSR PT2_Full_CHRROM_Switch	 ; Set up PT2 (Sprites) CHRROM

	LDA <Graphics_Queue
	ASL A
	TAX		 ; X = Graphics_Queue * 2

	; Roulette maintains its own update table, though not really used
	LDA Video_Upd_TableRoulette,X
	STA <Video_Upd_AddrL
	LDA Video_Upd_TableRoulette+1,X
	STA <Video_Upd_AddrH

	JSR Video_Misc_Updates	 ; Various updates other than scrolling (palettes, status bar, etc.)

	; Graphics_Queue = 0
	LDA #$00
	STA <Graphics_Queue

	STA Graphics_BufCnt	; Reset Graphics_Buffer counter
	STA Graphics_Buffer+$00	; Terminate it

	LDA PPU_STAT

	; Unknown hardware thing?  Is this for synchronization?
	LDX #$3f	 	; 
	STX PPU_VRAM_ADDR	; Access PPU address #3Fxx
	LDA #$00	 	; 
	STA PPU_VRAM_ADDR	; Access PPU address #3F00 (palettes?)
	STA PPU_VRAM_ADDR	; 
	STA PPU_VRAM_ADDR	; Now accessing $0000 (Pattern tables?)

	LDA <PPU_CTL2_Copy
	ORA #%00011000
	STA PPU_CTL2	 ; Show BG+Sprites

	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	LDA #$a8
	STA PPU_CTL1

	LDA PPU_STAT

	LDA #$00
	STA PPU_SCROLL
	STA PPU_SCROLL

	LDA PPU_STAT

	LDA #$ff
	STA MMC3_IRQCNT
	STA MMC3_IRQLATCH

	; Unknown hardware thing?  Is this for synchronization?
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR

	; Fire on scanline 32
	LDA #$20
	STA MMC3_IRQCNT
	STA MMC3_IRQLATCH
	STA MMC3_IRQENABLE

	CLI		; Enable maskable interrupts

	JSR Read_Joypads	 ; Updates both joypads in RAM

	LDX #$00	 ; X = 0
	LDY #$02	 ; Y = 2

	; Temp_Var1 = 0 or 2, random
	LDA Random_Pool
	AND #$02
	STA <Temp_Var1

	; Temp_Var1 = 0 or 2, random
	LDA RandomN
	AND #$02
	EOR <Temp_Var1

	CLC		 ; Clear carry

	BEQ PRG022_CF7C	 ; If random result is zero, jump to PRG022_CF7C

	SEC		 ; Set carry if non-zero

	; Rotates the first couple random values around
PRG022_CF7C:
	ROR Random_Pool,X
	INX		 ; X = 1
	DEY		 ; Y--
	BNE PRG022_CF7C	 ; While Y >= 0, loop

	JSR Roulette_DoGame	 ; Actually run the Roulette game

	; Switch to page 26 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #26		
	STA MMC3_PAGE	 

	JSR StatusBar_UpdateValues	 ; Update Status Bar (not really used)

	; Switch to page 28 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #28	
	STA MMC3_PAGE	 

	; Jump to the sound engine, newly inserted at page A000!
	JSR Sound_Engine_Begin

	; Change A000 back to whatever it was before the sound engine 
	JSR PRGROM_Change_A000

	INC <Counter_1	 ; Simply increments every frame, used for timing

	; Pull (pop) the three temp vars from the stack 
	PLA
	STA <Temp_Var3
	PLA
	STA <Temp_Var2
	PLA
	STA <Temp_Var1

	; This pulls (pops) all the registers from the stack...
	PLA
	TAY
	PLA
	TAX
	PLA
	PLP

	; Fully cleaned up "NMI" interrupt
	RTI


Video_Upd_TableRoulette:
	.word Graphics_Buffer

	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $BE, $07

Video_RoulBordAttr:
	vaddr $2020
	.byte VU_REPEAT | $20, $FC

	vaddr $2040
	.byte VU_REPEAT | $20, $FC

	vaddr $2061
	.byte VU_REPEAT | $1E, $A1

	vaddr $22E0
	.byte VU_REPEAT | $20, $FF

	vaddr $26E0
	.byte VU_REPEAT | $20, $FF

	vaddr $23C8
	.byte $20, $55, $55, $D5, $F5, $F5, $75, $55, $55, $55, $55, $DD, $FF, $FF, $77, $55
	.byte $55, $55, $55, $DD, $FF, $FF, $77, $95, $A5, $55, $55, $DD, $FF, $FF, $77, $99, $AA

	vaddr $23E8
	.byte VU_REPEAT | $08, $55

	vaddr $27C0
	.byte VU_REPEAT | $08, $55

	vaddr $27C8
	.byte $20, $55, $55, $D5, $F5, $F5, $75, $55, $55, $55, $55, $DD, $FF, $FF, $77, $55
	.byte $55, $A5, $65, $DD, $FF, $FF, $77, $55, $55, $AA, $66, $DD, $FF, $FF, $77, $55, $55

	vaddr $27E8
	.byte VU_REPEAT | $08, $55

	; Terminator
	.byte $00

Roulette_DoGame:
	LDA Roulette_ConfigRun
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Roulette_Configure	; Configure Roulette game
	.word Roulette_RunGame		; Run it!

Roulette_Configure:
	LDA Roulette_ConfigState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Roulette_ConfigPPUCTL2	; Set up to show BG+Sprites
	.word Roulette_ConfigTurns	; Set number of turns (always 0!)

Roulette_ConfigPPUCTL2:

	; Show BG+Sprites
	LDA #$18
	STA <PPU_CTL2_Copy

	INC Roulette_ConfigState	; Roulette_ConfigState = 1

	RTS		 ; Return 

Roulette_ConfigTurns:
	INC Roulette_ConfigRun	; Roulette_ConfigRun = 1

	; Roulette_Turns = 0 (No extra turns for you!)
	LDA #$00
	STA Roulette_Turns

	RTS		 ; Return

Roulette_RunGame:
	LDA Roulette_RunState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Roulette_Init		; 0: Initialize the game
	.word Roulette_Run		; 1: Run the game
	.word Roulette_FadeOut		; 2: Fade to black
	.word Roulette_ExitToMap	; 3: Exit to map
	.word Roulette_GiveReward	; 4: Get extra lives prize and display sprite

Roulette_Init:
	LDA #$00
	STA Roulette_StopState	 ; Roulette_StopState = 0
	STA Roulette_StopState+1	 ; Roulette_StopState+1 = 0
	STA Roulette_StopState+2	 ; Roulette_StopState+2 = 0
	STA Roulette_Lives	 ; Roulette_Lives = 0

	; Roulette_Speed = $70
	LDA #$70
	STA Roulette_Speed

	; Roulette_Speed+1 = $90
	LDA #$90
	STA Roulette_Speed+1

	; Roulette_Speed+2 = $7F
	LDA #$7f
	STA Roulette_Speed+2

	; Roulette_Unused7A5F_Delta = $30
	LDA #$30
	STA Roulette_Unused7A5F_Delta

	INC Roulette_RunState	 ; Roulette_RunState = 1 (Run game)

	JMP Roulette_DrawBorderSprites	 ; Draw border sprites and don't come back!

Roulette_Run:
	LDA <Pad_Input
	AND #(PAD_A | PAD_B)
	BEQ PRG022_D0DF	 ; If Player is NOT pressing A or B, jump to PRG022_D0DF

	; Player is pressing A or B...

	LDA Roulette_StopState
	BNE PRG022_D0A2	 ; If row 1 is already stopping/stopped, jump to PRG022_D0A2

	; Row 1 needs to be stopped...

	INC Roulette_StopState	 ; Row 1's stop state = 1

	; Set Roulette_StopCnt = $20 to $2F, random
	LDA RandomN
	AND #$0f
	ORA #$20
	STA Roulette_StopCnt

	JMP PRG022_D0D7	 ; Jump to PRG022_D0D7

PRG022_D0A2:
	LDA Roulette_StopState+1
	BNE PRG022_D0BE	 ; If row 2 is already stopping/stopped, jump to PRG022_D0BE

	LDA Roulette_StopState
	CMP #$02
	BLT PRG022_D0BE	 ; If Row 1 is not close enough to stopping yet, jump to PRG022_D0BE

	INC Roulette_StopState+1	 ; Row 2's stop state = 1

	; Set Roulette_StopCnt+1 = $20 to $3F, random
	LDA RandomN+1
	AND #$1f
	ORA #$20
	STA Roulette_StopCnt+1

	JMP PRG022_D0D7	 ; Jump to PRG022_D0D7

PRG022_D0BE:
	LDA Roulette_StopState+2
	BNE PRG022_D0DF	 ; If row 3 is already stopping/stopped, jump to PRG022_D0DF

	LDA Roulette_StopState+1
	CMP #$02
	BLT PRG022_D0DF	 ; If Row 2 is not close enough to stopping yet, jump to PRG022_D0DF

	INC Roulette_StopState+2	 ; Row 3's stop state = 1

	; Set Roulette_StopCnt+2 = $40 to $7F, random
	LDA RandomN+2
	AND #$3f
	ORA #$40
	STA Roulette_StopCnt+2

PRG022_D0D7:
	; Bleep sound
	LDA Sound_QMap
	ORA #SND_MAPPATHMOVE
	STA Sound_QMap

PRG022_D0DF:

	LDX #$02
PRG022_D0E1:
	STX <Roulette_RowIdx	; Update Roulette_RowIdx

	LDA Roulette_StopCnt,X
	BEQ PRG022_D0EB		; If this row's stop counter = 0, jump to PRG022_D0EB

	DEC Roulette_StopCnt,X	 ; Otherwise, decrement this row's stop counter

PRG022_D0EB:
	JSR RouletteRow_DoStopState	 ; Do the row's stop state code

	DEX		 ; X--
	BPL PRG022_D0E1	 ; While X >= 0, loop!

	RTS		 ; Return

RouletteRow_DoStopState:
	LDA Roulette_StopState,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word RouletteRow_Move		; 0: Row is not stopping; it is running, if you will
	.word RouletteRow_WaitToStop	; 1: Waits for specific Roulette_StopCnt to hit zero
	.word RouletteRow_Slow		; 2: Slow down row
	.word RouletteRow_HitLockPos	; 3: Slide row into lock position
	.word RouletteRow_LockDecide	; 4: Lock, bounce, decide reward, if any
	.word RouletteRow_EndTurn	; 5: End-of-turn logic (in modern game there are no more turns, Roulette_Turns = 0)

RouletteRow_Move:
	CPX #$02
	BNE PRG022_D11C	 ; If this is NOT row 3, jump to PRG022_D11C

	; On row 3 only... (basically stuff updated only once for all rows)

	; Roulette_Unused7A5F (value never used for anything) += Roulette_Unused7A5F_Delta
	LDA Roulette_Unused7A5F
	ADD Roulette_Unused7A5F_Delta
	STA Roulette_Unused7A5F

	; Something removed?
	NOP
	NOP

	; Play the "ringing" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERPOWER
	STA Sound_QPlayer

PRG022_D11C:
	JMP Roulette_MoveRow	 ; Jump to Roulette_MoveRow


RouletteRow_WaitToStop:
	LDA Roulette_StopCnt,X
	BNE RouletteRow_Move	 ; If this row's stop counter is not zero, move the Roulette rows and don't come back...

	INC Roulette_StopState,X ; This row's stop state = 2

	JMP RouletteRow_Move	 ; Move the Roulette rows and don't come back...


RouletteRow_Slow:
	LDA Roulette_Speed,X
	ADD #$3f
	CMP #$7f
	BGE PRG022_D13A	 ; If we have not reached a stop speed, jump to PRG022_D13A

	INC Roulette_StopState,X ; This row's stop state = 3
	JMP RouletteRow_Move	 ; Move the Roulette rows and don't come back...

PRG022_D13A:
	CPX #$02
	BNE PRG022_D151	 ; If this is not the third row, jump to PRG022_D151

	; Roulette_Unused7A5F_Delta is added to Roulette_Unused7A5F, but Roulette_Unused7A5F itself is never used!

	LDA Roulette_Unused7A5F_Delta
	CMP #$11
	BLT PRG022_D151	 ; If Roulette_Unused7A5F_Delta < $11, jump to PRG022_D151

	DEC Roulette_Unused7A5F_Delta	 ; Roulette_Unused7A5F_Delta--

	LDA <Counter_1
	AND #$01
	BNE PRG022_D151	 	; Every other tick, jump to PRG022_D151

	DEC Roulette_Unused7A5F_Delta	 ; Roulette_Unused7A5F_Delta--

PRG022_D151:
	LDA Roulette_Speed,X
	BPL PRG022_D15F	 ; If Roulette_Speed is positive, jump to PRG022_D15F

	; Roulette_Speed += 4
	LDA Roulette_Speed,X
	ADD #$04		; Really +2, but it hits the -2 after this
	STA Roulette_Speed,X

PRG022_D15F:
	; Roulette_Speed -= 2
	LDA Roulette_Speed,X
	SUB #$02
	STA Roulette_Speed,X

	JMP RouletteRow_Move	 ; Move the Roulette rows and don't come back...


RouletteRow_HitLockPos:
	LDA Roulette_Pos,X
	AND #%01111100
	BNE PRG022_D192	 ; If this is not a lock position, jump to PRG022_D192

	; "Swim" sound (row locking)
	LDA #SND_PLAYERSWIM
	STA Sound_QPlayer

	; Roulette_StopCnt = $12
	LDA #$12
	STA Roulette_StopCnt,X

	; Lock row position
	LDA Roulette_Pos,X
	ADD #$20
	AND #$80
	STA Roulette_Pos,X
	LDA Roulette_PosHi,X
	ADC #$00
	STA Roulette_PosHi,X

	INC Roulette_StopState,X ; This row's stop state = 4

PRG022_D192:
	JMP RouletteRow_Move	 ; Move the Roulette rows and don't come back...

Roulette_MatchSets:
	.byte $00, $02		; First row Mushroom (primary) alternating mushroom matches
	.byte $01, $01		; First row Flower (nothing special)
	.byte $02, $00		; First row Muchroom (secondary) alternating mushroom matches
	.byte $03, $03		; First row Star (nothing special)

Roulette_MatchReward:
	.byte $02, $03, $02, $05	; Number of lives you get (Mushroom, Flower, Mushroom, Star)

RouletteRow_LockDecide:
	LDA Roulette_StopCnt,X
	BNE PRG022_D20B	 ; If this row's stop counter is not zero, jump to PRG022_D20B

	; Enforce the lock position
	LDA Roulette_Pos,X
	ADD #$20
	AND #$80
	STA Roulette_Pos,X
	STA <Temp_Var1		 ; -> Temp_Var1
	LDA Roulette_PosHi,X
	ADC #$00
	STA Roulette_PosHi,X

	ASL <Temp_Var1
	ROL A
	AND #$03
	STA Roulette_ShapeLock,X

	CPX #$02
	BNE PRG022_D205	 ; If this is not the third row, jump to PRG022_D205

	; Roulette_StopCnt = $50
	LDA #$50
	STA Roulette_StopCnt,X

	LDA Roulette_ShapeLock
	ASL A
	TAY		 ; Y = Roulette_ShapeLock * 2

	LDX #$01	 ; X = 1 (mainly for the dual mushroom, there is two possible matches)
PRG022_D1D3:
	LDA Roulette_ShapeLock+1,X

	CMP Roulette_MatchSets,Y
	BEQ PRG022_D1E0	 ; If the first row locked shape matches this row, jump to PRG022_D1E0

	CMP Roulette_MatchSets+1,Y
	BNE PRG022_D200	 ; If we have a mismatch, jump to PRG022_D200

PRG022_D1E0:
	DEX		; X--
	BPL PRG022_D1D3	; While X >= 0, loop

	LDY Roulette_ShapeLock	 ; Y = Roulette_ShapeLock

	LDA Roulette_MatchReward,Y
	STA Roulette_Lives

	; Roulette_RunState = 4
	LDA #$04
	STA Roulette_RunState

	; Roulette_xUpY = 240
	LDA #240
	STA Roulette_xUpY

	; Roulette_StopCnt = 0
	LDA #$00
	STA Roulette_StopCnt

	LDX <Roulette_RowIdx		 ; X = Roulette_RowIdx

	; Do NOT return to caller
	PLA
	PLA

	RTS		 ; Return

PRG022_D200:
	; Play mismatch sound
	LDA #SND_MAPDENY
	STA Sound_QMap

PRG022_D205:
	LDX <Roulette_RowIdx		 ; X = Roulette_RowIdx

	INC Roulette_StopState,X ; This row's stop state = 5

	RTS		 ; Return

PRG022_D20B:
	LDY #$10	 ; Y = $10

	AND #$04
	BNE PRG022_D213	 ; 4 ticks on, 4 ticks off; jump to PRG022_D213

	LDY #-$10	 ; Y = -$10

PRG022_D213:

	; Set Roulette_Speed = $10/-$10 ("bounce" effect as locking)
	TYA
	STA Roulette_Speed,X

	JMP RouletteRow_Move	 ; Move the Roulette rows and don't come back...

RouletteRow_EndTurn:
	CPX #$02
	BNE PRG022_D223	 ; If this is not the third row, jump to PRG022_D223 (RTS) (doesn't do anything)

	LDA Roulette_StopCnt,X
	BEQ PRG022_D224	 ; If the stop counter is zero, jump to PRG022_D224

PRG022_D223:
	RTS		 ; Return

PRG022_D224:
	LDA Roulette_Turns
	BEQ PRG022_D238	 ; If Roulette_Turns = 0 (out of turns), jump to PRG022_D238

	; At least one turn remaining ... (this is UNUSED!)

	LDA <Pad_Holding
	AND #(PAD_A | PAD_B | PAD_START)
	BEQ PRG022_D237	 ; If Player is not pressing A, B, or START, jump to PRG022_D237

	DEC Roulette_Turns	 ; Roulette_Turns--

	; Roulette_RunState = 0 (re-initialize for another round!)
	LDA #$00
	STA Roulette_RunState

PRG022_D237:
	RTS		 ; Return

PRG022_D238:

	; Do not return to caller
	PLA
	PLA

PRG022_D23A:
	; Roulette_RunState = 2
	LDA #$02
	STA Roulette_RunState

	; Roulette_StopState = 0 <-- Reusing it differently, as pal fadeout prep flag
	LDA #$00
	STA Roulette_StopState

	RTS		 ; Return

Roulette_FadeOut:
	LDA Roulette_StopState	; Being reused as a flag here
	BNE PRG022_D250	 	; If Roulette_StopState <> 0 (palette fade prepared), jump to PRG022_D250

	INC Roulette_StopState	 ; Roulette_StopState = 1

	JMP Palette_PrepareFadeOut	 ; Prepare to fade out

PRG022_D250:
	JSR Roulette_DoFadeOut	 ; Do palette fade out

	LDA Fade_Level
	BNE PRG022_D52B	 ; If not completely faded out, jump to PRG022_D52B (RTS)

	INC Roulette_RunState	 ; Roulette_RunState = 3

PRG022_D52B:
	RTS		 ; Return


Roulette_ExitToMap:

	; Cancel the natural fade out that comes from exiting to map
	LDA #$01	 
	STA FadeOut_Cancel

	; Exit to map!
	LDA #$01
	STA <Level_ExitToMap

	LDA #$80
	STA Update_Select

	LDA #$00
	STA Update_Request

	RTS		 ; Return

Roulette_RewardPattern:
	;	     1    2         5
	.byte $01, $F3, $F5, $01, $F7	; $01 patterns are invalid

Roulette_GiveReward:

	; Load patterns for "x Up"
	LDA #$32
	STA PatTable_BankSel+4
	LDA #$55
	STA PatTable_BankSel+5

	LDA Roulette_StopCnt
	BEQ PRG022_D2B4	 ; If stop counter is zero, jump to PRG022_D2B4

	DEC Roulette_StopCnt	 ; Roulette_StopCnt--

	BNE PRG022_D28C	 ; If Roulette_StopCnt <> 0, jump to PRG022_D28C

	JMP PRG022_D23A	 ; Jump to PRG022_D23A

PRG022_D28C:
	LDA SndCur_Level1
	BNE PRG022_D2B1	 ; If 1-Up sound is playing, jump to PRG022_D2B1

	LDA Roulette_LivesToGive
	BEQ PRG022_D2B1	 ; If no lives left to give, jump to PRG022_D2B1

	; Roulette_StopCnt = $A0
	LDA #$a0
	STA Roulette_StopCnt

	DEC Roulette_LivesToGive ; Roulette_LivesToGive--

	; Play 1-up sound
	LDA Sound_QLevel1
	ORA #SND_LEVEL1UP
	STA Sound_QLevel1

	; Give life to appropriate Player
	LDX Player_Current	 ; X = Player_Current

	LDA Player_Lives,X
	BMI PRG022_D2B1	 ; If this Player is not dead from game over (??), jump to PRG022_D2B1

	INC Player_Lives,X	 ; One more life

PRG022_D2B1:
	JMP Roulette_DrawXUpReward	 ; Jump to Roulette_DrawXUpReward

PRG022_D2B4:
	; "x Up" Y -= 4
	DEC Roulette_xUpY
	DEC Roulette_xUpY
	DEC Roulette_xUpY
	DEC Roulette_xUpY

	LDA Roulette_xUpY
	CMP #96
	BGE Roulette_DrawXUpReward	 ; If Roulette_xUpY >= 96, jump to Roulette_DrawXUpReward

	; Initialize Roulette_LivesToGive
	LDA Roulette_Lives
	STA Roulette_LivesToGive

	; Roulette_StopCnt = $50
	LDA #$50
	STA Roulette_StopCnt

Roulette_DrawXUpReward:

	; Set "x Up" Sprite Y
	LDA Roulette_xUpY
	STA Sprite_RAM+$F0
	STA Sprite_RAM+$F4
	STA Sprite_RAM+$F8

	; Set sprite 1 X
	LDA #$70
	STA Sprite_RAM+$F3

	; Set sprite 2 X
	LDA #$7c
	STA Sprite_RAM+$F7

	; Set sprite 3 X
	LDA #$84
	STA Sprite_RAM+$FB

	; Set pattern by reward level
	LDY Roulette_Lives	 ; Y = Roulette_Lives
	LDA Roulette_RewardPattern-1,Y
	STA Sprite_RAM+$F1

	; 'U'
	LDA #$ab
	STA Sprite_RAM+$F5

	; 'P'
	LDA #$ad
	STA Sprite_RAM+$F9

	; Set attributes
	LDA #SPR_PAL3
	STA Sprite_RAM+$F2
	STA Sprite_RAM+$F6
	STA Sprite_RAM+$FA

	RTS		 ; Return


Roulette_DoFadeOut:

	; Sort of a clone of Palette_DoFadeOut

	LDA Fade_Tick
	BEQ PRG022_D314	 ; If Fade_Tick = 0, jump to PRG022_D314

	DEC Fade_Tick	 ; Otherwise, Fade_Tick--

PRG022_D314:
	LDA Fade_Level
	BEQ PRG022_D33C	 ; If Fade_Level = 0, jump to PRG022_D33C (RTS)

	LDA Fade_Tick
	BNE PRG022_D33C	 ; If Fade_Tick <> 0, jump to PRG022_D33C (RTS)

	; Fade_Tick = 4
	LDA #$04
	STA Fade_Tick

	DEC Fade_Level	 ; Fade_Level--

	; For all palette colors...
	LDY #31
PRG022_D328:
	LDA Palette_Buffer,Y	; Get this color
	SUB #16		 	; Subtract 16 from it
	BPL PRG022_D332	 	; If we didn't go below zero, jump to PRG026_AC55

	LDA #$0f	 	; Otherwise, set it to safe minimum

PRG022_D332:
	STA Palette_Buffer,Y	; Update palette color
	DEY		 	; Y--
	BPL PRG022_D328	 	; While Y >= 0, loop!


	; Commit palette fade
	LDA #$06
	STA <Graphics_Queue

PRG022_D33C:
	RTS		 ; Return

Roulette_MoveRow:

	LDA Roulette_Speed,X	; Get this Roulette row speed
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 	; Fractional part shifted up
	STA <Temp_Var2		; -> Temp_Var2

	LDA Roulette_Speed,X	; Get this Roulette row speed
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PRG022_D353	 ; If the value was not negatively signed, jump to PRG000_DD19
	ORA #%11110000	 ; Otherwise, apply a sign extension
PRG022_D353:
	STA <Temp_Var1	 ; -> Temp_Var1

	; NOTE: Other versions of the fractional accumulator usually merge this
	; part up with the sign extension application, which is probably better :)
	LDY #$00	 ; Y = 0 (positive high part)
	CMP #$00	 
	BPL PRG022_D35C	 ; If the whole part is positive, jump to PRG022_D35C
	DEY		 ; Y = $FF (negative high part)
PRG022_D35C:
	STY <Temp_Var3	 ; -> Temp_Var3

	; Fractional accumulation
	LDA Roulette_PosFrac,X
	ADD <Temp_Var2
	STA Roulette_PosFrac,X

	; Add to Pos/Hi
	LDA Roulette_Pos,X
	ADC <Temp_Var1
	STA Roulette_Pos,X
	LDA Roulette_PosHi,X
	ADC <Temp_Var3
	STA Roulette_PosHi,X

	RTS		 ; Return

Roulette_Shapes:
	.word Roulette_Star
	.word Roulette_Mushroom
	.word Roulette_Flower

Roulette_Star:
	.byte $FE, $FE, $FE, $FE, $FE, $9D, $9E, $FE, $FE, $FE, $FE, $FE
	.byte $FE, $FE, $FE, $FE, $AC, $AD, $AE, $AF, $FE, $FE, $FE, $FE
	.byte $FE, $FE, $FE, $FE, $BC, $FC, $FC, $BF, $FE, $FE, $FE, $FE
	.byte $FE, $FE, $FE, $9C, $CC, $FC, $FC, $CF, $9F, $FE, $FE, $FE
	.byte $96, $97, $97, $CD, $FC, $FC, $FC, $FC, $84, $97, $97, $C0
	.byte $A6, $FC, $FC, $FC, $34, $FC, $FC, $37, $FC, $FC, $FC, $D0
	.byte $BD, $BE, $FC, $FC, $44, $FC, $FC, $47, $FC, $FC, $F0, $E0
	.byte $FE, $CE, $FC, $FC, $FC, $FC, $FC, $FC, $FC, $ED, $B2, $FE
	.byte $FE, $D1, $FC, $FC, $8C, $8D, $8E, $8F, $FC, $F8, $EE, $FE
	.byte $FE, $E1, $FC, $FC, $FC, $FC, $FC, $FC, $FC, $FC, $E3, $FE
	.byte $E2, $FC, $FC, $FC, $FC, $CB, $FC, $FC, $FC, $FC, $F3, $E4
	.byte $F2, $FC, $FC, $F9, $DC, $DD, $DE, $DF, $FC, $FC, $FC, $F4
	.byte $E5, $FC, $E7, $E8, $DA, $FE, $FE, $DB, $E9, $EA, $FC, $EC
	.byte $F5, $F6, $F7, $FE, $FE, $FE, $FE, $FE, $FE, $FA, $FB, $EF

Roulette_Mushroom:
	.byte $FC, $FC, $FC, $0A, $0B, $0C, $0D, $0E, $0F, $FC, $FC, $FC
	.byte $FC, $FC, $1C, $1D, $FD, $FD, $06, $FE, $1E, $1F, $FC, $FC
	.byte $FC, $13, $14, $15, $16, $17, $FE, $FE, $18, $00, $01, $FC
	.byte $26, $2A, $FE, $FE, $FE, $FE, $FE, $FE, $2C, $FD, $2D, $2E
	.byte $2F, $FE, $3C, $3D, $3E, $3F, $FE, $FE, $33, $FD, $FD, $36
	.byte $31, $FE, $38, $FD, $FD, $3A, $FE, $FE, $4C, $4D, $4E, $4F
	.byte $41, $FE, $43, $FD, $FD, $45, $FE, $FE, $FE, $FE, $FE, $46
	.byte $5C, $5D, $5E, $5F, $48, $4A, $FE, $FE, $FE, $FE, $FE, $51
	.byte $56, $5A, $FE, $62, $63, $64, $64, $65, $66, $FE, $FE, $67
	.byte $6C, $6D, $6E, $6F, $34, $FC, $FC, $37, $7C, $7D, $7E, $7F
	.byte $FC, $FC, $70, $FC, $44, $FC, $FC, $47, $FC, $71, $FC, $FC
	.byte $FC, $FC, $7A, $FC, $FC, $FC, $FC, $FC, $FC, $7B, $FC, $FC
	.byte $FC, $FC, $68, $FC, $8C, $8D, $8E, $8F, $FC, $76, $FC, $FC
	.byte $FC, $FC, $89, $8A, $8B, $8B, $8B, $8B, $87, $88, $FC, $FC

Roulette_Flower:
	.byte $FE, $FE, $02, $03, $04, $05, $05, $07, $08, $09, $FE, $FE
	.byte $10, $11, $12, $FD, $FD, $FD, $FD, $FD, $FD, $19, $1A, $1B
	.byte $20, $21, $22, $23, $24, $25, $25, $27, $28, $29, $FD, $2B
	.byte $30, $FD, $32, $FC, $34, $FC, $FC, $37, $FC, $39, $FD, $3B
	.byte $40, $FD, $42, $FC, $44, $FC, $FC, $47, $FC, $49, $FD, $4B
	.byte $50, $FD, $52, $53, $54, $55, $55, $57, $58, $59, $FD, $5B
	.byte $60, $61, $FD, $FD, $FD, $FD, $FD, $FD, $FD, $69, $6A, $6B
	.byte $FE, $FE, $72, $73, $74, $75, $75, $77, $78, $79, $FE, $FE
	.byte $80, $81, $82, $83, $FC, $85, $86, $FC, $FC, $FC, $FC, $FC
	.byte $90, $91, $92, $93, $94, $95, $FC, $FC, $98, $99, $9A, $9B
	.byte $E6, $FE, $EB, $35, $A4, $A5, $FC, $A7, $A8, $A9, $AA, $AB
	.byte $B0, $B1, $FE, $B3, $B1, $B5, $B6, $B7, $B8, $B9, $BA, $BB
	.byte $FC, $C1, $FE, $C3, $C4, $C5, $C6, $C7, $C8, $C9, $CA, $FC
	.byte $FC, $FC, $D2, $D3, $D4, $D5, $D6, $D7, $D8, $D9, $FC, $FC



Roulette_DrawShapes:
	; The actual rendered pattern is Right Half Star, Mushroom, Flower, Mushroom, Left Half Star

	LDY #$20	 ; Y = $20 (VRAM address high)

	JSR PRG022_D57D

	LDY #$24	 ; Y = $24 (VRAM address high)

PRG022_D57D:

	; Temp_Var1 = $80
	LDA #$80
	STA <Temp_Var1
PRG022_D581:
	LDA PPU_STAT

	; Set VRAM address high
	STY PPU_VRAM_ADDR

	; Set VRAM address low
	LDA <Temp_Var1
	STA PPU_VRAM_ADDR

	; Fills in a row with the pinkish "background" color
	LDX #31		; X = 31 (32 tiles per row)
PRG022_D58E:

	; Insert a background tile
	LDA #$fe
	STA PPU_VRAM_DATA

	DEX		 ; X--
	BPL PRG022_D58E	 ; While X >= 0, loop!


	; Temp_Var1 += 32 (next row of patterns)
	LDA <Temp_Var1
	ADD #32
	STA <Temp_Var1
	BCC PRG022_D5A0	 ; If no carry, jump to PRG022_D5A0
	INY		 ; Otherwise, apply carry
PRG022_D5A0:
	TYA		 ; -> 'A'

	AND #$03
	CMP #$02
	BNE PRG022_D581	 ; If not on every third, jump to PRG022_D581

	LDA <Temp_Var1
	CMP #$e0
	BNE PRG022_D581	 ; If not at end column, jump to PRG022_D581

	; At end column...

	; VRAM high address
	LDA #$20
	STA <Temp_Var1

	; Temp_Var5 = 0 (current shape from Roulette_Shapes)
	LDA #$00
	STA <Temp_Var5

PRG022_D5B5:

	; VRAM low address
	LDA #$c0
	STA <Temp_Var2

	LDY #$06
PRG022_D5BB:

	; X = Temp_Var5 * 2 (2 byte index for Roulette shape pointer)
	LDA <Temp_Var5
	ASL A
	TAX

	; Load starting address of Roulette shape 
	LDA Roulette_Shapes,X
	STA <Temp_Var3
	LDA Roulette_Shapes+1,X
	STA <Temp_Var4

PRG022_D5C9:
	LDA PPU_STAT

	; Set VRAM address
	LDA <Temp_Var1
	STA PPU_VRAM_ADDR
	LDA <Temp_Var2
	STA PPU_VRAM_ADDR

	LDX #$00	; X = 0
PRG022_D5D8:
	LDA [Temp_Var3],Y	; Get pattern for shape
	STA PPU_VRAM_DATA	; Store into VRAM

	INY		; Y++ (next shape pattern)
	INX		; X++ (column counter)

	CPX #$06
	BNE PRG022_D5D8	; While X <> 6, loop!


	; Y += 6 (jump to next row only halfway across)
	TYA
	ADD #$06
	TAY

	; Temp_Var1/2 += 32 (go to next row)
	LDA <Temp_Var2
	ADD #32		; +32 next row
	BCC PRG022_D5F1	; If no carry, jump to PRG022_D5F1
	INC <Temp_Var1	; Apply carry
PRG022_D5F1:
	STA <Temp_Var2

	AND #$e0
	CMP #$80
	BNE PRG022_D5C9

	LDA <Temp_Var1
	AND #$03
	CMP #$02
	BNE PRG022_D5C9

	DEC <Temp_Var1
	DEC <Temp_Var1

	LDA <Temp_Var2
	ADD #$46
	STA <Temp_Var2

	LDA <Temp_Var5
	CMP #$01
	BNE PRG022_D61A

	CPY #$ae
	BEQ PRG022_D61A

	LDY #$06
	BNE PRG022_D5C9
PRG022_D61A:
	LDA <Temp_Var2
	ADD #$04
	STA <Temp_Var2

	LDY #$00

	LDA <Temp_Var1
	CMP #$24
	BEQ PRG022_D635

	INC <Temp_Var5
	LDA <Temp_Var5
	CMP #$03
	BNE PRG022_D5BB

	LDA #$24
	STA <Temp_Var1

PRG022_D635:
	DEC <Temp_Var5
	BMI PRG022_D642

	LDA <Temp_Var5
	CMP #$02
	BEQ PRG022_D643

	JMP PRG022_D5BB	 ; Jump to PRG022_D5BB

PRG022_D642:
	RTS		 ; Return

PRG022_D643:
	JMP PRG022_D5B5	 ; Jump to PRG022_D5B5


Card_InitGame:
	LDA Card_InitState	 
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Card_InitDeck	; 0: Initialize the card deck (if a game is not already in progress)
	.word Card_RenderDeck	; 1: Renders the entire deck
	.word Card_InitVars	; 2: Initializes game related memory

Card_InitDeck:
	LDA Map_NSpadeInProg
	BNE PRG022_D668	 ; If you already have an N-Spade game in progress from before, jump to PRG022_D668

	; Load in the initial set of cards
	LDY #(Card_InitialSet_End - Card_InitialSet - 1)
PRG022_D659:
	LDA Card_InitialSet,Y	 ; Get initial card
	STA Card_ActiveSet,Y	 ; Store into card memory

	DEY		 ; Y--
	BPL PRG022_D659	; While Y >= 0, loop!

	JSR Card_Shuffle	 ; Shuffle some of the cards a bit

	INC Map_NSpadeInProg	 ; There is an N-Spade in progress, people!

PRG022_D668:
	INC Card_InitState	 ; Card_InitState = 1

	; Card_Index = $11
	LDA #$11
	STA Card_Index

	RTS		 ; Return

Card_RenderDeck:
	; Temp_Var11 = Card_Index
	LDY Card_Index
	STY <Temp_Var11	

	LDA Card_ActiveSet,Y
	AND #$80
	BNE PRG022_D683	 ; If card value bit 7 is set (card is already flipped over), jump to PRG022_D683

	JSR Card_RenderBack	; Render "N-Spade" back of this cards
	JMP PRG022_D686		; Jump to PRG022_D686

PRG022_D683:
	JSR Card_RenderFace	; Render the face of the card

PRG022_D686:
	DEC Card_Index	; Card_Index--
	BPL PRG022_D68E	; While Card_Index >= 0, loop

	INC Card_InitState	 ; Card_Index =2

PRG022_D68E:
	RTS		 ; Return


Card_InitVars:
	INC Card_InitState	; Card_InitState = 3 (just used to break the loop)

	; Clear some card variables
	LDY #$19	 ; Y = $19
PRG022_D694:
	LDA #$00
	STA Card_SelectX,Y

	DEY		 ; Y--
	BPL PRG022_D694	 ; While Y >= 0, loop

	LDY #$03	 ; Y = $03
PRG022_D69E:
	LDA #$ff
	STA Card_UnusedArray,Y

	DEY		 ; Y--
	BPL PRG022_D69E	 ; While Y >= 0, loop

	; Card_UnusedVL = $20
	LDA #$20
	STA Card_UnusedVL

	; Card_UnusedVH = $DA
	LDA #$da
	STA Card_UnusedVH

	; Card_UnusedAttr = $CE
	LDA #$ce
	STA Card_UnusedAttr

	; Card_TurnsRemain = $01
	LDA #$01
	STA Card_TurnsRemain

	RTS		 ; Return

	; Sprite pattern and attributes per card selection sprite
Card_SelectPattern:
	.byte $8B, $8D, $8D, $8B, $8F, $8F, $8B, $8D, $8D, $8B
Card_SelectAttribute:
	.byte SPR_PAL1, SPR_PAL1, SPR_PAL1, SPR_PAL1 | SPR_HFLIP, SPR_PAL1, SPR_PAL1, SPR_PAL1 | SPR_VFLIP, SPR_PAL1 | SPR_VFLIP, SPR_PAL1 | SPR_VFLIP, SPR_PAL1 | SPR_HFLIP | SPR_VFLIP

	; X position of card selector by Card_Index
Card_CursorXs:
	.byte $18, $38, $58, $78, $98, $B8
	.byte $18, $38, $58, $78, $98, $B8
	.byte $18, $38, $58, $78, $98, $B8

	; Y position of card selector by Card_Index
Card_CursorYs:
	.byte $20, $20, $20, $20, $20, $20
	.byte $50, $50, $50, $50, $50, $50
	.byte $80, $80, $80, $80, $80, $80

	; Attribute by frame of card flip
CardFlip_Attributes:
	.byte SPR_PAL1, SPR_PAL1, SPR_PAL1, SPR_PAL3, SPR_PAL3

	; Pattern per sprite per frame of card flip
CardFlip_FrameDefs:
CardFlip_Frame4:	.byte $BD, $BD, $BF, $BF
CardFlip_Frame3:	.byte $B1, $B1, $B1, $B1
CardFlip_Frame2:	.byte $B5, $B5, $B5, $B5
CardFlip_Frame1:	.byte $B7, $B7, $B7, $B7
CardFlip_Frame0:	.byte $B7, $B7, $B7, $B7

CardFlip_FrameDefOff:
	.byte CardFlip_Frame0 - CardFlip_FrameDefs
	.byte CardFlip_Frame1 - CardFlip_FrameDefs
	.byte CardFlip_Frame2 - CardFlip_FrameDefs
	.byte CardFlip_Frame3 - CardFlip_FrameDefs
	.byte CardFlip_Frame4 - CardFlip_FrameDefs

	; N-Spade game initial card deck
Card_InitialSet:
	.byte CARD_MUSHROOM,	CARD_FLOWER,	CARD_1UP,	CARD_MUSHROOM,	CARD_10COIN,	CARD_STAR
	.byte CARD_20COIN,	CARD_STAR,	CARD_MUSHROOM,	CARD_10COIN,	CARD_1UP,	CARD_FLOWER
	.byte CARD_20COIN,	CARD_FLOWER,	CARD_STAR,	CARD_MUSHROOM,	CARD_FLOWER,	CARD_STAR
Card_InitialSet_End

	; N-Spade cards VRAM High address
Card_VRAMHi:
	.byte $20, $20, $20, $20, $20, $20
	.byte $21, $21, $21, $21, $21, $21
	.byte $22, $22, $22, $22, $22, $22

	; N-Spade cards VRAM Low address
Card_VRAMLo:
	.byte $A3, $A7, $AB, $AF, $B3, $B7
	.byte $63, $67, $6B, $6F, $73, $77
	.byte $23, $27, $2B, $2F, $33, $37

Card_FacePatterns:
	; CARD_MUSHROOM
	.byte $58, $5A
	.byte $59, $5B

	; CARD_FLOWER
	.byte $5C, $5E
	.byte $5D, $5F

	; CARD_STAR
	.byte $AC, $AD
	.byte $AE, $AF

	; CARD_1UP
	.byte $6C, $6E
	.byte $6D, $6F

	; CARD_10COIN
	.byte $7C, $7E
	.byte $7D, $7F

	; CARD_20COIN
	.byte $7C, $7E
	.byte $7D, $7F

Card_FaceAttribute:
	.byte $FD	; CARD_MUSHROOM
	.byte $FE	; CARD_FLOWER
	.byte $FF	; CARD_STAR
	.byte $FD	; CARD_1UP
	.byte $FD	; CARD_10COIN
	.byte $FD	; CARD_20COIN

Card_VRAMAttrLo:
	.byte $C9, $CA, $CB, $CC, $CD, $CE
	.byte $D9, $DA, $DB, $DC, $DD, $DE
	.byte $E1, $E2, $E3, $E4, $E5, $E6


PRG022_D777:
	.byte $7F, $BF, $FF, $7F, $7F

	; For the 1-up, 10 coin, and 20 coin cards that have additional text, patterns of the bottom row
Card_BottomLeft:	.byte $78, $9D, $9E
Card_BottomRight:	.byte $79, $7B, $7B

NSpade_DoGame:
	LDA Card_CoinsToGive
	BEQ PRG022_D792	 ; If there aren't any coins to give, jump to PRG022_D792

	; You got a coin
	INC Coins_Earned

	; 100 points per coin
	LDA #10
	STA Score_Earned

	DEC Card_CoinsToGive	 ; Card_CoinsToGive--

PRG022_D792:
	LDA Card_GameState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Card_SelectCard		; 0: Perform cursor movements
	.word Card_BeginFlip		; 1: Begin card flip
	.word Card_DoFlip		; 2: Perform card flip
	.word Card_TwoCardResponse	; 3: Respond to the two flipped cards
	.word Card_HandleMatch		; 4: Reward the card match
	.word Card_HandleMismatch	; 5: Handle the mismatch
	.word Card_WaitThenExit		; 6: Decrements Card_MoveDelay, then exits to map
	.word Card_BeginFlipBack	; 7: Begin flipping back a card
	.word Card_FlipBackCard		; 8: Flip back a card


Card_SelectCard:
	JSR Card_DoSelection	 ; Handle pressing direction or A button
	JSR Card_DrawCursor	 ; Draw selection cursor

	RTS		 ; Return


Card_BeginFlip:
	LDY Card_Index	 ; Y = Card_Index

	LDA Card_ActiveSet,Y
	AND #$80
	BNE PRG022_D7D8	 ; If this card is already flipped, jump to PRG022_D7D8

	; Card_FlipFrame = 4
	LDA #$04
	STA Card_FlipFrame

	; Temp_Var11 = Card_Index
	LDA Card_Index
	STA <Temp_Var11

	JSR Card_Blackout	 ; Blacks out the card that will get flipped

	; Card_AnimTick = 0
	LDA #$00
	STA Card_AnimTick

	INC Card_GameState	 ; Card_GameState = 2

	; Flip card sound
	LDA #SND_MAPINVENTORYFLIP
	STA Sound_QMap

	JMP Card_DoFlip	 ; Jump to Card_DoFlip

PRG022_D7D8:
	; Card was already flipped, so cancel
	DEC Card_GameState	 ; Card_GameState = 0
	RTS		 ; Return

Card_DoFlip:
	LDA Card_AnimTick
	BEQ PRG022_D7E5	 ; If Card_AnimTick = 0, jump to PRG022_D7E5

	DEC Card_AnimTick ; Card_AnimTick--

	RTS		 ; Return

PRG022_D7E5:

	; Temp_Var11 = Card_Index
	LDA Card_Index
	STA <Temp_Var11

	JSR CardFlip_Draw	 ; Draw card flip

	DEC Card_FlipFrame 	; Card_FlipFrame--
	BPL PRG022_D7FD	 	; If Card_FlipFrame >= 0 jump to PRG022_D7FD

	; Card flip complete

	; Temp_Var11 = Card_Index
	LDA Card_Index
	STA <Temp_Var11

	JSR Card_RenderFace	; Draw card face

	INC Card_GameState	; Card_GameState = 3

PRG022_D7FD:

	; Card_AnimTick = 4
	LDA #$04
	STA Card_AnimTick

	RTS		 ; Return

Card_TwoCardResponse:
	INC Card_FlipCount	; Card_FlipCount++

	JSR Card_CheckForMatch	; Determines if cards matched, sets proper state

	RTS		 ; Return

Card_HandleMatch:
	LDY Card_Index	 ; Y = Card_Index

	; Mark second card as flipped
	LDA Card_ActiveSet,Y
	ORA #$80
	STA Card_ActiveSet,Y

	; Card_GameState = 0 (Return to card selection)
	LDA #$00
	STA Card_GameState

	INC Map_NSpadeMatches	 ; Map_NSpadeMatches++
	INC Card_Matches	 ; Card_Matches++

	JSR Card_MatchPairReward	 ; Give reward

	LDA Map_NSpadeMatches
	CMP #$09
	BNE PRG022_D83D	 ; If Map_NSpadeMatches <> 9, jump to PRG022_D83D (RTS)

	; 9 matches means the game is complete

	; Card_GameState = 6
	LDA #$06
	STA Card_GameState

	; Card_MoveDelay = $40
	LDA #$40
	STA Card_MoveDelay

	LDA #$00
	STA Map_NSpadeInProg	; N-Spade game is no longer in prgoress
	STA Map_NSpadeMatches	; Clear the match counter

	RTS		 ; Return

PRG022_D83D:
	RTS		 ; Return


Card_HandleMismatch:
	; Card_FlipFrame = 0
	LDA #$00	 
	STA Card_FlipFrame

	; Temp_Var12 = 1
	LDA #$01
	STA <Temp_Var12

	INC Card_GameState	 ; Card_GameState = 6
	INC Card_GameState	 ; Card_GameState = 7

	; Card_MoveDelay = $40
	LDA #$40
	STA Card_MoveDelay

	LDY Card_Index	 ; Y = Card_Index

	; Clear the card flipped flag on the second card
	LDA Card_ActiveSet,Y
	AND #$7f
	STA Card_ActiveSet,Y

	LDY Card_FirstIndex	 ; Y = Card_FirstIndex

	; Clear the card flipped flag on the first card
	LDA Card_ActiveSet,Y
	AND #$7f
	STA Card_ActiveSet,Y

	; Mismatch sound
	LDA #SND_MAPDENY
	STA Sound_QMap

	DEC Card_TurnsRemain	; Card_TurnsRemain-- (one less turn)
	BPL PRG022_D875	 	; If turns remain, jump to PRG022_D875

	DEC Card_GameState	 ; Card_GameState = 6

PRG022_D875:
	RTS		 ; Return

Card_WaitThenExit:
	DEC Card_MoveDelay	; Card_MoveDelay--
	BPL PRG022_D87D	 	; If Card_MoveDelay > 0, jump to PRG022_D87D (RTS)

	; Exit to map
	INC <Level_ExitToMap

PRG022_D87D:
	RTS		 ; Return

Card_BeginFlipBack:
	LDA Card_MoveDelay
	BEQ PRG022_D887	 ; If Card_MoveDelay = 0, jump to PRG022_D887

	DEC Card_MoveDelay	 ; Card_MoveDelay--

	RTS		 ; Return

PRG022_D887:

	; Card_FlipFrame = 0
	LDA #$00
	STA Card_FlipFrame

	LDY <Temp_Var12		 ; Y = Temp_Var12

	LDA Card_Index,Y	; Get first or second card face value
	STA <Temp_Var11		; Face value -> Temp_Var11

	JSR Card_Blackout	 ; Black out this card

	INC Card_GameState	 ; Card_GameState = 8

	; Card_AnimTick= 0
	LDA #$00
	STA Card_AnimTick

Card_FlipBackCard:
	LDA Card_AnimTick
	BEQ PRG022_D8A7	 ; If Card_AnimTick = 0, jump to PRG022_D8A7

	DEC Card_AnimTick	 ; Card_AnimTick--

	RTS		 ; Return

PRG022_D8A7:
	LDY <Temp_Var12		 ; Y = Temp_Var12 (first or second card index)

	LDA Card_Index,Y	; Get first or second card face value
	STA <Temp_Var11		; Face value -> Temp_Var11

	JSR CardFlip_Draw	 ; Draw card flip

	INC Card_FlipFrame	 ; Card_FlipFrame++

	LDA Card_FlipFrame
	CMP #$05
	BLT PRG022_D8D8	 	; If Card_FlipFrame < 5, jump to PRG022_D8D8

	LDY <Temp_Var12		; Y = Temp_Var12 (first or second card index)

	LDA Card_Index,Y	; Get first or second card face value
	STA <Temp_Var11		; Face value -> Temp_Var11

	JSR Card_RenderBack	; Render the card's back side

	DEC <Temp_Var12	 ; Temp_Var12--
	BPL PRG022_D8CF	 ; If there's another card to do, jump to PRG022_D8CF

	; Both cards are flipped back over

	; Card_GameState = 0 (Return to card selection)
	LDA #$00
	STA Card_GameState

	RTS		 ; Return

PRG022_D8CF:
	; Card_MoveDelay = 2
	LDA #$02
	STA Card_MoveDelay

	DEC Card_GameState

	RTS		 ; Return

PRG022_D8D8:

	; Card_AnimTick = 4
	LDA #$04
	STA Card_AnimTick

	RTS		 ; Return


Card_Shuffle:
	; Temp_Var11 = 2 (3 shuffle operations)
	LDA #$02	 
	STA <Temp_Var11	
PRG022_D8E2:
	JSR Randomize
	AND #$1f
	TAY		 ; Y = 0 to 31, random

	; Rotate the first 15 cards 0 to 31 (random) times to shuffle
PRG022_D8E8:

	; Temp_Var12 = 15th card
	LDA Card_ActiveSet+14
	STA <Temp_Var12	

	LDX #$0D	 ; X = $0D
PRG022_D8EF:

	; Copy card into adjacent slot
	LDA Card_ActiveSet,X
	STA Card_ActiveSet+1,X

	DEX		 ; X--
	BPL PRG022_D8EF	; While X >= 0, loop!

	; Set the original 15th card as the first card
	LDA <Temp_Var12	
	STA Card_ActiveSet

	DEY		 ; Y--
	BPL PRG022_D8E8	 ; While Y >= 0, loop!

	LDX #$00	 ; X = 0 (this routine will only be run once, even though they structured a loop)
PRG022_D902:
	; First card -> Temp_Var12
	LDA Card_ActiveSet,X
	STA <Temp_Var12	

	; Sixth card -> first
	LDA Card_ActiveSet+5,X
	STA Card_ActiveSet,X

	; Eleventh card -> sixth
	LDA Card_ActiveSet+10,X
	STA Card_ActiveSet+5,X	

	; Former first card -> Eleventh
	LDA <Temp_Var12	
	STA Card_ActiveSet+10,X

	; X -= 2
	DEX
	DEX

	BPL PRG022_D902	 ; While X >= 0, loop!

	DEC <Temp_Var11	 ; Temp_Var11--
	BPL PRG022_D8E2	 ; While Temp_Var11 >= 0, loop!

	RTS		 ; Return

Card_RenderFace:
	LDY #(CardBase_BufCmds_End - CardBase_BufCmds - 1)
PRG022_D923:
	LDA CardBase_BufCmds,Y
	STA Graphics_Buffer+$00,Y

	DEY		 ; Y--
	BPL PRG022_D923	; While Y >= 0, loop

	LDY <Temp_Var11	 ; Y = Temp_Var11 (current card)

	; Get VRAM address of this card -> Card_VRAM_H/L
	LDA Card_VRAMHi,Y
	STA Card_VRAM_H	
	LDA Card_VRAMLo,Y
	STA Card_VRAM_L	

	LDY #$00	 ; Y = 0
	LDX #$03	 ; X = 0
PRG022_D93E: 

	; Patch card VRAM Hi into graphics buffer
	LDA Card_VRAM_H
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)

	; Patch card VRAM Lo into graphics buffer
	LDA Card_VRAM_L	
	STA Graphics_Buffer+$00,Y

	; Y += 6 (next card row in buffer commands)
	TYA
	ADD #$06
	TAY

	; +32 to go to next pattern row
	LDA Card_VRAM_L
	ADD #32
	STA Card_VRAM_L
	LDA Card_VRAM_H
	ADC #$00
	STA Card_VRAM_H

	DEX		 ; X--
	BPL PRG022_D93E	 ; While X >= 0, loop

	LDY <Temp_Var11	 ; Y = Temp_Var11 (current card)

	; Get the card face sans "already flipped" bit -> Temp_Var12
	LDA Card_ActiveSet,Y
	AND #$7f
	STA <Temp_Var12

	ASL A
	ASL A
	TAY		 ; Y = face * 4

	; Add the four patterns making up the card face
	LDA Card_FacePatterns,Y	
	STA Graphics_Buffer+$0B
	INY		 ; Y++ (next graphics buffer byte)
	LDA Card_FacePatterns,Y
	STA Graphics_Buffer+$0C
	INY		 ; Y++ (next graphics buffer byte)
	LDA Card_FacePatterns,Y
	STA Graphics_Buffer+$12
	INY		 ; Y++ (next graphics buffer byte)
	LDA Card_FacePatterns,Y
	STA Graphics_Buffer+$13

	LDY <Temp_Var12		 ; Y = Temp_Var12 (current card face)

	; Temp_Var13 = card face attribute
	LDA Card_FaceAttribute,Y
	STA <Temp_Var13	

	LDA <Temp_Var11
	CMP #6
	BLT PRG022_D99F	 ; If Temp_Var11 < 6 (card is on first row), jump to PRG022_D99F

	CMP #12
	BGE PRG022_D99F	 ; If Temp_Var11 < 12 (card is on second row), jump to PRG022_D99F

	JMP PRG022_D9A9	 ; Card is on third row; jump to PRG022_D9A9

PRG022_D99F:
	LDA <Temp_Var13
	ASL A
	ASL A
	ASL A
	ASL A
	ORA #$0f
	STA <Temp_Var13

PRG022_D9A9:
	LDX <Temp_Var11		 ; X = Temp_Var11 (current card index)

	; Patch attribute VRAM Hi into graphics buffer
	LDA #$23
	STA Graphics_Buffer+$1C

	; Patch card attribute VRAM Lo into graphics buffer
	LDA Card_VRAMAttrLo,X
	STA Graphics_Buffer+$1D

	; Run length of 1
	LDA #$01
	STA Graphics_Buffer+$1E

	; Attribute byte
	LDA <Temp_Var13
	STA Graphics_Buffer+$1F

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$20

	; Graphics_BufCnt = $20
	LDA #$20
	STA Graphics_BufCnt

	LDA <Temp_Var12
	CMP #CARD_1UP
	BLT PRG022_D9E0	 ; If Temp_Var12 < CARD_1UP, jump to PRG022_D9E0

	SUB #CARD_1UP
	TAY		 ; Y = relative (0 = 1-up, 1 = 10 coin, 2 = 20 coin)

	; Add the bottom text on 1-up, 10 coin, or 20 coin cards
	LDA Card_BottomLeft,Y
	STA Graphics_Buffer+$19
	LDA Card_BottomRight,Y
	STA Graphics_Buffer+$1A

PRG022_D9E0:

	; Card selector sprites all invisible
	LDA #$f8
	STA Sprite_RAM+$2C
	STA Sprite_RAM+$30
	STA Sprite_RAM+$34
	STA Sprite_RAM+$38

	RTS		 ; Return


Card_RenderBack:
	LDY #(CardBack_BufCmds_End - CardBack_BufCmds - 1)
PRG022_D9F1:
	LDA CardBack_BufCmds,Y	 	; Get graphics buffer command
	STA Graphics_Buffer+$00,Y	; Store into graphics buffer

	DEY		 ; Y--
	BPL PRG022_D9F1	; While Y >= 0, loop

	LDY <Temp_Var11	 ; Y = Temp_Var11 (current card)

	; Get VRAM address of this card -> Card_VRAM_H/L
	LDA Card_VRAMHi,Y
	STA Card_VRAM_H	
	LDA Card_VRAMLo,Y
	STA Card_VRAM_L	

	LDY #$00	 ; Y = 0
	LDX #$03	 ; X = 3 (4 rows of patterns per card)
PRG022_DA0C:

	; Patch card VRAM Hi into graphics buffer
	LDA Card_VRAM_H
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)

	; Patch card VRAM Lo into graphics buffer
	LDA Card_VRAM_L	
	STA Graphics_Buffer+$00,Y

	; Y += 6 (next card row in buffer commands)
	TYA
	ADD #$06
	TAY

	; Card_VRAM_L/H += 32 (next row of patterns)
	LDA Card_VRAM_L
	ADD #32
	STA Card_VRAM_L
	LDA Card_VRAM_H
	ADC #$00
	STA Card_VRAM_H

	DEX		 ; X--
	BPL PRG022_DA0C	 ; While X >= 0, loop

	LDX <Temp_Var11	 ; X = Temp_Var11 (current card)

	LDA #$23
	STA Graphics_Buffer+$1C

	LDA Card_VRAMAttrLo,X
	STA Graphics_Buffer+$1D

	; Run length 1
	LDA #$01
	STA Graphics_Buffer+$1E

	; Set palette 3
	LDA #$FF
	STA Graphics_Buffer+$1F

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$20

	; Graphics_BufCnt = $20
	LDA #$20
	STA Graphics_BufCnt

	; Card selector sprites all invisible
	LDA #$f8
	STA Sprite_RAM+$2C
	STA Sprite_RAM+$30
	STA Sprite_RAM+$34
	STA Sprite_RAM+$38

	RTS		 ; Return

; FIXME: Anyone want to claim this??
; This seems like it'd have displayed matched pairs perhaps or even just debug data
; $DA62 
	LDY #$00	 ; Y = 0

	; Temp_Var11 = 11
	LDA #$01
	STA <Temp_Var11

	LDX Card_Index	 	; X = Card_Index

	; Card face -> Temp_Var12
	LDA Card_ActiveSet,X
	STA <Temp_Var12	

	ASL A
	ASL A
	TAX		 ; X = card face * 4

PRG022_DA73:
	; Some VRAM Low
	LDA Card_UnusedVL
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)

	; Some VRAM High
	LDA Card_UnusedVH
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)

	; Run length of 2
	LDA #$02
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)


	LDA Card_FacePatterns,X
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)

	INX		 ; X++

	LDA Card_FacePatterns,X
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++
	INX		 ; X++

	; +32 for next row
	LDA Card_UnusedVH
	ADD #32
	STA Card_UnusedVH
	LDA Card_UnusedVL
	ADC #$00
	STA Card_UnusedVL

	DEC <Temp_Var11	 ; Temp_Var11--
	BPL PRG022_DA73	 ; While Temp_Var1 >= 0, loop

	LDX <Temp_Var12	 ; X = Temp_Var12

	; High VRAM in attribute table?
	LDA #$23
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)

	LDA Card_UnusedAttr
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)

	LDA #$01
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)

	LDA Card_Matches
	AND #$01
	BEQ PRG022_DAD6

	INC Card_UnusedArrIdx

	LDA PRG022_D777,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA #$f0
	BNE PRG022_DAE2

PRG022_DAD6:
	LDA Card_UnusedAttr
	ADD #$08
	STA Card_UnusedAttr

	LDA PRG022_D777,X

PRG022_DAE2:
	LDX Card_UnusedArrIdx
	AND Card_UnusedArray,X
	STA Card_UnusedArray,X
	STA Graphics_Buffer+$00,Y

	INY

	LDA #$00
	STA Graphics_Buffer+$00,Y

	RTS

Card_Blackout:
	LDY #(CardBlackout_BufCmds_End - CardBlackout_BufCmds - 1)
PRG022_DAF7:
	LDA CardBlackout_BufCmds,Y	 ; Get buffer command
	STA Graphics_Buffer+$00,Y	 ; Set in graphics buffer

	DEY		 ; Y--
	BPL PRG022_DAF7	 ; While Y >= 0, loop

	LDY <Temp_Var11	 ; Y = Temp_Var11

	; Get VRAM address of this card -> Card_VRAM_H/L
	LDA Card_VRAMHi,Y
	STA Card_VRAM_H	
	LDA Card_VRAMLo,Y
	STA Card_VRAM_L	

	LDA #(CardBlackout_BufCmds_End - CardBlackout_BufCmds - 1)
	STA Graphics_BufCnt

	LDY #$00	 ; Y = 0
	LDX #$03	 ; X = 3 
PRG022_DB17:
	; Patch card VRAM Hi into graphics buffer
	LDA Card_VRAM_H
	STA Graphics_Buffer+$00,Y

	INY		 ; Y++ (next graphics buffer byte)

	; Patch card VRAM Lo into graphics buffer
	LDA Card_VRAM_L	
	STA Graphics_Buffer+$00,Y

	; Y += 6 (next card row in buffer commands)
	TYA
	ADD #$06
	TAY

	; +32 to go to next pattern row
	LDA Card_VRAM_L
	ADD #32
	STA Card_VRAM_L
	LDA Card_VRAM_H
	ADC #$00
	STA Card_VRAM_H

	DEX		; X--
	BPL PRG022_DB17	; While X >= 0, loop

	RTS		 ; Return

Card_CheckForMatch:
	LDA Card_FlipCount
	AND #$01
	BNE PRG022_DB7E	 ; If this was the first card, jump to PRG022_DB7E

	; Second card flipped

	LDY Card_Index	 ; Y = Card_Index

	LDA Card_ActiveSet,Y
	CMP Card_MatchCard
	BEQ PRG022_DB98	 ; If you picked the same card, jump to PRG022_DB98

	; Mismatched cards

	; UNUSED Wild card!
	LDA Card_ActiveSet,Y
	CMP #CARD_WILD
	BNE PRG022_DB5D	 ; If this is not CARD_WILD, jump to PRG022_DB5D

	; Wild card!

	LDA Card_MatchCard	; Just pass the match on
	JMP PRG022_DB6C	 ; Jump to PRG022_DB6C

PRG022_DB5D:

	; UNUSED Wild card!
	LDA Card_MatchCard
	CMP #CARD_WILD
	BNE PRG022_DB72	 ; If this is not CARD_WILD, jump to PRG022_DB72

	; Wild card!

	LDA Card_ActiveSet,Y	; Get card face
	ORA #$80		; Mark card as flipped

	LDY Card_FirstIndex	; Y = Card_FirstIndex (the first card that was flipped over)

PRG022_DB6C:
	STA Card_ActiveSet,Y	; Mark first card as flipped
	JMP PRG022_DB98	 	; Jump to PRG022_DB98

PRG022_DB72:

	; Cards mismatched

	INC Card_GameState	 ; Card_GameState = 4
	INC Card_GameState	 ; Card_GameState = 5

	; Card_MoveDelay = $30
	LDA #$30
	STA Card_MoveDelay

	RTS		 ; Return

PRG022_DB7E:

	; First card flipped

	; Card_FirstIndex = Card_Index (hold the index of the first card you flipped)
	LDY Card_Index
	STY Card_FirstIndex

	; Record the first card face
	LDA Card_ActiveSet,Y
	STA Card_MatchCard

	; Mark card as flipped
	LDA Card_ActiveSet,Y
	ORA #$80
	STA Card_ActiveSet,Y

	; Card_GameState = 0; Return to selection mode
	LDA #$00
	STA Card_GameState

	RTS		 ; Return

PRG022_DB98:
	; Cards matched
	INC Card_GameState	 ; Card_GameState = 4
	RTS		 ; Return


Card_DoSelection:
	LDA Card_MoveDelay
	BEQ PRG022_DBA5	 ; If Card_MoveDelay = 0, jump to PRG022_DBA5

	DEC Card_MoveDelay	 ; Card_MoveDelay--

	RTS		 ; Return

PRG022_DBA5:
	LDA <Pad_Holding
	AND #PAD_A
	BEQ PRG022_DBAF	 ; If Player is not pressing A, jump to PRG022_DBAF

	INC Card_GameState	 ; Card_GameState = 1

	RTS		 ; Return

PRG022_DBAF:
	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	BEQ PRG022_DC1D	 ; If Player is not pressing a direction, jump to PRG022_DC1D (RTS)

	; Card_MoveDelay = 8
	LDA #$08
	STA Card_MoveDelay

	; Play blip sound
	LDA #SND_LEVELBLIP
	STA Sound_QLevel1

	LDA <Pad_Holding
	AND #PAD_UP
	BEQ PRG022_DBD9	 ; If Player is not pressing UP, jump to PRG022_DBD9

	; Card_Index -= 6 (one row up)
	LDA Card_Index
	SUB #$06
	STA Card_Index

	BCS PRG022_DBD9	 ; If not below zero, jump to PRG022_DBD9

	; Card_Index += 18 (return to bottom row)
	LDA Card_Index
	ADD #18
	STA Card_Index

PRG022_DBD9:
	LDA <Pad_Holding
	AND #PAD_DOWN
	BEQ PRG022_DBF8	 ; If Player is not pressing DOWN, jump to PRG022_DBF8

	; Card_Index += 6 (one row down)
	LDA Card_Index
	ADD #$06
	STA Card_Index

	LDA Card_Index
	CMP #18
	BLT PRG022_DBF8	 ; If not below the bottom row, jump to PRG022_DBF8

	; Card_Index -= 18 (return to top row)
	LDA Card_Index
	SUB #18
	STA Card_Index

PRG022_DBF8:
	LDA <Pad_Holding
	AND #PAD_RIGHT
	BEQ PRG022_DC0D	 ; If Player is not pressing RIGHT, jump to PRG022_DC0D

	INC Card_Index	 ; Card_Index++

	LDA Card_Index
	CMP #18
	BLT PRG022_DC0D	 ; If not passed the last card, jump to PRG022_DC0D

	; Return to first card
	LDA #$00
	STA Card_Index

PRG022_DC0D:
	LDA <Pad_Holding
	AND #PAD_LEFT
	BEQ PRG022_DC1D	 ; If Player is not pressing LEFT, jump to PRG022_DC1D (RTS)

	DEC Card_Index	 ; Card_Index--

	BPL PRG022_DC1D	 ; If did not go before first card, jump to PRG022_DC1D (RTS)

	; Card_Index = 17
	LDA #17
	STA Card_Index

PRG022_DC1D:
	RTS		 ; Return

Card_DrawSelectSprite:

	; Set sprite Y
	LDA Card_SelectY	 
	STA Sprite_RAM+$04,Y

	INY	; Y++ (next Sprite RAM offset)

	; Set sprite pattern
	LDA Card_SelectPattern,X
	STA Sprite_RAM+$04,Y

	INY	; Y++ (next Sprite RAM offset)

	; Set sprite attribute
	LDA Card_SelectAttribute,X
	STA Sprite_RAM+$04,Y

	INY	; Y++ (next Sprite RAM offset)

	; Set sprite Y
	LDA Card_SelectX
	STA Sprite_RAM+$04,Y

	INY	; Y++ (next Sprite RAM offset)

	INX		 ; X++

	RTS		 ; Return

Card_DrawCursor:
	LDX Card_Index	 ; X = Card_Index

	; Set Card_SelectX
	LDA Card_CursorXs,X
	STA Card_SelectX
	STA Card_SelectXOrig	 ; And keep original X

	; Set Card_SelectY
	LDA Card_CursorYs,X
	STA Card_SelectY

	LDX #$00	 ; X = 0
	LDY #$00	 ; Y = 0
PRG022_DC52:
	JSR Card_DrawSelectSprite	 ; Draw just a sprite 
 
	; Card_SelectX += 8
	LDA Card_SelectX
	ADD #$08
	STA Card_SelectX

	CPX #$04	
	BLT PRG022_DC52	; While X < 4, loop

	; Card_SelectY += 16
	LDA Card_SelectY
	ADD #16
	STA Card_SelectY

	; Card_SelectX = Card_SelectXOrig
	LDA Card_SelectXOrig
	STA Card_SelectX

	; Left edge sprite
	JSR Card_DrawSelectSprite

	LDA Card_SelectX
	ADD #24
	STA Card_SelectX

	; Right edge sprite
	JSR Card_DrawSelectSprite

	; Card_SelectY += 16
	LDA Card_SelectY
	ADD #16
	STA Card_SelectY

	; Card_SelectX = Card_SelectXOrig
	LDA Card_SelectXOrig
	STA Card_SelectX

PRG022_DC8F:
	JSR Card_DrawSelectSprite	 ; Draw just a sprite 
 
	; Card_SelectX += 8
	LDA Card_SelectX
	ADD #$08
	STA Card_SelectX

	CPX #$0a
	BLT PRG022_DC8F	 ; If X < $0A, loop

	; Hold current Sprite RAM offset
	STY Card_SprRAMOff

	RTS		 ; Return

CardFlip_Draw:
	LDX <Temp_Var11		 ; X = Temp_Var11 (Card Index)

	; Card starts at selection cursor +8
	LDA Card_CursorXs,X
	ADD #$08
	STA Card_SelectX
	STA Card_SelectXOrig

	; Card is at cursor Y
	LDA Card_CursorYs,X
	ADD #$08
	STA Card_SelectY

	LDX #$00	 	; X = 0
	LDY Card_SprRAMOff	; Y = Card_SprRAMOff

PRG022_DCBF:
	; Set sprite Y for card flip
	LDA Card_SelectY
	STA Sprite_RAM+$04,Y

	INY		 ; Y++ (next sprite byte)

	JSR CardFlipSprite_GetPattern	 ; Get pattern for sprite
	STA Sprite_RAM+$04,Y	 ; Set pattern

	INY		 ; Y++ (next sprite byte)

	; Temp_Var11 = 0
	LDA #$00
	STX <Temp_Var11

	LDX Card_FlipFrame	 ; X = Card_FlipFrame

	; Sprite attribute
	LDA CardFlip_Attributes,X
	STA Sprite_RAM+$04,Y

	LDX <Temp_Var11		 ; X = Temp_Var11 (current card flip sprite)

	INY		 ; Y++ (next sprite byte)

	; Set flip sprite X
	LDA Card_SelectX
	STA Sprite_RAM+$04,Y

	INY		 ; Y++ (next sprite byte)

	INX		 ; X++
	CPX #$04
	BGE PRG022_DD09	 ; If X >= 4, jump to PRG022_DD09

	; Card_SelectX += 8
	LDA Card_SelectX
	ADD #$08
	STA Card_SelectX

	TXA
	AND #$01
	BNE PRG022_DD06	 ; Every other flip sprite, jump to PRG022_DD06

	; Card_SelectY += 16
	LDA Card_SelectY
	ADD #16
	STA Card_SelectY

	; Card_SelectX = Card_SelectXOrig
	LDA Card_SelectXOrig
	STA Card_SelectX

PRG022_DD06:
	JMP PRG022_DCBF	; Jump to PRG022_DCBF

PRG022_DD09:

	; Some card flip sprites use HFLIP
	LDA Sprite_RAM+$32
	ORA #SPR_HFLIP
	STA Sprite_RAM+$32
	LDA Sprite_RAM+$3A
	ORA #SPR_HFLIP
	STA Sprite_RAM+$3A

	RTS		 ; Return

CardFlipSprite_GetPattern:
	STX <Temp_Var11	 ; Backup 'X' -> Temp_Var11 (current card flip sprite)

	LDX Card_FlipFrame	; X = Card_FlipFrame

	LDA CardFlip_FrameDefOff,X 	; Get initial frame def offset
	ADD <Temp_Var11		; Offset by current flip sprite
	TAX		  	; -> 'X'

	LDA CardFlip_FrameDefs,X ; Get this sprite pattern

	LDX <Temp_Var11	 ; Restore 'X'
	RTS		 ; Return

Card_MFSToInventory:	.byte $01, $02, $09	; Mushroom, Flower, Star card inventory item translation

Card_MatchPairReward:
	LDY Card_Index		; Y = Card_Index

	LDA Card_ActiveSet,Y	; Get the second card
	AND #$0f		; Mainly to mask the bit 7 "flipped" marker
	STA <Temp_Var13		; -> Temp_Var13

	CMP #CARD_1UP
	BNE PRG022_DD4A	 	; If the match was not a 1-up card, jump to PRG022_DD4A

	LDX Player_Current	 ; X = Player_Current

	INC Player_Lives,X	 ; Give Player extra life

	; Play 1-up sound
	LDA #SND_LEVEL1UP
	STA Sound_QLevel1

	BNE PRG022_DD77	 ; Jump (technically always) to PRG022_DD77 (RTS)

PRG022_DD4A:
	CMP #CARD_10COIN
	BLT PRG022_DD65	 ; If this is not one of the coin cards, jump to PRG022_DD65

	; A coin card

	LDY #10	 	; Y = 10 (10 coins)

	CMP #CARD_10COIN
	BEQ PRG022_DD56	 ; If this is the 10 coin card, jump to PRG022_DD56

	LDY #20		; Y = 20 (20 coins)

PRG022_DD56:
	TYA
	ADD Card_CoinsToGive
	STA Card_CoinsToGive	; Set coins to give

	; Play coin sound
	LDA #SND_LEVELCOIN
	STA Sound_QLevel1

	BNE PRG022_DD77	 ; Jump (technically always) to PRG022_DD77 (RTS)

PRG022_DD65:
	LDA <Temp_Var13
	CMP #CARD_1UP
	BGE PRG022_DD77	 ; If this is the 1-up, 10, or 20 coin card, jump to PRG022_DD77 (RTS)

	TAX		 		; Mushroom, Flower, Star index -> 'X'

	LDA Card_MFSToInventory,X	; Get the appropriate inventory item for this card pair
	JSR Player_GetItem		; Give it to Player

	; Play card match sound
	LDA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

PRG022_DD77:
	RTS		 ; Return

	; Base card before the face is added
CardBase_BufCmds:
	vaddr $0000	; Will be patched
	.byte $04, $64, $FE, $FE, $65

	vaddr $0000	; Will be patched
	.byte $04, $64, $00, $00, $65

	vaddr $0000	; Will be patched
	.byte $04, $64, $00, $00, $65

	vaddr $0000	; Will be patched
	.byte $04, $64, $FE, $FE, $65
CardBase_BufCmds_End

	; Blacks out a card
CardBlackout_BufCmds
	vaddr $0000	; Will be patched
	.byte $04, $FF, $FF, $FF, $FF

	vaddr $0000	; Will be patched
	.byte $04, $FF, $FF, $FF, $FF

	vaddr $0000	; Will be patched
	.byte $04, $FF, $FF, $FF, $FF

	vaddr $0000	; Will be patched
	.byte $04, $FF, $FF, $FF, $FF

	; Terminator
	.byte $00
CardBlackout_BufCmds_End

	; NSpade Card unflipped backside
CardBack_BufCmds:
	vaddr $0000	; Will be patched
	.byte $04, $66, $FD, $FD, $67

	vaddr $0000	; Will be patched
	.byte $04, $66, $2E, $2F, $67

	vaddr $0000	; Will be patched
	.byte $04, $66, $3E, $3F, $67

	vaddr $0000	; Will be patched
	.byte $04, $66, $FD, $FD, $67
CardBack_BufCmds_End

	; NSpade Game's Candystripe background
Video_NSpadeBG:
	vaddr $2000
	.byte VU_REPEAT | $22, $98

	vaddr $2020
	.byte VU_REPEAT | $22, $98

	vaddr $2040
	.byte VU_REPEAT | VU_VERT | $14, $98

	vaddr $2041
	.byte VU_REPEAT | VU_VERT | $14, $98

	vaddr $205E
	.byte VU_REPEAT | VU_VERT | $14, $98

	vaddr $205F
	.byte VU_REPEAT | VU_VERT | $14, $98

	vaddr $23C0
	.byte $10, $3F, $0F, $0F, $0F, $0F, $0F, $0F, $CF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF

	vaddr $23D0
	.byte $10, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF

	vaddr $23E0
	.byte $10, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F

	; Terminator
	.byte $00

; Rest of ROM bank was empty

