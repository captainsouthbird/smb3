; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:36.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup03 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $03 (i.e. objects starting at ID $6C) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup03_InitJumpTable:
	.word ObjInit_GroundTroop	; Object $6C - OBJ_GREENTROOPA
	.word ObjInit_GroundTroop	; Object $6D - OBJ_REDTROOPA
	.word ObjInit_GroundTroop	; Object $6E - OBJ_PARATROOPAGREENHOP
	.word ObjInit_GroundTroop	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.word ObjInit_GroundTroop	; Object $70 - OBJ_BUZZYBEATLE
	.word ObjInit_GroundTroop	; Object $71 - OBJ_SPINY
	.word ObjInit_GroundTroop	; Object $72 - OBJ_GOOMBA
	.word ObjInit_GroundTroop	; Object $73 - OBJ_PARAGOOMBA
	.word ObjInit_GroundTroop	; Object $74 - OBJ_PARAGOOMBAWITHMICROS
	.word ObjInit_BossAttack	; Object $75 - OBJ_BOSSATTACK
	.word ObjInit_Set3DoNothing	; Object $76 - OBJ_JUMPINGCHEEPCHEEP
	.word ObjInit_SpikeCheep	; Object $77 - OBJ_GREENCHEEP
	.word ObjInit_Set3DoNothing	; Object $78 - OBJ_BULLETBILL
	.word ObjInit_Set3DoNothing	; Object $79 - OBJ_BULLETBILLHOMING
	.word ObjInit_GiantTroop	; Object $7A - OBJ_BIGGREENTROOPA
	.word ObjInit_GiantTroop	; Object $7B - OBJ_BIGREDTROOPA
	.word ObjInit_GiantTroop	; Object $7C - OBJ_BIGGOOMBA
	.word ObjInit_GiantGreenPiranha	; Object $7D - OBJ_BIGGREENPIRANHA
	.word ObjInit_GiantTroop	; Object $7E - OBJ_BIGGREENHOPPER
	.word ObjInit_GiantRedPiranha	; Object $7F - OBJ_BIGREDPIRANHA
	.word ObjInit_Set3DoNothing	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.word ObjInit_HammerBro		; Object $81 - OBJ_HAMMERBRO
	.word ObjInit_BoomerangBro	; Object $82 - OBJ_BOOMERANGBRO
	.word ObjInit_Lakitu		; Object $83 - OBJ_LAKITU
	.word ObjInit_Set3DoNothing	; Object $84 - OBJ_SPINYEGG
	.word ObjInit_Set3DoNothing	; Object $85 - OBJ_SPINYEGGDUD
	.word ObjInit_HeavyBro		; Object $86 - OBJ_HEAVYBRO
	.word ObjInit_FireBro		; Object $87 - OBJ_FIREBRO
	.word ObjInit_OrangeCheep	; Object $88 - OBJ_ORANGECHEEP
	.word ObjInit_ChainChomp	; Object $89 - OBJ_CHAINCHOMP
	.word ObjInit_Thwomp		; Object $8A - OBJ_THWOMP
	.word ObjInit_ThwompLRSlide	; Object $8B - OBJ_THWOMPLEFTSLIDE
	.word ObjInit_ThwompLRSlide	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.word ObjInit_ThwompUDSlide	; Object $8D - OBJ_THWOMPUPDOWN
	.word ObjInit_ThwompUDSlide	; Object $8E - OBJ_THWOMPDIAGONALUL
	.word ObjInit_ThwompUDSlide	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup03_NormalJumpTable:
	.word ObjNorm_GroundTroop	; Object $6C - OBJ_GREENTROOPA
	.word ObjNorm_RedTroopa		; Object $6D - OBJ_REDTROOPA
	.word ObjNorm_GroundTroop	; Object $6E - OBJ_PARATROOPAGREENHOP
	.word ObjNorm_FlyingRedTroopa	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.word ObjNorm_GroundTroop	; Object $70 - OBJ_BUZZYBEATLE
	.word ObjNorm_GroundTroop	; Object $71 - OBJ_SPINY
	.word ObjNorm_GroundTroop	; Object $72 - OBJ_GOOMBA
	.word ObjNorm_ParaGoomba	; Object $73 - OBJ_PARAGOOMBA
	.word ObjNorm_ParaGoombaBomber	; Object $74 - OBJ_PARAGOOMBAWITHMICROS
	.word ObjNorm_BossAttack	; Object $75 - OBJ_BOSSATTACK
	.word ObjNorm_JumpingCheepCheep	; Object $76 - OBJ_JUMPINGCHEEPCHEEP
	.word ObjNorm_SpikeCheep	; Object $77 - OBJ_GREENCHEEP
	.word ObjNorm_BulletBill	; Object $78 - OBJ_BULLETBILL
	.word ObjNorm_BulletBill	; Object $79 - OBJ_BULLETBILLHOMING
	.word ObjNorm_GroundTroop	; Object $7A - OBJ_BIGGREENTROOPA
	.word ObjNorm_RedTroopa		; Object $7B - OBJ_BIGREDTROOPA
	.word ObjNorm_GroundTroop	; Object $7C - OBJ_BIGGOOMBA
	.word ObjNorm_BigPiranha	; Object $7D - OBJ_BIGGREENPIRANHA
	.word ObjNorm_GroundTroop	; Object $7E - OBJ_BIGGREENHOPPER
	.word ObjNorm_BigPiranha	; Object $7F - OBJ_BIGREDPIRANHA
	.word ObjNorm_FlyingGreenPara	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.word ObjNorm_HammerBro		; Object $81 - OBJ_HAMMERBRO
	.word ObjNorm_BoomerangBro	; Object $82 - OBJ_BOOMERANGBRO
	.word ObjNorm_Lakitu		; Object $83 - OBJ_LAKITU
	.word ObjNorm_SpinyEgg		; Object $84 - OBJ_SPINYEGG
	.word ObjNorm_SpinyEggDud	; Object $85 - OBJ_SPINYEGGDUD
	.word ObjNorm_HeavyBro		; Object $86 - OBJ_HEAVYBRO
	.word ObjNorm_FireBro		; Object $87 - OBJ_FIREBRO
	.word ObjNorm_OrangeCheep	; Object $88 - OBJ_ORANGECHEEP
	.word ObjNorm_ChainChomp	; Object $89 - OBJ_CHAINCHOMP
	.word ObjNorm_Thwomp		; Object $8A - OBJ_THWOMP
	.word ObjNorm_ThwompLRSlide	; Object $8B - OBJ_THWOMPLEFTSLIDE
	.word ObjNorm_ThwompLRSlide	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.word ObjNorm_ThwompVertical	; Object $8D - OBJ_THWOMPUPDOWN
	.word ObjNorm_ThwompVertical	; Object $8E - OBJ_THWOMPDIAGONALUL
	.word ObjNorm_ThwompVertical	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup03_CollideJumpTable:
	.word $0000					; Object $6C - OBJ_GREENTROOPA
	.word $0000					; Object $6D - OBJ_REDTROOPA
	.word OCSPECIAL_KILLCHANGETO | OBJ_GREENTROOPA	; Object $6E - OBJ_PARATROOPAGREENHOP
	.word OCSPECIAL_KILLCHANGETO | OBJ_REDTROOPA	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.word $0000					; Object $70 - OBJ_BUZZYBEATLE
	.word $0000					; Object $71 - OBJ_SPINY
	.word $0000					; Object $72 - OBJ_GOOMBA
	.word OCSPECIAL_KILLCHANGETO | OBJ_GOOMBA	; Object $73 - OBJ_PARAGOOMBA
	.word OCSPECIAL_KILLCHANGETO | OBJ_GOOMBA	; Object $74 - OBJ_PARAGOOMBAWITHMICROS
	.word OCSPECIAL_KILLCHANGETO | OBJ_GOOMBA	; Object $75 - OBJ_BOSSATTACK (OCSPECIAL_KILLCHANGETO must be a mistake, but interesting!)
	.word $0000					; Object $76 - OBJ_JUMPINGCHEEPCHEEP
	.word $0000					; Object $77 - OBJ_GREENCHEEP
	.word $0000					; Object $78 - OBJ_BULLETBILL
	.word $0000					; Object $79 - OBJ_BULLETBILLHOMING
	.word $0000					; Object $7A - OBJ_BIGGREENTROOPA
	.word $0000					; Object $7B - OBJ_BIGREDTROOPA
	.word $0000					; Object $7C - OBJ_BIGGOOMBA
	.word $0000					; Object $7D - OBJ_BIGGREENPIRANHA
	.word OCSPECIAL_KILLCHANGETO | OBJ_BIGGREENTROOPA	; Object $7E - OBJ_BIGGREENHOPPER
	.word $0000					; Object $7F - OBJ_BIGREDPIRANHA
	.word OCSPECIAL_KILLCHANGETO | OBJ_GREENTROOPA	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.word OCSPECIAL_HIGHSCORE			; Object $81 - OBJ_HAMMERBRO
	.word OCSPECIAL_HIGHSCORE			; Object $82 - OBJ_BOOMERANGBRO
	.word OCSPECIAL_HIGHSCORE			; Object $83 - OBJ_LAKITU
	.word $0000					; Object $84 - OBJ_SPINYEGG
	.word $0000					; Object $85 - OBJ_SPINYEGGDUD
	.word OCSPECIAL_HIGHSCORE			; Object $86 - OBJ_HEAVYBRO
	.word OCSPECIAL_HIGHSCORE			; Object $87 - OBJ_FIREBRO
	.word $0000					; Object $88 - OBJ_ORANGECHEEP
	.word $0000					; Object $89 - OBJ_CHAINCHOMP
	.word $0000					; Object $8A - OBJ_THWOMP
	.word $0000					; Object $8B - OBJ_THWOMPLEFTSLIDE
	.word $0000					; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.word $0000					; Object $8D - OBJ_THWOMPUPDOWN
	.word $0000					; Object $8E - OBJ_THWOMPDIAGONALUL
	.word $0000					; Object $8F - OBJ_THWOMPDIAGONALDL

	
	; Object group $03 (i.e. objects starting at ID $6C) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup03_Attributes:
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $6C - OBJ_GREENTROOPA
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $6D - OBJ_REDTROOPA
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $70 - OBJ_BUZZYBEATLE
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $71 - OBJ_SPINY
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $72 - OBJ_GOOMBA
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $73 - OBJ_PARAGOOMBA
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $74 - OBJ_PARAGOOMBAWITHMICROS
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $75 - OBJ_BOSSATTACK
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $76 - OBJ_JUMPINGCHEEPCHEEP
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $77 - OBJ_GREENCHEEP
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $78 - OBJ_BULLETBILL
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $79 - OBJ_BULLETBILLHOMING
	.byte OA1_PAL2 | OA1_HEIGHT48 | OA1_WIDTH24	; Object $7A - OBJ_BIGGREENTROOPA
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH24	; Object $7B - OBJ_BIGREDTROOPA
	.byte OA1_PAL3 | OA1_HEIGHT48 | OA1_WIDTH24	; Object $7C - OBJ_BIGGOOMBA
	.byte OA1_PAL2 | OA1_HEIGHT48 | OA1_WIDTH24	; Object $7D - OBJ_BIGGREENPIRANHA
	.byte OA1_PAL2 | OA1_HEIGHT48 | OA1_WIDTH24	; Object $7E - OBJ_BIGGREENHOPPER
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH24	; Object $7F - OBJ_BIGREDPIRANHA
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OA1_PAL3 | OA1_HEIGHT48 | OA1_WIDTH16	; Object $81 - OBJ_HAMMERBRO
	.byte OA1_PAL2 | OA1_HEIGHT48 | OA1_WIDTH16	; Object $82 - OBJ_BOOMERANGBRO
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $83 - OBJ_LAKITU
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $84 - OBJ_SPINYEGG
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $85 - OBJ_SPINYEGGDUD
	.byte OA1_PAL2 | OA1_HEIGHT48 | OA1_WIDTH24	; Object $86 - OBJ_HEAVYBRO
	.byte OA1_PAL1 | OA1_HEIGHT48 | OA1_WIDTH16	; Object $87 - OBJ_FIREBRO
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $88 - OBJ_ORANGECHEEP
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $89 - OBJ_CHAINCHOMP
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8A - OBJ_THWOMP
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8B - OBJ_THWOMPLEFTSLIDE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8D - OBJ_THWOMPUPDOWN
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8E - OBJ_THWOMPDIAGONALUL
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH48	; Object $8F - OBJ_THWOMPDIAGONALDL

	; Object group $03 (i.e. objects starting at ID $6C) second set attribute bits

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup03_Attributes2:
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $6C - OBJ_GREENTROOPA
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $6D - OBJ_REDTROOPA
	.byte OA2_TDOGRP1			; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OA2_TDOGRP1			; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $70 - OBJ_BUZZYBEATLE
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $71 - OBJ_SPINY
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $72 - OBJ_GOOMBA
	.byte OA2_TDOGRP1			; Object $73 - OBJ_PARAGOOMBA
	.byte OA2_TDOGRP1			; Object $74 - OBJ_PARAGOOMBAWITHMICROS
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $75 - OBJ_BOSSATTACK
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $76 - OBJ_JUMPINGCHEEPCHEEP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $77 - OBJ_GREENCHEEP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $78 - OBJ_BULLETBILL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $79 - OBJ_BULLETBILLHOMING
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP2	; Object $7A - OBJ_BIGGREENTROOPA
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP2	; Object $7B - OBJ_BIGREDTROOPA
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP2	; Object $7C - OBJ_BIGGOOMBA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $7D - OBJ_BIGGREENPIRANHA
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP2	; Object $7E - OBJ_BIGGREENHOPPER
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $7F - OBJ_BIGREDPIRANHA
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $81 - OBJ_HAMMERBRO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $82 - OBJ_BOOMERANGBRO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $83 - OBJ_LAKITU
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $84 - OBJ_SPINYEGG
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $85 - OBJ_SPINYEGGDUD
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $86 - OBJ_HEAVYBRO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $87 - OBJ_FIREBRO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $88 - OBJ_ORANGECHEEP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $89 - OBJ_CHAINCHOMP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8A - OBJ_THWOMP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8B - OBJ_THWOMPLEFTSLIDE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8D - OBJ_THWOMPUPDOWN
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8E - OBJ_THWOMPDIAGONALUL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP2	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup03_Attributes3:
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED 			; Object $6C - OBJ_GREENTROOPA
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED 			; Object $6D - OBJ_REDTROOPA
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED 			; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED 			; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED 			; Object $70 - OBJ_BUZZYBEATLE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_DIESHELLED 	; Object $71 - OBJ_SPINY
	.byte OA3_HALT_NORMALONLY | OA3_SQUASH 				; Object $72 - OBJ_GOOMBA
	.byte OA3_HALT_NORMALONLY | OA3_SQUASH 				; Object $73 - OBJ_PARAGOOMBA
	.byte OA3_HALT_NORMALONLY | OA3_SQUASH 				; Object $74 - OBJ_PARAGOOMBAWITHMICROS
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE			; Object $75 - OBJ_BOSSATTACK
	.byte OA3_HALT_NORMALONLY 					; Object $76 - OBJ_JUMPINGCHEEPCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 			; Object $77 - OBJ_GREENCHEEP
	.byte OA3_HALT_NORMALONLY 					; Object $78 - OBJ_BULLETBILL
	.byte OA3_HALT_NORMALONLY 					; Object $79 - OBJ_BULLETBILLHOMING
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED 			; Object $7A - OBJ_BIGGREENTROOPA
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED 			; Object $7B - OBJ_BIGREDTROOPA
	.byte OA3_HALT_NORMALONLY | OA3_SQUASH 				; Object $7C - OBJ_BIGGOOMBA
	.byte OA3_HALT_NORMALONLY | OA3_SQUASH | OA3_NOTSTOMPABLE 	; Object $7D - OBJ_BIGGREENPIRANHA
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED 			; Object $7E - OBJ_BIGGREENHOPPER
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 			; Object $7F - OBJ_BIGREDPIRANHA
	.byte OA3_HALT_NORMALONLY | OA3_DIESHELLED 			; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OA3_HALT_NORMALONLY 					; Object $81 - OBJ_HAMMERBRO
	.byte OA3_HALT_NORMALONLY 					; Object $82 - OBJ_BOOMERANGBRO
	.byte OA3_HALT_NORMALONLY 					; Object $83 - OBJ_LAKITU
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 			; Object $84 - OBJ_SPINYEGG
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 			; Object $85 - OBJ_SPINYEGGDUD
	.byte OA3_HALT_NORMALONLY 					; Object $86 - OBJ_HEAVYBRO
	.byte OA3_HALT_NORMALONLY 					; Object $87 - OBJ_FIREBRO
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 			; Object $88 - OBJ_ORANGECHEEP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $89 - OBJ_CHAINCHOMP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8A - OBJ_THWOMP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8B - OBJ_THWOMPLEFTSLIDE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8D - OBJ_THWOMPUPDOWN
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8E - OBJ_THWOMPDIAGONALUL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE ;Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup03_PatTableSel:
	.byte OPTS_SETPT6 | $4F	; Object $6C - OBJ_GREENTROOPA
	.byte OPTS_SETPT6 | $4F	; Object $6D - OBJ_REDTROOPA
	.byte OPTS_SETPT6 | $4F	; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte OPTS_SETPT6 | $4F	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte OPTS_SETPT5 | $0B	; Object $70 - OBJ_BUZZYBEATLE
	.byte OPTS_SETPT5 | $0B	; Object $71 - OBJ_SPINY
	.byte OPTS_SETPT6 | $4F	; Object $72 - OBJ_GOOMBA
	.byte OPTS_SETPT6 | $4F	; Object $73 - OBJ_PARAGOOMBA
	.byte OPTS_SETPT6 | $4F	; Object $74 - OBJ_PARAGOOMBAWITHMICROS
	.byte OPTS_NOCHANGE	; Object $75 - OBJ_BOSSATTACK
	.byte OPTS_SETPT6 | $4F	; Object $76 - OBJ_JUMPINGCHEEPCHEEP
	.byte OPTS_NOCHANGE	; Object $77 - OBJ_GREENCHEEP
	.byte OPTS_SETPT6 | $4F	; Object $78 - OBJ_BULLETBILL
	.byte OPTS_SETPT6 | $4F	; Object $79 - OBJ_BULLETBILLHOMING
	.byte OPTS_SETPT5 | $3D	; Object $7A - OBJ_BIGGREENTROOPA
	.byte OPTS_SETPT5 | $3D	; Object $7B - OBJ_BIGREDTROOPA
	.byte OPTS_SETPT5 | $3D	; Object $7C - OBJ_BIGGOOMBA
	.byte OPTS_SETPT5 | $3D	; Object $7D - OBJ_BIGGREENPIRANHA
	.byte OPTS_SETPT5 | $3D	; Object $7E - OBJ_BIGGREENHOPPER
	.byte OPTS_SETPT5 | $3D	; Object $7F - OBJ_BIGREDPIRANHA
	.byte OPTS_SETPT6 | $4F	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte OPTS_SETPT5 | $4E	; Object $81 - OBJ_HAMMERBRO
	.byte OPTS_SETPT5 | $4E	; Object $82 - OBJ_BOOMERANGBRO
	.byte OPTS_SETPT5 | $0B	; Object $83 - OBJ_LAKITU
	.byte OPTS_SETPT5 | $0B	; Object $84 - OBJ_SPINYEGG
	.byte OPTS_SETPT5 | $0B	; Object $85 - OBJ_SPINYEGGDUD
	.byte OPTS_SETPT5 | $4E	; Object $86 - OBJ_HEAVYBRO
	.byte OPTS_SETPT5 | $4E	; Object $87 - OBJ_FIREBRO
	.byte OPTS_SETPT6 | $4F	; Object $88 - OBJ_ORANGECHEEP
	.byte OPTS_SETPT5 | $0A	; Object $89 - OBJ_CHAINCHOMP
	.byte OPTS_SETPT5 | $12	; Object $8A - OBJ_THWOMP
	.byte OPTS_SETPT5 | $12	; Object $8B - OBJ_THWOMPLEFTSLIDE
	.byte OPTS_SETPT5 | $12	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte OPTS_SETPT5 | $12	; Object $8D - OBJ_THWOMPUPDOWN
	.byte OPTS_SETPT5 | $12	; Object $8E - OBJ_THWOMPDIAGONALUL
	.byte OPTS_SETPT5 | $12	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup03_KillAction:
	.byte KILLACT_JUSTDRAWMIRROR	; Object $6C - OBJ_GREENTROOPA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $6D - OBJ_REDTROOPA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $6E - OBJ_PARATROOPAGREENHOP
	.byte KILLACT_JUSTDRAWMIRROR	; Object $6F - OBJ_FLYINGREDPARATROOPA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $70 - OBJ_BUZZYBEATLE
	.byte KILLACT_JUSTDRAWMIRROR	; Object $71 - OBJ_SPINY
	.byte KILLACT_JUSTDRAWMIRROR	; Object $72 - OBJ_GOOMBA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $73 - OBJ_PARAGOOMBA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $74 - OBJ_PARAGOOMBAWITHMICROS
	.byte KILLACT_JUSTDRAW16X16	; Object $75 - OBJ_BOSSATTACK
	.byte KILLACT_JUSTDRAW16X16	; Object $76 - OBJ_JUMPINGCHEEPCHEEP
	.byte KILLACT_NORMALANDKILLED	; Object $77 - OBJ_GREENCHEEP
	.byte KILLACT_DRAWMOVENOHALT	; Object $78 - OBJ_BULLETBILL
	.byte KILLACT_DRAWMOVENOHALT	; Object $79 - OBJ_BULLETBILLHOMING
	.byte KILLACT_GIANTKILLED	; Object $7A - OBJ_BIGGREENTROOPA
	.byte KILLACT_GIANTKILLED	; Object $7B - OBJ_BIGREDTROOPA
	.byte KILLACT_GIANTKILLED	; Object $7C - OBJ_BIGGOOMBA
	.byte KILLACT_POOFDEATH		; Object $7D - OBJ_BIGGREENPIRANHA
	.byte KILLACT_GIANTKILLED	; Object $7E - OBJ_BIGGREENHOPPER
	.byte KILLACT_POOFDEATH		; Object $7F - OBJ_BIGREDPIRANHA
	.byte KILLACT_JUSTDRAWMIRROR	; Object $80 - OBJ_FLYINGGREENPARATROOPA
	.byte KILLACT_JUSTDRAW16X32	; Object $81 - OBJ_HAMMERBRO
	.byte KILLACT_JUSTDRAW16X32	; Object $82 - OBJ_BOOMERANGBRO
	.byte KILLACT_NORMALSTATE	; Object $83 - OBJ_LAKITU
	.byte KILLACT_JUSTDRAW16X16	; Object $84 - OBJ_SPINYEGG
	.byte KILLACT_NORMALANDKILLED	; Object $85 - OBJ_SPINYEGGDUD
	.byte KILLACT_NORMALANDKILLED	; Object $86 - OBJ_HEAVYBRO
	.byte KILLACT_JUSTDRAW16X32	; Object $87 - OBJ_FIREBRO
	.byte KILLACT_JUSTDRAW16X16	; Object $88 - OBJ_ORANGECHEEP
	.byte KILLACT_JUSTDRAW16X16	; Object $89 - OBJ_CHAINCHOMP
	.byte KILLACT_NORMALANDKILLED	; Object $8A - OBJ_THWOMP
	.byte KILLACT_NORMALANDKILLED	; Object $8B - OBJ_THWOMPLEFTSLIDE
	.byte KILLACT_NORMALANDKILLED	; Object $8C - OBJ_THWOMPRIGHTSLIDE
	.byte KILLACT_NORMALANDKILLED	; Object $8D - OBJ_THWOMPUPDOWN
	.byte KILLACT_NORMALANDKILLED	; Object $8E - OBJ_THWOMPDIAGONALUL
	.byte KILLACT_NORMALANDKILLED	; Object $8F - OBJ_THWOMPDIAGONALDL


	; Object group $03 (i.e. objects starting at ID $6C) pattern index starts
	; These are used for all states except "normal"

OG3_POff .func (\1 - ObjectGroup03_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup03_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG3_POff(ObjP6C), OG3_POff(ObjP6D), OG3_POff(ObjP6E), OG3_POff(ObjP6F)
	.byte OG3_POff(ObjP70), OG3_POff(ObjP71), OG3_POff(ObjP72), OG3_POff(ObjP73)
	.byte OG3_POff(ObjP74), OG3_POff(ObjP75), OG3_POff(ObjP76), OG3_POff(ObjP77)
	.byte OG3_POff(ObjP78), OG3_POff(ObjP79), OG3_POff(ObjP7A), OG3_POff(ObjP7B)
	.byte OG3_POff(ObjP7C), OG3_POff(ObjP7D), OG3_POff(ObjP7E), OG3_POff(ObjP7F)
	.byte OG3_POff(ObjP80), OG3_POff(ObjP81), OG3_POff(ObjP82), OG3_POff(ObjP83)
	.byte OG3_POff(ObjP84), OG3_POff(ObjP85), OG3_POff(ObjP86), OG3_POff(ObjP87)
	.byte OG3_POff(ObjP88), OG3_POff(ObjP89), OG3_POff(ObjP8A), OG3_POff(ObjP8B)
	.byte OG3_POff(ObjP8C), OG3_POff(ObjP8D), OG3_POff(ObjP8E), OG3_POff(ObjP8F)


	; Object group $03 (i.e. objects starting at ID $6C) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup03_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup03_PatternSets:
	; (End restricted alignment space)

	JMP GiantEnemy_Draw	; The special exception as noted above!!
ObjP75:
	.byte $DB, $F7, $DB, $DD, $F3, $F3, $DD, $DB, $F3, $F3, $BB, $BD, $BB, $BF, $F3, $F5
ObjP89:
	.byte $91, $93, $9D, $9F, $9D, $9F
ObjP8A:
ObjP8B:
ObjP8C:
ObjP8D:
ObjP8E:
ObjP8F:
	.byte $B1, $B3, $BB, $BD, $B1, $B3, $BB, $BD, $B1, $B3, $BB, $BD
ObjP7D:
ObjP7F:
	.byte $A1, $A3, $A5, $A7, $A9, $AB, $AD, $AF
ObjP7A:
ObjP7B:
ObjP7E:
	.byte $8D, $8F, $93, $95, $99, $8F, $9B, $9D, $B1, $B3, $B5, $B7
ObjP7C:
	.byte $81, $83, $87, $89, $81, $83, $87, $89, $81, $83, $87, $89, $71, $71, $BD, $BF
ObjP6C:
ObjP6D:
ObjP6E:
ObjP6F:
ObjP80:
	.byte $CB, $C5, $C3, $C5, $FD, $FD, $FD, $FD, $FD, $FD, $D1, $D1, $D3, $D5
ObjP70:
	.byte $95, $97, $91, $93, $9B, $9B, $9B, $9B, $A1, $A1, $9B, $9B, $A3, $A5
ObjP71:
	.byte $81, $83, $85, $87, $89, $89, $89, $89, $89, $89, $8F, $8F, $8B, $8D
ObjP72:
ObjP73:
ObjP74:
	.byte $D9, $DB, $DB, $D9, $D9, $DB, $EB, $EB
ObjP78:
ObjP79:
	.byte $DD, $DF, $DD, $DF, $DD, $DF, $DD, $DD, $7F, $7F
ObjP76:
ObjP77:
ObjP88:
	.byte $E7, $E9, $E7, $EF, $E7, $EF, $AD, $AF, $B9, $BB, $B9, $BB
ObjP84:
	.byte $99, $99, $BB, $BB, $81, $83
ObjP85:
	.byte $99, $99, $BB, $BB, $99, $99
ObjP83:
	.byte $9F, $9F, $9F, $9F, $9F, $9F, $01, $01, $9D, $9D, $9F, $9F
ObjP86:
	.byte $91, $9D, $A9, $AB, $91, $9D, $97, $99, $91, $93, $A9, $AB, $91, $93, $97, $99
ObjP87:
	.byte $81, $83, $A5, $A7, $81, $83, $B5, $B7, $85, $87, $BB, $A7
ObjP81:
ObjP82:
	.byte $B1, $B3, $B5, $B7, $B1, $B3, $A5, $A7, $BD, $BF, $B5, $B7, $BD, $BF, $A5, $A7
	.byte $A1, $A3, $AF, $B9, $89, $8B, $8D, $8F

BossAttack_XVelTowardsPlayer:
	.byte $10, -$10

ObjInit_BossAttack:

	; NOTE: This initialization state is used ONLY for the in-level Bowser Fireballs
	; (that you see just prior to Bowser himself), even though this object is 
	; actually intended for use by Bowser or the Koopalings as a respective attack.

	JSR Level_ObjCalcXDiffs

	; Set X velocity towards Player
	LDA BossAttack_XVelTowardsPlayer,Y
	STA <Objects_XVel,X

	; Var5 and Var4 = 2
	LDA #$02
	STA <Objects_Var5,X
	STA <Objects_Var4,X

	; Flame sound
	LDA #SND_LEVELFLAME
	STA Sound_QLevel2

	RTS		 ; Return

LemmyBall_FloorBounceYVel:	.byte -$40, -$3C, -$38, -$34

LemmyBall_RotateBits:	.byte $00, SPR_HFLIP, SPR_HFLIP | SPR_VFLIP, SPR_VFLIP

BossAttack_SprRAMOff:	.byte $80, $88, $90, $98
	
ObjNorm_BossAttack:
	LDA <Objects_Var5,X
	CMP #$02
	BEQ PRG004_A2B8	 ; If Var5 = 2 (Bowser fireball), jump to PRG004_A2B8

	JMP PRG004_A35F	 ; Jump to PRG004_A35F

PRG004_A2B8:

	; Load graphics
	LDA #$3b
	STA PatTable_BankSel+5

	LDA Objects_Timer,X
	CMP #$01
	BNE PRG004_A2C7	 ; If timer <> 1, jump to PRG004_A2C7

	JSR BossAttack_Poof	 ; Generate a poof at the boss attack object

PRG004_A2C7:

	TXA	
	AND #$03
	TAY		 ; Y = 0 to 3, based on boss attack's object index

	; Select a Sprite_RAM offset by the object's index
	LDA BossAttack_SprRAMOff,Y
	STA Object_SprRAM,X

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA <Player_HaltGame
	BNE PRG004_A33E	 ; If gameplay is halted, jump to PRG004_A33E

	JSR Object_FlipByXVel	 ; Flip based on direction of travel
	JSR Object_HandleBumpUnderneath	 ; Test if bumped underneath??

	LDA Objects_PlayerHitStat,X
	BEQ PRG004_A2E6	 ; If Player hasn't collided, jump to PRG004_A2E6

	JSR Player_GetHurt	 ; Any collision, hurt Player!

PRG004_A2E6:

	; Toggle frame to 5/6
	LDA <Counter_1
	LSR A
	AND #$01
	ADD #$05
	STA Objects_Frame,X

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_Var4,X
	BNE PRG004_A32D	 ; If Var4 <> 0, jump to PRG004_A32D

	LDA <Objects_Y,X
	PHA		 ; Save Object Y

	ADD Objects_TargetingYVal,X
	STA <Objects_Y,X

	JSR Object_WorldDetectN1	; Detect against world

	PLA		 ; Restore Object Y
	STA <Objects_Y,X

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_A33E	 ; If boss attack has NOT hit floor, jump to PRG004_A33E

	; Applies a Y offset
	LDA Objects_TargetingYVal,X
	AND #$0f
	STA Object_SlopeHeight

	JSR Object_HitGround	 ; Align to ground + offset

	INC <Objects_Var4,X	 ; Var4++

	LDY #-$10	 ; Y = -$10

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG004_A328	 ; If not horizontally flipped, jump to PRG004_A328

	LDY #$10	 ; Y = $10

PRG004_A328:
	NOP
	NOP
	JMP PRG004_A33E	 ; Jump to PRG004_A33E

PRG004_A32D:

	; Set frame to 7
	LDA #$07
	STA Objects_Frame,X

	ASL Objects_FlipBits,X
	LDA <Counter_1
	LSR A
	LSR A
	NOP
	NOP
	ROR Objects_FlipBits,X

PRG004_A33E:
	JMP Object_ShakeAndDraw	 ; Draw and don't come back

PRG004_A341:
	RTS		 ; Return


BossAttack_Poof:
	JSR SpecialObj_FindEmptyAbort	 

	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y

	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; A "poof"
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y

	; Poof counter"
	LDA #$17
	STA SpecialObj_Data,Y

	RTS		 ; Return


PRG004_A35F:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR BossAttack_Draw	 	; Draw the boss attack

	LDA <Player_HaltGame
	ORA Objects_ColorCycle,X
	BNE PRG004_A341	 ; If gameplay is halted or a color cycle is going on (Lemmy's ball when stomped), jump to PRG004_A341 (RTS)

	LDA <Counter_1
	AND #$03
	BEQ PRG004_A375	 ; 1:4 ticks jump to PRG004_A375

	INC Objects_Var3,X	 ; Var3++

PRG004_A375:
	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath (??)

	LDA Objects_PlayerHitStat,X
	BEQ PRG004_A3B2	 ; If player is not colliding with boss attack, jump to PRG004_A3B2

	LDA <Objects_Var5,X
	BNE PRG004_A3AF	 ; If Var5 <> 0 (Lemmy's balls), jump to PRG004_A3AF

	; Lemmy's balls here...

	LDA Objects_ColorCycle,X
	BNE PRG004_A3AF	 ; If already color cycling, jump to PRG004_A3AF

	LDA <Objects_XVel,X
	BNE PRG004_A393	 ; If moving horizontally, jump to PRG004_A393

	LDA #$08	 ; A = $08

	LDY RandomN,X
	BPL PRG004_A393	 ; Randomly jump to PRG004_A393

	LDA #-$08	 ; A = -$08

PRG004_A393:
	STA <Objects_Var4,X	 ; Var4 = randomly $08 or -$08 if the ball was stopped (by Player stomp), or the X Velocity

	; Halt movement
	LDA #$00
	STA <Objects_XVel,X
	STA <Objects_YVel,X

	; Player bounces off ball
	LDA #-$30
	STA <Player_YVel

	; Play bounce noise
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	; Short burst of color cycle
	LDA #$0c
	STA Objects_ColorCycle,X

	JMP PRG004_A3B2	 ; Jump to PRG004_A3B2

PRG004_A3AF:
	JSR Player_GetHurt	 ; Hurt Player!

PRG004_A3B2:
	LDA <Objects_Var5,X
	BNE PRG004_A408	 ; If Var5 <> 0 (Lemmy's ball), jump to PRG004_A408

	; Lemmy's ball...

	LDA <Objects_XVel,X

	PHP		 ; Save CPU state (most importantly, sign of Lemmy's ball's X velocity)

	LDA Objects_Var3,X
	LSR A
	LSR A
	AND #$03	; A = 0 to 3

	PLP		 ; Restore CPU state (most importantly, sign of Lemmy's ball's X velocity)

	BPL PRG004_A3C5	 ; If ball is not traveling to the left, jump to PRG004_A3C5

	EOR #$03	 ; Otherwise, reverse the value

PRG004_A3C5:
	TAY		 ; Y = 0 to 3

	; Rotation of Lemmy's ball
	LDA LemmyBall_RotateBits,Y
	STA Objects_FlipBits,X

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	CMP #$20
	BGS PRG004_A3DD	 ; If Lemmy's ball at $20 or faster, jump to PRG004_A3DD

	INC <Objects_YVel,X	 ; Y++ (fall rate)

	; Hm, something removed... maybe it was a scaled fall once?
	NOP
	NOP
	NOP

PRG004_A3DD:
	JSR Object_WorldDetectN1	 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG004_A3E9	 ; If ball did not hit ceiling, jump to PRG004_A3E9

	JSR BossAttack_HitOffCeiling	 ; Complete bounce off ceiling

PRG004_A3E9:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_A404	 ; If ball did not hit ground, jump to PRG004_A404

	LDA RandomN,X
	AND #$03
	TAY		 ; Y = random 0 to 3

	; Bounce off floor at a bit of random Y velocity
	LDA LemmyBall_FloorBounceYVel,Y
	STA <Objects_YVel,X

	LDA <Objects_Var4,X
	BEQ PRG004_A404	 ; If Var4 = 0 (no X velocity to restore), jump to PRG004_A404

	; Otherwise, restore X velocity
	STA <Objects_XVel,X

	; Clear Var4
	LDA #$00
	STA <Objects_Var4,X

PRG004_A404:
	; Hit off walls
	JSR BossAttack_HitOffWall

	RTS		 ; Return

PRG004_A408:

	; Wendy's rings...

	JSR Object_ApplyXVel	 	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity
	JSR Object_WorldDetectN1	; Detect against world

	LDY <Objects_SpriteY,X	 ; Y = Sprite Y

	LDA <Objects_YVel,X
	BPL PRG004_A41D	 ; If ring is not moving downward, jump to PRG004_A41D

	CPY #8
	BLT PRG004_A427	 ; If ring Sprite Yis higher than 8, jump to PRG004_A427
	BGE PRG004_A421	 ; Otherwise, jump to PRG004_A421

PRG004_A41D:
	CPY #240
	BGE PRG004_A427	 ; If ring Sprite Y is lower than 240, jump to PRG004_A427

PRG004_A421:
	LDA <Objects_DetStat,X
	AND #$0c
	BEQ BossAttack_HitOffWall	 ; If ring hit neither floor nor ceiling, jump to BossAttack_HitOffWall

PRG004_A427:
	JSR BossAttack_HitOffCeiling	 ; Otherwise, hit off ceiling

BossAttack_HitOffWall:
	LDA <Objects_DetStat,X
	AND #$03
	BNE PRG004_A440	 ; If boss attack has hit off a wall, jump to PRG004_A440

	LDY <Objects_SpriteX,X	 ; Y = Sprite X

	LDA <Objects_XVel,X
	BPL PRG004_A43C	 ; If boss attack is not moving to the left, jump to PRG004_A43C

	CPY #$08
	BLT PRG004_A440	 ; If Sprite X < 8, jump to PRG004_A440
	BGE PRG004_A443	 ; Otherwise, jump to PRG004_A443 (RTS)

PRG004_A43C:
	CPY #240
	BLT PRG004_A443	 ; If Sprite X < 240, jump to PRG004_A443

PRG004_A440:
	JSR Object_AboutFace	 ; Turn around

PRG004_A443:
	RTS		 ; Return


BossAttack_HitOffCeiling:

	; Reverse Y velocity
	LDA <Objects_YVel,X
	JSR Negate
	STA <Objects_YVel,X

	RTS		 ; Return

BossAttack_Frame:
	.byte $01, $02, $03, $04


BossAttack_Draw:
	LDA <Objects_Var5,X	 
	BNE PRG004_A457	 ; If Var5 <> 0, jump to PRG004_A457

	JMP Object_ShakeAndDraw	 ; Draw and don't come back

PRG004_A457:
	LDA Objects_Var3,X
	LSR A
	LSR A
	AND #$03
	TAY		 ; Y = 0 to 3

	LDA BossAttack_Frame,Y
	STA Objects_Frame,X

	JMP Object_ShakeAndDrawMirrored	 ; Draw mirrored and don't come back

	; A "hammer brother" object has special purpose when 
	; Player has entered through a enemy battle object
BattleEnemy_ByEnterID:
	.byte $00		; 0: (Unused, standard level entry)
	.byte $00		; 1: HELP (can't be "entered")
	.byte $00		; 2: Airship (not our concern here)
	.byte OBJ_HAMMERBRO	; 3: Hammer Bro battle
	.byte OBJ_BOOMERANGBRO	; 4: Boomerang Bro battle
	.byte OBJ_HEAVYBRO	; 5: Heavy Bro battle
	.byte OBJ_FIREBRO	; 6: Fire Bro battle
	.byte $00		; 7: World 7 Plant (not our concern here)
	.byte $00		; 8: Unknown marching glitch object (interesting!)
	.byte $00		; 9: N-Spade (not our concern)

	; NOTE: No definition for $0A-$10 map objects... not our concern,
	; sure, but still interesting that they went as far as they did.

ObjInit_HammerBro:
	LDA Level_Event
	CMP #$07
	BNE PRG004_A48F	 ; If we're not getting a treasure box (i.e. a Hammer Bro battle), jump to PRG004_A48F (RTS)

	LDY Map_EnterViaID	; Y = Map_EnterViaID

	LDA BattleEnemy_ByEnterID,Y
	CMP #OBJ_HAMMERBRO
	BEQ PRG004_A490	 	; If battling a hammer brother, jump to PRG004_A490

	; Not a hammer brother...

	STA Level_ObjectID,X	; Store the enemy ID

	DEC Objects_State,X	 ; Take state back to 0 

	RTS		 ; Return

ObjInit_BoomerangBro:

	; Var5 = random value
	LDA RandomN,X
	STA <Objects_Var5,X

PRG004_A48F:
	RTS		 ; Return

PRG004_A490:
	; Var6 = random value
	LDA RandomN,X
	STA Objects_Var6,X
	RTS		 ; Return

BoomerangBro_FacePlayerFlip:	.byte SPR_HFLIP, $00

ObjNorm_BoomerangBro:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR EnemyBro_DrawAndHandleBump	 ; Draw Boomerang Bro and handle getting bumped underneath

	LDA <Player_HaltGame
	BNE PRG004_A48F	 ; If gameplay halted, jump to PRG004_A48F (RTS)

	JSR Object_Move	 ; Do standard movement
	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped underneath (again, technically)

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_A4B2	 ; If Boomerang Bro has not hit ground, jump to PRG004_A4B2

	JSR Object_HitGround	 ; Align to ground

PRG004_A4B2:
	LDA <Counter_1
	AND #$0f
	BNE PRG004_A4C1	 ; 1:16 ticks proceed, otherwise jump to PRG004_A4C1

	JSR Level_ObjCalcXDiffs

	; Face towards Player
	LDA BoomerangBro_FacePlayerFlip,Y
	STA Objects_FlipBits,X

PRG004_A4C1:

	LDA <Objects_Var5,X
	AND #$03	; 0-3 based on Var5 for internal state

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BoomerangBro_WalkThenStop
	.word BoomerangBro_WalkRight
	.word BoomerangBro_WalkThenStop
	.word BoomerangBro_WalkLeft

BoomerangBro_WalkThenStop:
	LDA Objects_Timer3,X	 
	BNE PRG004_A4DC	 ; If timer 3 is not expired, jump to PRG004_A4DC

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Reload timer3 at $40
	LDA #$40
	STA Objects_Timer3,X

PRG004_A4DC:

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

BoomerangBro_WalkLeft:
	LDA #-$08	 ; A = -$08
	BNE PRG004_A4E7	 ; Jump (technically always) to PRG004_A4E7

BoomerangBro_WalkRight:
	LDA #$08	 ; A = $08

PRG004_A4E7:
	STA <Objects_XVel,X	 ; Set X Velocity

	; Var4 += 2
	INC <Objects_Var4,X
	INC <Objects_Var4,X

	LDA <Counter_1
	BNE PRG004_A4FA	 ; 1:256 ticks proceed, otherwise jump to PRG004_A4FA

	LDA RandomN,X
	BPL PRG004_A4FA	 ; 50/50 chance to jump to PRG004_A4FA

	; Little jump
	LDA #-$30
	STA <Objects_YVel,X

PRG004_A4FA:
	LDA Objects_Timer3,X
	BNE PRG004_A506	 ; If timer3 not expired, jump to PRG004_A506

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Reload timer3 with $10
	LDA #$10
	STA Objects_Timer3,X

PRG004_A506:
	LDA Objects_Var6,X
	INC Objects_Var6,X	; Var6++
	AND #$bf
	CMP #$1f
	BNE PRG004_A51A	 ; Periodically jump to PRG004_A51A (RTS)

	; Reload timer with $0F
	LDA #$0f
	STA Objects_Timer,X

	JSR BoomerangBro_ThrowBoomerang	 ; Throw a boomerang

PRG004_A51A:
	RTS		 ; Return

HammerBro_JumpYVel:	.byte -$30, $00, -$60
HammerBro_TimerReload:	.byte $28, $00, $20
PRG004_A522:	.byte $01, $00, $FF

HammerBro_FacePlayerFlip:
	.byte SPR_HFLIP, $00
	
ObjNorm_HammerBro: 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	JSR Level_ObjCalcXDiffs

	; Face Player
	LDA HammerBro_FacePlayerFlip,Y
	STA Objects_FlipBits,X

	LDA <Player_HaltGame
	BEQ PRG004_A539	 ; If gameplay is halted, jump to PRG004_A539

	JMP EnemyBro_DrawAndHandleBump	 ; Otherwise, jump to EnemyBro_DrawAndHandleBump

PRG004_A539:
	INC <Objects_Var5,X	 ; Var5++

	LDY #$06	 ; Y = $06

	LDA <Objects_Var5,X
	AND #$40
	BNE PRG004_A545	 ; 64 ticks on, 64 ticks off; jump to PRG004_A545

	LDY #-$06	 ; Y = -$06

PRG004_A545;
	STY <Objects_XVel,X	 ; Hammer Bros walk back and forth

	LDA <Objects_DetStat,X
	AND #$04
	BNE PRG004_A551	 ; If Hammer Bro hit ground, jump to PRG004_A551

	STA <Objects_Var4,X	 ;  Var4 = 0
	BEQ PRG004_A587	 ; Jump (technically always) to PRG004_A587

PRG004_A551:
	LDA Objects_Timer2,X
	BNE PRG004_A587	 ; If timer2 is not expired, jump to PRG004_A587

	INC <Objects_Var4,X	 ; Var4++
	JSR Object_HitGround	 ; Align to ground

	LDA Objects_Timer3,X
	BNE PRG004_A587	 ; if timer3 is not expired, jump to PRG004_A587

	LDA RandomN,X
	AND #$3e
	ADC #$c0
	STA Objects_Timer3,X	 ; Timer3 = $C0 to $FF

	LDY #$02	 ; Y = $02

	LDA <Objects_Y,X
	BMI PRG004_A57C	 ; If Hammer Bro is on the lower part of the screen, jump to PRG004_A57C

	LDY #$00	 ; Y = 0

	CMP #$30
	BLT PRG004_A57C	 ; If Hammer Bro Y < $30, jump to PRG004_A57C

	LDA RandomN,X
	AND #$02
	TAY		 ; Y = 0 or 2, random

PRG004_A57C:
	; Jump!
	LDA HammerBro_JumpYVel,Y
	STA <Objects_YVel,X

	; Timer2 reload
	LDA HammerBro_TimerReload,Y
	STA Objects_Timer2,X

PRG004_A587:
	JSR Object_Move	 ; Do standard movement

	LDA <Counter_1
	AND #$07
	BEQ PRG004_A593	 ; 1:8 ticks jump to PRG004_A593

	INC Objects_Var6,X	 ; Var6++

PRG004_A593:
	LDY #$3f	 ; Y = $3F

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_A59D	 ; If Hammer Bro did not hit floor, jump to PRG004_A59D

	LDY #$1f	 ; Y = $1F

PRG004_A59D:
	TYA	

	AND Objects_Var6,X	; Mask with 'Y'

	CMP #$1f
	BNE EnemyBro_DrawAndHandleBump	 ; If masked value <> $1F, jump to EnemyBro_DrawAndHandleBump

	LDA Objects_Timer,X
	BNE EnemyBro_DrawAndHandleBump	 ; If timer is not expired, jump to EnemyBro_DrawAndHandleBump

	; Timer set to $0F
	LDA #$0f
	STA Objects_Timer,X

	JSR HammerBro_ThrowHammer	 ; Throw Hammer at Player

EnemyBro_DrawAndHandleBump:
	LDY #$00	 ; Y = 0

	LDA <Objects_Var4,X
	AND #$10
	BEQ PRG004_A5BB	 ; 16 ticks on, 16 ticks off; jump to PRG004_A5BB

	INY		 ; Y = 1

PRG004_A5BB:
	LDA Objects_Timer,X
	BEQ PRG004_A5C2	 ; If timer is expired, jump to PRG004_A5C2

	; Y += 2
	INY
	INY

PRG004_A5C2:

	; Set Frame 0-3
	TYA
	STA Objects_Frame,X

	LDA <Objects_Y,X
	PHA		 ; Save Hammer Bro Y
 
	ADD #$08
	STA <Objects_Y,X ; Hammer Bro Y += 8

	LDA <Objects_YHi,X
	PHA		 ; Save Y Hi

	ADC #$00	 ; Apply carry
	STA <Objects_YHi,X	 ; Update Y Hi

	JSR Object_Draw16x32Sprite	 ; Draw Hammer Bro

	PLA		 
	STA <Objects_YHi,X	; Restore Y Hi

	PLA
	STA <Objects_Y,X	; Restore Y

	JSR Object_CalcSpriteXY_NoHi

	JMP PRG004_AF1A	 ; (Indirectly) Handle getting bumped underneath


Hammer_XVel:	.byte $12, -$12

HammerBro_ThrowHammer:
	LDA Objects_SprHVis,X	 
	BNE PRG004_A61B	 ; If any sprite is horizontally off-screen, jump to PRG004_A61B (RTS)

	LDY #$05	 ; Y = 5
PRG004_A5ED:
	LDA SpecialObj_ID,Y
	BEQ PRG004_A5F6	 ; If this Special Object slot is empty, jump to PRG004_A5F6

	DEY		 ; Y--
	BPL PRG004_A5ED	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG004_A5F6:

	; Set Hammer X/Y at Hammer Bro's position
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Hammer Y velocity = -$30
	LDA #-$30
	STA SpecialObj_YVel,Y

	STY <Temp_Var1		 ; Temp_Var1 = Special Object slot index

	JSR Level_ObjCalcXDiffs

	LDA Hammer_XVel,Y	; Hammer towards Player X Vel
	LDY <Temp_Var1		 ; Y = Special Object slot index
	STA SpecialObj_XVel,Y	 ; Set X Velocity

	LDA #SOBJ_HAMMER ; Hammer Bro hammer
	BNE PRG004_A658	 ; Jump (technically always) to PRG004_A658

PRG004_A61B:
	RTS		 ; Return

Boomerang_XVel:	.byte $20, -$20
Boomerang_ArrayValLoad:	.byte $01, $00
	
BoomerangBro_ThrowBoomerang:
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot or don't come back!

	; Set Boomerang at Boomerang Bro's position
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	STY <Temp_Var1		 ; Store special object index -> Temp_Var1

	JSR Level_ObjCalcXDiffs

	LDA Boomerang_XVel,Y
	PHA		 ; Save X Velocity value

	LDA Boomerang_ArrayValLoad,Y

	LDY <Temp_Var1	 ; Y = special object slot index

	STA SpecialObj_Var2,Y	 ; Store -> SpecialObj_Var2

	PLA		 ; Restore X velocity
	STA SpecialObj_XVel,Y	 ; Store into Boomerang

	; Set Boomerang Y Velocity
	LDA #-$16
	STA SpecialObj_YVel,Y

	; SpecialObj_Var3 = 0
	LDA #$00
	STA SpecialObj_Var3,Y

	; SpecialObj_Timer = $40
	LDA #$40
	STA SpecialObj_Timer,Y

	LDA #SOBJ_BOOMERANG	 ; Boomerang

PRG004_A658:
	STA SpecialObj_ID,Y	 ; Set Special Object ID

	; Pushes Hammer Bro's object index into SpecialObj_Data upper 4 bits, sets lower 4 bits to $0F
	TXA
	ASL A
	ASL A
	ASL A
	ASL A
	ORA #$0f
	STA SpecialObj_Data,Y

	; SpecialObj_Var1 = 0
	LDA #$00
	STA SpecialObj_Var1,Y

	RTS		 ; Return

ObjInit_Thwomp:

	; Var4 = origin Y
	LDA <Objects_Y,X
	STA <Objects_Var4,X

Thwomp_Center:
	; center the X
	LDA <Objects_X,X
	ADD #$04
	STA <Objects_X,X

PRG004_A676:
	RTS		 ; Return


ObjNorm_Thwomp:
	JSR Thwomp_Draw	 ; Draw Thwomp; if not in normal state, we don't come back!

	LDA <Player_HaltGame
	BNE PRG004_A676	 ; If gameplay halted, jump to PRG004_A676 (RTS)

	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JSR Player_HitEnemy	 	; Do Player to Thwomp collision

	LDA <Objects_Var5,X	 ; Var5 is internal state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Thwomp_WaitForPlayer
	.word Thwomp_FallToGround
	.word Thwomp_ReturnToOrigin

Thwomp_WaitForPlayer
	JSR Object_AnySprOffscreen
	BNE PRG004_A6A6	 ; If any sprite is off-screen, jump to PRG004_A6A6 (RTS)

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$24
	CMP #$50
	BGE PRG004_A6A6	 ; If Player is too far away, jump to PRG004_A6A6 (RTS)

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Stop Thwomp's vertical movement
	LDA #$00
	STA <Objects_YVel,X

PRG004_A6A6:
	RTS		 ; Return

Thwomp_FallToGround:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity
 
	LDA <Objects_YVel,X
	CMP #$70
	BGE PRG004_A6B4	 ; If Thwomp is falling >= $70, jump to PRG004_A6B4

	; Thwomp fall Y Vel += 4
	ADC #$04
	STA <Objects_YVel,X

PRG004_A6B4:
	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_A6D4	 ; If Thwomp did not hit ground, jump to PRG004_A6D4 (RTS)

	JSR Object_HitGround	 ; Align to floor

	; Shake floor!
	LDA #$18
	STA Level_Vibration

	; Ba-bam! sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

PRG004_A6D4:
	RTS		 ; Return

Thwomp_ReturnToOrigin:
	LDA Objects_Timer,X 
	BNE PRG004_A6EC	 ; If timer is not expired, jump to PRG004_A6EC (RTS)

	LDA <Objects_Y,X
	CMP <Objects_Var4,X
	BNE PRG004_A6E5	 ; If Thwomp has not returned to his origin Y, jump to PRG004_A6E5

	; Var5 = 0 (return to original internal state)
	LDA #$00
	STA <Objects_Var5,X

	RTS		 ; Return

PRG004_A6E5:
	; Set Thwomp Y velocity to -$10
	LDA #-$10
	STA <Objects_YVel,X

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

PRG004_A6EC:
	RTS		 ; Return


Thwomp_Draw:

	; Clear any flip
	LDA #$00 
	STA Objects_FlipBits,X

	JSR Object_Draw16x32Sprite	 ; Draw left 2/3 of Thwomp

	LDA Objects_SprHVis,X
	AND #$20
	BNE PRG004_A737	 ; If sprite is not visible, jump to PRG004_A737

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; The right sprites appear +16 away from Thwomp's left
	LDA <Objects_SpriteX,X
	ADD #16
	STA Sprite_RAM+$13,Y
	STA Sprite_RAM+$17,Y

	; Temp_Var1 = vertical visibility bits
	LDA Objects_SprVVis,X
	STA <Temp_Var1	

	LDA <Objects_SpriteY,X

	LSR <Temp_Var1
	BCS PRG004_A718	 ; If sprite is vertically off-screen, jump to PRG004_A718

	STA Sprite_RAM+$10,Y	 ; Set upper Sprite Y

PRG004_A718:
	LSR <Temp_Var1
	BCS PRG004_A722	 ; If sprite is vertically off-screen, jump to PRG004_A722

	ADD #16
	STA Sprite_RAM+$14,Y	 ; Set lower Sprite Y

PRG004_A722:

	; Right sprite horizontally flipped
	LDA Sprite_RAM+$02,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$12,Y
	STA Sprite_RAM+$16,Y

	; Upper sprite pattern
	LDA #$b1
	STA Sprite_RAM+$11,Y

	; Lower sprite pattern
	LDA #$bb
	STA Sprite_RAM+$15,Y

PRG004_A737:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG004_A740	 ; If Thwomp's state is Normal, jump to PRG004_A740 (RTS)

	; If Thwomp is in normal state, don't return to caller!
	PLA
	PLA

PRG004_A740:
	RTS		 ; Return

ObjInit_ThwompLRSlide:
	JSR Thwomp_Center	 ; Center the X of the Thwomp

	; Var4 = origin X
	STA <Objects_Var4,X

	RTS		 ; Return

ObjNorm_ThwompLRSlide:
	JSR Thwomp_Draw	 ; Draw Thwomp

	LDA <Player_HaltGame
	BNE PRG004_A78B	 ; If gameplay is halted, jump to PRG004_A78B (RTS)

	JSR Object_DeleteOffScreen_N2	 ; Delete if falls off-screen
	JSR Player_HitEnemy	 ; Do Player to Thwomp collision detection

	LDA <Objects_Var5,X	 ; Var5 is internal state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word ThwompLR_WaitForPlayer
	.word ThwompLR_Slide
	.word ThwompLR_Return


ThwompLR_WaitForPlayer:
	JSR Object_AnySprOffscreen
	BNE PRG004_A78B	 ; If any sprite is off-screen, jump to PRG004_A78B (RTS)

	JSR Level_ObjCalcXDiffs	

	LDA <Temp_Var16
	ADD #$70
	CMP #$e8
	BGE PRG004_A78B	 ; If Player is too far from Thwomp, jump to PRG004_A78B (RTS)

	LDA Level_ObjectID,X
	SUB #OBJ_THWOMPLEFTSLIDE
	STA <Temp_Var1		 ; Temp_Var1 = 0 if left sliding Thwomp, or 1 if right sliding Thwomp

	CPY <Temp_Var1	
	BEQ PRG004_A78B	 ; If Player is not on correct side of Thwomp, jump to PRG004_A78B (RTS)

	; Set Var7 for slide direction
	TYA
	STA Objects_Var7,X

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Stop Thwomp's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	; Set timer to $3B
	LDA #$3b
	STA Objects_Timer,X

PRG004_A78B:
	RTS		 ; Return

ThwompLR_XVelAccel:	.byte  $02, -$02
ThwompLR_XVelLimit:	.byte  $20, -$20
ThwompLR_ReturnXVel:	.byte -$08,  $08
	

ThwompLR_Slide:
	LDA Objects_Timer,X
	BNE PRG004_A79E	 ; If timer not expired, jump to PRG004_A79E

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Timer set to $40
	LDA #$40
	STA Objects_Timer,X

PRG004_A79E:
	JSR Object_ApplyXVel	 ; Apply X Velocity

	LDY Objects_Var7,X	 ; Y = Var7 (slide direction)

	LDA <Objects_XVel,X
	CMP ThwompLR_XVelLimit,Y
	BEQ PRG004_A7B1	 	; If Thwomp's X velocity is at its limit, jump to PRG004_A7B1

	; Accelerate!
	ADD ThwompLR_XVelAccel,Y
	STA <Objects_XVel,X

PRG004_A7B1:
	RTS		 ; Return


ThwompLR_Return:
	LDA Objects_Timer,X	 
	BNE PRG004_A7CD	 ; If timer is not expired, jump to PRG004_A7CD (RTS)

	LDA <Objects_X,X
	CMP <Objects_Var4,X
	BNE PRG004_A7C2	 ; If Thwomp is not back to his origin X, jump to PRG004_A7C2

	; Var5 = 0 (return to original internal state)
	LDA #$00
	STA <Objects_Var5,X

	RTS		 ; Return

PRG004_A7C2:
	LDY Objects_Var7,X	 ; Y = Var7 (slide direction)

	; Set Thwomp's return X velocity
	LDA ThwompLR_ReturnXVel,Y
	STA <Objects_XVel,X

	JSR Object_ApplyXVel	 ; Apply X Velocity

PRG004_A7CD:
	RTS		 ; Return

	; Values for OBJ_THWOMPUPDOWN, OBJ_THWOMPDIAGONALUL, OBJ_THWOMPDIAGONALDL, respectively
SlideThwomp_InitXVel:	.byte $00, $10, $10
SlideThwomp_InitYVel:	.byte $10, $10, $F0

ObjInit_ThwompUDSlide:
	LDA Level_ObjectID,X
	SUB #OBJ_THWOMPUPDOWN
	TAY		 ; Y = relative Thwomp index

	; Set initial X velocity
	LDA SlideThwomp_InitXVel,Y
	STA <Objects_XVel,X

	; Set initial Y velocity
	LDA SlideThwomp_InitYVel,Y
	STA <Objects_YVel,X

	JMP Thwomp_Center	 ; Center this Thwomp and don't come back!


ObjNorm_ThwompVertical:
	JSR Thwomp_Draw		; Draw Thwomp
	 
	LDA <Player_HaltGame
	BNE PRG004_A831	 ; If gameplay is halted, jump to PRG004_A831 (RTS)

	JSR Object_DeleteOffScreen_N2	 ; Delete if Thwomp falls off-screen
	JSR Player_HitEnemy	 ; Do Player to Thwomp collision

	LDA <Objects_Var5,X	 ; Var5 is internal state
	AND #$03	 	; Limit 0-3

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word ThwompVert_Reverse
	.word ThwompVert_Slide
	.word ThwompVert_Reverse
	.word ThwompVert_Slide

ThwompVert_Reverse:
	LDA Objects_Timer,X
	BNE PRG004_A81E	 ; If timer not expired, jump to PRG004_A81E (RTS)

	; Thwomp turns around...

	; Negate X velocity
	LDA <Objects_XVel,X
	JSR Negate
	STA <Objects_XVel,X

	; Negate Y velocity
	LDA <Objects_YVel,X
	JSR Negate
	STA <Objects_YVel,X

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Set timer to $80
	LDA #$80
	STA Objects_Timer,X

PRG004_A81E:
	RTS		 ; Return

ThwompVert_Slide:
	LDA Objects_Timer,X
	BNE PRG004_A82B	 ; If timer not expired, jump to PRG004_A82B

	INC <Objects_Var5,X	 ; Var5++

	; Set timer to $3C
	LDA #$3c
	STA Objects_Timer,X

PRG004_A82B:
	JSR Object_ApplyXVel	 	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity

PRG004_A831:
	RTS		 ; Return

OrangeCheep_Accel:	.byte $01, $FF
OrangeCheep_Limit:	.byte $10, $F0

ObjNorm_OrangeCheep:

	; ########################################
	; ##################          ############
	; ############      LLLLLLLLLLLL##########
	; ############      LLLLLLLLLLLL##########
	; ##########  LLLLLLLLLLLL      LL  ######
	; ##########LLLLLLLLLLLL                ##
	; ##        LLLLLLLLLLLL      ##  ##    ##
	;             LLLLLLLLLL      ##  ##    ##
	;             LLLLLLLLLL      ##  ##    ##
	;               LLLLLLLL                ##
	; ##            LLLLLLLLLL      LL  ######
	; ########LLLLLLLLLLLLLLLLLLLL##        ##
	; ##  LLLLLLLLLLLLLLLLLLLL####    ########
	; ##  LLLLLLLLLLLLLLLLLLLL####    ########
	; ##  LLLLLLLLLLLLLLLL  ##      ##########
	; ##      LLLLLL        ##      ##########
	; ##      ##LL            ####      ######
	; ##############              ############
	; ##############              ############
	; ########################################

	; The lost Orange Cheep...

	LDA <Player_HaltGame
	BNE PRG004_A870	 ; If gameplay is halted, jump to PRG004_A870

	LDA #$10	; A = $10

	LDY Objects_FlipBits,X
	BNE PRG004_A843	 ; If Orange Cheep is flipped, jump to PRG004_A843

	LDA #-$10	 ; A = -$10

PRG004_A843:
	STA <Objects_XVel,X	 ; Set proper X velocity

	JSR Object_SetPaletteFromAttr	 ; Set Orange Cheep's palette
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	INC <Objects_Var5,X	 ; Var5++

	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

	LDA <Objects_Var5,X
	AND #$01
	BNE PRG004_A86D	 ; Every other tick, jump to PRG004_A86D

	LDA <Objects_Var4,X
	AND #$01
	TAY		 ; Y = 0 or 1 (vertical direction)

	; Accelerate!
	LDA <Objects_YVel,X
	ADD OrangeCheep_Accel,Y
	STA <Objects_YVel,X

	CMP OrangeCheep_Limit,Y
	BNE PRG004_A86D	 ; If Orange Cheep is not at his limit, jump to PRG004_A86D

	INC <Objects_Var4,X	 ; Change direction

PRG004_A86D: 
	JSR Player_HitEnemy	 ; Do Player to Orange Cheep collision detection

PRG004_A870:

	; Toggle frame 0/1
	LDA <Objects_Var5,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR Object_FlipByXVel	 ; Flip based on horizontal travel direction
	JMP GroundTroop_DrawNormal	 ; Draw and don't come back!

ObjInit_FireBro:

	; Var6 = random value
	LDA RandomN,X
	STA Objects_Var6,X

	; Var7 = $90
	LDA #$90
	STA Objects_Var7,X

ObjInit_OrangeCheep:
	RTS		 ; Return

FireBro_FacePlayerFlip:	.byte SPR_HFLIP, $00

ObjNorm_FireBro: 
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	JSR Level_ObjCalcXDiffs

	; Fire Bro faces Player
	LDA FireBro_FacePlayerFlip,Y
	STA Objects_FlipBits,X

	INC Objects_Var7,X	; Var7++

	LDA Objects_Var7,X
	CMP #$a0
	BNE PRG004_A8B9	 ; If Var7 <> $A0, jump to PRG004_A8B9

	; Var7 = $A0...

	; Reset Var7	
	LDA #$00
	STA Objects_Var7,X

	LDA #$50	 ; A = $50

	LDY RandomN,X
	BPL PRG004_A8B2	 ; 50/50 chance we jump toPRG004_A8B2

	LDA #$30	 ; A = $30

PRG004_A8B2:
	STA Objects_Timer,X	 ; Set timer

	; X Velocity = 0
	LDA #$00
	STA <Objects_XVel,X

PRG004_A8B9:
	LDY #$00	 ; Y = 0

	LDA Objects_Var3,X
	AND #$08
	BEQ PRG004_A8C3	 ; 8 ticks on, 8 ticks off; jump to PRG004_A8C3

	INY		 ; Y = 1

PRG004_A8C3:
	LDA Objects_Timer,X
	BEQ PRG004_A8DD	 ; If timer expired, jump to PRG004_A8DD

	CMP #$20
	BNE PRG004_A8DB	 ; If timer <> $20, jump to PRG004_A8DB

	; Timer = $20...

	LDA RandomN,X
	BMI PRG004_A8DB	 ; 50/50 chance we jump to PRG004_A8DB

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_A8DB	 ; If Fire Bro has not hit floor, jump to PRG004_A8DB

	; Jump!
	LDA #-$38
	STA <Objects_YVel,X

PRG004_A8DB:
	LDY #$02	 ; Y = 2

PRG004_A8DD:
	TYA	
	STA Objects_Frame,X	 ; Set frame 0 to 2

	LDA <Objects_Y,X
	PHA		 ; Save Object Y

	ADD #$08
	STA <Objects_Y,X	 ; Object Y += 8

	LDA <Objects_YHi,X
	PHA		 ; Save Object Y Hi

	ADC #$00
	STA <Objects_YHi,X	 ; Apply carry

	JSR Object_Draw16x32Sprite	 ; Draw sprite

	; Restore Y/Hi
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	JSR Object_CalcSpriteXY_NoHi

	LDA <Player_HaltGame
	BNE PRG004_A92C	 ; If gameplay is halted, jump to PRG004_A92C (RTS)

	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath

	LDA Objects_Timer,X
	CMP #$40
	BGE PRG004_A913	 ; If timer >= $40, jump to PRG004_A913

	AND #$1f
	CMP #$0f
	BNE PRG004_A913	 ; Periodically jump to PRG004_A913

	JSR FireBro_SpitFire	 ; Spit fire at Player

PRG004_A913:
	LDA Objects_Timer,X
	BNE PRG004_A91C

	LDA <Objects_Var5,X
	BEQ PRG004_A92D	 ; If Var5 = 0, jump to PRG004_A92D

PRG004_A91C:
	JSR Object_Move	 ; Do standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_A92C	 ; If Fire Bro hasn't hit floor, jump PRG004_A92C (RTS)

	; Var5 = 0
	LDA #$00
	STA <Objects_Var5,X

	JSR Object_HitGround	 ; Align to floor

PRG004_A92C:
	RTS		 ; Return


PRG004_A92D:
	LDA Objects_Var1,X
	BEQ PRG004_A935	 ; If Var1 = 0, jump to PRG004_A935

	DEC Objects_Var1,X	 ; Var1--

PRG004_A935:
	INC Objects_Var6,X	 ; Var6++

	LDA Objects_Var6,X
	AND #$1f
	BNE PRG004_A957	 ; 1:32 ticks proceed, otherwise jump to PRG004_A957

	LDA RandomN,X
	AND #$01
	BNE PRG004_A957	 ; 50/50 chance we jump to PRG004_A957

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_A957	 ; If Fire Bro has not hit floor, jump to PRG004_A957

	INC <Objects_Var5,X	 ; Var5++

	; Fire Bro jumps!
	LDA #-$28
	STA <Objects_YVel,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG004_A957:
	LDA <Objects_Var4,X
	AND #$03	 ; Var4 masked 0-3, internal state

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word FireBro_WalkLeft
	.word FireBro_WaitState
	.word FireBro_WalkRight
	.word FireBro_WaitState

FireBro_WalkLeft:
	LDA Objects_Var1,X
	BNE PRG004_A972	 ; If Var1 <> 0, jump to PRG004_A972

	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	; Var1 = $10
	LDA #$10
	STA Objects_Var1,X

PRG004_A972:

	; X Velocity = -$08 (walk left)
	LDA #-$08
	STA <Objects_XVel,X

	JMP PRG004_A998	 ; Jump to PRG004_A998

FireBro_WaitState:
	LDA Objects_Var1,X	 
	BNE PRG004_A985	 ; If Var1 <> 0, jump to PRG004_A985

	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	; Var1 = $20
	LDA #$20
	STA Objects_Var1,X

PRG004_A985:
	JMP PRG004_A9B1	 ; Jump to PRG004_A9B1

FireBro_WalkRight:
	LDA Objects_Var1,X	 
	BNE PRG004_A994	 ; If Var1 <> 0, jump to PRG004_A994

	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	; Var1 = $10
	LDA #$10
	STA Objects_Var1,X

PRG004_A994:

	; X Velocity = $08 (walk right)
	LDA #$08
	STA <Objects_XVel,X

PRG004_A998:
	LDA Objects_Var1,X
	AND #$3f
	BNE PRG004_A9B1	 ; 1:64 ticks proceed, otherwise jump to PRG004_A9B1

	LDA Objects_Var1,X
	AND #$40

	; Something removed...
	NOP
	NOP
	NOP

	ASL A
	ASL A
	LDA #-$20	 ; A = -$20

	BCC PRG004_A9AF	 ; 64 ticks on, 64 ticks off; jump to PRG004_A9AF

	LDA #-$28	 ; A = -$28

PRG004_A9AF:
	STA <Objects_YVel,X	 ; Set jump velocity

PRG004_A9B1:
	JSR Object_Move	 ; Do standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_A9C0	 ; If Fire Bro has not hit floor, jump to PRG004_A9C0

	INC Objects_Var3,X	 ; Var3++

	JSR Object_HitGround	 ; Align to ground

PRG004_A9C0:
	RTS		 ; Return

FireBro_FireballXVel:	.byte $20, -$20

FireBro_SpitFire:
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot or don't come back

	; Fireball sound!
	LDA Sound_QPlayer
	ORA #SND_PLAYERFIRE
	STA Sound_QPlayer

	; Fireball at X + 4
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Fireball at Y + 3
	LDA <Objects_Y,X
	ADD #$03
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Fireball Y Vel
	LDA #$20
	STA SpecialObj_YVel,Y

	STY <Temp_Var1		 ; Special object slot index -> Temp_Var1

	JSR Level_ObjCalcXDiffs

	; Spit fire towards Player!
	LDA FireBro_FireballXVel,Y
	LDY <Temp_Var1		; Y = special object slot
	STA SpecialObj_XVel,Y

	; Fire bro bouncing fireball
	LDA #SOBJ_FIREBROFIREBALL
	STA SpecialObj_ID,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,Y

	RTS		 ; Return

ObjInit_HeavyBro:
	INC Objects_IsGiant,X	 ; Flag as giant
	RTS		 ; Return


HeavyBro_FacePlayerFlip:	.byte SPR_HFLIP, $00

ObjNorm_HeavyBro:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG004_AA12	 ; If Heavy Bro's state is Normal, jump to PRG004_AA12

	JMP HeavyBro_Draw	 ; Draw Heavy Bro and don't come back!

PRG004_AA12:
	LDA Objects_Timer2,X
	BEQ PRG004_AA2F	 ; If timer2 is expired, jump to PRG004_AA2F

	; Timer2 not expired...

	LDA <Player_InAir
	BNE PRG004_AA2F	 ; If Player is in the air, jump to PRG004_AA2F

	; Heavy Bro STOMP

	INC <Player_InAir ; Flag Player as in the air ...

	; "Vibrationally disable" Player
	LDA #$20
	STA Player_VibeDisable

	; Bounce Player a little
	LDA #-$10
	STA <Player_YVel

	DEC <Player_Y	 ; Player_Y--

	LDY <Player_Y	; Y = Player_Y
	INY		; Reset the Y back to where it was
	BNE PRG004_AA2F	; If the Player's Y low was not zero, we have nothing to worry about; jump to PRG004_AA2F

	DEC <Player_YHi	 ; Otherwise, we essentially have a carry (but DEC doesn't set carry)

PRG004_AA2F:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	JSR Level_ObjCalcXDiffs

	; Flip Heavy Bro towards Player
	LDA HeavyBro_FacePlayerFlip,Y
	STA Objects_FlipBits,X

	TXA
	ASL A
	ASL A
	ASL A	; This just applies a little effect from the object's index to keep things interesting
	ADC Level_NoStopCnt
	AND #$3f
	ORA Objects_Timer,X
	BNE PRG004_AA51	 ; Basically every 64 ticks or an expired timer proceed; otherwise, jump to PRG004_AA51

	; Reset timer to $10
	LDA #$10
	STA Objects_Timer,X

	JSR HammerBro_ThrowHammer	 ; Throw hammer!

PRG004_AA51:
	LDY #$00	 ; Y = 0

	LDA Objects_Var3,X
	AND #$10
	BEQ PRG004_AA5B	 ; Every 16 ticks of Var3 proceed, otherwise jump to PRG004_AA5B

	INY		 ; Y = 1

PRG004_AA5B:
	LDA Objects_Timer,X
	BEQ PRG004_AA62	 ; If timer expired, jump to PRG004_AA62

	; Otherwise, Y = 2 or 3 (arm up for hammer toss, although the draw routine doesn't actually use this, it checks timer instead)
	INY
	INY

PRG004_AA62:
	TYA
	STA Objects_Frame,X	 ; Set frame appropriately

	JSR HeavyBro_Draw	 ; Draw the Heavy Bro

	LDA <Player_HaltGame
	BNE PRG004_AABE	 ; If gameplay is halted, jump to PRG004_AABE

	LDA <Objects_Var5,X
	BEQ PRG004_AABF	 ; If Var5 = 0, jump to PRG004_AABF

	JSR Object_ApplyXVel	 	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity
	JSR Object_WorldDetectN1	 ; Detect against world
	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath

	LDA <Objects_YVel,X
	BMI PRG004_AA87	 ; If Heavy Bro is moving upward, jump to PRG004_AA87

	CMP #$70
	BGE PRG004_AA9B	 ; If Heavy Bro is falling >= $70, jump to PRG004_AA9B
	BLT PRG004_AA8C	 ; Otherwise, jump to PRG004_AA8C

PRG004_AA87:
	NEG	; Get absolute value of Y velocity

PRG004_AA8C:
	LSR A
	LSR A		 ; Divide by 4

	LDY <Objects_YVel,X
	BPL PRG004_AA94	 ; If Heavy Bro is not moving downward, jump to PRG004_AA94

	LSR A
	LSR A		 ; Divide by 4

PRG004_AA94:
	ADD #$01
	ADC <Objects_YVel,X	; Add a fraction of the absolute value of the Y velocity
	STA <Objects_YVel,X	; Set new Y velocity

PRG004_AA9B:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_AABE	 ; If Heavy Bro has not hit ground, jump to PRG004_AABE (RTS)

	; Var5 = 0
	LDA #$00
	STA <Objects_Var5,X

	; Vibrate level!
	LDA #$0c
	STA Level_Vibration

	; Ba-boom! sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	JSR Object_HitGround	 ; Align to floor

	LDA <Player_InAir
	BNE PRG004_AABE	 ; If Player is in air, jump to PRG004_AABE (RTS)

	; Timer2 = $40
	LDA #$40
	STA Objects_Timer2,X

PRG004_AABE:
	RTS		 ; Return


PRG004_AABF:
	LDA Objects_Var1,X
	BEQ PRG004_AAC7	 ; If Var1 = 0, jump to PRG004_AAC7

	DEC Objects_Var1,X	 ; Otherwise, Var1--

PRG004_AAC7:
	TXA
	ASL A
	ASL A
	ASL A
	ASL A	; This just applies a little effect from the object's index to keep things interesting
	ADC Level_NoStopCnt
	AND #$7f
	BNE PRG004_AAE5	 ; Basically, proceed every 127 ticks, otherwise jump to PRG004_AAE5

	LDA RandomN,X
	AND #$03
	BEQ PRG004_AAE5	 ; 1:4 Chance we jump to PRG004_AAE5

	INC <Objects_Var5,X	 ; Var5++

	; Jump!!
	LDA #-$58
	STA <Objects_YVel,X

	; Stop horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG004_AAE5:
	LDA <Objects_Var4,X
	AND #$03	 ; Var4 masked 0-3, internal state

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word HeavyBro_WalkLeft
	.word HeavyBro_WaitState
	.word HeavyBro_WalkRight
	.word HeavyBro_WaitState

HeavyBro_WalkLeft:
	LDA Objects_Var1,X	 
	BNE PRG004_AB00		; If Var1 <> 0, jump to PRG004_AB00

	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	; Var1 = $20
	LDA #$20
	STA Objects_Var1,X

PRG004_AB00:

	; X Velocity = -$04 (walk left)
	LDA #-$04
	STA <Objects_XVel,X

	JMP PRG004_AB29	 ; Jump to PRG004_AB29

HeavyBro_WaitState:
	LDA Objects_Var1,X	 
	BNE PRG004_AB13	 ; If Var1 <> 0, jump to PRG004_AB13

	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	; Var1 = $40
	LDA #$40
	STA Objects_Var1,X

PRG004_AB13:
	JSR Object_WorldDetectN1	 ; Detect against world
	JMP Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath and don't come back!

HeavyBro_WalkRight:
	LDA Objects_Var1,X	 
	BNE PRG004_AB25	 ; If Var1 <> 0, jump to PRG004_AB25

	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	; Var1 = $20
	LDA #$20
	STA Objects_Var1,X

PRG004_AB25:
	; X Velocity = $04 (walk right)
	LDA #$04
	STA <Objects_XVel,X

PRG004_AB29:
	JSR Object_Move	 ; Do standard movements
	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_AB3B	 ; If Heavy Bro has not hit ground, jump to PRG004_AB3B (RTS)

	INC Objects_Var3,X	 ; Var3++

	JSR Object_HitGround	 ; Align to ground

PRG004_AB3B:
	RTS		 ; Return

Giant_HVisBit:	.byte $20, $80	; Not horizontally flipped, horizontally flipped
Giant_HXOff:	.byte $10, $00	; Not horizontally flipped, horizontally flipped


HeavyBro_Draw:

	; Save Heavy Bro's X/Hi
	LDA <Objects_X,X
	PHA
	LDA <Objects_XHi,X
	PHA

	LDA Objects_SprHVis,X
	STA Temp_VarNP0	

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG004_AB63	 ; If Heavy Bro is not horizontally flipped, jump to PRG004_AB63

	ASL Objects_SprHVis,X

	; X += 8
	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X
	LDA <Objects_XHi,X
	ADC #$00
	STA <Objects_XHi,X

PRG004_AB63:
	JSR Object_Draw16x32Sprite	 ; Draw most of Heavy Bro

	; Restore X/Hi
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	JSR Object_CalcSpriteXY_NoHi

	LDY #$00	 ; Y = 0

	LDA Objects_FlipBits,X	
	AND #SPR_HFLIP
	BEQ PRG004_AB79	 ; If Heavy Bro is not horizontally flipped, jump to PRG004_AB79

	INY		 ; Y = 1

PRG004_AB79:
	LDA Temp_VarNP0
	AND Giant_HVisBit,Y
	BNE PRG004_ABE3	 ; If this sprite isn't visible, jump to PRG004_ABE3 (RTS)

	; Temp_Var2 = Sprite X
	LDA <Objects_SpriteX,X
	ADD Giant_HXOff,Y
	STA <Temp_Var2

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Set Sprite Xs
	LDA <Temp_Var2
	STA Sprite_RAM+$13,Y
	STA Sprite_RAM+$17,Y

	; Vertical visibility bits -> Temp_Var1
	LDA Objects_SprVVis,X
	STA <Temp_Var1

	LDA <Objects_SpriteY,X
	LSR <Temp_Var1
	BCS PRG004_ABA2	 ; If this sprite is vertically off-screen, jump to PRG004_ABA2

	STA Sprite_RAM+$10,Y	 ; Otherwise, set Sprite Y

PRG004_ABA2:
	LSR <Temp_Var1
	BCS PRG004_ABAC	 ; If this sprite is vertically off-screen, jump to PRG004_ABAC

	ADD #16		; +16 for lower sprite
	STA Sprite_RAM+$14,Y	 ; Set lower sprite Y

PRG004_ABAC:

	; Copy attributes
	LDA Sprite_RAM+$02,Y
	STA Sprite_RAM+$12,Y
	STA Sprite_RAM+$16,Y

	LDA #$00
	CMP Objects_Timer,X

	LDA #$9f	; A = $9F

	BGE PRG004_ABC0	 ; If timer is not expired, jump to PRG004_ABC0

	LDA #$95	; A = $95

PRG004_ABC0:
	STA Sprite_RAM+$11,Y	 ; Set appropriate upper sprite pattern

	LDA Objects_Frame,X
	LSR A	

	LDA #$9b	 ; A = $9B

	BCS PRG004_ABCD	 ; If frame 1, jump to PRG004_ABCD

	LDA #$ad	 ; A = $AD

PRG004_ABCD:
	STA Sprite_RAM+$15,Y	 ; Set appropriate lower sprite pattern

	LDA Objects_FlipBits,X
	BPL PRG004_ABE3	 ; If Heavy Bro isn't vertically flipped, jump to PRG004_ABE3

	; Otherwise, swap upper and lower sprites
	LDA Sprite_RAM+$10,Y
	PHA
	LDA Sprite_RAM+$14,Y
	STA Sprite_RAM+$10,Y
	PLA
	STA Sprite_RAM+$14,Y

PRG004_ABE3:
	RTS		 ; Return

SpinyEggDud_FlipTowardsPlayer:	.byte SPR_HFLIP, $00

ObjNorm_SpinyEggDud:
	LDA <Player_HaltGame
	BNE PRG004_AC53	 ; If gameplay is halted, jump to PRG004_AC53

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG004_AC53	 ; If Spiny Egg Dud is not in state Normal, jump to PRG004_AC53

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA Objects_InWater,X
	PHA		 ; Push "in water" flag

	JSR Object_Move	 ; Do standard movements

	PLA		 ; Pull "in water" flag...
	BNE PRG004_AC08	 ; If was in water before, jump to PRG004_AC08

	LDA Objects_InWater,X
	BEQ PRG004_AC08	 ; If not in water now, jump to PRG004_AC08

	; Otherwise, arithmetically shift X velocity to the right (signed divide by two)
	LDA <Objects_XVel,X
	ASL A
	ROR <Objects_XVel,X

PRG004_AC08:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG004_AC11	 ; If Spiny Egg Dud did not hit a wall, jump to PRG004_AC11

	JSR Object_AboutFace	 ; Otherwise, turn around

PRG004_AC11:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_AC43	 ; If Spiny Egg Dud has not hit floor, jump to PRG004_AC43

	LDA <Objects_YVel,X
	PHA		 ; Save Y velocity

	JSR Object_HitGround	 ; Align to ground

	PLA		 ; Restore Y velocity
	CMP #$10
	BLS PRG004_AC38	 ; If Y velocity < $10, jump to PRG004_AC38

	LSR A		 ; Divide by 2

	; Something removed...
	NOP
	NOP

	NEG			; Negate (bounce)
	STA <Objects_YVel,X	 ; Set as Y velocity

	JSR Level_ObjCalcXDiffs

	; Set towards Player
	LDA SpinyEggDud_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	JMP PRG004_AC43	; Jump to PRG004_AC43

PRG004_AC38:

	; Set velocity based on facing direction of egg
	LDA #$0c
	LDY Objects_FlipBits,X
	BNE PRG004_AC41
	LDA #-$0C
PRG004_AC41:
	STA <Objects_XVel,X

PRG004_AC43:
	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG004_AC4D	 ; If egg has not hit ceiling, jump to PRG004_AC4D

	; Bounce off ceiling
	LDA #$10
	STA <Objects_YVel,X

PRG004_AC4D:
	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath
	JSR GroundTroop_BumpOffOthers	 ; Bounce off other objects

PRG004_AC53:
	LDY #$00	 ; Y = 0

	LDA Level_NoStopCnt
	AND #$08
	BEQ PRG004_AC5D	 ; 8 ticks on, 8 ticks off; jump to PRG004_AC5D

	INY		 ; Y = 1

PRG004_AC5D:
	TYA
	STA Objects_Frame,X	; Toggle frame 0/1

	JSR GroundTroop_DrawMirrored	 ; Draw Spiny Egg Dud

	; Anything but vertical flip
	LDA Sprite_RAM+$02,Y
	AND #~SPR_VFLIP
	STA Sprite_RAM+$02,Y

	; V+H flip
	ORA #$c0
	STA Sprite_RAM+$06,Y

	RTS		 ; Return

SpinyEgg_HatchFacePlayerFlip:	.byte SPR_HFLIP, $00

ObjNorm_SpinyEgg:
	LDA <Player_HaltGame
	BNE PRG004_ACCF	 ; If gameplay is halted, jump to PRG004_ACCF

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	; Toggle frame 0/1
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	LDA Objects_InWater,X
	BEQ PRG004_AC99	 ; If egg is not in water, jump to PRG004_AC99

	; In water...

	LDA <Objects_XVel,X
	PHA		 ; Save X velocity

	ASL A		 ; Pushes sign bit into carry
	ROR <Objects_XVel,X	 ; Arithmetically shift to the right (signed divide by 2)
	JSR Object_Move	 ; Do movement

	PLA
	STA <Objects_XVel,X	 ; Restore X velocity

	JMP PRG004_ACAC	 ; Jump to PRG004_ACAC

PRG004_AC99:

	; Not in water...

	LDA <Objects_YVel,X
	CMP #$30
	BGS PRG004_ACA3	 ; If Y Velocity >= $30, jump to PRG004_ACA3

	; Otherwise, increase rate of fall 
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG004_ACA3:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_WorldDetect4	 ; Detect against world

PRG004_ACAC:
	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped underneath

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_ACCF	 ; If spiny egg not hit ground, jump to PRG004_ACCF

	; When egg hits ground, hatch into Spiny
	LDA #OBJ_SPINY
	STA Level_ObjectID,X

	JSR Level_ObjCalcXDiffs

	; Face Player
	LDA SpinyEgg_HatchFacePlayerFlip,Y
	STA Objects_FlipBits,X

	JSR Object_HitGround	 ; Align to ground

	LDA Objects_InWater,X
	BNE PRG004_ACCF	 ; If Spiny is not in water, jump to PRG004_ACCF

	; Otherwise, slowly fall into water
	LDA #-$0E
	STA <Objects_YVel,X

PRG004_ACCF:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG004_ACD8	 ; If Spiny did not hit wall, jump to PRG004_ACD8

	JSR Object_AboutFace	 ; Otherwise, turn around

PRG004_ACD8:
	JSR GroundTroop_DrawMirrored	 ; Draw Spiny Egg

	; Vertically flip right hand sprite
	LDA Sprite_RAM+$06,Y
	ORA #SPR_VFLIP
	STA Sprite_RAM+$06,Y

	RTS		 ; Return

ObjInit_Lakitu:

	; Lakitu_Active = 1
	LDA #$01
	STA Lakitu_Active

	; Using Objects_TargetingYVal and Objects_TargetingXVal as original Y/Hi
	; Wish these guys could have been more consistent sometimes...
	LDA <Objects_Y,X
	STA Objects_TargetingYVal,X
	LDA <Objects_YHi,X
	STA Objects_TargetingXVal,X

	RTS		 ; Return


Lakitu_XVelAccel:	.byte $01, -$01
Lakitu_XVelLimit:	.byte $20, -$20

Lakitu_YOff:	.byte -15, -14, -15, -16

ObjNorm_Lakitu:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG004_AD59	 ; If Lakitu is in state Normal, jump to PRG004_AD59

	; Not normal state...


	; Vertical flip
	LDA Objects_FlipBits,X
	ORA #SPR_VFLIP
	STA Objects_FlipBits,X

	JSR Object_DrawTallAndHFlip	 ; Draw Lakitu

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Flip Lakitu himself vertically
	LDA #$83
	STA Sprite_RAM+$0A,Y
	LDA #$c3
	STA Sprite_RAM+$0E,Y

	LDA <Player_HaltGame
	BNE PRG004_AD58	 ; If gameplay is halted, jump to PRG004_AD58 (RTS)

	JSR Object_Move	 ; Do standard movement

	LDA Objects_InWater,X
	BNE PRG004_AD29	 ; If Lakitu is in water, jump to PRG004_AD29

	DEC <Objects_YVel,X	 ; YVel--

PRG004_AD29:
	LDA <Objects_YHi,X
	CMP #$02
	BLS PRG004_AD58	 ; If Lakitu is not too low yet, jump to PRG004_AD58 (RTS)

	; At this point, Lakitu has fallen off-screen...

	; Set Lakitu's X equal to two screens behind
	LDA <Horz_Scroll
	SUB #$00
	STA <Objects_X,X
	LDA <Horz_Scroll_Hi
	SBC #$02	; Two screens back
	STA <Objects_XHi,X

	; Reset Lakitu's state to Normal
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA Objects_TargetingYVal,X
	PHA		 ; Save Lakitu's original Y
	STA <Objects_Y,X	; Restore Lakitu to original Y

	LDA Objects_TargetingXVal,X
	PHA		 ; Save Lakitu's original Y Hi
	STA <Objects_YHi,X	 ; Restore Lakitu's Y Hi

	; Reset Lakitu
	JSR Level_PrepareNewObject

	; Restore the Y/Hi values
	PLA
	STA Objects_TargetingXVal,X
	PLA
	STA Objects_TargetingYVal,X

PRG004_AD58:
	RTS		 ; Return

PRG004_AD59:

	; Lakitu normal operation...

	LDA <Player_HaltGame
	BNE PRG004_ADC2	 ; If gameplay is halted, jump to PRG004_ADC2

	LDA Lakitu_Active
	BNE PRG004_AD65	 ; If Lakitu is active, jump to PRG004_AD65

	JSR Object_DeleteOffScreen	 ; Lakitu is leaving...

PRG004_AD65:
	JSR Player_HitEnemy	 ; Do Player to Lakitu collision

	JSR Level_ObjCalcXDiffs

	LDA Lakitu_Active
	BNE PRG004_AD74	 ; If Lakitu is active, jump to PRG004_AD74

	; Lakitu exists but has been marked inactive (by special event object) so he must flee Player

	; Invert bit 0 of the difference (make Lakitu flee the Player!)
	TYA
	EOR #$01
	TAY

PRG004_AD74:
	STY <Objects_Var5,X	 ; -> Var5

	INC Objects_Var3,X	 ; Var3++

	LDA Objects_Var3,X
	AND #$01
	BNE PRG004_AD8D	 ; Every other tick, jump to PRG004_AD8D

	LDA <Objects_XVel,X
	CMP Lakitu_XVelLimit,Y
	BEQ PRG004_AD8D	 ; If Lakitu is at X Velocity limit, jump to PRG004_AD8D

	; Acclerate
	ADD Lakitu_XVelAccel,Y
	STA <Objects_XVel,X

PRG004_AD8D:
	LDA #$7f	 ; A = $7F

	LDY Level_SlopeEn
	BNE PRG004_AD96	 ; If this is a sloped level, jump to PRG004_AD96

	LDA #$3f	 ; A = $3F

PRG004_AD96:
	AND Objects_Var3,X
	BNE PRG004_ADA5	 

	LDA Lakitu_Active
	BEQ PRG004_ADA5	 ; If Lakitu_Active is not set, jump to PRG004_ADA5

	; Set timer to $1F
	LDA #$1f
	STA Objects_Timer,X

PRG004_ADA5:
	LDY Objects_Timer,X
	DEY		 ; Y--
	BNE PRG004_ADAE	 ; If timer > 1, jump to PRG004_ADAE

	JSR Lakitu_TossEnemy	 ; Toss enemy

PRG004_ADAE:
	LDA <Objects_XVel,X
	PHA		 ; Save Lakitu X Velocity

	; Move Lakitu along with the screen
	LDA Level_ScrollDiffH
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	ADC <Objects_XVel,X
	STA <Objects_XVel,X

	JSR Object_ApplyXVel	 ; Apply X Velocity

	PLA		 
	STA <Objects_XVel,X	; Restore Lakitu X Vloeicty

PRG004_ADC2:
	JSR GroundTroop_DrawMirrored	 ; Draw's Lakitu's cloud

	; Temp_Var1 = $F6
	LDA #$f6
	STA <Temp_Var1

	LDA Objects_Timer,X
	BEQ PRG004_ADE1	 ; If timer expired, jump to PRG004_ADE1

	CMP #16
	BLT PRG004_ADF1	 ; If timer < 16 ticks, jump to PRG004_ADF1

	; Timer >= $10 ticks remaining...

	SBC #16		; Subtract 16 ticks
	LSR A		; Divide by 2
	EOR #%00000111	; Flip the lowest 3 bits 
	ADD #$01	; +1
	SBC #16		; Subtract 16 again
	STA <Temp_Var1	; -> Temp_Var1

	JMP PRG004_ADF1	 ; Jump to PRG004_ADF1

PRG004_ADE1:
	LDA Objects_Var3,X
	LSR A	
	LSR A	
	LSR A	
	AND #$03
	TAX		 ; X = 0 to 3 by Var3

	LDA Lakitu_YOff,X
	LDX <SlotIndexBackup	 ; X = object slot index
	STA <Temp_Var1		 ; Temp_Var1 = Lakitu's in-cloud Y offset

PRG004_ADF1:
	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG004_ADFE	 ; If this Lakitu cloud sprite is vertically off-screen, jump to PRG004_ADFE

	; Otherwise, set Lakitu's left sprite Y
	ADD <Temp_Var1
	STA Sprite_RAM+$08,Y

PRG004_ADFE:
	LDA Sprite_RAM+$04,Y
	CMP #$f8
	BEQ PRG004_AE0B	 ; If this Lakitu cloud sprite is vertically off-screen, jump to PRG004_AE0B

	; Otherwise, set Lakitu's right sprite Y
	ADD <Temp_Var1	
	STA Sprite_RAM+$0C,Y

PRG004_AE0B:
	; Copy Lakitu's Left Sprite X
	LDA Sprite_RAM+$03,Y
	STA Sprite_RAM+$0B,Y

	; Copy Lakitu's Right Sprite X
	LDA Sprite_RAM+$07,Y
	STA Sprite_RAM+$0F,Y

	; Lakitu's sprite patterns
	LDA #$9d
	STA Sprite_RAM+$09,Y
	STA Sprite_RAM+$0D,Y

	; Lakitu's left sprite attributes
	LDA #$03
	STA Sprite_RAM+$0A,Y

	; Lakitu's right sprite attributes
	LDA #$43
	STA Sprite_RAM+$0E,Y

	RTS		 ; Return

Lakitu_TossEnemy:
	LDY #$04	 ; Y = 4
PRG004_AE2C:
	LDA Objects_State,Y
	BEQ PRG004_AE35	 ; If this object slot is dead/empty, jump to PRG004_AE35

	DEY		 ; Y--
	BPL PRG004_AE2C	 ; While Y >= 0, loop

	RTS		 ; Return

PRG004_AE35:

	; Not really better than TYA, TAX is it?
	STY <Temp_Var1	 ; Temp_Var1 = the empty object slot index
	LDX <Temp_Var1	 ; X = empty object slot index

	JSR Level_PrepareNewObject	 ; Prepare new object

	LDX <SlotIndexBackup		 ; X = object slot index

	; Set object immediately to "Normal" state
	LDA #OBJSTATE_NORMAL
	STA Objects_State,Y

	; Set palette select 1
	LDA #SPR_PAL1
	STA Objects_SprAttr,Y

	LDA #$00
	CMP Level_SlopeEn

	; Non-sloped level uses Spiny Egg instead
	LDA #OBJ_SPINYEGG

	BGE PRG004_AE58	 ; If Level_SlopeEn >= 0 (i.e. a level with slopes), jump to PRG004_AE58

	; Sloped level uses Green "Dud" Egg
	LDA #$02
	STA Objects_SprAttr,Y

	LDA #OBJ_SPINYEGGDUD

PRG004_AE58:
	STA Level_ObjectID,Y	 ; Set appropriate drop object

	; Object appears at Lakitu Y - 12
	LDA <Objects_Y,X
	SBC #12
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA Objects_YHi,Y

	; Object appears same as Lakitu X
	LDA <Objects_X,X
	STA Objects_X,Y
	LDA <Objects_XHi,X
	STA Objects_XHi,Y

	; Set object Y velocity at -$30
	LDA #-$30
	STA Objects_YVel,Y

	LDA Level_ScrollDiffH
	ASL A
	ASL A
	ASL A
	STA <Temp_Var1	 ; Temp_Var1 = 4.4FP of the scroll difference divided by 2

	; Var5 is direction Lakitu is going
	LDA <Objects_Var5,X
	LSR A

	LDA #$10	; A = $10 (move right)

	BCC PRG004_AE89	; If carry not set, jump to PRG004_AE89

	LDA #-$10	; A = -$10 (move left)

PRG004_AE89:
	ADD <Temp_Var1	 ; Add the divided screen difference
	STA Objects_XVel,Y	 ; Set the object's X velocity

	RTS		 ; Return

ObjNorm_ParaGoomba:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA <Player_HaltGame
	BEQ PRG004_AE9A	 ; If gameplay is not halted, jump to PRG004_AE9A

	JMP ParaGoomba_Draw	 ; Jump to ParaGoomba_Draw

PRG004_AE9A:
	LDY #$08	 ; Y = $08

	LDA Objects_FlipBits,X
	BNE PRG004_AEA3	 ; If flipped, jump to PRG004_AEA3

	LDY #-$08	 ; Y = -$08

PRG004_AEA3:
	STY <Objects_XVel,X	; Update X Velocity

	JSR Object_Move	 	; Do standard movements

	DEC <Objects_YVel,X	; YVel--

	; Toggle frame 0/1
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

	JSR ParaGoomba_Draw	 ; Draw the winged Goomba

	INC <Objects_Var5,X	 ; Var5++

	LDA <Objects_Var4,X
	BNE PRG004_AEC7	 ; If Var4 <> 0, jump to PRG004_AEC7

	LDA <Objects_YVel,X
	BPL PRG004_AEC7	 ; If Paragoomba is not moving upward, jump to PRG004_AEC7

	; Var3 += 2
	INC Objects_Var3,X
	INC Objects_Var3,X

PRG004_AEC7:
	INC Objects_Var3,X	 ; Var3++

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG004_AED4	 ; If Paragoomba did NOT hit ceiling, jump to PRG004_AED4

	; Bounce off ceiling
	LDA #$01
	STA <Objects_YVel,X

PRG004_AED4:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_AF11	 ; If Paragoomba did NOT hit ground, jump to PRG004_AF11

	LDA <Objects_Var5,X
	AND #$3f
	BNE PRG004_AEE9	 ; 64 ticks on, 64 ticks off; jump to PRG004_AEE9

	JSR Level_ObjCalcXDiffs

	; Set flip towards Player
	LDA GroundTroop_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

PRG004_AEE9:
	JSR Object_HitGround	 ; Align to floor

	LDA <Objects_Var4,X
	BNE PRG004_AEF5	 ; If Var4 <> 0, jump to PRG004_AEF5

	; Var3 = 0
	LDA #$00
	STA Objects_Var3,X

PRG004_AEF5:
	LDA Objects_Timer,X
	BNE PRG004_AF11	 ; If timer not expired, jump to PRG004_AF11

	INC <Objects_Var4,X	; Var4++ (next internal state)

	LDY #-$10	; Y = -$10 (little hop)

	LDA <Objects_Var4,X
	CMP #$04
	BNE PRG004_AF0F	 ; If Var4 <> 4, jump to PRG004_AF0F

	; Var4 = 0
	LDA #$00
	STA <Objects_Var4,X

	; Timer set to $50
	LDA #$50
	STA Objects_Timer,X

	LDY #-$30	 ; Y = -$30 (big hop)

PRG004_AF0F:
	STY <Objects_YVel,X	 ; Set Y velocity appropriately

PRG004_AF11:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG004_AF1A	 ; If Paragoomba did not hit wall, jump to PRG004_AF1A

	JSR Object_FlipFace	 ; Turn around

PRG004_AF1A:
	JMP Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath

	RTS		 ; Return


ParaGoomba_Draw:
	JSR GroundTroop_DrawMirrored	 ; Draw mirrored goomba enemy

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Left wing
	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG004_AF31	 ; If this sprite is vertically off-screen, jump to PRG004_AF31

	SUB #10
	STA Sprite_RAM+$08,Y

PRG004_AF31:

	; Right wing
	LDA Sprite_RAM+$04,Y
	CMP #$f8
	BEQ PRG004_AF3E	 ; If this sprite is vertically off-screen, jump to PRG004_AF3E

	SUB #10
	STA Sprite_RAM+$0C,Y

PRG004_AF3E:

	; Left wing sprite X
	LDA Sprite_RAM+$03,Y
	SUB #$02
	STA Sprite_RAM+$0B,Y

	; Right wing sprite X
	LDA Sprite_RAM+$07,Y
	ADD #$02
	STA Sprite_RAM+$0F,Y

	; Left wing attribute
	LDA #$42
	STA Sprite_RAM+$0A,Y

	; Right wing attribute
	LDA #$02
	STA Sprite_RAM+$0E,Y

	LDA Objects_Var3,X

	LDX #$cd	 ; X = $CD (Wing up pattern)
	AND #$08	 
	BNE PRG004_AF65	 ; 8 ticks on, 8 ticks off; jump to PRG004_AF65

	LDX #$cf	 ; X = $CF (Wing down pattern)

PRG004_AF65:
	TXA		 
	STA Sprite_RAM+$09,Y	 ; Store left wing pattern
	STA Sprite_RAM+$0D,Y	 ; Store right wing pattern

	LDX <SlotIndexBackup		 ; X = object slot index

	RTS		 ; Return

Paragoomba_XVelAccel:	.byte $01, -$01
Paragoomba_XVelLimit:	.byte $14, $EC

ObjNorm_ParaGoombaBomber:
	JSR Object_DeleteOffScreen	; Delete if off-screen

	LDA <Player_HaltGame
	BEQ PRG004_AF7D	 ; If gameplay is not halted, jump to PRG004_AF7D

	JMP ParaGoomba_Draw	 ; Draw Paragoomba and don't come back!

PRG004_AF7D:
	LDY LRBounce_Vel
	INY
	INY

	LDA PRG004_B34E,Y

	LDY #$00	 ; Y = 0

	AND <Objects_Var5,X
	BEQ PRG004_AF8C	 ; If mask results in zero, jump to PRG004_AF8C

	INY		 ; Y = 1

PRG004_AF8C:
	TYA		 
	STA Objects_Frame,X	 ; Set frame appropriately

	JSR ParaGoomba_Draw	 ; Draw Paragoomba
	JSR PRG004_AF1A	 ; (Indirectly) Handle getting bumped underneath

	LDA <Objects_Var4,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Paragoomba_FlutterDown		; 0: Paragoomba flutters down
	.word Paragoomba_FlyAbovePlayer		; 1: Fly above Player
	.word Paragoomba_DropMicrogoombas	; 2: Drop Micro goombas on Player

Paragoomba_FlutterDown:
	INC <Objects_Var5,X	 ; Var5++

	LDY #$08	 ; Y = $08

	LDA Objects_FlipBits,X
	BNE PRG004_AFAC	 ; If flipped, jump to PRG004_AFAC

	LDY #-$08	 ; Y = -$08

PRG004_AFAC:
	STY <Objects_XVel,X	 ; Set horizontal velocity

	JSR Object_Move	 ; Do standard movement

	; Fall slowly
	DEC <Objects_YVel,X
	DEC <Objects_YVel,X

	LDY #$08	 ; Y = 8

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG004_AFDC	 ; If Paragoomba has not hit floor, jump to PRG004_AFDC

	LDA <Objects_Var5,X
	AND #$3f
	BNE PRG004_AFCC	 ; 64 ticks on, 64 ticks off; jump to PRG004_AFCC

	JSR Level_ObjCalcXDiffs	

	; Set flip towards Player
	LDA GroundTroop_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

PRG004_AFCC:
	JSR Object_HitGround	 ; Align to floor

	LDY #$00	 ; Y = 0

	LDA Objects_Timer,X
	BEQ PRG004_AFE3	 ; If timer expired, jump to PRG004_AFE3

	CMP #$20
	BGE PRG004_AFDC	 ; If timer >= $20, jump to PRG004_AFDC

	LDY #$08	 ; Y = 8

PRG004_AFDC:
	TYA
	STA Objects_Var3,X	; Set Var3 to 0 or 8

	JMP PRG004_AFE5	 ; Jump to PRG004_AFE5

PRG004_AFE3:
	INC <Objects_Var4,X	 ; Var4++ (next internal state)

PRG004_AFE5:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG004_AFEE	 ; If Paragoomba did not hit wall, jump to PRG004_AFEE (RTS)

	JSR Object_FlipFace	 ; Turn around

PRG004_AFEE:
	RTS		 ; Return


Paragoomba_FlyAbovePlayer:

	; Var3 += 3
	INC Objects_Var3,X
	INC Objects_Var3,X
	INC Objects_Var3,X

	JSR Level_ObjCalcYDiffs

	CPY #$00
	BNE PRG004_B011	 ; If Player is higher than Paragoomba, jump to PRG004_B011

	LDA <Temp_Var16
	CMP #$38
	BLT PRG004_B011	 ; If Paragoomba is not sufficiently above Player, jump to PRG004_B011

	INC <Objects_YVel,X	 ; A little lower

	BNE PRG004_B015	 	; If Paragoomba hit zero, jump to PRG004_B015

	INC <Objects_Var4,X	; Var4++ (next internal state)

	; Set timer to $80
	LDA #$80
	STA Objects_Timer,X

	RTS		 ; Return

PRG004_B011:

	; Fly higher
	LDA #-$10
	STA <Objects_YVel,X

PRG004_B015:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	JMP PRG004_B046		; Jump to PRG004_B046

Paragoomba_DropMicrogoombas:
	LDY Objects_Timer,X
	BNE PRG004_B029	 ; If timer not expired, jump to PRG004_B029
 
	; Return to first internal state
	LDA #$00
	STA <Objects_Var4,X

	; Set timer to $80
	LDA #$80
	STA Objects_Timer,X

PRG004_B029:
	; Var3 += 2
	INC Objects_Var3,X
	INC Objects_Var3,X

	INC <Objects_Var5,X	 ; Var5++

	LDA <Objects_Var5,X
	AND #$1f
	BNE PRG004_B03A	 ; 1:32 ticks, proceed, otherwise jump to PRG004_B03A

	JSR Paragoomba_SpawnMicroGoomba	 ; Drop a Microgoomba

PRG004_B03A:
	LDY #$08	 ; Y = $08

	LDA <Objects_Var5,X
	AND #$10
	BEQ PRG004_B044	 ; 16 ticks on, 16 ticks off; jump to PRG004_B044

	LDY #-$08	 ; Y = -$08

PRG004_B044:
	STY <Objects_YVel,X	 ; Update Y velocity

PRG004_B046:
	LDY #$00	 ; Y = 0

	LDA Objects_FlipBits,X
	BNE PRG004_B04E	 ; If flipped, jump to PRG004_B04E

	INY		 ; Y = 1

PRG004_B04E:
	LDA <Objects_XVel,X
	CMP Paragoomba_XVelLimit,Y
	BEQ PRG004_B05B	 	; If Paragoomba is at his X velocity limit, jump to PRG004_B05B

	ADD Paragoomba_XVelAccel,Y
	STA <Objects_XVel,X	 ; Accelerate Paragoomba

PRG004_B05B:
	INC Objects_Var2,X	 ; Var2++

	LDA Objects_Var2,X
	AND #$3f
	BNE PRG004_B06E	 ; 1:64 ticks proceed, otherwise jump to PRG004_B06E

	JSR Level_ObjCalcXDiffs	

	; Move towards Player
	LDA GroundTroop_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

PRG004_B06E:
	JSR Object_ApplyXVel	 ; Apply X Velocity
	JMP Object_ApplyYVel_NoLimit	 ; Apply Y velocity and don't come back!

Paragoomba_SpawnMicroGoomba:
	LDY #$05	 ; Searching special object slots 0 - 5
	JSR SpecialObj_FindEmptyAbortY	 ; Find an open special object slot or don't come back

	; A microgoomba
	LDA #SOBJ_MICROGOOMBA
	STA SpecialObj_ID,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,Y

	; Microgoomba Y
	LDA <Objects_Y,X
	ADD #$04
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Microgoomba X
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Microgoomba X/YVel = 0
	LDA #$00
	STA SpecialObj_YVel,Y
	STA SpecialObj_XVel,Y

	RTS		 ; Return


ObjNorm_JumpingCheepCheep:
	JSR Object_SetPaletteFromAttr	 ; Set palette for Cheep Cheep

	LDA <Player_HaltGame
	BNE PRG004_B0BA	 ; If gameplay is halted, jump to PRG004_B0BA

	INC <Objects_Var5,X	 ; Var5++

	JSR Object_ApplyXVel	 	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity
	JSR Object_WorldDetectN1	; Detect against world

	INC <Objects_YVel,X	 ; YVel++

	JSR Player_HitEnemy	 ; Player to Cheep Cheep collision

PRG004_B0BA:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

PRG004_B0BD:
	LDA <Objects_Var5,X
	LSR A
	LSR A
	LSR A
	AND #$01	 ; A = 0 or 1

	LDY Objects_Var1,X
	BEQ PRG004_B0CC	 ; If Var1 = 0, jump to PRG004_B0CC

	ADD #$03	 ; A = 3 or 4

PRG004_B0CC:
	STA Objects_Frame,X	 ; Set object frame

	JSR Object_FlipByXVel	 ; Apply X velocity

	JMP GroundTroop_DrawNormal	 ; Draw and don't come back!

SpikeCheep_YAccel:	.byte $01, -$01
SpikeCheep_YLimit:	.byte $04, -$04

ObjNorm_SpikeCheep:
	LDA Objects_Var1,X
	BEQ PRG004_B0E5	 ; If Var1 = 0, jump to PRG004_B0E5

	; This is Spiny Cheep's graphics
	LDA #$1a
	STA PatTable_BankSel+4

	BNE PRG004_B0EA	 ; Jump (technically always) to PRG004_B0EA

PRG004_B0E5:

	; Not sure what this loads for?
	LDA #$4f
	STA PatTable_BankSel+5

PRG004_B0EA:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG004_B0FE	 ; If Spike Cheep's state is Normal, jump to PRG004_B0FE

	; Not normal state...

	LDA Objects_Var1,X
	BEQ PRG004_B0FB	 ; If Var1 = 0, jump to PRG004_B0FB

	; Frame = 5
	LDA #$05
	STA Objects_Frame,X

PRG004_B0FB:
	JMP GroundTroop_DrawNormal	 ; Draw Spiny Cheep

PRG004_B0FE:
	JSR Object_SetPaletteFromAttr	 ; Set Spike Cheep's palette

	LDA <Player_HaltGame
	BNE PRG004_B14D	 ; If gameplay is halted, jump to PRG004_B14D

	INC <Objects_Var5,X	 ; Var5++

	LDA <Counter_1
	AND #$07
	BNE PRG004_B121	 ; 1:8 ticks proceed, otherwise jump to PRG004_B121

	LDA <Objects_Var4,X
	AND #$01
	TAY		 ; Y = 0 or 1 (vertical direction)

	; Accelerate Y Velocity
	LDA <Objects_YVel,X
	ADD SpikeCheep_YAccel,Y
	STA <Objects_YVel,X

	CMP SpikeCheep_YLimit,Y
	BNE PRG004_B121	 ; If Spike Cheep is not at its Y velocity limit, jump to PRG004_B121

	INC <Objects_Var4,X	 ; Otherwise, Var4++ (reverses his vertical direction)

PRG004_B121:
	JSR Object_ApplyXVel	 	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity

	LDA Objects_Var1,X
	BNE PRG004_B14A	 ; If Var1 <> 0, jump to PRG004_B14A

	LDA <Objects_X,X
	CMP Objects_Var10,X
	BEQ PRG004_B141	 ; If Spike Cheep is at left limit, jump to PRG004_B141

	CMP Objects_Var11,X
	BEQ PRG004_B141	 ; If Spike Cheep is at right limit, jump to PRG004_B141

	JSR Object_WorldDetect4	 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG004_B14A	 ; If Spike Cheep did not hit wall, jump to PRG004_B14A

PRG004_B141:
	JSR Object_AboutFace	 ; Turn around
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyXVel	 ; Apply Y velocity

PRG004_B14A:
	JSR Player_HitEnemy	 ; Player to Spike Cheep collision check

PRG004_B14D:
	JSR Object_DeleteOffScreen_N4	 ; Delete if Spike Cheep goes off-screen
	JMP PRG004_B0BD	; Jump to PRG004_B0BD

BulletBill_XAccel:	.byte $01, -$01
BulletBill_XLimit:	.byte $18, -$18

BulletBill_FlipBits:	.byte SPR_HFLIP, $00

ObjNorm_BulletBill:
	LDA <Player_HaltGame
	BNE PRG004_B1C2	 ; If gameplay is halted, jump to PRG004_B1C2

	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JSR Player_HitEnemy	 	; Player to Bullet Bill collision
	JSR Object_ApplyXVel	 	; Apply X velocity

	LDA Level_ObjectID,X
	CMP #OBJ_BULLETBILLHOMING
	BNE PRG004_B1C2	 ; If this is NOT a homing Bullet Bill, jump to PRG004_B1C2

	; Homing Bullet Bill...

	; Color cycling
	LDA <Counter_1
	ORA #$f8
	STA Objects_ColorCycle,X

	; Palette select into attribute
	AND #$03
	STA Objects_SprAttr,X

	LDA Objects_Var3,X
	BEQ PRG004_B193	 ; If Var3 = 0, jump to PRG004_B193

	JSR Level_ObjCalcXDiffs	
	STY <Temp_Var1	 ; Store the difference value -> Temp_Var1

	LDY #$00	 ; Y = 0 (moving right)

	LDA <Objects_XVel,X
	BPL PRG004_B18A	 ; If Bullet Bill is not moving left, jump to PRG004_B18A

	INY		 ; Y = 1 (moving left)

PRG004_B18A:
	CPY <Temp_Var1	
	BEQ PRG004_B1C2	 ; If too close, jump to PRG004_B1C2

	DEC Objects_Var3,X	; Var3--

	BNE PRG004_B1C2	 ; If Var3 <> 0, jump to PRG004_B1C2

PRG004_B193:
	LDA <Counter_1
	AND #$01
	BNE PRG004_B1C2	 ; Every other tick, jump to PRG004_B1C2

	LDA <Objects_Var4,X
	BMI PRG004_B1C2	 ; If Var4 < 0, jump to PRG004_B1C2

	AND #$01
	TAY		 ; Y = 0 or 1

	; Set Bullet Bill flip bits
	LDA BulletBill_FlipBits,Y
	STA Objects_FlipBits,X

	; Accelerate towards target
	LDA <Objects_XVel,X
	ADD BulletBill_XAccel,Y
	STA <Objects_XVel,X

	CMP #$00
	NOP
	BNE PRG004_B1B9	 ; If X velocity = 0, jump to PRG004_B1B9

	; X velocity hit zero point

	PHA		 ; Save X velocity

	; Clear Var5
	LDA #$00
	STA <Objects_Var5,X

	PLA		 ; Restore X velocity

PRG004_B1B9:
	CMP BulletBill_XLimit,Y
	BNE PRG004_B1C2	 ; If Bullet Bill is not at X velocity limit, jump to PRG004_B1C2
 
	; Var4 = $FF
	LDA #$ff
	STA <Objects_Var4,X

PRG004_B1C2:
	LDA <Objects_Var5,X
	BEQ PRG004_B1D3	 ; If Var5 = 0, jump to PRG004_B1D3

	DEC <Objects_Var5,X	 ; Var5--

	; Frame = 3
	LDA #$03
	STA Objects_Frame,X

	JSR GroundTroop_DrawMirrored	 ; Draw mirrored??
	JMP PRG004_B21A	 ; Jump to PRG004_B21A

PRG004_B1D3:

	; Frame = 0
	LDA #$00
	STA Objects_Frame,X

	LDA Object_SprRAM,X
	PHA		 ; Save Sprite_RAM offset

	; +8 
	ADD #$08
	STA Object_SprRAM,X

	JSR GroundTroop_DrawNormal	; Draw Bullet Bill

	; Restore Sprite_RAM offset
	PLA
	STA Object_SprRAM,X

	LDA Objects_Timer,X
	BEQ PRG004_B21A	 ; If timer expired, jump to PRG004_B21A

	LDA <Objects_Y,X
	PHA		 ; Save Object Y

	LDA <Objects_X,X
	PHA		 ; Save Object X

	LDA Objects_FlipBits,X
	PHA		 ; Save Flip Bits

	LDA Objects_Var13,X
	STA <Objects_X,X

	INC <Objects_Y,X	; Y++

	; Set priority bit
	LDA #$20
	STA Objects_FlipBits,X

	; Frame = 4
	LDA #$04
	STA Objects_Frame,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility

	JSR GroundTroop_DrawNormal	 ; Draw Bullet Bill

	; Restore Flip Bits
	PLA
	STA Objects_FlipBits,X

	; Restore X
	PLA
	STA <Objects_X,X

	; Restore Y
	PLA
	STA <Objects_Y,X

	RTS		 ; Return

PRG004_B21A:
	JMP Fish_FixedY_ExceptHitFloor	 ; Fix the Y unless fish hit floor and don't come back!


GroundTroop_FlipTowardsPlayer:	.byte SPR_HFLIP, $00
SpikeCheep_XVelTowardsPlayer:	.byte $08, -$08

	; DEAD CODE
	LDA #$10	 
	STA <Objects_YVel,X
	BNE ObjInit_GroundTroop

ObjInit_GiantTroop:
	INC Objects_IsGiant,X	 ; Flag this enemy as giant!

ObjInit_GroundTroop:
	JSR Level_ObjCalcXDiffs

	; Face Player when appearing
	LDA GroundTroop_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

ObjInit_Set3DoNothing:
	RTS		 ; Return

ObjInit_SpikeCheep:
	INC Objects_InWater,X	 ; Flag as in-water

	JSR Level_ObjCalcXDiffs

	; Set X velocity towards Player!
	LDA SpikeCheep_XVelTowardsPlayer,Y
	STA <Objects_XVel,X

	; Var1 = 0
	LDA #$00
	STA Objects_Var1,X

	; Var10 = initial X - 48 (left limit)
	LDA <Objects_X,X
	SUB #48
	STA Objects_Var10,X

	; Var11 = initial X + 48 (right limit)
	ADD #96
	STA Objects_Var11,X

	RTS		 ; Return


ObjNorm_RedTroopa:

	; Normal sized and giant red troopas...

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	; Toggle frame 0/1
	LDA <Objects_Var5,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR GroundTroop_Draw	 ; Draw the troopa

	LDA <Player_HaltGame
	BNE PRG004_B2A2	 ; If gameplay is halted, jump to PRG004_B2A2

	INC <Objects_Var5,X	; Var5++

	JSR GroundTroop_BumpOffOthers	 ; Bump off other enemies

	LDA #$08	 ; A = $08

	LDY Objects_FlipBits,X
	BNE PRG004_B275	 ; If flipped, jump to PRG004_B275

	LDA #-$08	 ; A = -$08

PRG004_B275:
	STA <Objects_XVel,X	; Set X velocity as appropriate

	JSR Object_Move	 ; Do standard movement

	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG004_B283	 ; If troopa has not hit a wall, jump to PRG004_B283

	JSR Object_FlipFace	 ; Turn around

PRG004_B283:

	; Logic that keeps a red troopa from marching himself right off an edge

	LDA <Objects_DetStat,X
	AND #$04
	BNE PRG004_B29B	 ; If troopa has hit ground, jump to PRG004_B29B

	LDA <Objects_Var4,X
	BNE PRG004_B2A2	 ; If Var4 <> 0, jump to PRG004_B2A2

	INC <Objects_Var4,X	 ; Var4++

	JSR Object_AboutFace	 ; Turn around

	; Applies X velocity twice to undo his previous step that would have put him over
	JSR Object_ApplyXVel
	JSR Object_ApplyXVel

	JMP PRG004_B29F	 ; Jump to PRG004_B29F

PRG004_B29B:

	; Var4 = 0
	LDA #$00
	STA <Objects_Var4,X

PRG004_B29F:
	JSR Object_HitGround	 ; Align to floor

PRG004_B2A2:
	JMP PRG004_AF1A	 ; (Indirectly) Handle getting bumped underneath and don't come back

ParaTroopaFly_Accel:	.byte $01, $FF
ParaTroopaFly_Limit:	.byte $10, $F0

ObjNorm_FlyingGreenPara:
	JSR Object_DeleteOffScreen_N2	 ; Delete if object falls off screen
	JSR Troopa_Draw	 		; Draw the paratroopa

	LDA <Player_HaltGame
	BNE PRG004_B2FB	 ; If gameplay halted, jump to PRG004_B2FB

	LDY #SPR_HFLIP	 ; Y = SPR_HFLIP (paratroopa moving to the right)

	LDA <Objects_XVel,X
	BEQ PRG004_B2C1	 ; If paratroopa is not moving horizontally, jump to PRG004_B2C1
	BPL PRG004_B2BD	 ; If paratroopa is moving to the right, jump to PRG004_B2BD

	LDY #$00	 ; Y = 0 (paratroopa moving to the left)

PRG004_B2BD:
	TYA		 
	STA Objects_FlipBits,X	 ; Set appropriate flip

PRG004_B2C1:
	INC <Objects_Var5,X	 ; Var5++

	; Toggle frame 0/1
	LDA <Objects_Var5,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA Objects_Timer,X
	BNE PRG004_B2FB	 ; If timer is not expired, jump to PRG004_B2FB

	INC <Objects_Var4,X	 ; Var4++

	LDA <Objects_Var4,X
	AND #$03
	BNE PRG004_B2FB	 ; 1:4 ticks proceed, otherwise jump to PRG004_B2FB

	LDA Objects_Var3,X
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate!
	LDA <Objects_XVel,X
	ADD ParaTroopaFly_Accel,Y
	STA <Objects_XVel,X

	CMP ParaTroopaFly_Limit,Y
	BNE PRG004_B2FB	 ; If Paratroopa is not at his velocity limit, jump to PRG004_B2FB
 
	INC Objects_Var3,X	 ; Var3++

	; Reset timer to $30
	LDA #$30
	STA Objects_Timer,X

PRG004_B2FB:
	LDY #$02	 ; Y = $02

	LDA <Objects_Var5,X
	AND #$20
	BEQ PRG004_B305	 ; 32 ticks on, 32 ticks off; jump to PRG004_B305

	LDY #-$02	 ; Y = -$02

PRG004_B305:
	STY <Objects_YVel,X	 ; Slight bob in the flight path
	JMP Player_HitEnemy	 ; Do Player to Paratroopa collision and don't come back!


ObjNorm_FlyingRedTroopa:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR Troopa_Draw	 		; Draw like a troopa

	LDA <Player_HaltGame
	BNE PRG004_B34B	 ; If gameplay is halted, jump to PRG004_B34B

	INC <Objects_Var5,X	 ; Var5++

	; Toggle frame 0/1
	LDA <Objects_Var5,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA Objects_Timer,X
	BNE PRG004_B34B	 ; If timer not expired, jump to PRG004_B34B

	INC <Objects_Var4,X	 ; Var4++

	LDA <Objects_Var4,X
	AND #$03
	BNE PRG004_B34B	 ; 1:4 ticks proceed, otherwise jump to PRG004_B34B

	LDA Objects_Var3,X
	AND #$01
	TAY		 ; Y = 0 or 1 (current flight direction)

	; Accelerate
	LDA <Objects_YVel,X
	ADD ParaTroopaFly_Accel,Y
	STA <Objects_YVel,X

	CMP ParaTroopaFly_Limit,Y
	BNE PRG004_B34B	 ; If Y velocity is not at limit, jump to PRG004_B34B

	INC Objects_Var3,X	 ; Var3++ (technically, turn around, only bit 0 matters)

	; Set timer to $30
	LDA #$30
	STA Objects_Timer,X

PRG004_B34B:
	JMP Player_HitEnemy	 ; Do Player to enemy collision and don't come back

PRG004_B34E:
	.byte $04, $08, $08, $08, $10

PRG004_B353:
	.byte $FF, $C0, $80, $60, $40

GroundTroop_XVel:
	.byte -$08, $08
	.byte -$06, $06
	.byte -$05, $05

	.byte $F0, $10, $F4, $0C, $F7, $09

ObjNorm_GroundTroop:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA <Player_HaltGame
	BEQ PRG004_B36E	 ; If gameplay is not halted, jump to PRG004_B36E

	JMP GroundTroop_Draw	 ; Draw the enemy and don't come back!

PRG004_B36E:
	LDA Objects_FlipBits,X
	ASL A
	ASL A
	ROL A
	AND #$01
	TAY		 ; Y = 0 or 1, depending if horizontally flipped or not

	; Objects_TargetingXVal is set if enemy is hit by a left/right bouncing block
	LDA Objects_TargetingXVal,X
	BPL PRG004_B384	 ; If TargetingXVal >= 0, jump to PRG004_B384

	; Otherwise, 'Y' += 2
	INY
	INY

	CMP #-$02
	BNE PRG004_B384	 ; If TargetingXVal <> -2, jump to PRG004_B384 

	; Otherwise, 'Y' += 2
	INY
	INY

PRG004_B384:

	; Set proper ground troop X velocity
	LDA GroundTroop_XVel,Y
	STA <Objects_XVel,X

	; Toggle frame 0/1
	LDA <Objects_Var5,X
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	LDA Objects_Var1,X
	BEQ PRG004_B3A5	 ; If Var1 = 0, jump to PRG004_B3A5

	DEC Objects_Var1,X	 ; Var1--

	JSR Object_ApplyXVel	 ; Apply X velocity

	INC <Objects_Var5,X	 ; Var5++

	JSR GroundTroop_Draw	 ; Draw the enemy
	JMP Player_HitEnemy	 ; Do Player to enemy collision and don't come back!

PRG004_B3A5:
	JSR GroundTroop_Draw	 ; Draw the enemy
	JSR Object_Move		 ; Standard object movements

	; If this enemy is in contact with a left/right bouncing block, set Objects_TargetingXVal
	LDA LRBounce_Vel
	STA Objects_TargetingXVal,X

	JSR GroundTroop_BumpOffOthers	 ; Bounce off other enemies

	LDY LRBounce_Vel
	INY
	INY

	; Var7 += PRG004_B353[Y]
	LDA Objects_Var7,X
	ADD PRG004_B353,Y
	STA Objects_Var7,X

	BCC PRG004_B3C7	 ; If no carry, jump to PRG004_B3C7

	INC <Objects_Var5,X	 ; Var5++

PRG004_B3C7:

	LDA <Objects_DetStat,X
	AND #$04
	BNE PRG004_B3EC	 ; If enemy hit ground, jump to PRG004_B3EC

	; Enemy did not hit ground...

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG004_B3D7	 ; If enemy hit did NOT ceiling, jump to PRG004_B3D7

	; If enemy hit ceiling, bounce off it
	LDA #$01
	STA <Objects_YVel,X

PRG004_B3D7:
	LDY Level_ObjectID,X
	CPY #OBJ_PARATROOPAGREENHOP
	BEQ PRG004_B3E7	 ; If this is a hopping green shell paratroopa, jump to PRG004_B3E7

	CPY #OBJ_BIGGREENHOPPER
	BEQ PRG004_B3E7	 ; If this is a GIANT hopping green shell paratroopa, jump to PRG004_B3E7

	; Not a green shell hopper...

	STA <Objects_Var5,X	; Var5 = 1 
	JMP PRG004_B405	 ; Jump to PRG004_B405

PRG004_B3E7:
	; Hopping green shelled troopas have a slight "float" in their Y velocity
	DEC <Objects_YVel,X
	JMP PRG004_B405	 ; Jump to PRG004_B405

PRG004_B3EC:

	; Ground troop hit ground...

	JSR Object_HitGround	 ; Align to floor

	LDA Level_ObjectID,X
	CMP #OBJ_BIGGREENHOPPER
	BEQ PRG004_B3FA	 ; If this the GIANT hopping green shell paratroopa, jump to PPRG004_B3FA

	CMP #OBJ_PARATROOPAGREENHOP
	BNE PRG004_B405	 ; If this is NOT a hopping green shell paratroopa, jump to PRG004_B405

PRG004_B3FA:

	; Green shelled troopas...

	LDA #-$30	; Y velocity will be set to -$30 out of water

	LDY Objects_InWater,X
	BEQ PRG004_B403	 ; If this troopa is not in the water, jump to PRG004_B403

	LDA #-$18	; Y velocity will be set to -$18 in water

PRG004_B403:
	STA <Objects_YVel,X	 ; Set Y velocity for hop

PRG004_B405:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG004_B40E	 ; If enemy hasn't hit a wall, jump to PRG004_B40E

	JSR Object_FlipFace	 ; Turn around

PRG004_B40E:
	JMP PRG004_AF1A	 ; (Indirectly) Handle getting bumped underneath

	RTS		 ; Return


	; Essentially a version of Object_BumpOffOthers tuned to ground troop enemies (paying attention to Var1)
GroundTroop_BumpOffOthers:
	TXA		 ; object index -> 'A'
	ADD <Counter_1	 ; Add counter
	LSR A		 ; Shift low bit into carry
	BCS PRG004_B41A	 ; Semi-randomly jump to PRG004_B41A

PRG004_B419:
	RTS		 ; Return

PRG004_B41A:
	LDA Objects_SprVVis,X
	BNE PRG004_B419	 ; If any sprites are vertically off-screen, jump to PRG004_B419 (RTS)

	LDA Objects_SprHVis,X
	AND #%11000000
	CMP #%11000000
	BEQ PRG004_B49F	 ; If two sprites are off-screen, jump to PRG004_B49F (RTS)

	JSR Object_CalcBoundBox2	; Calc the bounding box of the enemy for future object-to-other-object collision check

	TXA
	BEQ PRG004_B49F	 ; If this is the first object, jump to PRG004_B49F (RTS)

	DEX		 ; X-- (previous object)

PRG004_B42F:
	LDA Objects_State,X

	CMP #OBJSTATE_NORMAL
	BEQ PRG004_B43A	 ; If object is in state Normal, jump to PRG004_B43A

	CMP #OBJSTATE_SHELLED
	BNE PRG004_B49A	 ; If object is NOT in state Shelled, jump to PRG004_B49A (skip to next object)

PRG004_B43A:

	; Object is in normal or shelled state...

	LDY Level_ObjectID,X	 ; Y = this object's ID

	LDA Object_AttrFlags,Y
	AND #OAT_BOUNCEOFFOTHERS
	BEQ PRG004_B49A	 ; If this object does not bounce off other objects, jump to PRG004_B49A (skip to next object)

	LDA Objects_Var1,X
	BNE PRG004_B49A	 ; If Var1 <> 0, jump to PRG004_B49A (skip to next object)

	LDA Objects_SprVVis,X
	BNE PRG004_B49A	 ; If this object has sprites vertically off-screen, jump to PRG004_B49A (skip to next object)

	LDA Objects_SprHVis,X
	AND #%11000000
	CMP #%11000000
	BEQ PRG004_B49A	 ; If two sprites are horizontally off-screen, jump to PRG004_B49A (skip to next object)

	JSR Object_CalcSpriteXY_NoHi

	JSR Object_CalcBoundBox	 ; Calculate the bounding box of this object
	JSR ObjectObject_Intersect	 ; Test for collision between the original enemy and this object
	BCC PRG004_B49A	 ; If no collision, jump to PRG004_B49A (skip to next object)

	LDY <SlotIndexBackup	 ; Y = original enemy's object slot index

	LDA <Objects_X,X
	SBC Objects_X,Y	
	PHA		 ; Save difference between object Xs

	LDA <Objects_XHi,X
	SBC Objects_XHi,Y
	STA <Temp_Var1	 ; Temp_Var1 = difference between object X His

	ROL <Temp_Var2	 ; Sets carry if offset was negative

	PLA		 ; Restore X difference

	ADC #$80	 ; +$80

	LDA <Temp_Var1
	ADC #$00
	BNE PRG004_B49A	 ; If sprite is off-screen, jump to PRG004_B49A (skip to next object)

	LSR <Temp_Var2	 ; Determine which side the object is on

	LDY #$00	 ; Y = 0 
	BCS PRG000_B484	 ; If this object's sprite X < the OTHER object's sprite X, jump to PRG000_B484
	LDY #SPR_HFLIP	 ; Otherwise, Y = SPR_HFLIP

PRG000_B484:
	TYA 
 	STA <Temp_Var1	 ; Store target flip -> Temp_Var1

	LDY <SlotIndexBackup	 ; Y = original enemy slot index
	STA Objects_FlipBits,Y	 ; -> FlipBits

	; This check is redundant
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG004_B49A	 ; If the hit object is not in state Normal, jump to PRG004_B49A (skip to next object)

	; Set the object flip opposite of the object it hit
	LDA <Temp_Var1
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X

PRG004_B49A:
	DEX		 ; X-- (previous object)
	BPL PRG004_B42F	 ; While X >= 0, loop

	LDX <SlotIndexBackup	 ; X = object slot index

PRG004_B49F:
	RTS		 ; Return

Troopa_YOffByFrame:
	.byte $06, $05

	; Basically select first and second column if the frame is even and the
	; second and third if the frame is odd for the foot sprite patterns.
Troopa_FootByEvenOddFrame:
	.byte $C7, $C9, $C7	; Even
	.byte $F9, $FB, $F9	; Odd

GroundTroop_Draw:
	LDA Level_ObjectID,X
	CMP #OBJ_BUZZYBEATLE
	BLT Troopa_Draw	 ; If this is one of the regular troopas or paratroopas, jump to Troopa_Draw

	CMP #OBJ_BIGGREENTROOPA
	BLT PRG004_B4B6	 ; If this is not one of the giant troopas, jump to PRG004_B4B6

	JMP ObjectGroup03_PatternSets	 ; Jump indirectly to GiantEnemy_Draw

PRG004_B4B6:

	; Not a green shell troopa/paratroopa nor a giant enemy...

	LDY Objects_Var1,X
	BEQ PRG004_B4CC	 ; If Var1 = 0, jump to PRG004_B4CC

	; Var1 > 0...

	LDA Objects_FlipBits,X
	PHA		 ; Save FlipBits
	ORA #SPR_BEHINDBG
	STA Objects_FlipBits,X	 ; Set priority bit

	JSR GroundTroop_DrawMirrored	 ; Draw mirrored sprite

	PLA		 ; Restore priority bit

	STA Objects_FlipBits,X	 ; Restore without priority bit
	RTS		 ; Return

PRG004_B4CC:

	; Var1 = 0

	LDY ObjGroupRel_Idx	 ; Y = object group relative index

	LDA ObjectGroup03_Attributes3,Y
	AND #OA3_SQUASH
	BNE PRG004_B4D9	 ; If this enemy gets "squashed" instead of "shelled", jump to PRG004_B4D9

	JMP GroundTroop_DrawNormal	 ; Draw shelled enemy normally and don't come back!

PRG004_B4D9:
	JMP GroundTroop_DrawMirrored	 ; Draw squashed enemy mirrored and don't come back!

Troopa_Draw:
	; Regular troopas / paratroopas

	; Add 8 to the assigned Sprite_RAM offset -- this makes
	; room for the troopa's tip of the head above the body
	; and for a wing (used if this is a paratroopa only)
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	LDY Objects_Frame,X	 ; Y = current frame

	LDA Troopa_YOffByFrame,Y
	TAY		 ; Sprite Y offset -> 'Y'

	; For the following GroundTroop_DrawOffsetInY call:
	; This draws the troopa's "middle", which incidentally includes
	; the head (minus the top), although the simplicity of the function 
	; will set the attributes wrong on the head (wrong palette) which
	; will be corrected below...

	JSR GroundTroop_DrawOffsetInY	 ; Draw with specified offset

	NOP		 ; ? Removed something

	; Temp_Var2 = FlipBits
	LDA Objects_FlipBits,X
	STA <Temp_Var2

	BEQ PRG004_B4FB	 ; If not flipped (i.e. horizontal), jump to PRG004_B4FB

	; Y += 4 (next sprite, deciding which sprite to place the head on)
	INY
	INY
	INY
	INY

PRG004_B4FB:

	; Starting here, we begin the process of drawing the tip of the head,
	; correcting the lower head's attribute, and drawing the feet...

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG004_B520	 ; If this sprite is vertically off-screen, jump to PRG004_B520

	; We use -8 Sprite_RAM offsets here because of the initial +8 before...

	; -16 to get to tip of head
	SUB #16
	STA Sprite_RAM-$08,Y	 ; Store sprite Y

	; Tip of Troopa's head pattern
	LDA #$c1
	STA Sprite_RAM-$07,Y

	; Copy the same X coordinate
	LDA Sprite_RAM+$03,Y
	STA Sprite_RAM-$05,Y

	LDA Sprite_RAM+$02,Y
	AND #~$03	 ; Clear old palette select
	ORA #SPR_PAL3	 ; Set correct palette select
	STA Sprite_RAM-$06,Y	 ; Set on upper head
	STA Sprite_RAM+$02,Y	 ; Set on lower head

PRG004_B520:

	; Sprite on opposite side of whatever we just put the head on
	TYA
	EOR #$04
	TAY

	LDA Level_ObjectID,X
	CMP #OBJ_PARATROOPAGREENHOP
	BLT PRG004_B55D	 ; If this is not a paratroopa, jump to PRG004_B55D

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG004_B55D	 ; If sprite was found to be vertically off-screen, jump to PRG004_B55D

	; The wing sprite is Y-8 from the body
	SUB #$08
	STA Sprite_RAM-$08,Y

	; Temp_Var1 = $CD (pattern for wing up)
	LDA #$CD
	STA <Temp_Var1

	LDA <Objects_Var5,X
	ADC #$02
	AND #$04
	BEQ PRG004_B548	 ; 4 ticks on, 4 ticks off; jump to PRG004_B548

	; Temp_Var1 = $CF (pattern for wing down)
	LDA #$CF
	STA <Temp_Var1 

PRG004_B548:

	; Set correct wing pattern
	LDA <Temp_Var1
	STA Sprite_RAM-$07,Y

	; Copy Sprite X
	LDA Sprite_RAM+$03,Y
	STA Sprite_RAM-$05,Y

	LDA Sprite_RAM+$02,Y
	AND #~$03	 ; Clear old palette select
	ORA #SPR_PAL1	 ; Use proper palette select for wing
	STA Sprite_RAM-$06,Y	 ; Set wing attribute

PRG004_B55D:

	; Time for the left foot...

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG004_B56D	 ; If left bottom of troopa is off-screen, jump to PRG004_B56D

	; Left foot appears at Sprite Y + 16
	ADD #16
	STA Sprite_RAM+$08,Y

PRG004_B56D:
	LDA Sprite_RAM+$04,Y
	CMP #$f8
	BEQ PRG004_B57A	 ; If right bottom of troopa is off-screen, jump to PRG004_B57A

	; Right foot appears at Sprite Y + 16
	ADD #16
	STA Sprite_RAM+$0C,Y

PRG004_B57A:
	; Copy Sprite X for left foot
	LDA Sprite_RAM+$03,Y
	STA Sprite_RAM+$0B,Y

	; Copy Sprite X for right foot
	LDA Sprite_RAM+$07,Y
	STA Sprite_RAM+$0F,Y

	LDA Sprite_RAM+$02,Y
	AND #~$03	 ; Clear old palette select
	ORA #SPR_PAL3	 ; Set correct palette select

	STA Sprite_RAM+$0A,Y	 ; Set left foot attribute
	STA Sprite_RAM+$0E,Y	 ; Set right foot attribute

	LDA Objects_Frame,X

	LDX #$00	 ; X = 0

	LSR A
	BCC PRG004_B59E	 ; On even frames, jump to PRG004_B59E

	; On odd frames, X = 3
	INX
	INX
	INX

PRG004_B59E:
	LDA <Temp_Var2
	BEQ PRG004_B5A3	 ; If not flipped (horizontally), jump to PRG004_B5A3

	INX		 ; Otherwise, X++

PRG004_B5A3:

	; Left foot pattern
	LDA Troopa_FootByEvenOddFrame,X
	STA Sprite_RAM+$09,Y

	; Right foot pattern
	LDA Troopa_FootByEvenOddFrame+1,X
	STA Sprite_RAM+$0D,Y

	LDX <SlotIndexBackup	 ; X = object slot index
	RTS		 ; Return

GiantEnemy_Draw:
	LDA Level_ObjectID,X
	CMP #OBJ_BIGGOOMBA
	BNE PRG004_B5D6	 ; If this is not a Giant Goomba, jump to PRG004_B5D6

	; Giant Goomba only...

	LDA Objects_FlipBits,X
	PHA		 ; Save flip bits

	AND #~SPR_HFLIP
	STA <Temp_Var1	 ; Temp_Var1 = flip bits sans horizontal flip

	; Set horizontal flip only if Var5 bit 2 is set
	LDA <Objects_Var5,X
	AND #$04
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	ORA <Temp_Var1
	STA Objects_FlipBits,X

	JSR PRG004_B5D6 	; Otherwise, draw like any other

	PLA
	STA Objects_FlipBits,X	; Restore flip bits

	RTS		 ; Return

PRG004_B5D6:

	; Save X/Hi and Y
	LDA <Objects_X,X
	PHA
	LDA <Objects_XHi,X
	PHA
	LDA <Objects_Y,X
	PHA

	CLC	

	LDY Objects_FlipBits,X
	BMI PRG004_B5E7	 ; If vertically flipped, jump to PRG004_B5E7

	ADC #$08	 ; Otherwise, add 8

PRG004_B5E7:
	STA <Objects_Y,X ; -> Y

	LDA <Objects_YHi,X
	PHA		 ; Save Y Hi

	ADC #$00
	STA <Objects_YHi,X	 ; Apply carry

	; Temp_VarNP0 = sprite horizontal visibility bits
	LDA Objects_SprHVis,X
	STA Temp_VarNP0

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG004_B60D	 ; If not horizontally flipped, jump to PRG004_B60D

	ASL Objects_SprHVis,X

	; Add 8 to X
	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X
	LDA <Objects_XHi,X
	ADC #$00
	STA <Objects_XHi,X

PRG004_B60D:
	JSR Object_Draw16x32Sprite	 ; Draw left 2/3 of Giant Enemy

	; Restore Y/Hi and X/Hi
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	JSR Object_CalcSpriteXY_NoHi

	LDY #$00	 ; Y = 0

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG004_B629	 ; If not horizontally flipped, jump to PRG004_B629

	INY		 ; Y = 1

PRG004_B629:
	LDA Temp_VarNP0	
	AND Giant_HVisBit,Y
	BNE PRG004_B68A	 ; If sprite is not visible, jump to PRG004_B68A

	SEC	; Carry set if Timer4 is expired

	LDA Objects_Timer4,X
	BEQ PRG004_B638	 ; If Timer4 is expired, jump to PRG004_B638

	LSR A	; Otherwise, set carry by timer

PRG004_B638:

	; Temp_Var2 = Sprite X
	LDA <Objects_SpriteX,X
	SBC #$00
	ADD Giant_HXOff,Y
	STA <Temp_Var2	

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Set Sprite Xs
	LDA <Temp_Var2
	STA Sprite_RAM+$13,Y
	STA Sprite_RAM+$17,Y

	; Vertical visibilty -> Temp_Var1
	LDA Objects_SprVVis,X
	STA <Temp_Var1	

	LDA <Objects_SpriteY,X	
	ADD #$08
	LSR <Temp_Var1
	BCS PRG004_B65E	 ; If this sprite is vertically off-screen, jump to PRG004_B65E

	STA Sprite_RAM+$10,Y	 ; Otherwise, set Sprite Y

PRG004_B65E:
	LSR <Temp_Var1
	BCS PRG004_B668	 ; If this sprite is vertically off-screen, jump to PRG004_B668

	ADD #16			; Lower sprite is +16 Y
	STA Sprite_RAM+$14,Y	 ; Set lower Sprite Y

PRG004_B668:

	; Copy attributes
	LDA Sprite_RAM+$02,Y
	STA Sprite_RAM+$12,Y
	STA Sprite_RAM+$16,Y

	LDA Objects_FlipBits,X
	BPL PRG004_B68A	 ; If not vertically flipped, jump to PRG004_B68A

	; Otherwise, swap Sprite Ys
	LDA Sprite_RAM+$10,Y
	PHA
	LDA Sprite_RAM+$14,Y
	SUB #$08
	STA Sprite_RAM+$10,Y
	PLA
	SUB #$08
	STA Sprite_RAM+$14,Y

PRG004_B68A:
	LDA Level_ObjectID,X
	CMP #OBJ_BIGGOOMBA
	BNE PRG004_B694	 ; If this is not a Giant Goomba, jump to PRG004_B694

	JMP PRG004_B719	 ; Jump to PRG004_B719

PRG004_B694:

	; The only other Giant Enemy that uses this routine at this point are the Giant Troopas,
	; so from here on out it's Giant Troopa code. 

	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG004_B69E	 ; If Giant Troopa's state is Normal, jump to PRG004_B69E

	JMP PRG004_B73E	 ; Jump to PRG004_B73E

PRG004_B69E:
	LDY #$00	 ; Y = 0

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG004_B6A9	 ; If Giant Troopa is not horizontally flipped, jump to PRG004_B6A9

	LDY #$04	 ; Y = 4

PRG004_B6A9:
	STY <Temp_Var4	 ; Temp_Var4 = 0 or 4 (which sprite to use)

	TYA
	ADD Object_SprRAM,X	; Set base offset

	TAY
	LDA Sprite_RAM+$00,Y

	CMP #$f8
	BEQ PRG004_B6BE	 ; If sprite vertically not visible, jump to PRG004_B6BE

	SUB #$08
	STA Sprite_RAM+$00,Y

PRG004_B6BE:
	LDA Sprite_RAM+$08,Y

	CMP #$f8
	BEQ PRG004_B6CB	 ; If sprite vertically not visible, jump to PRG004_B6CB

	SUB #$08
	STA Sprite_RAM+$08,Y

PRG004_B6CB:

	; Palette select 3
	LDA Sprite_RAM+$02,Y
	ORA #SPR_PAL3
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$0A,Y

	LDA <Temp_Var4	 
	EOR #$04	 ; Use "other" sprite
	ADD Object_SprRAM,X	 ; Add base offset
	TAY		 ; -> 'Y'

	; Palette select 3
	LDA Sprite_RAM+$0A,Y
	ORA #SPR_PAL3
	STA Sprite_RAM+$0A,Y

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Top of rear part of shell pattern
	LDA #$91
	STA Sprite_RAM+$11,Y

	LDA Objects_Frame,X
	LSR A

	LDA #$9f	 ; Foot pattern for odd frames

	BCS PRG004_B6F9	 ; If odd frame, jump to PRG004_B6F9

	LDA #$97	 ; Foot pattern for even frames

PRG004_B6F9:
	STA Sprite_RAM+$15,Y	 ; Store proper foot pattern

	LDA Level_ObjectID,X
	CMP #OBJ_BIGGREENHOPPER
	BLT PRG004_B710	 ; If this is not a Giant Paratroopa, jump to PRG004_B710

	LDA Objects_Frame,X
	LSR A

	LDA #$b9	 ; Wing up pattern

	BCC PRG004_B70D	 ; If even frame, jump to PRG004_B70D

	LDA #$bb	 ; Wing down pattern

PRG004_B70D:
	STA Sprite_RAM+$11,Y	 ; Set proper wing pattern

PRG004_B710:

	; Palette select 3
	LDA Sprite_RAM+$16,Y
	ORA #SPR_PAL3
	STA Sprite_RAM+$16,Y

	RTS		 ; Return

PRG004_B719:

	; Giant Goomba only...

	LDA Objects_State,X
	CMP #OBJSTATE_SQUASHED
	BEQ PRG004_B72B	 ; If Giant Goomba is in state Squashed (Giant Goomba Only), jump to PRG004_B72B

	; Otherwise, use standard Goomba patterns

	LDA #$85
	STA Sprite_RAM+$11,Y
	LDA #$8b
	STA Sprite_RAM+$15,Y

	RTS		 ; Return

PRG004_B72B:

	; Giant Goomba is squashed

	; Squashed goomba patterns
	LDA #$71
	STA Sprite_RAM+$11,Y
	LDA #$bd
	STA Sprite_RAM+$15,Y

	; Mirror sprite
	LDA Sprite_RAM+$16,Y
	EOR #SPR_HFLIP
	STA Sprite_RAM+$16,Y

	RTS		 ; Return

PRG004_B73E:

	; Giant Troopa is non-normal state...

	; Shell patterns
	LDA #$b1
	STA Sprite_RAM+$11,Y
	LDA #$b5
	STA Sprite_RAM+$15,Y

	; Mirror the shell
	LDA Sprite_RAM+$12,Y
	EOR #SPR_HFLIP
	STA Sprite_RAM+$12,Y
	STA Sprite_RAM+$16,Y

	RTS		 ; Return

ObjInit_GiantGreenPiranha:
	LDA #4		; A = 4
	BNE PRG004_B75A	; Jump (technically always) to PRG004_B75A

ObjInit_GiantRedPiranha:
	LDA #12	 	; A = 12

PRG004_B75A:
	ADD <Objects_X,X
	STA <Objects_X,X	; Set centering X

	LDY #$21	 ; Y = $21

	; Var5 = original Y
	LDA <Objects_Y,X
	STA <Objects_Var5,X
	
	; Objects_TargetingYVal = $21
	TYA
	STA Objects_TargetingYVal,X

	; Var7 = original Y Hi
	LDA <Objects_YHi,X
	STA Objects_Var7,X

	; Set priority
	LDA #SPR_BEHINDBG
	STA Objects_FlipBits,X

	INC Objects_IsGiant,X	 ; Flag as a giant enemy
	RTS		 ; Return

GiantPiranha_TimerReloads:
	.byte $30, $30, $30, $30

ObjNorm_BigPiranha:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	LDA <Objects_Var4,X
	AND #$03
	BNE PRG004_B78C	 ; If (Var4 & 3) <> 0 (internal state 0 means Piranha is fully retracted), jump to PRG004_B78C

	; Set all sprites as horizontally off-screen (piranha is fully retracted in pipe)
	LDA #$ff
	STA Objects_SprHVis,X

	JMP PRG004_B79D	 ; Jump to PRG004_B79D

PRG004_B78C:

	; Toggle frame 0/1
	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR GiantPiranha_Draw	 ; Draw the giant piranha
	JSR Player_HitEnemy	 ; Player to piranha collision

PRG004_B79D:
	LDA <Player_HaltGame
	BNE PRG004_B7FD	 ; If gameplay is halted, jump to PRG004_B7FD (RTS)

	INC Objects_Var3,X	 ; Var3++

	LDA <Objects_Var4,X
	AND #$03	; Keep internal state counter 0-3

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word GiantPiranha_HideInPipe	; 0: Retracted in pipe
	.word GiantPiranha_Emerge	; 1: Emerging
	.word GiantPiranha_Chomp	; 2: Chomp
	.word GiantPiranha_Retract	; 3: Retract

GiantPiranha_Emerge:

	; Objects_TargetingYVal = $21
	; Var5 = original Y 
	; Var7 = original Y Hi

	LDA <Objects_Var5,X		; Original Y
	SUB Objects_TargetingYVal,X	; subtract TargetingYVal
	PHA				; Save it

	LDA Objects_Var7,X
	SBC #$00
	STA <Temp_Var1			; Temp_Var1 = Original Y Hi, carry applied

	PLA		 ; Restore the Original Y difference
	CMP <Objects_Y,X
	LDA <Temp_Var1
	SBC <Objects_YHi,X
	BCS PRG004_B7F0	 ; Basically if Giant Piranha is at his Y and Y Hi highest point, jump to PRG004_B7F0

	LDA #-$10	 ; A = -$10
	BNE PRG004_B7E6	 ; Jump (technically always) to PRG004_B7E6

GiantPiranha_Retract:
	LDA <Objects_Y,X
	ADD #$01
	PHA		 ; Save Y + 1

	LDA <Objects_YHi,X
	ADC #$00
	STA <Temp_Var1	 ; Temp_Var1 = carry applied to Y Hi

	PLA		 ; Restore Y + 1

	CMP <Objects_Var5,X
	LDA <Temp_Var1	
	SBC Objects_Var7,X
	BCS PRG004_B7F0	 ; Basically if Giant Piranha is at his Y and Y Hi origin, jump to PRG004_B7F0

	LDA #$10	 ; A = $10

PRG004_B7E6:

	; Giant Piranha is not fully extended/retracted...

	STA <Objects_YVel,X	 ; Set Y velocity as appropriate
	JMP Object_ApplyYVel_NoLimit	 ; Apply Y velocity and don't come back!!

GiantPiranha_Chomp:
	LDA Objects_Timer,X
	BNE PRG004_B80F	 ; If timer not expired, jump to PRG004_B80F

PRG004_B7F0:
	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	LDA <Objects_Var4,X
	AND #$03
	TAY		 ; Y = 0 to 3, based on internal state

	LDA GiantPiranha_TimerReloads,Y	 ; Get timer reload value for this state
	STA Objects_Timer,X	 ; Reload timer

PRG004_B7FD:
	RTS		 ; Return

GiantPiranha_HideInPipe:
	LDA Objects_Timer,X
	BNE PRG004_B80F	 ; If timer not expired, jump to PRG004_B80F

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$18
	CMP #$31
	BGE PRG004_B7F0	 ; If Player is not too close, jump to PRG004_B7F0

PRG004_B80F:
	RTS		 ; Return

GiantPiranha_Draw:
	LDA <Objects_X,X	 
	PHA		 ; Save piranha X

	LDA <Objects_XHi,X
	PHA		 ; Save piranha X Hi

	; Temp_VarNP0 = Sprite horizontal visibility flags
	LDA Objects_SprHVis,X
	STA Temp_VarNP0

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG004_B833	 ; If piranha is not horizontally flipped, jump to PRG004_B833

	ASL Objects_SprHVis,X

	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X
	LDA <Objects_XHi,X
	ADC #$00
	STA <Objects_XHi,X

PRG004_B833:
	JSR Object_Draw16x32Sprite	 ; Draw left 2/3 of piranha

	; Restore X/Hi
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	JSR Object_CalcSpriteXY_NoHi

	LDY #$00	 ; Y = 0 (Not H-flipped)

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG004_B849	 ; If piranha is not horizontally flipped, jump to PRG004_B849

	INY		 ; Y = 1 (H-flipped)

PRG004_B849:
	LDA Temp_VarNP0	 ; Get horizontal visibility bits

	AND Giant_HVisBit,Y
	BNE PRG004_B8B0	 ; If sprite is off-screen, jump to PRG004_B8B0 (RTS)

	; Temp_Var2 = Sprite X + offset
	LDA <Objects_SpriteX,X
	ADD Giant_HXOff,Y
	STA <Temp_Var2

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Set Sprite Xs
	LDA <Temp_Var2
	STA Sprite_RAM+$13,Y
	STA Sprite_RAM+$17,Y

	; Temp_Var1 = vertical visibility flags
	LDA Objects_SprVVis,X
	STA <Temp_Var1	

	LDA <Objects_SpriteY,X
	LSR <Temp_Var1
	BCS PRG004_B872	 ; If sprite is vertically off-screen, jump to PRG004_B872

	STA Sprite_RAM+$10,Y	 ; Set upper Sprite Y

PRG004_B872:
	LSR <Temp_Var1
	BCS PRG004_B87C	 ; If sprite is vertically off-screen, jump to PRG004_B87C

	ADD #16

	STA Sprite_RAM+$14,Y	 ; Set lower Sprite Y

PRG004_B87C:
	; Set equal-but-flipped attributes on right edge sprites
	LDA Sprite_RAM+$02,Y
	EOR #SPR_HFLIP
	STA Sprite_RAM+$12,Y
	STA Sprite_RAM+$16,Y

	LDA Objects_Frame,X
	LSR A

	; Set proper sprite pattern on upper sprite
	LDA #$a1
	BCC PRG004_B891	 ; On even frames, jump to PRG004_B891
	LDA #$a9
PRG004_B891:
	STA Sprite_RAM+$11,Y

	; Set proper sprite pattern on upper sprite
	LDA #$a5
	BCC PRG004_B89A	 ; On even frames, jump to PRG004_B891
	LDA #$ad
PRG004_B89A:
	STA Sprite_RAM+$15,Y

	LDA Objects_FlipBits,X
	BPL PRG004_B8B0	 ; If not horizontally flipped, jump to PRG004_B8B0 (RTS)

	; Otherwise swap left and right sprites
	LDA Sprite_RAM+$10,Y
	PHA
	LDA Sprite_RAM+$14,Y
	STA Sprite_RAM+$10,Y
	PLA
	STA Sprite_RAM+$14,Y

PRG004_B8B0:
	RTS		 ; Return


; FIXME: Anybody want to claim this?
; I think it's an integer division/modulus kind of routine, but I didn't look at it real hard
; $B8B1 

	; 'A' -> Temp_Var2
	STA <Temp_Var2

	; Backup X and Y
	TXA
	PHA
	TYA
	PHA

	; Y Difference flag -> Temp_Var3
	JSR Level_ObjCalcYDiffs
	STY <Temp_Var3

	; Get absolute value of Temp_Var16 (Y difference) -> Temp_Var13
	LDA <Temp_Var16
	BPL PRG004_B8C5
	NEG
PRG004_B8C5:
	STA <Temp_Var13

	; X Difference flag -> Temp_Var4
	JSR Level_ObjCalcXDiffs
	STY <Temp_Var4

	; Get absolute value of Temp_Var16 (X difference) -> Temp_Var14
	LDA <Temp_Var16
	BPL PRG004_B8D5
	NEG
PRG004_B8D5:
	STA <Temp_Var14

	LDY #$00	 ; Y = 0

	LDA <Temp_Var14
	CMP <Temp_Var13
	BGE PRG004_B8E8	 ; If X distance > Y distance, jump to PRG004_B8E8

	INY		 ; Otherwise, Y = 1

	; Swap Temp_Var13/14 so that Temp_Var14 is greater
	PHA
	LDA <Temp_Var13
	STA <Temp_Var14
	PLA
	STA <Temp_Var13

PRG004_B8E8:

	LDA #$00
	STA <Temp_Var12	; Temp_Var12 = 0
	STA <Temp_Var1	; Temp_Var1 = 0

	LDX <Temp_Var2		 ; X = Temp_Var2 (input value)
PRG004_B8F0:
	LDA <Temp_Var12
	ADD <Temp_Var13
	CMP <Temp_Var14
	BLT PRG004_B8FD		; If Temp_Var12 + Temp_Var13 < Temp_Var14, jump to PRG004_B8FD

	SBC <Temp_Var14		; Temp_Var14 -= Temp_Var12 + Temp_Var13
	INC <Temp_Var1		; Temp_Var1

PRG004_B8FD:
	STA <Temp_Var12	 ; Update Temp_Var12
	DEX		 ; X--
	BNE PRG004_B8F0	 ; While X >= 0, loop

	TYA
	BEQ PRG004_B90F	 ; If Y = 0, jump to PRG004_B90F

	; Otherwise, swap Temp_Var1 and Temp_Var2
	LDA <Temp_Var1
	PHA
	LDA <Temp_Var2
	STA <Temp_Var1
	PLA
	STA <Temp_Var2

PRG004_B90F:
	LDA <Temp_Var1

	LDY <Temp_Var3
	BEQ PRG004_B91C	 ; If Temp_Var3 = 0, jump to PRG004_B91C

	; Otherwise, negate Temp_Var1
	NEG
	STA <Temp_Var1

PRG004_B91C:
	LDA <Temp_Var2

	LDY <Temp_Var4
	BEQ PRG004_B929	 ; If Temp_Var4 = 0, jump to PRG004_B929

	; Otherwise, negate Temp_Var2
	NEG
	STA <Temp_Var2

PRG004_B929:
	; Restore Y and X
	PLA
	TAY
	PLA
	TAX

	RTS		 ; Return

GroundTroop_DrawMirrored:
	LDY #$00	; Y = 0 (Sprite Y offset)
	LDA #SPR_VFLIP	; A = SPR_VFLIP (draw mirrored sprite)
	BNE PRG004_B938	; Jump (technically always) to PRG004_B938

GroundTroop_DrawNormal:
	LDY #$00	; Y = 0 (Sprite Y offset)

GroundTroop_DrawOffsetInY:
	LDA #$00	; A = 0 (draw non-mirrored sprite)

PRG004_B938:
	STA <Temp_Var9		 ; Temp_Var9 = $00 (non-mirrored sprite) or SPR_VFLIP (mirrored sprite), depending on entry
	STY <Temp_Var1		 ; Temp_Var1 = Sprite Y offset

	JSR Object_CalcSpriteXY_NoHi

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	LDA Objects_SprVVis,X
	LSR A
	BCS PRG004_B9BA	 	; If this sprite is vertically off-screen, jump to PRG004_B9BA (RTS)

	; Temp_Var3 = horizontal visibility bits
	LDA Objects_SprHVis,X
	STA <Temp_Var3

	LDA <Objects_SpriteY,X
	SUB <Temp_Var1

	ASL <Temp_Var3
	BCS PRG004_B959	 ; If this sprite is horizontally off-screen, jump to PRG004_B959

	STA Sprite_RAM+$00,Y	 ; Otherwise, set Sprite Y

PRG004_B959:
	ASL <Temp_Var3
	BCS PRG004_B960	 ; If this sprite is horizontally off-screen, jump to PRG004_B960

	STA Sprite_RAM+$04,Y	 ; Otherwise, set Sprite Y


	; The following block appears to be unused
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG004_B960:
	SEC		; Set carry??

	LDA Objects_Timer4,X
	BEQ PRG004_B96D	 ; If timer 4 is expired, jump to PRG004_B96D

	CMP #$40
	BLT PRG004_B96C	 ; If timer 4 < $40, jump to PRG004_B96C

	; Timer 4 >= $40...

	LSR A
	LSR A		 ; Divide timer4 by 4

PRG004_B96C:
	LSR A		 ; Divide timer4 by 2

PRG004_B96D:
	; No one cares about the accumulator value or the carry flag...
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Set left sprite X
	LDA <Objects_SpriteX,X
	STA Sprite_RAM+$03,Y

	; Set right sprite X
	ADD #$08
	STA Sprite_RAM+$07,Y

	; Temp_Var1 = current flip bits
	LDA Objects_FlipBits,X
	STA <Temp_Var1
	ORA Objects_SprAttr,X	 ; OR in the sprite attributes

	ASL <Temp_Var9
	BCC PRG004_B986	 ; If Temp_Var9 was assigned to $00 at start, we jump to PRG004_B986

	AND #~SPR_HFLIP	 ; Clear horizontal flip if Temp_Var9 was $80 at start

PRG004_B986:
	STA Sprite_RAM+$02,Y	 ; Set left sprite attribute

	BCC PRG004_B98D	 ; If Temp_Var9 was assigned to $00 at start, we jump to PRG004_B98D

	ORA #SPR_HFLIP	 ; Set horizontal flip if Temp_Var9 was $80 at start

PRG004_B98D:
	STA Sprite_RAM+$06,Y	 ; Set right sprite attribute

	LDA Objects_Frame,X
	LDX ObjGroupRel_Idx	 ; X = object group relative index

	ASL A		 ; Multiply frame by 2

	ADD ObjectGroup03_PatternStarts,X	; Add in the base pattern set index

	TAX		 ; Frame * 2 + Pattern Start -> 'X'

	LDA ObjectGroup03_PatternSets,X	 ; Get the appropriate pattern for this frame

	BIT <Temp_Var1
	BVS PRG004_B9AF	 ; If horizontally flipped, jump to PRG004_B9AF

	; Store left sprite pattern
	STA Sprite_RAM+$01,Y

	LDA ObjectGroup03_PatternSets+1,X ; Get the next pattern

	; Store right sprite pattern
	STA Sprite_RAM+$05,Y

	JMP PRG004_B9B8	 ; Jump to PRG004_B9B8

PRG004_B9AF:
	; Store right sprite pattern
	STA Sprite_RAM+$05,Y

	LDA ObjectGroup03_PatternSets+1,X ; Get the next pattern

	; Store left sprite pattern
	STA Sprite_RAM+$01,Y

PRG004_B9B8:
	LDX <SlotIndexBackup	 ; X = object slot index

PRG004_B9BA:
	RTS		 ; Return

ObjInit_ChainChomp:

	; Fill in all of the following with the Chain Chomp's starting X coordinate
	LDA <Objects_X,X
	STA Objects_Var13,X
	STA ChainChomp_ChainX1,X
	STA ChainChomp_ChainX2,X
	STA ChainChomp_ChainX3,X
	STA ChainChomp_ChainX4,X

	; Var10 = origin X - 44 (left limit)
	SUB #44
	STA Objects_Var10,X

	; Var 11 = origin X + 44 (right limit)
	ADD #88
	STA Objects_Var11,X

	; Fill in all of the following with the Chain Chomp's starting Y coordinate
	LDA <Objects_Y,X
	STA Objects_Var14,X
	STA ChainChomp_ChainY1,X
	STA ChainChomp_ChainY2,X
	STA ChainChomp_ChainY3,X
	STA ChainChomp_ChainY4,X

	; Var12 = origin Y - 56 (upper limit)
	SUB #56
	STA Objects_Var12,X

	; Var7 holds corresponding Y Hi
	LDA <Objects_YHi,X
	SBC #$00
	STA Objects_Var7,X

	RTS		 ; Return

ChainChomp_BreakFree:
	LDY #$01	 ; Y = 1 (two buffer slots)
PRG004_B9F9:
	LDA Buffer_Occupied,Y
	BEQ PRG004_BA02	 ; If this buffer is free, jump to PRG004_BA02

	DEY		 ; Y--
	BPL PRG004_B9F9	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG004_BA02:

	; Become a freed Chain Chomp!
	LDA #OBJ_CHAINCHOMPFREE
	STA Level_ObjectID,X

	; Var7 = 4
	LDA #$04
	STA Objects_Var7,X

	; Claim this buffer slot
	LDA #$01
	STA Buffer_Occupied,Y

	JSR Object_CalcSpriteXY_NoHi

	; Temp_Var1 = Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; Temp_Var2 = Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2	

	TYA
	STA Objects_Var6,X	 ; Var6 = buffer slot select

	LSR A
	ROR A
	LSR A
	LSR A	; A = $00 or $20 (offset into corresponding buffer)
	TAX		 ; -> 'X'

	; This loop loads up the X/Y buffers with the Chain Chomp's position
	LDY #$1f	 ; Y = $1F (buffer space count)
PRG004_BA27:
	LDA <Temp_Var1
	STA Object_BufferY,X
	LDA <Temp_Var2
	STA Object_BufferX,X

	INX		 ; X++ (next buffer byte)
	DEY		 ; Y-- (one less count)
	BPL PRG004_BA27	 ; While Y >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	; Reset Timer
	LDA #$00
	STA Objects_Timer,X

	RTS		 ; Return

ChainChomp_ChaseYVel:	.byte -$20, -$40, -$30, -$50
ChainChomp_ChaseXVel:	.byte  $50,  $30,  $40,  $20

ChainChomp_YDelta:	.byte  $03, $0D, $08, $0D
ChainChomp_XDelta:	.byte  $0C, $0A, $0A, $08

ObjNorm_ChainChomp:
	JSR ChainChomp_Draw	 ; Draw Chain Chomp and his chain

	LDA <Player_HaltGame
	BNE PRG004_BAC8	 ; If gameplay is halted, jump to PRG004_BAC8 (RTS)

	JSR Player_HitEnemy	 ; Do Player to Chain Chomp collision detection
	JSR Object_DeleteOffScreen_N4	 ; Detect against world
	JSR Object_FlipByXVel	 ; Flip based on travel direction

	INC Objects_Var3,X	 ; Var3++
	INC <Objects_Var4,X	 ; Var4++

	; Toggle frame 0/1
	LDA <Objects_Var4,X
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	LDA <Objects_Var5,X	 ; Var5 is internal state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word ChainChomp_ChooseLunge
	.word ChainChomp_DoMove
	.word ChainChomp_Drop

ChainChomp_ChooseLunge:
	LDA Objects_Timer,X	 
	BNE PRG004_BAC8	 ; If timer not expired, jump to PRG004_BAC8 (RTS)

	LDA RandomN,X
	AND #$03
	; ...??

	JSR Level_ObjCalcXDiffs	

	LDA <Temp_Var16
	PHP		 ; Save CPU state
	BPL PRG004_BA8B	 ; If Player is to the right of Chain Chomp, jump to PRG004_BA8B

	EOR #$ff	 ; Otherwise, sort of negate the difference (almost absolute value)

PRG004_BA8B:
	CMP #64
	BLT PRG004_BA97	 ; If the distance < 64, jump to PRG004_BA97

	; If Player is too far away, just sort of dart about randomly
	LDA RandomN,X
	AND #$03	; A = random 0 to 3
	JMP PRG004_BA9E	 ; Jump to PRG004_BA9E

PRG004_BA97:

	; Divide distance by 16
	LSR A
	LSR A
	LSR A
	LSR A

	; .. something removed?
	NOP
	NOP
	NOP

PRG004_BA9E:
	STA Objects_TargetingXVal,X	 ; -> Objects_TargetingXVal
 
	TAY		
	LDA ChainChomp_ChaseYVel,Y
	STA <Objects_YVel,X	 ; Set Y Velocity
 
	LDA ChainChomp_ChaseXVel,Y
	PLP		 ; Restore CPU state
	BPL PRG004_BAB2	 ; If we inverted for Y, we must invert for X too, jump to PRG004_BAB2

	NEG	; Negate (absolute value)

PRG004_BAB2:
	STA <Objects_XVel,X	 ; -> X velocity

	; Timer = $28
	LDA #$28
	STA Objects_Timer,X

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	INC Objects_Var1,X	 ; Var1++

	LDA Objects_Var1,X
	CMP #$32
	BNE PRG004_BAC8	 ; If Var1 <> $32, jump to PRG004_BAC8

	JSR ChainChomp_BreakFree	 ; Chain Chomp breaks free!

PRG004_BAC8:
	RTS		 ; Return


ChainChomp_DoMove:
	LDA Objects_Timer,X	 
	BNE PRG004_BAEC	 ; If timer not expired, jump to PRG004_BAEC

	LDA RandomN,X
	AND #$3f
	ORA #$20
	STA Objects_Timer,X	 ; Set timer to $20 - $3F

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Halt vertical movement
	LDA #$00
	STA <Objects_YVel,X

	LDY #$08	 ; Y = 8

	LDA <Objects_X,X
	CMP Objects_Var13,X
	BLT PRG004_BAE9	 ; If Chain Chomp X < starting X, jump to PRG004_BAE9

	LDY #-$08	 ; Otherwise, Y = -8

PRG004_BAE9:
	STY <Objects_XVel,X	 ; Update X velocity
	RTS		 ; Return


PRG004_BAEC:
	LDA <Objects_X,X
	CMP Objects_Var10,X
	BLT PRG004_BB07	 ; If Chain Chomp is already at his left limit, jump to PRG004_BB07

	CMP Objects_Var11,X
	BGE PRG004_BB07	 ; If Chain Chomp is already at his right limit, jump to PRG004_BB07

	LDA <Objects_Y,X
	CMP Objects_Var12,X
	LDA <Objects_YHi,X
	SBC Objects_Var7,X
	BCC PRG004_BB07	 ; If Chain Chomp is above his upper limit, jump to PRG004_BB07

	JMP ChainChomp_MoveChain	 ; Chain Chomp moves with his chain, and don't come back!

PRG004_BB07:

	; Var4 += 2
	INC Objects_Var4,X
	INC Objects_Var4,X

	; Temp_Var4 = 4
	LDA #$04
	STA <Temp_Var4

	LDA Objects_Var13,X	 	; Chain Chomp starting X
	SUB <Objects_X,X		; Subtract current X (relative difference)
	JSR Modulus_ByTempVar4		
	ADD <Objects_X,X		; Add modulus result to Chain Chomp X
	STA ChainChomp_ChainX1,X	; Set Chain link 1 X

	ADC <Temp_Var1			; Apply same
	STA ChainChomp_ChainX2,X	; Set Chain link 2 X

	ADC <Temp_Var1			; Apply same
	STA ChainChomp_ChainX3,X	; Set Chain link 3 X

	ADC <Temp_Var1			; Apply same
	STA ChainChomp_ChainX4,X	; Set Chain link 4 X

	; Temp_Var4 = 5
	LDA #$05
	STA <Temp_Var4

	LDA Objects_Var14,X	 	; Chain Chomp starting Y
	SUB <Objects_Y,X		; Subtract current Y (relative difference)
	JSR Modulus_ByTempVar4		
	ADD <Objects_Y,X		; Add modulus result to Chain Chomp Y
	STA ChainChomp_ChainY1,X	; Set Chain link 1 Y

	ADC <Temp_Var1			; Apply same
	STA ChainChomp_ChainY2,X	; Set Chain link 2 Y

	ADC <Temp_Var1			; Apply same
	STA ChainChomp_ChainY3,X	; Set Chain link 3 Y

	ADC <Temp_Var1			; Apply same
	STA ChainChomp_ChainY4,X	; Set Chain link 4 Y

	LDA Object_SprRAM,X
	ADD #$08	 ; A = Sprite_RAM offset + 8 (two sprites over)

	LDY <Objects_YVel,X
	TAX		 ; X = sprite RAM offset
	CPY #-$30
	BGE PRG004_BB61	 

	; Change sprite Y instead of X
	INX
	INX
	INX

PRG004_BB61:
	LDY #$03	 ; Y = 3

	LDA <Counter_1
	LSR A	
	LSR A	
PRG004_BB67:
	BCC PRG004_BB6C	 ; If carry set, jump to PRG004_BB6C (this actually ought to skip the loop, it ends up does nothing)

	INC Sprite_RAM+$00,X	 ; Increment X or Y

PRG004_BB6C:

	; X += 4 (next sprite)
	INX
	INX
	INX
	INX

	DEY		 ; Y--
	BPL PRG004_BB67	 ; While Y >= 0, loop

	LDX <SlotIndexBackup		 ; X = object slot index

	RTS		 ; Return

	; Essentially performs a modulus against the accumulator by Temp_Var4
	; 'Y' stores the effective division result
Modulus_ByTempVar4:
	PHP		 ; Save CPU state
	BPL PRG004_BB7E	 ; If input is positive, jump to PRG004_BB7E

	NEG		; Otherwise, negate! (Absolute value)

PRG004_BB7E:
	LDY #$ff	 ; Y = $FF

PRG004_BB80:
	SBC <Temp_Var4	 ; Subtract Temp_Var4 from input

	INY		 ; Y++
	BCS PRG004_BB80	 ; If the value has not gone below zero, loop!

	TYA		 ; Y -> A

	PLP		 ; Restore CPU state
	BPL PRG004_BB8E	 ; If input is positive, jump to PRG004_BB8E

	NEG

PRG004_BB8E:
	STA <Temp_Var1		 ; Result -> Temp_Var1

	RTS		 ; Return

ChainChomp_LungeMask:	.byte $1f, $0f
ChainChomp_XVel:	.byte $10, $20

ChainChomp_Drop:
	JSR Level_ObjCalcXDiffs	 

	LDA <Temp_Var16
	ADC #$60
	CMP #$c0
	LDY #$00	 ; Y = 0
	BGE PRG004_BBB5	 ; If Player is too close, jump to PRG004_BBB5

	INC <Objects_Var4,X	 ; Var4++

	LDA Objects_Timer,X
	BNE PRG004_BBB4	 ; If timer not expired, jump to PRG004_BBB4

	LDA #$00
	STA Objects_Timer,X	 ; Reset timer
	STA <Objects_Var5,X	 ; Return to initial internal state
	STA Objects_TargetingYVal,X

	RTS		 ; Return

PRG004_BBB4:
	INY		 ; Y = 1

PRG004_BBB5:
	STY <Temp_Var16	 ; Temp_Var16 = 0 or 1

	JSR ChainChomp_MoveChain	 ; Chain Chomp moves with his chain, and don't come back!

	; Chain Chomp falls down
	INC <Objects_YVel,X
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	LDA Objects_TargetingYVal,X
	BEQ PRG004_BBE2	 ; If PRG004_BBCC = 0, jump to PRG004_BBE2

	; Temp_Var1 = Var14 (Chain Chomp's starting Y)
	LDA Objects_Var14,X
	STA <Temp_Var1

	LDY #$03	 ; Y = 3 (4 chain links)
PRG004_BBCC:
	LDA ChainChomp_ChainY1,X
	CMP <Temp_Var1
	BGE PRG004_BBD8	

	ADC #$02
	STA ChainChomp_ChainY1,X

PRG004_BBD8:

	; Next chain link
	INX
	INX
	INX
	INX
	INX

	DEY		 ; Y--
	BPL PRG004_BBCC	 ; While Y >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

PRG004_BBE2:
	LDA <Objects_Y,X
	CMP Objects_Var14,X
	BLT PRG004_BC58	 ; If Chain Chomp is above the starting Y, jump to PRG004_BC58

	; Objects_TargetingYVal = 1
	LDA #$01
	STA Objects_TargetingYVal,X

	LDA <Objects_YVel,X
	PHA		 ; Save Y Velocity

	JSR Object_HitGround	 ; Align to ground

	PLA		 ; Restore Y velocity
	CMP #$28
	BLT PRG004_BC02	 ; If Y Velocity < $28, jump to PRG004_BC02

	; Chain Chomp Y Vel = -$18
	LDA #-$18
	STA <Objects_YVel,X

	; Var3 = 0
	LDA #$00
	STA Objects_Var3,X

PRG004_BC02:
	LDA #$03	 ; A = 3

	LDY <Temp_Var16	
	BEQ PRG004_BC0A	; If PRG004_BC0A = 0, jump to PRG004_BC0A

	LDA #$00	 ; A = 0

PRG004_BC0A:
	STA Objects_TargetingXVal,X	 ; Objects_TargetingXVal = 0 or 3

	LDA Objects_Var3,X
	AND ChainChomp_LungeMask,Y
	BNE PRG004_BC29	 

	LDA ChainChomp_XVel,Y
	PHA		 ; Save value

	LDA Objects_Var13,X
	CMP <Objects_X,X
	BGE PRG004_BC26	 ; If origin X >= Chain Chomp's X, jump to PRG004_BC26

	PLA		 ; Restore value

	; Negate
	EOR #$ff
	ADC #$01

	PHA		 ; Save value (just because it runs into the PLA below)

PRG004_BC26:
	PLA		 ; Restore value
	STA <Objects_XVel,X	 ; Set as X velocity

PRG004_BC29:
	LDA RandomN,X
	AND #$d5
	BNE PRG004_BC34	 ; Randomly jump to PRG004_BC34

	; Stop horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG004_BC34:
	LDA <Objects_X,X

	LDY Objects_FlipBits,X
	BNE PRG004_BC42	 ; If Chain Chomp is flipped, jump to PRG004_BC42

	CMP Objects_Var10,X
	BLT PRG004_BC47	 ; If Chain Chomp X < left limit, jump to PRG004_BC47
	BGE PRG004_BC58	 ; Otherwise, jump to PRG004_BC58 (RTS)

PRG004_BC42:
	CMP Objects_Var11,X
	BLT PRG004_BC58	 ; If Chain Chomp X < right limit, jump to PRG004_BC58 (RTS)

PRG004_BC47:
	LDY <Temp_Var16	 ; Y = Temp_Var16

	LDA ChainChomp_XVel,Y
	BCC PRG004_BC53	 

	NEG	; Negate!

PRG004_BC53:
	STA <Objects_XVel,X	 ; Set as X velocity
	JSR ChainChomp_MoveChain	 ; Chain Chomp moves with his chain, and don't come back!

PRG004_BC58:
	RTS		 ; Return

ChainChomp_Draw:
	JSR GroundTroop_DrawNormal	 ; Draw Chain Chomp's head

	CLC
	TYA
	ADC #$14
	STA <Temp_Var14	 ; Temp_Var14 = ending sprite offset + $14 (5 more sprites inward)

	; Temp_Var16 = 3
	LDA #$03
	STA <Temp_Var16

PRG004_BC66:
	LDA <Temp_Var16	
	ASL A	
	ASL A	
	ADC <Temp_Var16
	ADC <SlotIndexBackup
	TAY		 

	; Temp_Var1 = Chain Chomp chain link Y made relative
	LDA ChainChomp_ChainY1,Y
	SUB Level_VertScroll
	ADD #$04
	STA <Temp_Var1

	; Temp_Var2 = Chain Chomp 
	LDA ChainChomp_ChainX1,Y
	SUB <Horz_Scroll
	ADD #$04
	STA <Temp_Var2

	JSR ChainChomp_LinkVisibleTest
	BCS PRG004_BCB4	 ; If this link is not visible, jump to PRG004_BCB4

	; Temp_Var14: Current chain sprite offset
	LDA <Temp_Var14
	TAY			; Sprite Offset -> 'Y'
	SUB #$04
	STA <Temp_Var14		 ; Temp_Var14 -= 4 (one sprite prior in memory)

	; Chain Link Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Chain Link X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; Chain Link pattern
	LDA #$9b
	STA Sprite_RAM+$01,Y

	LDA Objects_Var1,X
	CMP #$2f
	LDA #$03	 ; A = 3
	BLT PRG004_BCB1	 ; If Var1 < $2F, jump to PRG004_BCB1

	LDA Level_NoStopCnt
	LSR A
	AND #$03	; Palette cycle 0-3

PRG004_BCB1:
	STA Sprite_RAM+$02,Y	 ; Store attribute

PRG004_BCB4:
	DEC <Temp_Var16		; Temp_Var16--
	BPL PRG004_BC66		; While Temp_Var16 >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

ChainChomp_MoveChain:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity
	STA <Temp_Var1		 ; Store carry flag -> Temp_Var1

	JSR Object_ApplyXVel	; Apply X velocity
	STA <Temp_Var2		 ; Store carry flag -> Temp_var2

	LDY Objects_TargetingXVal,X	 ; Y = Objects_TargetingXVal (0-3, CC's chosen direction)

	LDA <Objects_XVel,X
	BLS PRG004_BD22	 ; If Chain Chomp is moving to the left, jump to PRG004_BD22

	; Chain Chomp moving rightward version...

	LDA ChainChomp_ChainX1,X
	ADD ChainChomp_XDelta,Y	; Add X Delta for direction
	CMP <Objects_X,X
	BGE PRG004_BD1F	 	; If chain is beyong Chain Chomp, jump to PRG004_BD1F

	; Apply velocity carry
	LDA ChainChomp_ChainX1,X
	ADD <Temp_Var2	
	STA ChainChomp_ChainX1,X

	LDA ChainChomp_ChainX2,X
	ADD ChainChomp_XDelta,Y	; Add X Delta for direction
	CMP ChainChomp_ChainX1,X
	BGE PRG004_BD1F	 	; If chain link is beyond previous chain link, jump to PRG004_BD1F

	; Apply velocity carry
	LDA ChainChomp_ChainX2,X
	ADD <Temp_Var2	
	STA ChainChomp_ChainX2,X

	LDA ChainChomp_ChainX3,X
	ADD ChainChomp_XDelta,Y	; Add X Delta for direction
	CMP ChainChomp_ChainX2,X
	BGE PRG004_BD1F	 	; If chain link is beyond previous chain link, jump to PRG004_BD1F

	; Apply velocity carry
	LDA ChainChomp_ChainX3,X
	ADD <Temp_Var2	
	STA ChainChomp_ChainX3,X

	LDA ChainChomp_ChainX4,X
	ADD ChainChomp_XDelta,Y	; Add X Delta for direction
	CMP ChainChomp_ChainX3,X
	BGE PRG004_BD1F	 	; If chain link is beyond previous chain link, jump to PRG004_BD1F

	; Apply velocity carry
	LDA ChainChomp_ChainX4,X
	ADD <Temp_Var2	
	STA ChainChomp_ChainX4,X

PRG004_BD1F:
	JMP PRG004_BD75

PRG004_BD22:

	; Chain Chomp moving leftward version...

	LDA ChainChomp_ChainX1,X
	SUB ChainChomp_XDelta,Y	; Add X Delta for direction
	CMP <Objects_X,X
	BLT PRG004_BD75	 	; If chain is beyong Chain Chomp, jump to PRG004_BD75

	; Apply velocity carry
	LDA ChainChomp_ChainX1,X
	ADD <Temp_Var2	
	STA ChainChomp_ChainX1,X

	LDA ChainChomp_ChainX2,X
	SUB ChainChomp_XDelta,Y	; Add X Delta for direction
	CMP ChainChomp_ChainX1,X
	BLT PRG004_BD75	 	; If chain link is beyond previous chain link, jump to PRG004_BD75

	; Apply velocity carry
	LDA ChainChomp_ChainX2,X
	ADD <Temp_Var2	
	STA ChainChomp_ChainX2,X

	LDA ChainChomp_ChainX3,X
	SUB ChainChomp_XDelta,Y	; Add X Delta for direction
	CMP ChainChomp_ChainX2,X
	BLT PRG004_BD75	 	; If chain link is beyond previous chain link, jump to PRG004_BD75

	; Apply velocity carry
	LDA ChainChomp_ChainX3,X
	ADD <Temp_Var2	
	STA ChainChomp_ChainX3,X

	LDA ChainChomp_ChainX4,X
	SUB ChainChomp_XDelta,Y	; Add X Delta for direction
	CMP ChainChomp_ChainX3,X
	BLT PRG004_BD75	 	; If chain link is beyond previous chain link, jump to PRG004_BD75

	; Apply velocity carry
	LDA ChainChomp_ChainX4,X
	ADD <Temp_Var2	
	STA ChainChomp_ChainX4,X
 

PRG004_BD75:
	LDA <Objects_YVel,X
	BMI PRG004_BDCD	 ; If Chain Chomp is moving upward, jump to PRG004_BDCD

	; Chain Chomp moving downward version...

	LDA ChainChomp_ChainY1,X
	ADD ChainChomp_YDelta,Y	; Add Y Delta for direction
	CMP <Objects_Y,X
	BGE PRG004_BDCC	 	; If chain is beyond Chain Chomp, jump to PRG004_BDCC (RTS)

	; Apply velocity carry
	LDA ChainChomp_ChainY1,X
	ADD <Temp_Var1
	STA ChainChomp_ChainY1,X

	LDA ChainChomp_ChainY2,X
	ADD ChainChomp_YDelta,Y	; Add Y Delta for direction
	CMP ChainChomp_ChainY1,X
	BGE PRG004_BDCC	 	; If chain is beyond Chain Chomp, jump to PRG004_BDCC (RTS)

	; Apply velocity carry
	LDA ChainChomp_ChainY2,X
	ADD <Temp_Var1
	STA ChainChomp_ChainY2,X

	LDA ChainChomp_ChainY3,X
	ADD ChainChomp_YDelta,Y	; Add Y Delta for direction
	CMP ChainChomp_ChainY2,X
	BGE PRG004_BDCC	 	; If chain is beyond Chain Chomp, jump to PRG004_BDCC (RTS)

	; Apply velocity carry
	LDA ChainChomp_ChainY3,X
	ADD <Temp_Var1
	STA ChainChomp_ChainY3,X

	LDA ChainChomp_ChainY4,X
	ADD ChainChomp_YDelta,Y	; Add Y Delta for direction
	CMP ChainChomp_ChainY3,X
	BGE PRG004_BDCC	 	; If chain is beyond Chain Chomp, jump to PRG004_BDCC (RTS)

	; Apply velocity carry
	LDA ChainChomp_ChainY4,X
	ADD <Temp_Var1
	STA ChainChomp_ChainY4,X

PRG004_BDCC:
	RTS		 ; Return


PRG004_BDCD:

	; Chain Chomp moving upward version...

	LDA ChainChomp_ChainY1,X
	SUB ChainChomp_YDelta,Y	; Add Y Delta for direction
	CMP <Objects_Y,X
	BLT PRG004_BE20	 	; If chain is beyond Chain Chomp, jump to PRG004_BE20 (RTS)

	; Apply velocity carry
	LDA ChainChomp_ChainY1,X
	ADD <Temp_Var1
	STA ChainChomp_ChainY1,X

	LDA ChainChomp_ChainY2,X
	SUB ChainChomp_YDelta,Y	; Add Y Delta for direction
	CMP ChainChomp_ChainY1,X
	BLT PRG004_BE20	 	; If chain is beyond Chain Chomp, jump to PRG004_BE20 (RTS)

	; Apply velocity carry
	LDA ChainChomp_ChainY2,X
	ADD <Temp_Var1
	STA ChainChomp_ChainY2,X

	LDA ChainChomp_ChainY3,X
	SUB ChainChomp_YDelta,Y	; Add Y Delta for direction
	CMP ChainChomp_ChainY2,X
	BLT PRG004_BE20	 	; If chain is beyond Chain Chomp, jump to PRG004_BE20 (RTS)

	; Apply velocity carry
	LDA ChainChomp_ChainY3,X
	ADD <Temp_Var1
	STA ChainChomp_ChainY3,X

	LDA ChainChomp_ChainY4,X
	SUB ChainChomp_YDelta,Y	; Add Y Delta for direction
	CMP ChainChomp_ChainY3,X
	BLT PRG004_BE20	 	; If chain is beyond Chain Chomp, jump to PRG004_BE20 (RTS)

	; Apply velocity carry
	LDA ChainChomp_ChainY4,X
	ADD <Temp_Var1
	STA ChainChomp_ChainY4,X

PRG004_BE20:
	RTS		 ; Return


Object_FlipByXVel:
	LDA Objects_FlipBits,X	 
	AND #~SPR_HFLIP	; Clear horizontal flip

	LDY <Objects_XVel,X
	BEQ PRG004_BE31	 ; If not moving horizontally, jump to PRG004_BE31
	BMI PRG004_BE2E	 ; If moving to the left, jump to PRG004_BE2E

	; Moving to the right
	ORA #SPR_HFLIP	; Set horizontal flip

PRG004_BE2E:
	; Moving to the left/right
	STA Objects_FlipBits,X	 ; Set flip bits

PRG004_BE31:
	RTS		 ; Return


	; Check if a chain link sprite is visible or not
	; Carry set if not visible, cleared if it is visible
ChainChomp_LinkVisibleTest:

	LDA Objects_SprVVis,X
	BNE PRG004_BE52	 ; If any sprite is vertically off-screen, jump to PRG004_BE52

	LDA <Objects_SpriteY,X	
	CMP #200
	BGE PRG004_BE52	 ; If Sprite Y >= 200, jump to PRG004_BE52

	LDY #$40	 ; Y = $40

	LDA <Objects_SpriteX,X
	BMI PRG004_BE45	 ; If on right half, jump to PRG004_BE45

	LDY #$c0	 ; Y = $C0

PRG004_BE45:
	CPY <Temp_Var2
	EOR Objects_SprHVis,X
	BMI PRG004_BE50
	BCC PRG004_BE52
	BCS PRG004_BE54

PRG004_BE50:
	BCC PRG004_BE54

PRG004_BE52:
	SEC		 ; Set carry (link not visible)

	RTS		 ; Return

PRG004_BE54:
	CLC		 ; Clear carry (link is visible)
	RTS		 ; Return

; Rest of ROM bank was empty

