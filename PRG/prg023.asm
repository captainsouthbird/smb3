; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-01-15 12:25:51.067135346 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
Tile_Layout_TS10:
	; This defines the individual 8x8 blocks used to construct one of the tiles
	; Referenced by Address_Per_Tileset, addressed by Level_Tileset
	; Stored by upper left, then lower left, then upper right, then lower right

	; Remember that palette is determined by the upper 2 bits of a TILE (not the PATTERN)
	; I.e. tiles starting at index $00, $40, $80, $C0 are each on that respective palette

	; Upper left 8x8 pattern per tile
	.byte $FF, $FF, $FF, $05, $05, $E8, $FF, $FC, $FD, $FE, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $40, $43, $6C, $6E, $64, $68, $66, $FC, $4B, $4A, $B8, $B8 ; Tiles $20 - $2F
	.byte $B8, $B8, $BC, $5E, $5F, $FC, $FC, $05, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DC, $05, $FF, $FF, $05, $05, $05, $82, $92, $B9, $FE, $FE, $B9, $FE, $FE, $10 ; Tiles $40 - $4F
	.byte $37, $37, $11, $05, $05, $11, $05, $0A, $0C, $2A, $0A, $2A, $80, $89, $89, $D8 ; Tiles $50 - $5F
	.byte $98, $98, $98, $98, $98, $98, $92, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4, $B4 ; Tiles $60 - $6F
	.byte $B4, $B8, $C0, $C0, $C0, $C0, $A4, $EC, $E4, $C0, $13, $37, $37, $10, $11, $11 ; Tiles $70 - $7F
	.byte $FC, $BE, $B0, $8F, $05, $C4, $FE, $A9, $B9, $B9, $05, $05, $05, $CD, $FE, $CD ; Tiles $80 - $8F
	.byte $FE, $CF, $05, $A7, $9D, $CB, $09, $36, $E8, $EA, $05, $4D, $A4, $8E, $89, $80 ; Tiles $90 - $9F
	.byte $89, $90, $89, $CC, $CE, $CE, $C8, $AE, $C4, $E4, $C6, $E6, $C0, $16, $18, $16 ; Tiles $A0 - $AF
	.byte $18, $16, $18, $16, $18, $FC, $FC, $68, $64, $66, $24, $26, $B8, $E0, $C2, $E2 ; Tiles $B0 - $BF
	.byte $23, $05, $32, $05, $05, $05, $B4, $B6, $86, $AA, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $05, $B3, $CC, $FC, $C5, $C6, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $00, $01, $03, $03, $0A, $1A, $3A, $3A, $0A, $0C, $1A, $1C, $3A, $3C ; Tiles $E0 - $EF
	.byte $88, $D7, $E0, $05, $3A, $3C, $22, $45, $01, $30, $32, $34, $34, $42, $56, $FF ; Tiles $F0 - $FF

	; Lower left 8x8 pattern per tile
	.byte $FF, $FF, $FF, $06, $D6, $E9, $FF, $FC, $FD, $FE, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $50, $53, $7C, $7E, $74, $78, $76, $6A, $5B, $5A, $B9, $B9 ; Tiles $20 - $2F
	.byte $B9, $B9, $BD, $04, $04, $FC, $FC, $06, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DD, $06, $FC, $FC, $06, $06, $06, $92, $84, $B9, $A8, $A8, $90, $89, $89, $11 ; Tiles $40 - $4F
	.byte $06, $06, $12, $37, $37, $11, $06, $1A, $1C, $3A, $1A, $3A, $B9, $A8, $A8, $D9 ; Tiles $50 - $5F
	.byte $99, $99, $99, $99, $99, $99, $93, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5, $B5 ; Tiles $60 - $6F
	.byte $B5, $B9, $C1, $C1, $C1, $C1, $A5, $ED, $E4, $C1, $13, $37, $37, $11, $11, $12 ; Tiles $70 - $7F
	.byte $FC, $BF, $B0, $9F, $94, $C4, $FE, $B9, $B9, $B8, $06, $06, $06, $CD, $FE, $BA ; Tiles $80 - $8F
	.byte $8C, $8C, $8D, $BC, $06, $AF, $EC, $EE, $F8, $FA, $06, $5D, $A4, $9E, $06, $B9 ; Tiles $90 - $9F
	.byte $06, $06, $06, $CD, $FE, $CF, $C9, $AE, $D4, $F4, $D6, $F6, $D0, $24, $26, $24 ; Tiles $A0 - $AF
	.byte $26, $24, $26, $24, $26, $6A, $6A, $78, $74, $76, $24, $26, $B9, $F0, $D2, $F2 ; Tiles $B0 - $BF
	.byte $06, $06, $48, $20, $06, $21, $B7, $B7, $96, $AC, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $E6, $CD, $CD, $CD, $FE, $D6, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $30, $31, $33, $33, $2A, $2A, $0E, $1E, $2A, $2C, $2A, $2C, $0E, $2E ; Tiles $E0 - $EF
	.byte $89, $06, $E1, $06, $1E, $3E, $23, $06, $48, $06, $31, $33, $34, $39, $57, $FF ; Tiles $F0 - $FF

	; Upper right 8x8 pattern per tile	
	.byte $FF, $FF, $FF, $07, $07, $EA, $FF, $FC, $FD, $FE, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $41, $44, $6D, $6F, $65, $69, $67, $FC, $4A, $4A, $BA, $BA ; Tiles $20 - $2F
	.byte $BA, $BA, $BE, $5E, $5F, $FC, $FC, $07, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DE, $07, $FC, $FC, $07, $07, $07, $83, $93, $A8, $A8, $B9, $A8, $A8, $B9, $37 ; Tiles $40 - $4F
	.byte $37, $11, $07, $07, $11, $07, $11, $0B, $0D, $2B, $0D, $2D, $89, $89, $81, $DA ; Tiles $50 - $5F
	.byte $9A, $9A, $9A, $9A, $9A, $9A, $CA, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6, $B6 ; Tiles $60 - $6F
	.byte $B6, $BA, $C2, $C2, $C2, $C2, $A6, $EE, $E5, $C2, $37, $37, $38, $10, $11, $11 ; Tiles $70 - $7F
	.byte $FC, $BE, $B1, $07, $07, $C6, $FE, $07, $07, $07, $A9, $B9, $B9, $FE, $AD, $CF ; Tiles $80 - $8F
	.byte $FE, $AD, $A6, $07, $B3, $9D, $28, $49, $E9, $EB, $4C, $07, $A5, $8E, $89, $89 ; Tiles $90 - $9F
	.byte $81, $89, $91, $CE, $CE, $AB, $CA, $AF, $C5, $E5, $C7, $E7, $C1, $17, $19, $17 ; Tiles $A0 - $AF
	.byte $19, $17, $19, $17, $19, $FC, $FC, $69, $65, $67, $25, $27, $BA, $E1, $C3, $E3 ; Tiles $B0 - $BF
	.byte $31, $07, $33, $06, $07, $07, $B5, $07, $87, $8B, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $07, $B3, $CE, $FC, $C5, $C7, $D4, $FE, $FC ; Tiles $D0 - $DF
	.byte $AA, $AB, $02, $02, $14, $15, $0D, $1D, $3D, $2F, $0B, $0D, $1B, $1D, $3B, $3D ; Tiles $E0 - $EF
	.byte $8A, $D7, $E2, $07, $3B, $3D, $01, $14, $02, $31, $33, $33, $35, $29, $58, $FF ; Tiles $F0 - $FF

	; Lower right 8x8 pattern per tile
	.byte $FF, $FF, $FF, $08, $D6, $EB, $FF, $FC, $FD, $FE, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $00 - $0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $10 - $1F
	.byte $FF, $FF, $FF, $FF, $51, $54, $7D, $7F, $75, $79, $77, $6B, $5A, $5A, $B9, $B9 ; Tiles $20 - $2F
	.byte $B9, $B9, $BF, $04, $04, $FC, $FC, $08, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $30 - $3F
	.byte $DF, $08, $FC, $FC, $08, $08, $08, $93, $85, $FE, $FE, $B9, $89, $89, $91, $08 ; Tiles $40 - $4F
	.byte $08, $12, $37, $37, $12, $08, $11, $1B, $1D, $3B, $1D, $3D, $FE, $FE, $B9, $DB ; Tiles $50 - $5F
	.byte $9B, $9B, $9B, $9B, $9B, $9B, $CB, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7, $B7 ; Tiles $60 - $6F
	.byte $B7, $B9, $C3, $C3, $C3, $C3, $A7, $EF, $E5, $C3, $37, $37, $38, $11, $11, $12 ; Tiles $70 - $7F
	.byte $FC, $BF, $B1, $08, $95, $C6, $FE, $08, $08, $08, $B9, $B9, $B8, $FE, $AD, $8C ; Tiles $80 - $8F
	.byte $8C, $BB, $B2, $8D, $AE, $08, $ED, $EF, $F9, $FB, $5C, $08, $A5, $9E, $08, $08 ; Tiles $90 - $9F
	.byte $B9, $08, $08, $CF, $FE, $AD, $CB, $AF, $D5, $F5, $D7, $F7, $D1, $25, $27, $25 ; Tiles $A0 - $AF
	.byte $27, $25, $27, $25, $27, $6B, $6B, $79, $75, $77, $25, $27, $B9, $F1, $D3, $F3 ; Tiles $B0 - $BF
	.byte $47, $08, $32, $21, $20, $08, $08, $08, $97, $9C, $FF, $FF, $FF, $FF, $FF, $FF ; Tiles $C0 - $CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $E7, $CF, $CF, $CF, $FE, $D7, $FE, $FE, $FE ; Tiles $D0 - $DF
	.byte $AB, $AB, $32, $32, $34, $35, $2D, $2D, $2F, $3F, $2B, $2D, $2B, $2D, $0F, $2F ; Tiles $E0 - $EF
	.byte $8B, $08, $E3, $08, $1F, $3F, $46, $47, $32, $30, $32, $34, $35, $4E, $59, $FF ; Tiles $F0 - $FF

Tile_Attributes_TS10:
	.byte $24, $5C, $9C, $E2, $24, $5F, $A6, $E2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad_TS10
;
; Entry point for loading level layout data for Level_Tileset = 10
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LevelLoad_TS10:
	; Clear Tile memory
	LDY #$00	 
PRG023_A40A:
	LDA #TILE10_SKY		; just clear everything to sky	 
	JSR Tile_Mem_ClearB
	JSR Tile_Mem_ClearA
	CPY #$f0
	BNE PRG023_A40A

	JMP LevelLoad	; Begin actual level loading!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Generator_TS10
;
; Based on the values in Temp_Var15 and LL_ShapeDef, chooses an
; appropriate generator function to builds this piece of the
; level.  Tedious, but saves space and is paper-design friendly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG023_A419:
	.byte 0, 15, 30, 45, 60, 75, 90, 105

LoadLevel_Generator_TS10:
	; From level loader function:
	; * Temp_Var15, Temp_Var16, and LL_ShapeDef are three bytes read from the data


	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	TAX		 	; X = upper 3 bits of Temp_Var15 (0-7) (selects a multiple of 15 as the base)

	LDA LL_ShapeDef
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = upper 4 bits of LL_ShapeDef shifted down
	ADD PRG023_A419,X	; Add multiple of 15
	TAX
	DEX
	TXA		 ; A = ((LL_ShapeDef >> 4) + PRG023_A419[X]) - 1


	; PRG023_A419 provides values well in excess of 56, but only 56
	; addresses are defined here; reserved for expansion...

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_WoodBody		;  0 - Wood body
	.word LoadLevel_WoodBodyLong		;  1 - Long wood body
	.word LoadLevel_WoodBodyLong		;  2 - Long wood underside
	.word LoadLevel_WoodVert		;  3 - Wood vertical
	.word LoadLevel_WoodVertShortRepeat	;  4 - Short 3-high vertical log repeats
	.word LoadLevel_WoodThick		;  5 - Thick wood
	.word LoadLevel_LeftBoltThreadH		;  6 - Horizontal thread, left bolt
	.word LoadLevel_RightBoltThreadH	;  7 - Horizontal thread, right bolt
	.word LoadLevel_BottomBoltThreadV	;  8 - Vertical thread, bottom bolt
	.word LoadLevel_TopBoltThreadV		;  9 - Vertical thread, top bolt
	.word LoadLevel_MetalSupportHRun	; 10 - Metal support horizontal
	.word LoadLevel_MetalSupportLVRun	; 11 - Metal left support vertical
	.word LoadLevel_MetalSupportRVRun	; 12 - Metal right support vertical
	.word LoadLevel_WoodFloor		; 13 - Wood floor A 1
	.word LoadLevel_WoodFloor		; 14 - Wood floor A 2
	.word LoadLevel_BlockRun		; 15 - Run of bricks
	.word LoadLevel_BlockRun		; 16 - Run of '?' blocks with a coin
	.word LoadLevel_BlockRun		; 17 - Run of bricks with a coin
	.word LoadLevel_BlockRun		; 18 - Run of wood blocks
	.word LoadLevel_BlockRun		; 19 - Run of green note blocks (?)
	.word LoadLevel_BlockRun		; 20 - Run of note blocks
	.word LoadLevel_BlockRun		; 21 - Run of bouncing wood blocks
	.word LoadLevel_BlockRun		; 22 - Run of coins
	.word LoadLevel_VGroundPipeRun		; 23 - Vertical ground pipe 1 (alt level)
	.word LoadLevel_VGroundPipeRun		; 24 - Vertical ground pipe 2 (Big [?] area)
	.word LoadLevel_VGroundPipeRun		; 25 - Vertical ground pipe 3 (no entrance)
	.word LoadLevel_VCeilingPipeRun		; 26 - Vertical ceiling pipe 1 (alt level)
	.word LoadLevel_VCeilingPipeRun		; 27 - Vertical ceiling pipe 2 (no entrance)
	.word LoadLevel_HRightWallPipeRun	; 28 - Horizontal right-hand wall pipe (alt level)
	.word LoadLevel_HRightWallPipeRun	; 29 - Horizontal right-hand wall pipe (no entrance)
	.word LoadLevel_HLeftWallPipeRun	; 30 - Horizontal left-hand wall pipe (alt level)
	.word LoadLevel_HLeftWallPipeRun	; 31 - Horizontal left-hand wall pipe (no entrance)
	.word LoadLevel_Cannon			; 32 - Bullet bill cannon
	.word LoadLevel_CCBridge		; 33 - Cheep-Cheep style 'oo' bridge
	.word LoadLevel_CCBridge		; 34 - Would result in empty tiles?  (form of 33)
	.word LoadLevel_TopDecoBlocks		; 35 - Top-Deco Rectangle Waterfall
	.word LoadLevel_TopDecoBlocks		; 36 - Top-Deco Rectangle Left waving water pool
	.word LoadLevel_TopDecoBlocks		; 37 - Top-Deco Rectangle No current waving water pool
	.word LoadLevel_TopDecoBlocks		; 38 - Top-Deco Rectangle Right waving water pool
	.word LoadLevel_TopDecoBlocks		; 39 - Top-Deco Rectangle Water wrong-way BG
	.word LoadLevel_TopDecoBlocks		; 40 - Top-Deco Rectangle Diamond blocks (not really any deco on top)
	.word LoadLevel_TopDecoBlocks		; 41 - Top-Deco Rectangle Sand ground 
	.word LoadLevel_TopDecoBlocks		; 42 - Top-Deco Rectangle orange block??
	.word LoadLevel_IceBricks		; 43 - Run of ice bricks
	.word LoadLevel_VTransitPipeRun		; 44 - Vertical in-level transit pipe
	.word LoadLevel_WoodFloor2		; 45 - Wood floor B
	.word LoadLevel_RopeRailing		; 46 - Rope railing
	.word LoadLevel_WarGround		; 47 - Run of war ground
	.word LoadLevel_MetalPlate		; 48 - Rectangle of metal plate
	.word LoadLevel_Crate			; 49 - Crate
	.word LoadLevel_Portholes		; 50 - Portholes
	.word LoadLevel_DoubleTipBodyWood	; 51 - Double-tipped long body wood
	.word LoadLevel_BigCannonLeft		; 52 - Leftward facing big cannon
	.word LoadLevel_BigCannonRight		; 53 - Rightward facing big cannon
	.word LoadLevel_LittleCannon		; 54 - Leftward facing little cannon
	.word LoadLevel_TankTread			; 55 - Tank Tread (obviously only valid with W8 animations)
	.word LoadLevel_InvisibleSolid		; 56 - Invisible solid block


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LeveLoad_FixedSizeGen_TS10
;
; Much simpler generators that are fixed-size, commonly used for 
; just single tile placement styles (although a couple relatively 
; complex ones exist in here as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LeveLoad_FixedSizeGen_TS10:
	; It is verified before calling this function that all of
	; the upper 4 bits of LL_ShapeDef are ZERO

	; So the upper 3 bits of Temp_Var15 serve as the most significant bits
	; to a value where LL_ShapeDef provide the 4 least significant bits

	LDA <Temp_Var15
	AND #%11100000
	LSR A		
	ADD LL_ShapeDef	
	TAX		 	; Resultant index is put into 'X'
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LoadLevel_AirshipMisc		;  0 - Horizontal screw tile
	.word LoadLevel_AirshipMisc		;  1 - Horizontal flamejet tile
	.word LoadLevel_AirshipMisc		;  2 - Vertical flamejet tile
	.word LoadLevel_AirshipMisc		;  3 - Short wood tip
	.word LoadLevel_AirshipMisc		;  4 - Stowed anchor
	.word LoadLevel_AirshipMisc		;  5 - Vertical screw tile
	.word LoadLevel_AirshipMisc		;  6 - Upright cannon pointed left
	.word LoadLevel_AirshipMisc		;  7 - Upright cannon pointed right
	.word LoadLevel_AirshipMisc		;  8 - Ceiling cannon pointed left
	.word LoadLevel_AirshipMisc		;  9 - Ceiling cannon pointed right
	.word LoadLevel_4WayCannon90		; 10 - 4-way ceiling mounted cannon at 90 degrees
	.word LoadLevel_4WayCannon45		; 11 - 4-way ceiling mounted cannon at 45 degrees
	.word LoadLevel_WallCannonF		; 12 - Wall cannon "forward" (like the slash)
	.word LoadLevel_WallCannonB		; 13 - Wall cannon "backward" (like the slash)
	.word LoadLevel_MetalSquare		; 14 - Metal support square
	.word LoadLevel_Black14Rows		; 15 - 14 rows of black
	.word LoadLevel_PowerBlock		; 16 - ? block with flower
	.word LoadLevel_PowerBlock		; 17 - ? block with leaf 
	.word LoadLevel_PowerBlock		; 18 - ? block with star
	.word LoadLevel_PowerBlock		; 19 - ? block with coin OR star
	.word LoadLevel_PowerBlock		; 20 - ? block with coin (??)
	.word LoadLevel_PowerBlock		; 21 - Muncher Plant!
	.word LoadLevel_PowerBlock		; 22 - Brick with flower
	.word LoadLevel_PowerBlock		; 23 - Brick with leaf
	.word LoadLevel_PowerBlock		; 24 - Brick with star
	.word LoadLevel_PowerBlock		; 25 - Brick with coin OR star
	.word LoadLevel_PowerBlock		; 26 - Brick with 10-coin
	.word LoadLevel_PowerBlock		; 27 - Brick with 1-up
	.word LoadLevel_PowerBlock		; 28 - Brick with vine
	.word LoadLevel_PowerBlock		; 29 - Brick with P-Switch
	.word LoadLevel_PowerBlock		; 30 - Invisible coin
	.word LoadLevel_PowerBlock		; 31 - Invisible 1-up
	.word LoadLevel_PowerBlock		; 32 - Invisible note
	.word LoadLevel_PowerBlock		; 33 - Note block with flower
	.word LoadLevel_PowerBlock		; 34 - Note block with leaf
	.word LoadLevel_PowerBlock		; 35 - Note block with star
	.word LoadLevel_PowerBlock		; 36 - Wood block with flower
	.word LoadLevel_PowerBlock		; 37 - Wood block with leaf
	.word LoadLevel_PowerBlock		; 38 - Wood block with star
	.word LoadLevel_PowerBlock		; 39 - Invisible note to coin heaven
	.word LoadLevel_PowerBlock		; 40 - P-Switch
	.word LoadLevel_EndGoal			; 41 - The end goal
	.word LoadLevel_WoodTipsUnderside	; 42 - Wooden tips
	.word LoadLevel_WoodTipsUnderside	; 43 - Wooden underside curve
	.word LoadLevel_TankPrefab1		; 44 - Tank prefabricated 1
	.word LoadLevel_TankPrefab2		; 45 - Tank prefabricated 2
	.word LoadLevel_IntroAirship		; 46 - The airship front from the run n' jump intro
	.word LoadLevel_Ledge			; 47 - Ledge tile
	.word LoadLevel_RockyWrenchHole		; 48 - Rocky's hole
	.word LoadLevel_MiniShip		; 49 - World 8 mini ship 1
	.word LoadLevel_MiniShip		; 50 - World 8 mini ship 2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WoodBody
;
; Generates a 1-16 length log as part of the airship body
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_WoodBody:
	.byte TILE10_WOODH_L, TILE10_WOODBOTTOM_L
	.byte TILE10_WOODH_M1, TILE10_WOODBOTTOM_M1
	.byte TILE10_WOODH_M2, TILE10_WOODBOTTOM_M2
	.byte TILE10_WOODH_R, TILE10_WOODBOTTOM_R

LoadLevel_WoodBody:
	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDX #$00	 	; X = 0
PRG023_A532:
	LDY TileAddr_Off 	; Y = TileAddr_Off

	LDA LL_WoodBody,X	; Get wood body left tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEC <Temp_Var3		 ; Temp_Var3--
	BEQ PRG023_A559	 	; If Temp_Var3 = 0, jump to PRG023_A559

PRG023_A541:
	LDA LL_WoodBody+2,X	 ; Get wood body middle 1
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var3		 ; Temp_Var3--
	BEQ PRG023_A559	 	; If Temp_Var3 = 0, jump to PRG023_A559

	LDA LL_WoodBody+4,X	 ; Get wood body middle 2
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column

	DEC <Temp_Var3		 ; Temp_Var3--
	BNE PRG023_A541	 	; While Temp_Var3 > 0, loop

PRG023_A559:
	LDA LL_WoodBody+6,X	 ; Get woody body right
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WoodBodyLong
;
; Generates a 1-256 length log OR bottom as part of the airship body
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_WoodBodyLong:
	JSR LL23_GetLayoutByte_AndBackup	; Get byte from layout -> Temp_Var3, and backup Map_Tile_AddrL/H into Temp_Var1/2
	LDX #$00	 ; X = 0

	LDA LL_ShapeDef
	SUB #$20	
	LSR A		
	LSR A
	LSR A
	LSR A
	TAX		 ; X = relative index
	JMP PRG023_A532	 ; Jump to PRG023_A532


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WoodVert
;
; Generates a 1-16 high log as part of the airship body
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_WoodVert:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

PRG023_A578:
	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA #TILE10_WOODV_T	; Vertical wood top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG023_A598	 	; Jump to PRG023_A598

PRG023_A582:
	LDA #TILE10_WOODV_M1	; Vertical wood middle 1
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BEQ PRG023_A5A6	 ; If X = 0, jump to PRG023_A5A6

	LDA #TILE10_WOODV_M2	; Vertical wood middle 2
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG023_A598:
	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BNE PRG023_A582	 ; While X > 0, loop

PRG023_A5A6:
	LDA #TILE10_WOODV_B	; Vertical wood bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WoodVertShortRepeat
;
; Generates a 1-16 repeat of 3-tile high vertical logs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_WoodVertShortRepeat:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

PRG023_A5BA:
	LDX #$02	
	JSR PRG023_A578	 ; Generate 3 high vertical log

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	LDY TileAddr_Off 		; Y = TileAddr_Off
	JSR LoadLevel_NextColumn	; Next column
	STY TileAddr_Off 		; TileAddr_Off = Y

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG023_A5BA	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WoodThick
;
; Generates a 1-16 height "thick" wood
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_WoodThick:
	.byte TILE10_WOODTHICK_UL, TILE10_WOODTHICK_UR
	.byte TILE10_WOODTHICK_M1L, TILE10_WOODTHICK_M1R
	.byte TILE10_WOODTHICK_M2L, TILE10_WOODTHICK_M2R
	.byte TILE10_WOODTHICK_LL, TILE10_WOODTHICK_LR

LoadLevel_WoodThick:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDX #$00	 ; X = 0

PRG023_A5F6:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA LL_WoodThick,X	 ; Get wood thick tile top
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEC <Temp_Var4		 ; Temp_Var4--
	BEQ PRG023_A639	 	; If Temp_Var4 = 0, jump to PRG023_A639

PRG023_A611:
	LDA LL_WoodThick+2,X	 ; Get wood thick tile middle 1
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEC <Temp_Var4		 ; Temp_Var4--
	BEQ PRG023_A639	 	; If Temp_Var4 = 0, jump to PRG023_A639

	LDA LL_WoodThick+4,X	 ; Get wood thick tile middle 2
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEC <Temp_Var4		 ; Temp_Var4--
	BNE PRG023_A611	 ; While Temp_Var4 > 0, loop

PRG023_A639:
	LDA LL_WoodThick+6,X	 ; Get wood thick tile bottom
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	LDY TileAddr_Off ; Y = TileAddr_Off

	JSR LoadLevel_NextColumn	 ; Next column

	STY TileAddr_Off ; TileAddr_Off = Y

	INX		 ; X++ (do other side now)
	CPX #$02
	BNE PRG023_A5F6	 ; If X <> 2, jump to PRG023_A5F6

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LeftBoltThreadH
;
; Generates a 1-16 width bolt and thread, bolt on the left
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LeftBoltThreadH:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA #TILE10_BOLT_H	 ; Horizontal bolt
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG023_A669	 	; Jump to PRG023_A669

PRG023_A665:
	LDA #TILE10_THREAD_H	; Thread horizontal
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG023_A669:
	JSR LoadLevel_NextColumn ; Next column
	DEX		 	; X--
	BPL PRG023_A665	 	; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_RightBoltThreadH
;
; Generates a 1-16 width bolt and thread, bolt on the right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_RightBoltThreadH:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	CPX #$00
	BEQ PRG023_A687	 ; If X = 0, jump to PRG023_A687

PRG023_A67D:
	LDA #TILE10_THREAD_H	; Horizontal thread
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BNE PRG023_A67D	 ; While X >= 0, loop

PRG023_A687:
	LDA #TILE10_BOLT_H	; Horizontal bolt
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BottomBoltThreadV
;
; Generates a 1-16 height bolt and thread, bolt on the bottom
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BottomBoltThreadV:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 	; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off 	; Y = TileAddr_Off

PRG023_A695:
	LDA #TILE10_THREAD_V	; Vertical thread
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BNE PRG023_A695	 ; While X > 0, loop

	LDA #TILE10_BOLT_V	; Vertical bolt
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_TopBoltThreadV
;
; Generates a 1-16 height bolt and thread, bolt on the top
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_TopBoltThreadV:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA #TILE10_BOLT_V	; Vertical bolt
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JMP PRG023_A6C0	 ; Jump to PRG023_A6C0

PRG023_A6BC:
	LDA #TILE10_THREAD_V	; Vertical thread
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG023_A6C0:
	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BPL PRG023_A6BC	 ; While X >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_MetalSupportHRun
;
; Generates a 1-16 width horizontal metal support
; See LoadLevel_MetalSupport[L/R]VRun; these horizontals should be
; placed FIRST because the vertical run has intersect code, but
; this does not...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_MetalSupportHRun:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

PRG023_A6D8:
	LDA #TILE10_METSUPPORT_UM	; Metal support upper middle
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	JSR LoadLevel_NextColumn	; Next column

	DEX		 ; X--
	BPL PRG023_A6D8	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_MetalSupportLVRun
;
; Generates a 1-16 height vertical metal support, which also
; looks for intersecting horizontal runs and adds appropriate
; junctions at corners... so horizontal comes first
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_MetalSupportLVRun:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA [Map_Tile_AddrL],Y	 	; Get tile here
	CMP #TILE10_METSUPPORT_UM
	BNE PRG023_A6F7	 		; If tile is not a middle support bar, jump to PRG023_A6F7

	LDA #TILE10_METSUPPORT_UL	; Otherwise, we need a vertical/horizontal junction
	JMP PRG023_A6F9	 	; Jump to PRG023_A6F9

PRG023_A6F7:
	LDA #TILE10_METSUPPORT_LT	; Just the upward bar

PRG023_A6F9:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG023_A702	 	; Jump to PRG023_A702

PRG023_A6FE:
	LDA #TILE10_METSUPPORT_LM	; Middle vertical bar
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

PRG023_A702:
	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BNE PRG023_A6FE	 ; While X >= 0, loop

	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE10_METSUPPORT_UM
	BNE PRG023_A71B	 	; If tile here is not a middle support bar, jump to PRG023_A71B

	LDA #TILE10_METSUPPORT_LL	; Metal support bar lower junction with horizontal
	JMP PRG023_A71D	 	; Jump to PRG023_A71D

PRG023_A71B:
	LDA #TILE10_METSUPPORT_LB	; Bottom vertical piece

PRG023_A71D:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_MetalSupportRVRun
;
; Generates a 1-16 height vertical metal support, which also
; looks for intersecting horizontal runs and adds appropriate
; junctions at corners... so horizontal comes first
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_MetalSupportRVRun:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE10_METSUPPORT_UM
	BNE PRG023_A734		 ; If tile is not a middle support bar, jump to PRG023_A734

	LDA #TILE10_METSUPPORT_UR
	JMP PRG023_A736	 ; Jump to PRG023_A736

PRG023_A734:
	LDA #TILE10_METSUPPORT_RT	; Right side top metal support

PRG023_A736:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG023_A73F	 	; Jump to PRG023_A73F

PRG023_A73B:
	LDA #TILE10_METSUPPORT_RM	; Right side middle metal support
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG023_A73F:
	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BNE PRG023_A73B	 ; While X > 0, loop

	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	CMP #TILE10_METSUPPORT_UM
	BNE PRG023_A758	 	; If tile is not a middle support bar, jump to PRG023_A758

	LDA #TILE10_METSUPPORT_LR
	JMP PRG023_A75A	 ; Jump to PRG023_A75A

PRG023_A758:
	LDA #TILE10_METSUPPORT_RB

PRG023_A75A:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WoodFloor
;
; Generates a 1-16 width bit of wood floor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_WoodFloor:
	.byte TILE10_WOODFLOOR_THK_L, TILE10_WOODFLOOR_2
	.byte TILE10_WOODFLOOR_1, TILE10_WOODFLOOR_3

LoadLevel_WoodFloor:
	LDA LL_ShapeDef
	PHA		 ; Save LL_ShapeDef

	SUB #$e0
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 ; X = relative index

	PLA		 ; Restore LL_ShapeDef
	AND #$0f	 
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA LL_WoodFloor,X	 ; Get wood floor tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG023_A782	 	; Jump to PRG023_A782

PRG023_A77D:
	LDA LL_WoodFloor+2,X	 ; Get wood floor tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG023_A782:

	; Go to next row by adding 16 -- WARNING: Not protected!
	TYA
	ADD #16
	TAY

	DEC <Temp_Var3		 ; Temp_Var3--
	BPL PRG023_A77D	 	; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WoodFloor2
;
; Generates a 1-16 width bit of wood floor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_WoodFloor2:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

PRG023_A795:
	LDA #TILE10_WOODFLOOR_THK_R
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BPL PRG023_A795	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_RopeRailing
;
; Generates a 1-16 width of rope railing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_RopeRailing:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef
	LDY TileAddr_Off ; Y = TileAddr_Off

PRG023_A7A9:
	LDA #TILE10_ROPERAIL	; Rope railing
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BNE PRG023_A7A9	 ; $A7B1 

	LDA #TILE10_ROPERAIL_END
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WarGround
;
; Generates a 1-16 width run of "War Ground"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_WarGround:
	.byte TILE10_WARGROUND_UL, TILE10_WARGROUND_LL
	.byte TILE10_WARGROUND_UR, TILE10_WARGROUND_LR

LoadLevel_WarGround:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDX #$00	 ; X = 0

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3	 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

PRG023_A7D0:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

PRG023_A7D4:
	LDA LL_WarGround,X	 ; Get war ground left tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEC <Temp_Var4		 ; Temp_Var4--
	BMI PRG023_A7EC	 	; If Temp_Var4 < 0, jump to PRG023_A7EC

	LDA LL_WarGround+2,X	 ; Get war ground right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEC <Temp_Var4	 ; Temp_Var4--
	BPL PRG023_A7D4	 ; While Temp_Var4 >= 0, loop

PRG023_A7EC:
	JSR LL23_ReturnTileAndNextRow	 ; Return to beginning, then go to next row

	INX		 ; X++ (next row of war ground)
	CPX #$02
	BNE PRG023_A7D0	 ; If X <> 2, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Crate
;
; Produces a variable middle width large crate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_Crate:
	.byte TILE10_CRATE_UL, TILE10_CRATE_ML, TILE10_CRATE_LL, TILE10_CRATE_UM, TILE10_CRATE_MM, TILE10_CRATE_LM, TILE10_CRATE_UR, TILE10_CRATE_MR, TILE10_CRATE_LR

LoadLevel_Crate:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDX #$00	 ; X = 0

	LDA #$03
	STA <Temp_Var5	 ; Temp_Var5 = 3

PRG023_A816:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

	LDA LL_Crate,X	 	 ; Get crate left tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG023_A827	 	 ; Jump to PRG023_A827
 
PRG023_A822:
	LDA LL_Crate+3,X	 ; Get crate middle tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG023_A827:
	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4--
	BNE PRG023_A822	 	; While Temp_Var4 >= 0, loop

	LDA LL_Crate+6,X	 ; Get crate right tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LL23_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	LDX #$01	 ; X = 1 (middle of crate)
	DEC <Temp_Var5	 ; Temp_Var5--
	BNE PRG023_A841	 ; If Temp_Var5 <> 0, jump to PRG023_A841

	LDX #$02	 ; X = 2 (right of crate)
	JMP PRG023_A816	 ; Jump to PRG023_A816

PRG023_A841:
	BPL PRG023_A816	 ; While Temp_Var5 >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_MetalPlate
;
; Rectangle of metal plate 1-256 width x 1-16 height
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_MetalPlate:
	.byte TILE10_METALPLATE_UL, TILE10_METSUPPORT_ML, TILE10_METALPLATE_LL
	.byte TILE10_METALPLATE_UM, TILE10_METALBG, TILE10_METALPLATE_LM
	.byte TILE10_METALPLATE_UR, TILE10_METSUPPORT_MR, TILE10_METALPLATE_LR

LoadLevel_MetalPlate:
	JSR LL23_GetLayoutByte_AndBackup	; Get byte from layout -> Temp_Var3, and backup Map_Tile_AddrL/H into Temp_Var1/2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var5		 ; Temp_Var5 = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDX #$00	 ; X = 0

PRG023_A85C:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3 (width copy)

	LDA LL_MetalPlate,X	 ; Get left metal plate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JMP PRG023_A86D	 	; Jump to PRG023_A86D

PRG023_A868:
	LDA LL_MetalPlate+3,X	 ; Get middle metal plate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

PRG023_A86D:
	JSR LoadLevel_NextColumn	 ; Next column

	DEC <Temp_Var4	 ; Temp_Var4-- (width decrement)
	BNE PRG023_A868	 ; While Temp_Var4 > 0, loop

	LDA LL_MetalPlate+6,X	 ; Get right metal plate tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LL23_ReturnTileAndNextRow	 ; Return to beginning, then go to next row

	LDX #$01	 ; X = 1

	DEC <Temp_Var5	 ; Temp_Var5-- (height decrement)
	BNE PRG023_A887	 ; While Temp_Var5 > 0, loop

	LDX #$02	 ; X = 2
	JMP PRG023_A85C	 ; Jump to PRG023_A85C

PRG023_A887:
	BPL $A85C	 ; $A887 
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_AirshipMisc
;
; Inserts one of a handful of miscellaneous tiles
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_AirshipMisc:
	.byte TILE10_SCREW_H, TILE10_FLAMEJET_H, TILE10_FLAMEJET_V, TILE10_WOODTIP_SHORT, TILE10_STOWEDANCHOR
	.byte TILE10_SCREW_V, TILE10_UPRIGHTCANNON_L, TILE10_UPRIGHTCANNON_R, TILE10_CEILINGCANNON_L, TILE10_CEILINGCANNON_R

LoadLevel_AirshipMisc:
	LDX LL_ShapeDef	 	; X = index
	LDY TileAddr_Off 	; Y = TileAddr_Off
	LDA LL_AirshipMisc,X	; Get misc tile
	STA [Map_Tile_AddrL],Y	; Store into tile mem
	RTS		 	; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_4WayCannon90
;
; Inserts a ceiling mounted 4-way cannon at 90 degrees
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; These are lumped together since they all require essentially the same insertion routine
LL_4WayCannon90:
	.byte TILE10_4WAYCANNON_MNT_L, TILE10_4WAYCANNON_MNT_R
	.byte TILE10_4WAYCANNON_90_UL, TILE10_4WAYCANNON_90_UR, TILE10_4WAYCANNON_90_LL, TILE10_4WAYCANNON_90_LR

LL_4WayCannon45:
	.byte TILE10_4WAYCANNON_MNT_L, TILE10_4WAYCANNON_MNT_R
	.byte TILE10_4WAYCANNON_45_UL, TILE10_4WAYCANNON_45_UR, TILE10_4WAYCANNON_45_LL, TILE10_4WAYCANNON_45_LR

LL_WallCannonF:	.byte TILE10_WALLCANNONF_UL, TILE10_WALLCANNONF_UR, TILE10_WALLCANNONF_LL, TILE10_WALLCANNONF_LR
LL_WallCannonB:	.byte TILE10_WALLCANNONB_UL, TILE10_WALLCANNONB_LL, TILE10_WALLCANNONB_UR, TILE10_WALLCANNONB_LR
LL_SupportSqr:	.byte TILE10_SUPPORT_UL, TILE10_SUPPORT_UR, TILE10_SUPPORT_LL, TILE10_SUPPORT_LR

LoadLevel_4WayCannon90:
	LDX #$00	 ; 90 degrees aligned 4-way cannon
	JMP PRG023_A8BF	 ; Jump to PRG023_A8BF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_4WayCannon45
;
; Inserts a ceiling mounted 4-way cannon at 45 degrees
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_4WayCannon45:
	LDX #(LL_4WayCannon45 - LL_4WayCannon90)	; 45 degrees aligned 4-way cannon

PRG023_A8BF:
	LDA #(LL_4WayCannon45 - LL_4WayCannon90)
	STA <Temp_Var3		 ; Temp_Var3 = Number of tiles to copy

PRG023_A8C3:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDY TileAddr_Off ; Y = TileAddr_Off

PRG023_A8CE:
	LDA LL_4WayCannon90,X	 ; Get tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	DEC <Temp_Var3	 ; Temp_Var3-- (tile counter decrement)
	INX		 ; X++
	TXA		 
	AND #$01	 
	BNE PRG023_A8CE	 ; New row every 2 tiles

	JSR LL23_ReturnTileAndNextRow	 ; Return to beginning, then go to next row

	LDA <Temp_Var3	
	BNE PRG023_A8CE	 ; If Temp_Var3 > 0 (tiles to go), loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WallCannonF
;
; Inserts a "forward" wall mounted cannon
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_WallCannonF:
	LDX #(LL_WallCannonF - LL_4WayCannon90)	; Wall mounted cannon forward (like a slash)
	JMP PRG023_A8ED	 ; Jump to PRG023_A8ED

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WallCannonB
;
; Inserts a "backward" wall mounted cannon
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_WallCannonB:
	LDX #(LL_WallCannonB - LL_4WayCannon90)	; Wall mounted cannon backward (like a slash)

PRG023_A8ED:
	LDA #$04	 ; #(LL_WallCannonB - LL_WallCannonF)
	STA <Temp_Var3	 ; Temp_Var3 = appropriate number of tiles for wall-mounted cannon

	JMP PRG023_A8C3	 ; Jump to PRG023_A8C3


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_MetalSquare
;
; Inserts a metal square support
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_MetalSquare:
	LDX #(LL_SupportSqr - LL_4WayCannon90)	; Metal support square
	JMP PRG023_A8ED	 ; Jump to PRG023_A8ED

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_WoodTipsUnderside
;
; Inserts a 2-tile wooden tip or underside curve
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_WoodTipsUnderside:
	.byte TILE10_WOODTIP_LONGL, TILE10_WOODUNDERCURVE_L, TILE10_WOODTIP_LONGR, TILE10_WOODUNDERCURVE_R

LoadLevel_WoodTipsUnderside:
	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA LL_ShapeDef	 
	SUB #$0a	 
	TAX		 ; X = relative index

	LDA LL_WoodTipsUnderside,X	; Wooden tips and underside left tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	JSR LoadLevel_NextColumn	; Next column

	LDA LL_WoodTipsUnderside+2,X	; Wooden tips and underside right tile
	STA [Map_Tile_AddrL],Y	 	; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Portholes
;
; Run of 1-16 porthole windows, spaced one tile in between
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Portholes:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

PRG023_A91E:
	LDA #TILE10_PORTHOLE	 ; Porthole (circular window) tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column
	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BPL PRG023_A91E	 ; While X >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_DoubleTipBodyWood
;
; Long 1-256 width run of body wood, with blunt tips on both ends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_DoubleTipBodyWood:
	JSR LL23_GetLayoutByte_AndBackup	; Get byte from layout -> Temp_Var3, and backup Map_Tile_AddrL/H into Temp_Var1/2

	LDX <Temp_Var3	 	  ; X = Temp_Var3
	LDY TileAddr_Off 	  ; Y = TileAddr_Off
	LDA #TILE10_WOODTIP_SHORT ; Blunt wood tip in front
	JMP PRG023_A945		  ; Jump to PRG023_A945

PRG023_A939:
	LDA #TILE10_WOODH_M1	; Wood body horizontal middle 1
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEX		 ; X--
	BEQ PRG023_A94D	 ; If X = 0, jump to PRG023_A94D

	LDA #TILE10_WOODH_M2	 ; Wood body horizontal middle 2

PRG023_A945:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column
	DEX		 ; X--
	BNE PRG023_A939	 ; If X <> 0, jump to PRG023_A939

PRG023_A94D:
	LDA #TILE10_REARTIP	; Rear wood tip
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BigCannonLeft
;
; Generate a leftward facing 1-16 width "big cannon"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_BigCannon:	.byte TILE10_BIGCANNONEND_T, TILE10_BIGCANNONEND_B, TILE10_BIGCANNONMID_T, TILE10_BIGCANNONMID_B

LoadLevel_BigCannonLeft:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDX #$00	 ; X = 0
	LDY TileAddr_Off ; Y = TileAddr_Off

PRG023_A96A:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

	LDA LL_BigCannon,X	 ; Get big cannon end tile
	JMP PRG023_A977	 	; Jump to PRG023_A977

PRG023_A974:
	LDA LL_BigCannon+2,X	 ; Get big cannon mid tile

PRG023_A977:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4--
	BPL PRG023_A974	 	; While Temp_Var4 >= 0, loop

	JSR LL23_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	INX		 ; X++
	CPX #$02
	BNE PRG023_A96A	 ; If X <> 2, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_BigCannonRight
;
; Generate a rightward facing 1-16 width "big cannon"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_BigCannonRight:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	AND #$0f
	STA <Temp_Var3		 ; Temp_Var3 = lower 4 bits of LL_ShapeDef

	LDX #$00	 	; X = 0
	LDY TileAddr_Off 	; Y = TileAddr_Off

PRG023_A99D:
	LDA <Temp_Var3
	STA <Temp_Var4		 ; Temp_Var4 = Temp_Var3

PRG023_A9A1:
	LDA LL_BigCannon+2,X	 ; Get big cannon middle tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column
	DEC <Temp_Var4		 ; Temp_Var4--
	BNE PRG023_A9A1	 	; While Temp_Var4 > 0, loop

	LDA LL_BigCannon,X	 ; Get big cannon end tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LL23_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	INX		 ; X++
	CPX #$02
	BNE PRG023_A99D	 ; If X <> 2, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_LittleCannon
;
; Generate a leftward facing 1-16 width "little cannon"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_LittleCannon:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA #TILE10_LILCANNON_END	; End of little cannon
	JMP PRG023_A9CB	 ; Jump to PRG023_A9CB

PRG023_A9C9:
	LDA #TILE10_LILCANNON_MID	; Mid part of little cannon

PRG023_A9CB:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn	 ; Next column

	DEX		 ; X--
	BPL PRG023_A9C9	 ; While X >= 0, loop
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_TankTread
;
; Forms a 1-16 width tank tread (only valid with W8 tank anims)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_TankTread:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDA #TILE10_WALLCANNONB_UL
	JMP PRG023_A9E4	 ; Jump to PRG023_A9E4

PRG023_A9E2:
	LDA #TILE10_METALPLATE_UL

PRG023_A9E4:
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn ; Next column

	DEX		 ; X--
	BNE PRG023_A9E2	 ; While X > 0, loop

	LDA #TILE10_WALLCANNONB_LL
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Black14Rows
;
; Adds 14 rows of entire-screen-width black tiles; NOTE!  Must be
; aligned to left edge of screen!  Does not use common "next 
; column" function and doesn't check for wraps...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Black14Rows:
	LDA #14
	STA <Temp_Var1	 	; Temp_Var1 = 14 (number of rows)
	LDY TileAddr_Off 	; Y = TileAddr_Off

PRG023_A9F8:
	LDA #TILE10_BLACK	; Black tile
	STA [Map_Tile_AddrL],Y	; Store into tile mem

	INY		 	; Next column
	TYA
	AND #$0f
	BNE PRG023_A9F8	 	; If we haven't crossed to a new row, jump to PRG023_A9F8

	DEC <Temp_Var1		 ; Temp_Var1-- (one less row)
	BPL PRG023_A9F8	 	; While Temp_Var1 >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_TankPrefab1
;
; One of the tanks, prefabricated
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_TankPrefab1:
	LDX #$00	 ; X = 0 (first prefab)
	JMP PRG023_AA6D	 ; Jump to PRG023_AA6D

	; $FF is a terminator for any row, and five rows are processed
LL_TankPrefab1:
	.byte TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_ROCKYWRENCH_HOLE, TILE10_SKY, TILE10_SKY, $FF
	.byte TILE10_SKY, TILE10_SKY, TILE10_LEDGE, TILE10_WOODH_M1, TILE10_WOODH_R, TILE10_SKY, $FF
	.byte TILE10_LILCANNON_END, TILE10_LILCANNON_MID, TILE10_WOODH_L, TILE10_WOODH_M2, TILE10_REARTIP, TILE10_SKY, $FF
	.byte TILE10_SKY, TILE10_LEDGE, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_R, $FF
	.byte TILE10_SKY, TILE10_WALLCANNONB_UL, TILE10_METALPLATE_UL, TILE10_METALPLATE_UL, TILE10_METALPLATE_UL, TILE10_WALLCANNONB_LL, $FF

LL_TankPrefab2:
	.byte TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_ROCKYWRENCH_HOLE, TILE10_SKY, TILE10_WALLCANNONB_UR, TILE10_SKY, TILE10_SKY, TILE10_SKY, $FF
	.byte TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_LEDGE, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_R, TILE10_SKY, TILE10_SKY, TILE10_SKY, $FF
	.byte TILE10_LILCANNON_END, TILE10_LILCANNON_MID, TILE10_LILCANNON_MID, TILE10_WOODH_L, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_REARTIP, TILE10_SKY, TILE10_SKY, TILE10_SKY, $FF
	.byte TILE10_SKY, TILE10_LEDGE, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_REARTIP, $FF
	.byte TILE10_SKY, TILE10_WALLCANNONB_UL, TILE10_METALPLATE_UL, TILE10_METALPLATE_UL, TILE10_METALPLATE_UL, TILE10_METALPLATE_UL, TILE10_METALPLATE_UL, TILE10_METALPLATE_UL, TILE10_METALPLATE_UL, TILE10_WALLCANNONB_LL, TILE10_SKY, $FF


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_TankPrefab2
;
; One of the tanks, prefabricated
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_TankPrefab2:
	LDX #(LL_TankPrefab2 - LL_TankPrefab1)

PRG023_AA6D:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA #$04	 
	STA <Temp_Var4	 ; Temp_Var4 = 4

PRG023_AA79:
	LDY TileAddr_Off 	; Y = TileAddr_Off
PRG023_AA7C:
	LDA LL_TankPrefab1,X	; Get airship prefab tile

	CMP #$ff
	BEQ PRG023_AA8C	 ; If it's a terminator, jump to PRG023_AA8C

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++ (next prefab tile)
	JMP PRG023_AA7C	 ; Jump to PRG023_AA7C

PRG023_AA8C:
	JSR LL23_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	INX		 ; X++ (next prefab tile)

	DEC <Temp_Var4	 ; Temp_Var4-- (row decrement)
	BPL PRG023_AA79	 ; While Temp_Var4 >= 0, loop

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_IntroAirship
;
; The airship front from player's run and jump to the anchor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LL_IntroAirship:
	.byte TILE10_WOODTIP_SHORT, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_R, $FF
	.byte TILE10_SKY, TILE10_WOODTIP_SHORT, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_R, $FF
	.byte TILE10_SKY, TILE10_SKY, TILE10_WOODTIP_SHORT, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_R, $FF
	.byte TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_WOODTIP_LONGL, TILE10_WOODTIP_LONGR, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_R, $FF
	.byte TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_WOODUNDERCURVE_L, TILE10_WOODUNDERCURVE_R, TILE10_WOODBOTTOM_M1, TILE10_WOODBOTTOM_M2, TILE10_WOODBOTTOM_M1, TILE10_WOODBOTTOM_M2, TILE10_WOODBOTTOM_M1, TILE10_WOODBOTTOM_M2, TILE10_WOODBOTTOM_M1, TILE10_WOODBOTTOM_M2, TILE10_WOODBOTTOM_M1, TILE10_WOODBOTTOM_M2, TILE10_WOODBOTTOM_M1, TILE10_WOODBOTTOM_M2, TILE10_WOODBOTTOM_M1, TILE10_WOODBOTTOM_M2, TILE10_WOODBOTTOM_M1, TILE10_WOODBOTTOM_M2, TILE10_WOODBOTTOM_R, $FF

LoadLevel_IntroAirship:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDY TileAddr_Off ; Y = TileAddr_Off

	LDX #$00	 ; X = 0

	LDA #$04
	STA <Temp_Var3	 ; Temp_Var3 = 4 (5 rows)

PRG023_AB23:
	LDA LL_IntroAirship,X	 ; Intro airship tile
	CMP #$ff	 
	BEQ PRG023_AB33	 ; If this is the terminator, jump to PRG023_AB33

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	JSR LoadLevel_NextColumn	 ; Next column

	INX		 ; X++
	JMP PRG023_AB23	 ; Jump to PRG023_AB23

PRG023_AB33:
	INX		 ; X++
	JSR LL23_ReturnTileAndNextRow	 ; Return to beginning, then go to next row
	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG023_AB23	 ; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Ledge
;
; Adds ledge tile
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Ledge:
	LDX #$00	 ; X = 0
	JMP PRG023_AB45	 ; Jump to PRG023_AB45 

LL_RockyTiles:	.byte TILE10_LEDGE, TILE10_ROCKYWRENCH_HOLE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_RockyWrenchHole
;
; Adds Rocky Wrench's hole
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_RockyWrenchHole
	LDX #$01
PRG023_AB45:
	LDY TileAddr_Off ; Y = TileAddr_Off
	LDA LL_RockyTiles,X	 ; Get tile
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_MiniShip
;
; Prefabricated mini ships as used in World 8
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; $FF is a terminator
LL_W8MiniShip1:
	.byte TILE10_SKY, TILE10_SKY, TILE10_ROCKYWRENCH_HOLE, TILE10_SKY, TILE10_FLAMEJET_H, $FF
	.byte TILE10_WOODTIP_SHORT, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_R, $FF

LL_W8MiniShip2:
	.byte TILE10_SKY, TILE10_SKY, TILE10_SKY, TILE10_WOODV_T, TILE10_SKY, $FF
	.byte TILE10_SKY, TILE10_LEDGE, TILE10_WOODH_M1, TILE10_WOODH_R, TILE10_FLAMEJET_H, $FF
	.byte TILE10_WOODTIP_SHORT, TILE10_WOODH_M1, TILE10_WOODH_M2, TILE10_WOODH_M1, TILE10_WOODH_R, $FF

	; Start index to each ship
LL_W8MiniShipIndex:	.byte 0, (LL_W8MiniShip2 - LL_W8MiniShip1)

	; Rows for each ship type
LL_W8MiniShipRows:	.byte 1, 2

LoadLevel_MiniShip:
	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1
	LDA <Map_Tile_AddrH
	STA <Temp_Var2

	LDA LL_ShapeDef
	SUB #$01	
	TAX		 ; X = relative index

	LDA LL_W8MiniShipRows,X	 ; Get number of rows for this ship
	STA <Temp_Var3		 ; Temp_Var3 holds the rows

	LDA LL_W8MiniShipIndex,X ; Get starting index of mini ship
	TAX		 

	LDY TileAddr_Off 	; Y = TileAddr_Off

PRG023_AB8B:
	LDA LL_W8MiniShip1,X	; Get tile to mini ship
	CMP #$ff
	BEQ PRG023_AB9B	 	; If byte is terminator, jump to PRG023_AB9B

	STA [Map_Tile_AddrL],Y	 ; Store into tile mem
	JSR LoadLevel_NextColumn ; Next column
	INX			 ; X++ (next tile to mini ship)
	JMP PRG023_AB8B	 	 ; Jump to PRG023_AB8B

PRG023_AB9B:
	INX			 ; X++

	JSR LL23_ReturnTileAndNextRow	 ; Return to beginning, then go to next row

	DEC <Temp_Var3		 ; Temp_Var3-- (row decrement)
	BPL PRG023_AB8B	 	; While Temp_Var3 >= 0, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_InvisibleSolid
;
; Forms a 1-16 high run of invisible solid blocks (forming an
; invisible barrier where appropriate, hmm?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_InvisibleSolid:
	LDA LL_ShapeDef
	AND #$0f
	TAX		 ; X = lower 4 bits of LL_ShapeDef

	LDY TileAddr_Off ; Y = TileAddr_Off

PRG023_ABAD:
	LDA #TILE10_INVISSOLID	; invisible solid block?
	STA [Map_Tile_AddrL],Y	 ; Store into tile mem

	; Go to next row by adding 16
	TYA
	ADD #16
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	DEX		 ; X--
	BPL PRG023_ABAD	 ; While X >= 0, loop
	RTS		 ; Return


	; Routine to get a byte from the layout, put it into Temp_Var3,
	; and advance the Level_LayPtr_Addr pointer...
	; Also backup Map_Tile_AddrL/H into Temp_Var1/2
LL23_GetLayoutByte_AndBackup:
	LDY #$00	 		; Y = 0
	LDA [Level_LayPtr_AddrL],Y	; Get another byte from layout
	STA <Temp_Var3	 		; -> Temp_Var3

	LDA <Level_LayPtr_AddrL
	ADD #$01
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

	; Backup Map_Tile_AddrL/H into Temp_Var1/2
	LDA <Map_Tile_AddrL
	STA <Temp_Var1	
	LDA <Map_Tile_AddrH
	STA <Temp_Var2	

	RTS		 ; Return


	; Goes to next row and updates backup variable Temp_Var2
LL23_ReturnTileAndNextRow:
	; Restore Map_Tile_Addr from backup
	LDA <Temp_Var1
	STA <Map_Tile_AddrL
	LDA <Temp_Var2
	STA <Map_Tile_AddrH

	LDA TileAddr_Off
	ADD #16
	STA TileAddr_Off
	TAY
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH
	STA <Temp_Var2
	RTS		 ; Return

	; Broken into another file for ease of integration in NoDice editor
	.include "PRG/levels/Airship.asm"

; Rest of ROM bank was empty

